# Comparing `tmp/dott_ng-1.9.1-py3-none-any.whl.zip` & `tmp/dott_ng-1.9.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 57830 bytes, number of entries: 23
--rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-16 18:20 dottmi/__init__.py
--rw-rw-rw-  2.0 fat    15481 b- defN 23-Jul-16 18:20 dottmi/breakpoint.py
--rw-rw-rw-  2.0 fat     2550 b- defN 23-Jul-16 18:20 dottmi/breakpointhandler.py
--rw-rw-rw-  2.0 fat     8392 b- defN 23-Jul-16 18:20 dottmi/dott.py
--rw-rw-rw-  2.0 fat    24993 b- defN 23-Jul-16 18:20 dottmi/dott_conf.py
--rw-rw-rw-  2.0 fat      924 b- defN 23-Jul-16 18:20 dottmi/dottexceptions.py
--rw-rw-rw-  2.0 fat    14850 b- defN 23-Jul-16 18:20 dottmi/fixtures.py
--rw-rw-rw-  2.0 fat    10838 b- defN 23-Jul-16 18:20 dottmi/gdb.py
--rw-rw-rw-  2.0 fat     8411 b- defN 23-Jul-16 18:20 dottmi/gdb_cmds.py
--rw-rw-rw-  2.0 fat    15897 b- defN 23-Jul-16 18:20 dottmi/gdb_mi.py
--rw-rw-rw-  2.0 fat     3312 b- defN 23-Jul-16 18:20 dottmi/gdb_shared.py
--rw-rw-rw-  2.0 fat     1643 b- defN 23-Jul-16 18:20 dottmi/gdbcontrollerdott.py
--rw-rw-rw-  2.0 fat     6247 b- defN 23-Jul-16 18:20 dottmi/monitor.py
--rw-rw-rw-  2.0 fat     4755 b- defN 23-Jul-16 18:20 dottmi/pylinkdott.py
--rw-rw-rw-  2.0 fat     1245 b- defN 23-Jul-16 18:20 dottmi/symbols.py
--rw-rw-rw-  2.0 fat    23977 b- defN 23-Jul-16 18:20 dottmi/target.py
--rw-rw-rw-  2.0 fat    32809 b- defN 23-Jul-16 18:20 dottmi/target_mem.py
--rw-rw-rw-  2.0 fat    20124 b- defN 23-Jul-16 18:20 dottmi/utils.py
--rw-rw-rw-  2.0 fat    11558 b- defN 23-Jul-16 18:24 dott_ng-1.9.1.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat      890 b- defN 23-Jul-16 18:24 dott_ng-1.9.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-16 18:24 dott_ng-1.9.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-Jul-16 18:24 dott_ng-1.9.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1758 b- defN 23-Jul-16 18:24 dott_ng-1.9.1.dist-info/RECORD
-23 files, 210753 bytes uncompressed, 55056 bytes compressed:  73.9%
+Zip file size: 57911 bytes, number of entries: 23
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-31 18:53 dottmi/__init__.py
+-rw-rw-rw-  2.0 fat    15481 b- defN 23-Jul-31 18:53 dottmi/breakpoint.py
+-rw-rw-rw-  2.0 fat     2550 b- defN 23-Jul-31 18:53 dottmi/breakpointhandler.py
+-rw-rw-rw-  2.0 fat     8442 b- defN 23-Jul-31 18:53 dottmi/dott.py
+-rw-rw-rw-  2.0 fat    25263 b- defN 23-Jul-31 18:53 dottmi/dott_conf.py
+-rw-rw-rw-  2.0 fat      924 b- defN 23-Jul-31 18:53 dottmi/dottexceptions.py
+-rw-rw-rw-  2.0 fat    14852 b- defN 23-Jul-31 18:53 dottmi/fixtures.py
+-rw-rw-rw-  2.0 fat    10838 b- defN 23-Jul-31 18:53 dottmi/gdb.py
+-rw-rw-rw-  2.0 fat     8411 b- defN 23-Jul-31 18:53 dottmi/gdb_cmds.py
+-rw-rw-rw-  2.0 fat    15897 b- defN 23-Jul-31 18:53 dottmi/gdb_mi.py
+-rw-rw-rw-  2.0 fat     3312 b- defN 23-Jul-31 18:53 dottmi/gdb_shared.py
+-rw-rw-rw-  2.0 fat     1643 b- defN 23-Jul-31 18:53 dottmi/gdbcontrollerdott.py
+-rw-rw-rw-  2.0 fat     6363 b- defN 23-Jul-31 18:53 dottmi/monitor.py
+-rw-rw-rw-  2.0 fat     4755 b- defN 23-Jul-31 18:53 dottmi/pylinkdott.py
+-rw-rw-rw-  2.0 fat     1245 b- defN 23-Jul-31 18:53 dottmi/symbols.py
+-rw-rw-rw-  2.0 fat    24031 b- defN 23-Jul-31 18:53 dottmi/target.py
+-rw-rw-rw-  2.0 fat    32809 b- defN 23-Jul-31 18:53 dottmi/target_mem.py
+-rw-rw-rw-  2.0 fat    20124 b- defN 23-Jul-31 18:53 dottmi/utils.py
+-rw-rw-rw-  2.0 fat    11558 b- defN 23-Jul-31 18:57 dott_ng-1.9.2.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat      890 b- defN 23-Jul-31 18:57 dott_ng-1.9.2.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-31 18:57 dott_ng-1.9.2.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Jul-31 18:57 dott_ng-1.9.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1758 b- defN 23-Jul-31 18:57 dott_ng-1.9.2.dist-info/RECORD
+23 files, 211245 bytes uncompressed, 55137 bytes compressed:  73.9%
```

## zipnote {}

```diff
@@ -48,23 +48,23 @@
 
 Filename: dottmi/target_mem.py
 Comment: 
 
 Filename: dottmi/utils.py
 Comment: 
 
-Filename: dott_ng-1.9.1.dist-info/LICENSE.txt
+Filename: dott_ng-1.9.2.dist-info/LICENSE.txt
 Comment: 
 
-Filename: dott_ng-1.9.1.dist-info/METADATA
+Filename: dott_ng-1.9.2.dist-info/METADATA
 Comment: 
 
-Filename: dott_ng-1.9.1.dist-info/WHEEL
+Filename: dott_ng-1.9.2.dist-info/WHEEL
 Comment: 
 
-Filename: dott_ng-1.9.1.dist-info/top_level.txt
+Filename: dott_ng-1.9.2.dist-info/top_level.txt
 Comment: 
 
-Filename: dott_ng-1.9.1.dist-info/RECORD
+Filename: dott_ng-1.9.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dottmi/dott.py

```diff
@@ -16,15 +16,15 @@
 #   limitations under the License.
 ###############################################################################
 
 from __future__ import annotations  # available from Python 3.7 onwards, default from Python 3.11 onwards
 
 import typing
 
-from dottmi.dott_conf import DottConf
+from dottmi.dott_conf import DottConf, DottConfExt
 from dottmi.gdb import GdbServer
 
 if typing.TYPE_CHECKING:
     from dottmi.target import Target
 
 import types
 from typing import List
@@ -114,47 +114,47 @@
         Returns:
             GdbServer instance.
         """
         from dottmi.utils import log
         log.warn('create_gdb_server() will be deprecated in a forthcoming release. Port your code to used dott().target.monitor.create_gdb_server() instead!')
         return dott().target.monitor.create_gdb_server(DottConf())
 
-    def create_target(self, dconf: DottConf) -> Target:
+    def create_target(self, dconf: [DottConf | DottConfExt]) -> Target:
         """
         Creates and retunrs a target object according to the settings of the provided DottConf instance.
 
         Args:
             dconf: DottConf instance used to configure the target instance.
 
         Returns:
             Target instance configured according to dconf.
         """
         from dottmi import target
         from dottmi.gdb import GdbClient
 
-        monitor_type = dconf.get(dconf.keys.monitor_type)
+        monitor_type = dconf.get(DottConf.keys.monitor_type)
 
         if monitor_type == 'jlink':
             monitor: Monitor = MonitorJLink()
         elif monitor_type == 'openocd':
             monitor: Monitor = MonitorOpenOCD()
         elif monitor_type == 'custom':
             try:
                 import importlib
-                monitor_cls = getattr(importlib.import_module(dconf.get(dconf.keys.monitor_module)), dconf.get(dconf.keys.monitor_class))
+                monitor_cls = getattr(importlib.import_module(dconf.get(DottConf.keys.monitor_module)), dconf.get(DottConf.keys.monitor_class))
                 monitor: Monitor = monitor_cls()
             except:
-                raise DottException(f'Failed to instantiate {dconf.get(dconf.keys.monitor_module)}::{dconf.get(dconf.keys.monitor_class)}') from None
+                raise DottException(f'Failed to instantiate {dconf.get(DottConf.keys.monitor_module)}::{dconf.get(DottConf.keys.monitor_class)}') from None
         else:
-            raise DottException(f'Unknown debug monitor type {dconf.get(dconf.keys.monitor_type)}.')
+            raise DottException(f'Unknown debug monitor type {dconf.get(DottConf.keys.monitor_type)}.')
 
         gdb_server: GdbServer = monitor.create_gdb_server(dconf)
 
         # start GDB client
-        gdb_client = GdbClient(dconf.get(dconf.keys.gdb_client_binary))
+        gdb_client = GdbClient(dconf.get(DottConf.keys.gdb_client_binary))
         gdb_client.create()
 
         try:
             # create target instance and set GDB server address
             target = target.Target(gdb_server, gdb_client, monitor, dconf)
 
         except TimeoutError:
```

## dottmi/dott_conf.py

```diff
@@ -119,15 +119,15 @@
             for lib in libs:
                 try:
                     if not os.path.exists(f'{os.path.dirname(lib)}{os.path.sep}{jlink_gdb_server_binary}'):
                         # Skip dirs which contain a JLINK dll but no GDB server executable (e.g., Ozone install folders).
                         continue
                     clib = CDLL(lib)
                 except OSError:
-                    # Note: On Linux, Segger provides symlinks in the x86 folder to the 32bit version of the the
+                    # Note: On Linux, Segger provides symlinks in the x86 folder to the 32bit version of the
                     # JLink library using the 64bit library name. Attempting to load this library on a 64bit system
                     # results in an exception.
                     continue
                 ver = clib.JLINKARM_GetDLLVersion()
                 all_libs[ver] = lib
 
         jlink_path: str = ''
@@ -225,22 +225,22 @@
         else:
             self._conf['bl_symbol_addr'] = int(self._conf['bl_symbol_addr'], base=16)
         log.info(f'BL ADDR (symbol):      0x{self._conf["bl_symbol_addr"]:x}')
 
         if 'app_load_elf' in self._conf:
             if not os.path.exists(self._conf['app_load_elf']):
                 raise ValueError(f'{self._conf["app_load_elf"]} does not exist.')
-            log.info(f'APP ELF (load):        {self._conf["app_load_elf"]}')
         else:
             self._conf["app_load_elf"] = None
+        log.info(f'APP ELF (load):        {self._conf["app_load_elf"]}')
 
         if 'app_symbol_elf' not in self._conf:
             # if no symbol file is specified assume that symbols are contained in the load file
             self._conf['app_symbol_elf'] = self._conf['app_load_elf']
-        if not os.path.exists(self._conf['app_symbol_elf']):
+        if self._conf['app_symbol_elf'] is not None and not os.path.exists(self._conf['app_symbol_elf']):
             raise ValueError(f'{self._conf["app_symbol_elf"]} does not exist.')
         log.info(f'APP ELF (symbol):      {self._conf["app_symbol_elf"]}')
 
         if 'device_name' not in self._conf:
             self._conf["device_name"] = 'unknown'
         log.info(f'Device name:           {self._conf["device_name"]}')
 
@@ -268,48 +268,49 @@
                         self._conf['monitor_module'] = None
                     self._conf['monitor_type'] = 'custom'
 
                 else:
                     raise ValueError(f'Unknown monitor type (supported: "jlink", "openocd" or "my.module.path.MyMonitorClass"')
         log.info(f'Selected monitor type: {self._conf["monitor_type"].upper()}')
 
-        # determine J-Link path and version
-        jlink_path, jlink_lib_name, jlink_version = self._get_jlink_path(jlink_default_path, jlink_lib_name, jlink_gdb_server_binary)
-        self._conf["jlink_path"] = jlink_path
-        self._conf["jlink_lib_name"] = jlink_lib_name
-        self._conf["jlink_version"] = jlink_version
-        log.info(f'J-LINK local path:     {self._conf["jlink_path"]}')
-        log.info(f'J-LINK local version:  {self._conf["jlink_version"]}')
-
-        # We are connecting to a J-LINK gdb server which was not started by DOTT. Therefore, it does not make sense
-        # to print, e.g., SWD connection parameters.
-        if 'jlink_interface' not in self._conf:
-            self._conf['jlink_interface'] = 'SWD'
-        log.info(f'J-LINK interface:      {self._conf["jlink_interface"]}')
-
-        if 'jlink_speed' not in self._conf:
-            self._conf['jlink_speed'] = '15000'
-        log.info(f'J-LINK speed (set):    {self._conf["jlink_speed"]}')
-
-        if 'jlink_serial' not in self._conf:
-            self._conf['jlink_serial'] = None
-        elif self._conf['jlink_serial'] is not None and self._conf['jlink_serial'].strip() == '':
-            self._conf['jlink_serial'] = None
-        if self._conf['jlink_serial'] is not None:
-            log.info(f'J-LINK serial:         {self._conf["jlink_serial"]}')
-
-        if 'jlink_script' not in self._conf:
-            self._conf['jlink_script'] = None
-        if self._conf['jlink_script'] is not None:
-            log.info(f'J-LINK script:         {self._conf["jlink_script"]}')
-
-        if 'jlink_extconf' not in self._conf:
-            self._conf['jlink_extconf'] = None
-        if self._conf['jlink_extconf'] is not None:
-            log.info(f'J-LINK extra config:   {self._conf["jlink_extconf"]}')
+        if self._conf[DottConf.keys.monitor_type] == 'jlink':
+            # determine J-Link path and version
+            jlink_path, jlink_lib_name, jlink_version = self._get_jlink_path(jlink_default_path, jlink_lib_name, jlink_gdb_server_binary)
+            self._conf["jlink_path"] = jlink_path
+            self._conf["jlink_lib_name"] = jlink_lib_name
+            self._conf["jlink_version"] = jlink_version
+            log.info(f'J-LINK local path:     {self._conf["jlink_path"]}')
+            log.info(f'J-LINK local version:  {self._conf["jlink_version"]}')
+
+            # We are connecting to a J-LINK gdb server which was not started by DOTT. Therefore, it does not make sense
+            # to print, e.g., SWD connection parameters.
+            if 'jlink_interface' not in self._conf:
+                self._conf['jlink_interface'] = 'SWD'
+            log.info(f'J-LINK interface:      {self._conf["jlink_interface"]}')
+
+            if 'jlink_speed' not in self._conf:
+                self._conf['jlink_speed'] = '15000'
+            log.info(f'J-LINK speed (set):    {self._conf["jlink_speed"]}')
+
+            if 'jlink_serial' not in self._conf:
+                self._conf['jlink_serial'] = None
+            elif self._conf['jlink_serial'] is not None and self._conf['jlink_serial'].strip() == '':
+                self._conf['jlink_serial'] = None
+            if self._conf['jlink_serial'] is not None:
+                log.info(f'J-LINK serial:         {self._conf["jlink_serial"]}')
+
+            if 'jlink_script' not in self._conf:
+                self._conf['jlink_script'] = None
+            if self._conf['jlink_script'] is not None:
+                log.info(f'J-LINK script:         {self._conf["jlink_script"]}')
+
+            if 'jlink_extconf' not in self._conf:
+                self._conf['jlink_extconf'] = None
+            if self._conf['jlink_extconf'] is not None:
+                log.info(f'J-LINK extra config:   {self._conf["jlink_extconf"]}')
 
         if 'gdb_client_binary' not in self._conf:
             default_gdb = 'arm-none-eabi-gdb-py'
             self._conf['gdb_client_binary'] = str(Path(f'{os.environ["DOTTGDBPATH"]}/{default_gdb}'))
         log.info(f'GDB client binary:     {self._conf["gdb_client_binary"]}')
 
         if 'gdb_server_addr' not in self._conf:
@@ -351,15 +352,15 @@
             log.info(f'JLINK server port:     {self._conf["jlink_server_port"]}')
         if self._conf['gdb_server_addr'] is None:
             # no (remote) GDB server address given. try to find a local GDB server binary to launch instead
 
             if 'gdb_server_binary' in self._conf:
                 if not os.path.exists(self._conf['gdb_server_binary']):
                     raise Exception(f'GDB server binary {self._conf["gdb_server_binary"]} ({self._dott_ini}) not found!')
-            elif os.path.exists(jlink_path):
+            elif self._conf[DottConf.keys.monitor_type] == 'jlink' and os.path.exists(jlink_path):
                 self._conf['gdb_server_binary'] = str(Path(f'{jlink_path}/{jlink_gdb_server_binary}'))
             else:
                 # As a last option we check if the GDB server binary is in PATH
                 try:
                     subprocess.check_call((jlink_gdb_server_binary, '-device'))
                 except subprocess.CalledProcessError:
                     # Segger gdb server exists and responded with an error since no device was specified
```

## dottmi/fixtures.py

```diff
@@ -42,28 +42,28 @@
         pytest.exit('Aborting test execution.')
 
     try:
         if not silent:
             log.info(f'Triggering download of APP to {name}...')
 
         # optionally load bootloader binary (load elf ONLY - symbols are loaded after the app)
-        bl_load_elf = dt.dconf.get(dt.dconf.keys.bl_load_elf)
+        bl_load_elf = dt.dconf.get(DottConf.keys.bl_load_elf)
         if bl_load_elf is not None:
             dt.load(bl_load_elf, None, enable_flash=load_to_flash)
 
         # load application binaries
-        app_load_elf = dt.dconf.get(dt.dconf.keys.app_load_elf)
-        app_symbol_elf = dt.dconf.get(dt.dconf.keys.app_symbol_elf)
+        app_load_elf = dt.dconf.get(DottConf.keys.app_load_elf)
+        app_symbol_elf = dt.dconf.get(DottConf.keys.app_symbol_elf)
         if app_load_elf is not None:
             dt.load(app_load_elf, app_symbol_elf, enable_flash=load_to_flash)
 
         # add bootloader symbol file; note: it is important to this 'add' so after doing target.load() with symbol elf.
-        bl_symbol_elf = dt.dconf.get(dt.dconf.keys.bl_symbol_elf)
+        bl_symbol_elf = dt.dconf.get(DottConf.keys.bl_symbol_elf)
         if bl_symbol_elf is not None:
-            dt.cli_exec('add-symbol-file %s 0x%x' % bl_symbol_elf, int(dt.dconf.get(dt.dconf.keys.bl_symbol_addr)))
+            dt.cli_exec('add-symbol-file %s 0x%x' % (bl_symbol_elf, int(dt.dconf.get(DottConf.keys.bl_symbol_addr))))
 
         # disable FLASH breakpoints
         dt.monitor.enable_flash_breakpoints(False)
     except Exception as ex:
         log.exception(str(ex))
         pytest.exit('Unhandled exception target download. See trace above.')
 
@@ -115,22 +115,22 @@
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 def _target_mem_init_noalloc(dt: Target = None) -> None:
     dt = dott().target if dt is None else dt
 
     # print mem model override information
-    if dt.dconf.get(dt.dconf.keys.on_target_mem_model) != TargetMemModel.NOALLOC:
+    if dt.dconf.get(DottConf.keys.on_target_mem_model) != TargetMemModel.NOALLOC:
         log.info(f'Overriding std. target mem model with {TargetMemModel.NOALLOC}.')
 
     # define the initial test breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint('main')
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
+        bp.wait_complete(timeout=float(dt.dconf.get(DottConf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn('main not reached. Target halted after timeout at PC: 0x%x' % dt.eval('$pc'))
 
     # remove test hook breakpoint
     bp.delete()
 
@@ -141,22 +141,22 @@
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 def _target_mem_init_testhook(dt: Target = None) -> None:
     dt = dott().target if dt is None else dt
 
     # print mem model override information
-    if dt.dconf.get(dt.dconf.keys.on_target_mem_model) != TargetMemModel.TESTHOOK:
+    if dt.dconf.get(DottConf.keys.on_target_mem_model) != TargetMemModel.TESTHOOK:
         log.info(f'Overriding std. target mem model with {TargetMemModel.TESTHOOK}.')
 
     # define the initial test breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint('DOTT_test_hook_chained')
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
+        bp.wait_complete(timeout=float(dt.dconf.get(DottConf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn('DOTT_test_hook_chained not reached. Target halted after timeout at PC: 0x%x' % dt.eval('$pc'))
 
     # remove test hook breakpoint
     bp.delete()
 
@@ -168,35 +168,35 @@
 
 # ----------------------------------------------------------------------------------------------------------------------
 def _target_mem_init_prestack(mem_model_args: Dict = None, dt: Target = None) -> None:
     dt = dott().target if dt is None else dt
     override = False
 
     # override default value of on-target memory size
-    target_mem_num_bytes: int = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_alloc_size)
+    target_mem_num_bytes: int = dt.dconf.get(DottConf.keys.on_target_mem_prestack_alloc_size)
     if mem_model_args is not None and 'alloc_size' in mem_model_args:
         target_mem_num_bytes = int(mem_model_args['alloc_size'])
         override = True
     if target_mem_num_bytes % 4 != 0:
         raise DottException('The num_bytes argument for prestack memory allocation shall be a multiple of 4!')
 
     # override default value for target alloc location
-    alloc_location: str = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_alloc_location)
+    alloc_location: str = dt.dconf.get(DottConf.keys.on_target_mem_prestack_alloc_location)
     if mem_model_args is not None and 'alloc_location' in mem_model_args:
         alloc_location = str(mem_model_args['alloc_location'])
         override = True
 
     # override default value for target halt location
-    halt_location: str = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_halt_location)
+    halt_location: str = dt.dconf.get(DottConf.keys.on_target_mem_prestack_halt_location)
     if mem_model_args is not None and 'halt_location' in mem_model_args:
         halt_location = str(mem_model_args['halt_location'])
         override = True
 
     # override default value for target total_stack_size
-    total_stack_num_bytes: int = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_total_stack_size)
+    total_stack_num_bytes: int = dt.dconf.get(DottConf.keys.on_target_mem_prestack_total_stack_size)
     if mem_model_args is not None and 'total_stack_size' in mem_model_args:
         total_stack_num_bytes = mem_model_args['total_stack_size']
         override = True
 
     # print mem model override information
     if override:
         log.info(f'Overriding std. target mem model with {TargetMemModel.PRESTACK}'
@@ -205,15 +205,15 @@
                  f'halt @{halt_location}; '
                  f'total stack: {total_stack_num_bytes if total_stack_num_bytes is not None else "unknown"}).')
 
     # define the initial allocation breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint(alloc_location)
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
+        bp.wait_complete(timeout=float(dt.dconf.get(DottConf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn(f'{alloc_location} not reached. Target halted after timeout at PC: 0x{dt.eval("$pc"):x}')
     bp.delete()
 
     # adjust the stack pointer (i.e., steal the requested amount of on-target memory)
     dt.eval(f'$sp -= {target_mem_num_bytes}')
@@ -222,15 +222,15 @@
     target_mem_stack_start = dt.eval('$sp')
     dt.mem = TargetMem(dt, target_mem_stack_start, target_mem_num_bytes)
 
     # define the halt breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint(halt_location)
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
+        bp.wait_complete(timeout=float(dt.dconf.get(DottConf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn(f'{halt_location} not reached. Target halted after timeout at PC: 0x{dt.eval("$pc"):x}')
     bp.delete()
 
     # pass control to test
     yield
@@ -251,15 +251,15 @@
         dt.eval(f'$pc = *{pc}')
 
     # if a callback was specified give user code a chance to do early device initialization
     if setup_cb is not None:
         setup_cb()
 
     # set on-target memory allocation model either from config or from pytest marker
-    mem_model: TargetMemModel = dt.dconf.get(dt.dconf.keys.on_target_mem_model)
+    mem_model: TargetMemModel = dt.dconf.get(DottConf.keys.on_target_mem_model)
     mem_model_args = None
     if 'pytestmark' in request.keywords:
         for m in request.keywords['pytestmark']:
             if m.name == 'dott_mem' and 'model' in m.kwargs:
                 mem_model = m.kwargs['model']
                 mem_model_args = m.kwargs
                 break
```

## dottmi/monitor.py

```diff
@@ -17,15 +17,15 @@
 
 from __future__ import annotations  # available from Python 3.7 onwards, default from Python 3.11 onwards
 
 import abc
 import typing
 
 from dottmi import utils
-from dottmi.dott_conf import DottConf
+from dottmi.dott_conf import DottConf, DottConfExt
 from dottmi.gdb import GdbServer, GdbServerExternal, GdbServerJLink
 
 if typing.TYPE_CHECKING:
     from dottmi.target import Target
 
 from dottmi.dottexceptions import DottException
 
@@ -72,58 +72,58 @@
         pass
 
     @abc.abstractmethod
     def xpsr_name(self) -> str:
         pass
 
     @abc.abstractmethod
-    def _instantiate_gdb_server(self, dconf: DottConf):
+    def _instantiate_gdb_server(self, dconf: [DottConf | DottConfExt]):
         pass
 
-    def create_gdb_server(self, dconf: DottConf) -> GdbServer:
+    def create_gdb_server(self, dconf: [DottConf | DottConfExt]) -> GdbServer:
         """
         Create new GDB server instance. If the configuration contains a gdb server address it is assumed that a GDB server is already running at this
         address and no attempt is made to launch a GDB server instance. Otherwise, it is tried to launch a gdb server instance corresponding to the
         monitor type.
 
         Args:
             dconf: Dott configuration database.
 
         Returns: GDB server instance.
         """
-        addr = dconf.get(dconf.keys.gdb_server_addr)
-        port = dconf.get(dconf.keys.gdb_server_port)
+        addr = dconf.get(DottConf.keys.gdb_server_addr)
+        port = dconf.get(DottConf.keys.gdb_server_port)
         if addr is not None:
             return GdbServerExternal(addr, port)
         else:
             return self._instantiate_gdb_server(dconf)
 
 
 class MonitorJLink(Monitor):
-    def _instantiate_gdb_server(self, dconf: DottConf):
-        srv_addr = dconf.get(dconf.keys.gdb_server_addr)
+    def _instantiate_gdb_server(self, dconf: [DottConf | DottConfExt]):
+        srv_addr = dconf.get(DottConf.keys.gdb_server_addr)
 
         if srv_addr is not None:
-            srv_port = dconf.get(dconf.keys.gdb_server_port)
+            srv_port = dconf.get(DottConf.keys.gdb_server_port)
         else:
             # if gdb server is launched by DOTT, we determine the port ourselves
             srv_port = utils.Network.get_next_srv_port('127.0.0.1')
 
         return GdbServerJLink(
-            dconf.get(dconf.keys.gdb_server_binary),
+            dconf.get(DottConf.keys.gdb_server_binary),
             srv_addr,
             srv_port,
-            dconf.get(dconf.keys.device_name),
-            dconf.get(dconf.keys.jlink_interface),
-            dconf.get(dconf.keys.device_endianess),
-            dconf.get(dconf.keys.jlink_speed),
-            dconf.get(dconf.keys.jlink_serial),
-            dconf.get(dconf.keys.jlink_server_addr),
-            dconf.get(dconf.keys.jlink_script),
-            dconf.get(dconf.keys.jlink_extconf)
+            dconf.get(DottConf.keys.device_name),
+            dconf.get(DottConf.keys.jlink_interface),
+            dconf.get(DottConf.keys.device_endianess),
+            dconf.get(DottConf.keys.jlink_speed),
+            dconf.get(DottConf.keys.jlink_serial),
+            dconf.get(DottConf.keys.jlink_server_addr),
+            dconf.get(DottConf.keys.jlink_script),
+            dconf.get(DottConf.keys.jlink_extconf)
         )
 
     def set_flash_device(self, device_name: str) -> None:
         self.run_cmd(f'flash device {device_name}')
 
     def enable_flash_download(self, enable: bool) -> None:
         flag: int = 1 if enable else 0
@@ -143,15 +143,15 @@
         self.run_cmd('reset')
 
     def xpsr_name(self) -> str:
         return 'xpsr'
 
 
 class MonitorOpenOCD(Monitor):
-    def _instantiate_gdb_server(self, dconf: DottConf):
+    def _instantiate_gdb_server(self, dconf: [DottConf | DottConfExt]):
         raise NotImplementedError('Automatic starting of OpenOCD GDB server is not supported. Provide "gdb_server_addr" and "gdb_server_addr" '
                                   'config parameters to connect to an externally started/remote GDB server instance.')
 
     def set_flash_device(self, device_name: str) -> None:
         # For OpenOCD the flash device name is ignored for now
         pass
```

## dottmi/target.py

```diff
@@ -22,15 +22,15 @@
 import os
 import threading
 import time
 from pathlib import Path, PurePosixPath
 from typing import Dict, Union, List, TYPE_CHECKING
 
 from dottmi.dott import DottHooks
-from dottmi.dott_conf import DottConf
+from dottmi.dott_conf import DottConf, DottConfExt
 
 if TYPE_CHECKING:
     from dottmi.target_mem import TargetMem
 
 from dottmi.breakpointhandler import BreakpointHandler
 from dottmi.dottexceptions import DottException
 from dottmi.gdb import GdbClient, GdbServer
@@ -41,27 +41,27 @@
 from dottmi.utils import cast_str, log
 
 logging.basicConfig(level=logging.DEBUG)
 
 
 class Target(NotifySubscriber):
 
-    def __init__(self, gdb_server: GdbServer, gdb_client: GdbClient, monitor: Monitor, dconf: DottConf, auto_connect: bool = True) -> None:
+    def __init__(self, gdb_server: GdbServer, gdb_client: GdbClient, monitor: Monitor, dconf: [DottConf | DottConfExt], auto_connect: bool = True) -> None:
         """
         Creates a target which represents a target device. It requires both a GDB server (either started by DOTT
         or started externally) and a GDB client instance used to connect to the GDB server.
         If auto_connect is True (the default) the connected from GDB client to GDB server is automatically established.
         """
         NotifySubscriber.__init__(self)
-        self._dconf: DottConf = dconf
+        self._dconf: [DottConf | DottConfExt] = dconf
         self._load_elf_file_name = None
         self._symbol_elf_file_name = None
 
-        self._device_name: str = dconf.get(dconf.keys.device_name)
-        self._device_endianess: str = dconf.get(dconf.keys.device_endianess)
+        self._device_name: str = dconf.get(DottConf.keys.device_name)
+        self._device_endianess: str = dconf.get(DottConf.keys.device_endianess)
         self._gdb_client: GdbClient = gdb_client
         self._gdb_server: GdbServer = gdb_server
         self._monitor: Monitor = monitor
         self._monitor.set_target(self)
 
         # condition variable and status flag used to implement helpers
         # allowing callers to wait until target is stopped or running
@@ -85,15 +85,15 @@
         self._gdb_client.gdb_mi.response_handler.notify_subscribe(self, 'stopped', None)
         self._gdb_client.gdb_mi.response_handler.notify_subscribe(self, 'running', None)
 
         # delay after device startup / continue
         self._startup_delay: float = 0.0
 
         # timeout used when connection to remote GDB server ("target remote")
-        self._connect_timeout: float = float(dconf.get(dconf.keys.gdb_server_connect_timeout))
+        self._connect_timeout: float = float(dconf.get(DottConf.keys.gdb_server_connect_timeout))
 
         # flag which indicates if gdb client is attached to target
         self._gdb_client_is_connected = False
 
         if auto_connect:
                 self.gdb_client_connect()
```

## Comparing `dott_ng-1.9.1.dist-info/LICENSE.txt` & `dott_ng-1.9.2.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `dott_ng-1.9.1.dist-info/METADATA` & `dott_ng-1.9.2.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dott-ng
-Version: 1.9.1
+Version: 1.9.2
 Summary: Debugger-based on Target Testing (DOTT)
 Home-page: https://github.com/tw-ghub/dott-ng
 Author: Thomas Winkler
 Author-email: thomas.winkler@gmail.com
 Classifier: Environment :: Console
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Topic :: Software Development :: Testing
```

## Comparing `dott_ng-1.9.1.dist-info/RECORD` & `dott_ng-1.9.2.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 dottmi/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dottmi/breakpoint.py,sha256=yGOoCKAXwqdfO-UDhC73tuSZpOltkXA_UycQU2PDX4Q,15481
 dottmi/breakpointhandler.py,sha256=hqEZMsg58k4UD5U7XrCSHmfvJmp6gVSWoVfyx522RE8,2550
-dottmi/dott.py,sha256=K-p2o4vXLLswKgaqYDTAxOfQUh-8i0r8ZswcGCp1f8E,8392
-dottmi/dott_conf.py,sha256=B_W7d0lXbJjXCMNwYhygLd9xq2ZQ20xzDxX_cmJTesI,24993
+dottmi/dott.py,sha256=CqCOnjrNTNz4IFxRQkIhlCrEmN7Yybtp97hBiitKxmc,8442
+dottmi/dott_conf.py,sha256=-wfQa-Q9yFUEjXBoAKWgBMjV-iO0n1hnLEZPk4-JX_w,25263
 dottmi/dottexceptions.py,sha256=6rDpCEzodl_lXL4Zx8v3XO46hDiIUNPzjWvMDL1PN0s,924
-dottmi/fixtures.py,sha256=ZjDFU0ueL1v8ZSFKo6KeT_U1nMvVCCp02Zc_shoFOr0,14850
+dottmi/fixtures.py,sha256=VZDoMYeRSDjwCjIFsrTIN0yiSfQSP7X1ixl0hoA6mcw,14852
 dottmi/gdb.py,sha256=MxKrb1ci4xMxfPPQyIELDfqesdaCT_YPJXMBxeWoO8c,10838
 dottmi/gdb_cmds.py,sha256=kB_LDdvGaxUIt-kMtdVVv0OgCVQocPVc1b0y8mfxFoI,8411
 dottmi/gdb_mi.py,sha256=Lrq0UQtVuu0wGQPtaMqV4UZkLr-xo009tG8sXO6QO-g,15897
 dottmi/gdb_shared.py,sha256=ivDsqIJmO7ToHcux4gQKbQp2f2rMy8mmcAtIxfbuE1A,3312
 dottmi/gdbcontrollerdott.py,sha256=_pm6jBJdMLq87AG6_nDZTQI5BBRoVKT4ij1YOXXnEMA,1643
-dottmi/monitor.py,sha256=tiQIe9ORdBNSDRPiJE0ijaiqblfKPs3BTrvF-Ee74F8,6247
+dottmi/monitor.py,sha256=g_KbeYd46FwAtPJ6r9d56TtOaXzVSi_xWfvi226iLEo,6363
 dottmi/pylinkdott.py,sha256=wu_QNDej3GqkMZK07UokDdcmvRU7yz-ZX7M3PC7PSRg,4755
 dottmi/symbols.py,sha256=63yUpDuf9Q4PPub2BN6YLHvGnygixuiV5M7lm7Kuemg,1245
-dottmi/target.py,sha256=ILMP9FU5EWDhtAyqAv7hR4QAKJce0-JVxMhzuuY6b-s,23977
+dottmi/target.py,sha256=0a2PH6aYqvQp2RarJs0GoLoZsWSiQqXtG7KRdeuofqU,24031
 dottmi/target_mem.py,sha256=0sqEP7ZOrzA8OdRDPa0PvYfhZjFEfbTGaHuNrhDbEzw,32809
 dottmi/utils.py,sha256=tKQgxS6MhQviWDLieYzIpKVG4qbrbvS0N0Udo6kDcDk,20124
-dott_ng-1.9.1.dist-info/LICENSE.txt,sha256=SbvpEU5JIU3yzMMkyzrI0dGqHDoJR_lMKGdl6GZHsy4,11558
-dott_ng-1.9.1.dist-info/METADATA,sha256=Av-HVhqSvYDoOrQDmjJnphLozQ6HnI_Ns1IND4A5pjU,890
-dott_ng-1.9.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-dott_ng-1.9.1.dist-info/top_level.txt,sha256=zHszyamN3VN0AAzMMo7e00JdWgdlNPvenbbPAsRt-Kc,7
-dott_ng-1.9.1.dist-info/RECORD,,
+dott_ng-1.9.2.dist-info/LICENSE.txt,sha256=SbvpEU5JIU3yzMMkyzrI0dGqHDoJR_lMKGdl6GZHsy4,11558
+dott_ng-1.9.2.dist-info/METADATA,sha256=_ppDMlfIaJRBlg8M8m7PAxSRKtIWbw1UKk4V08P0sE0,890
+dott_ng-1.9.2.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+dott_ng-1.9.2.dist-info/top_level.txt,sha256=zHszyamN3VN0AAzMMo7e00JdWgdlNPvenbbPAsRt-Kc,7
+dott_ng-1.9.2.dist-info/RECORD,,
```

