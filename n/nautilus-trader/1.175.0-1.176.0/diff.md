# Comparing `tmp/nautilus_trader-1.175.0.tar.gz` & `tmp/nautilus_trader-1.176.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "nautilus_trader-1.175.0.tar", max compression
+gzip compressed data, was "nautilus_trader-1.176.0.tar", max compression
```

## Comparing `nautilus_trader-1.175.0.tar` & `nautilus_trader-1.176.0.tar`

### file list

```diff
@@ -1,735 +1,745 @@
--rw-r--r--   0        0        0     7652 2023-06-17 12:45:50.819001 nautilus_trader-1.175.0/LICENSE
--rw-r--r--   0        0        0    24139 2023-06-17 12:45:50.819001 nautilus_trader-1.175.0/README.md
--rw-r--r--   0        0        0    12563 2023-06-17 12:45:50.819001 nautilus_trader-1.175.0/build.py
--rw-r--r--   0        0        0      663 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/.cargo/config.toml
--rw-r--r--   0        0        0    94369 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/Cargo.lock
--rw-r--r--   0        0        0     1691 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/Cargo.toml
--rw-r--r--   0        0        0     7652 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/LICENSE
--rw-r--r--   0        0        0     1248 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/README.md
--rw-r--r--   0        0        0      702 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/Cargo.toml
--rw-r--r--   0        0        0     1882 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/build.rs
--rw-r--r--   0        0        0      484 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/cbindgen.toml
--rw-r--r--   0        0        0      810 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/cbindgen_cython.toml
--rw-r--r--   0        0        0     5732 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/src/engine.rs
--rw-r--r--   0        0        0      900 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/src/lib.rs
--rw-r--r--   0        0        0       65 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/clippy.toml
--rw-r--r--   0        0        0      715 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/Cargo.toml
--rw-r--r--   0        0        0     2536 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/build.rs
--rw-r--r--   0        0        0      531 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/cbindgen.toml
--rw-r--r--   0        0        0      724 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/cbindgen_cython.toml
--rw-r--r--   0        0        0    18875 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/clock.rs
--rw-r--r--   0        0        0     8305 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/clock_api.rs
--rw-r--r--   0        0        0     9689 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/enums.rs
--rw-r--r--   0        0        0     1038 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/lib.rs
--rw-r--r--   0        0        0    22774 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/logging.rs
--rw-r--r--   0        0        0     4372 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/logging_api.rs
--rw-r--r--   0        0        0     7311 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/msgbus.rs
--rw-r--r--   0        0        0     2463 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/testing.rs
--rw-r--r--   0        0        0     7894 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/timer.rs
--rw-r--r--   0        0        0     1857 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/timer_api.rs
--rw-r--r--   0        0        0      639 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/Cargo.toml
--rw-r--r--   0        0        0     1234 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/benches/criterion_time_benchmark.rs
--rw-r--r--   0        0        0     2532 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/build.rs
--rw-r--r--   0        0        0      681 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/cbindgen.toml
--rw-r--r--   0        0        0      791 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/cbindgen_cython.toml
--rw-r--r--   0        0        0     7666 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/correctness.rs
--rw-r--r--   0        0        0     5544 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/cvec.rs
--rw-r--r--   0        0        0     5257 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/datetime.rs
--rw-r--r--   0        0        0      998 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/lib.rs
--rw-r--r--   0        0        0     7462 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/parsing.rs
--rw-r--r--   0        0        0     5143 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/string.rs
--rw-r--r--   0        0        0     5106 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/core/src/time.rs
--rw-r--r--   0        0        0     7991 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/core/src/uuid.rs
--rw-r--r--   0        0        0      497 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/indicators/Cargo.toml
--rw-r--r--   0        0        0     5107 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/indicators/src/ema.rs
--rw-r--r--   0        0        0     1512 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/indicators/src/lib.rs
--rw-r--r--   0        0        0      881 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/Cargo.toml
--rw-r--r--   0        0        0      399 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/benches/criterion_fixed_precision_benchmark.rs
--rw-r--r--   0        0        0      225 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/benches/iai_fixed_precision_benchmark.rs
--rw-r--r--   0        0        0     2534 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/build.rs
--rw-r--r--   0        0        0     1201 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/cbindgen.toml
--rw-r--r--   0        0        0     1410 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/cbindgen_cython.toml
--rw-r--r--   0        0        0    22050 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/currencies.rs
--rw-r--r--   0        0        0    14495 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/bar.rs
--rw-r--r--   0        0        0     5702 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/bar_api.rs
--rw-r--r--   0        0        0    11452 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/book.rs
--rw-r--r--   0        0        0     3433 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/book_api.rs
--rw-r--r--   0        0        0     1947 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/mod.rs
--rw-r--r--   0        0        0     6502 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/tick.rs
--rw-r--r--   0        0        0     3272 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/tick_api.rs
--rw-r--r--   0        0        0    34427 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/enums.rs
--rw-r--r--   0        0        0      936 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/mod.rs
--rw-r--r--   0        0        0    11566 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/order.rs
--rw-r--r--   0        0        0     4127 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/order_api.rs
--rw-r--r--   0        0        0     3530 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/position.rs
--rw-r--r--   0        0        0     7357 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/account_id.rs
--rw-r--r--   0        0        0     4823 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/client_id.rs
--rw-r--r--   0        0        0     4213 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/client_order_id.rs
--rw-r--r--   0        0        0     3856 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/component_id.rs
--rw-r--r--   0        0        0     3998 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs
--rw-r--r--   0        0        0     6978 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/instrument_id.rs
--rw-r--r--   0        0        0     1901 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/macros.rs
--rw-r--r--   0        0        0     2798 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/mod.rs
--rw-r--r--   0        0        0     3830 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/order_list_id.rs
--rw-r--r--   0        0        0     3820 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/position_id.rs
--rw-r--r--   0        0        0     3733 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/strategy_id.rs
--rw-r--r--   0        0        0     3810 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/symbol.rs
--rw-r--r--   0        0        0     3744 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/trade_id.rs
--rw-r--r--   0        0        0     3678 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/trader_id.rs
--rw-r--r--   0        0        0     3765 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/venue.rs
--rw-r--r--   0        0        0     4004 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/venue_order_id.rs
--rw-r--r--   0        0        0     1866 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/instruments/mod.rs
--rw-r--r--   0        0        0     6754 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/instruments/synthetic.rs
--rw-r--r--   0        0        0     4886 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/instruments/synthetic_api.rs
--rw-r--r--   0        0        0     2485 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/lib.rs
--rw-r--r--   0        0        0    23202 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/book.rs
--rw-r--r--   0        0        0     6676 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/book_api.rs
--rw-r--r--   0        0        0    20289 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/ladder.rs
--rw-r--r--   0        0        0     9955 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/level.rs
--rw-r--r--   0        0        0      947 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/mod.rs
--rw-r--r--   0        0        0     4581 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orders/limit.rs
--rw-r--r--   0        0        0    27066 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orders/mod.rs
--rw-r--r--   0        0        0     7661 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/position.rs
--rw-r--r--   0        0        0     1342 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/balance.rs
--rw-r--r--   0        0        0     7370 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/currency.rs
--rw-r--r--   0        0        0     6164 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/fixed.rs
--rw-r--r--   0        0        0      982 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/mod.rs
--rw-r--r--   0        0        0     8544 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/money.rs
--rw-r--r--   0        0        0    11276 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/price.rs
--rw-r--r--   0        0        0    11648 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/quantity.rs
--rw-r--r--   0        0        0      835 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/network/Cargo.toml
--rw-r--r--   0        0        0     1649 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/network/benches/test_client.rs
--rw-r--r--   0        0        0     1652 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/benches/test_server.rs
--rw-r--r--   0        0        0    13452 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/http.rs
--rw-r--r--   0        0        0     1321 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/lib.rs
--rw-r--r--   0        0        0    10031 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/socket.rs
--rw-r--r--   0        0        0    21477 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/websocket.rs
--rw-r--r--   0        0        0       18 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/.gitignore
--rw-r--r--   0        0        0     2862 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md
--rw-r--r--   0        0        0     2408 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/Cargo.toml
--rw-r--r--   0        0        0     1093 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/LICENSE
--rw-r--r--   0        0        0     2861 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/README.md
--rw-r--r--   0        0        0      268 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/rustfmt.toml
--rw-r--r--   0        0        0     6903 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/compat.rs
--rw-r--r--   0        0        0     2747 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/connect.rs
--rw-r--r--   0        0        0     5486 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs
--rw-r--r--   0        0        0    14222 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/lib.rs
--rw-r--r--   0        0        0     2974 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/stream.rs
--rw-r--r--   0        0        0     9381 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/tls.rs
--rw-r--r--   0        0        0     3623 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/tests/communication.rs
--rw-r--r--   0        0        0      883 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/tests/handshakes.rs
--rw-r--r--   0        0        0     1065 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/Cargo.toml
--rw-r--r--   0        0        0     4179 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/benches/bench_persistence.rs
--rw-r--r--   0        0        0     6102 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/kmerge_batch.rs
--rw-r--r--   0        0        0     1285 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/lib.rs
--rw-r--r--   0        0        0     6861 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/bar.rs
--rw-r--r--   0        0        0     8163 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/delta.rs
--rw-r--r--   0        0        0      926 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/mod.rs
--rw-r--r--   0        0        0     6551 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/quote.rs
--rw-r--r--   0        0        0     6894 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/trade.rs
--rw-r--r--   0        0        0     1632 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/mod.rs
--rw-r--r--   0        0        0    11170 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/session.rs
--rw-r--r--   0        0        0     3536 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_catalog.rs
--rw-r--r--   0        0        0     2906 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_persistence_module.py
--rw-r--r--   0        0        0     2159 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_util.rs
--rw-r--r--   0        0        0      647 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/pyo3/Cargo.toml
--rw-r--r--   0        0        0     2591 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/pyo3/src/lib.rs
--rw-r--r--   0        0        0       50 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/rust-toolchain.toml
--rw-r--r--   0        0        0      225 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/rustfmt.toml
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/__init__.pxd
--rw-r--r--   0        0        0     1268 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.pxd
--rw-r--r--   0        0        0     1414 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.pxd
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.py
--rw-r--r--   0        0        0     3975 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pxd
--rw-r--r--   0        0        0    14292 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pyx
--rw-r--r--   0        0        0     1738 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pxd
--rw-r--r--   0        0        0     3421 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pyx
--rw-r--r--   0        0        0     1886 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pxd
--rw-r--r--   0        0        0    11342 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pyx
--rw-r--r--   0        0        0     3178 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pxd
--rw-r--r--   0        0        0    20725 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pyx
--rw-r--r--   0        0        0     1488 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pxd
--rw-r--r--   0        0        0    10737 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pyx
--rw-r--r--   0        0        0     2111 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/error.py
--rw-r--r--   0        0        0     1089 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pxd
--rw-r--r--   0        0        0     4063 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pyx
--rw-r--r--   0        0        0     2659 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pxd
--rw-r--r--   0        0        0    22701 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pyx
--rw-r--r--   0        0        0     1153 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/adapters/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/__init__.py
--rw-r--r--   0        0        0     1013 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/core.py
--rw-r--r--   0        0        0    13291 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/data.py
--rw-r--r--   0        0        0     6617 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/execution.py
--rw-r--r--   0        0        0     2461 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/providers.py
--rw-r--r--   0        0        0      946 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/__init__.py
--rw-r--r--   0        0        0    11386 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/core.py
--rw-r--r--   0        0        0     2278 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/enums.py
--rw-r--r--   0        0        0     3484 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/exceptions.py
--rw-r--r--   0        0        0     2395 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/spec.py
--rw-r--r--   0        0        0     2725 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/util.py
--rw-r--r--   0        0        0     2856 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/common.py
--rw-r--r--   0        0        0     2342 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/config.py
--rw-r--r--   0        0        0     2056 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/constants.py
--rw-r--r--   0        0        0    12886 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data.py
--rw-r--r--   0        0        0     7890 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data_types.py
--rw-r--r--   0        0        0    41677 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/execution.py
--rw-r--r--   0        0        0     8697 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/factories.py
--rw-r--r--   0        0        0     2919 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/historic.py
--rw-r--r--   0        0        0     1267 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pxd
--rw-r--r--   0        0        0     1994 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/__init__.py
--rw-r--r--   0        0        0     2557 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/common.py
--rw-r--r--   0        0        0     2153 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/core.py
--rw-r--r--   0        0        0    12492 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/requests.py
--rw-r--r--   0        0        0    24233 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/streaming.py
--rw-r--r--   0        0        0    13453 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/providers.py
--rw-r--r--   0        0        0     7303 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/sockets.py
--rw-r--r--   0        0        0      939 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/__init__.py
--rw-r--r--   0        0        0      957 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/constants.py
--rw-r--r--   0        0        0    26457 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/data.py
--rw-r--r--   0        0        0    11941 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/enums.py
--rw-r--r--   0        0        0    33817 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/execution.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/__init__.py
--rw-r--r--   0        0        0    10209 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/account.py
--rw-r--r--   0        0        0    21891 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/market.py
--rw-r--r--   0        0        0     2434 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/symbol.py
--rw-r--r--   0        0        0     1199 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/user.py
--rw-r--r--   0        0        0    14968 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/types.py
--rw-r--r--   0        0        0     4013 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/config.py
--rw-r--r--   0        0        0    16833 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/factories.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/__init__.py
--rw-r--r--   0        0        0     8645 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/data.py
--rw-r--r--   0        0        0     6746 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/enums.py
--rw-r--r--   0        0        0    12254 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/execution.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/__init__.py
--rw-r--r--   0        0        0    13350 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/account.py
--rw-r--r--   0        0        0     3643 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/market.py
--rw-r--r--   0        0        0     1961 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/user.py
--rw-r--r--   0        0        0     4879 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/wallet.py
--rw-r--r--   0        0        0    16510 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/providers.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py
--rw-r--r--   0        0        0     6885 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/account.py
--rw-r--r--   0        0        0     7589 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/market.py
--rw-r--r--   0        0        0    13834 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/user.py
--rw-r--r--   0        0        0     1271 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py
--rw-r--r--   0        0        0     5069 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/types.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/__init__.py
--rw-r--r--   0        0        0    24539 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/account.py
--rw-r--r--   0        0        0     4838 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/client.py
--rw-r--r--   0        0        0     3226 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/endpoint.py
--rw-r--r--   0        0        0     1558 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/error.py
--rw-r--r--   0        0        0    32295 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/market.py
--rw-r--r--   0        0        0     7770 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/user.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/__init__.py
--rw-r--r--   0        0        0     5722 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/data.py
--rw-r--r--   0        0        0     4799 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/enums.py
--rw-r--r--   0        0        0     9841 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/execution.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/__init__.py
--rw-r--r--   0        0        0    26418 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/account.py
--rw-r--r--   0        0        0     6703 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/market.py
--rw-r--r--   0        0        0     1967 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/user.py
--rw-r--r--   0        0        0     4663 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/wallet.py
--rw-r--r--   0        0        0    13621 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/providers.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py
--rw-r--r--   0        0        0     3299 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/account.py
--rw-r--r--   0        0        0     6803 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/market.py
--rw-r--r--   0        0        0    11677 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/user.py
--rw-r--r--   0        0        0     1252 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/__init__.py
--rw-r--r--   0        0        0     9396 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/client.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/__init__.py
--rw-r--r--   0        0        0     5601 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/client.py
--rw-r--r--   0        0        0     1554 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/error.py
--rw-r--r--   0        0        0      931 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/__init__.py
--rw-r--r--   0        0        0      957 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py
--rw-r--r--   0        0        0    61657 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/client.py
--rw-r--r--   0        0        0     6375 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/common.py
--rw-r--r--   0        0        0     6816 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/common.py
--rw-r--r--   0        0        0     7192 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/config.py
--rw-r--r--   0        0        0    17666 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/data.py
--rw-r--r--   0        0        0    36373 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/execution.py
--rw-r--r--   0        0        0     9483 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/factories.py
--rw-r--r--   0        0        0     7055 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/gateway.py
--rw-r--r--   0        0        0    13994 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/historic.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py
--rw-r--r--   0        0        0     3248 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py
--rw-r--r--   0        0        0     3843 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py
--rw-r--r--   0        0        0    15711 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py
--rw-r--r--   0        0        0    11931 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/providers.py
--rw-r--r--   0        0        0     4646 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/web.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/__init__.py
--rw-r--r--   0        0        0     1393 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/config.py
--rw-r--r--   0        0        0     7838 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/execution.py
--rw-r--r--   0        0        0     2693 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/factory.py
--rw-r--r--   0        0        0      979 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/__init__.py
--rw-r--r--   0        0        0    15157 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/analyzer.py
--rw-r--r--   0        0        0     4706 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/reporter.py
--rw-r--r--   0        0        0     3968 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistic.py
--rw-r--r--   0        0        0     2255 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/__init__.py
--rw-r--r--   0        0        0     2016 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/expectancy.py
--rw-r--r--   0        0        0     1717 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/long_ratio.py
--rw-r--r--   0        0        0     1481 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_avg.py
--rw-r--r--   0        0        0     1527 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_max.py
--rw-r--r--   0        0        0     1525 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_min.py
--rw-r--r--   0        0        0     1576 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/profit_factor.py
--rw-r--r--   0        0        0     1412 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg.py
--rw-r--r--   0        0        0     1427 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_loss.py
--rw-r--r--   0        0        0     1426 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_win.py
--rw-r--r--   0        0        0     1728 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_volatility.py
--rw-r--r--   0        0        0     1336 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/risk_return_ratio.py
--rw-r--r--   0        0        0     1788 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sharpe_ratio.py
--rw-r--r--   0        0        0     1895 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sortino_ratio.py
--rw-r--r--   0        0        0     1511 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/win_rate.py
--rw-r--r--   0        0        0     1502 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_avg.py
--rw-r--r--   0        0        0     1360 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_max.py
--rw-r--r--   0        0        0     1507 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_min.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.pxd
--rw-r--r--   0        0        0      945 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.py
--rw-r--r--   0        0        0     1710 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/__main__.py
--rw-r--r--   0        0        0     3840 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/auction.py
--rw-r--r--   0        0        0     1100 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pxd
--rw-r--r--   0        0        0    12847 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pyx
--rw-r--r--   0        0        0     2164 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pxd
--rw-r--r--   0        0        0    47964 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pyx
--rw-r--r--   0        0        0     7183 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pxd
--rw-r--r--   0        0        0    29202 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pyx
--rw-r--r--   0        0        0     1084 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pxd
--rw-r--r--   0        0        0     5182 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pyx
--rw-r--r--   0        0        0    11478 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pxd
--rw-r--r--   0        0        0    86190 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pyx
--rw-r--r--   0        0        0     2075 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/models.pxd
--rw-r--r--   0        0        0     5344 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/models.pyx
--rw-r--r--   0        0        0     1814 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pxd
--rw-r--r--   0        0        0     8294 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pyx
--rw-r--r--   0        0        0    11390 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/node.py
--rw-r--r--   0        0        0     3110 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/results.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/__init__.pxd
--rw-r--r--   0        0        0     1052 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/__init__.py
--rw-r--r--   0        0        0     9896 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/base.pxd
--rw-r--r--   0        0        0    23040 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/base.pyx
--rw-r--r--   0        0        0     7346 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/cache.pxd
--rw-r--r--   0        0        0   123311 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/cache.pyx
--rw-r--r--   0        0        0     3663 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/database.pxd
--rw-r--r--   0        0        0     9114 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/database.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/__init__.pxd
--rw-r--r--   0        0        0     1571 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/__init__.py
--rw-r--r--   0        0        0    10008 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/actor.pxd
--rw-r--r--   0        0        0    73784 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/actor.pyx
--rw-r--r--   0        0        0     3551 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/clock.pxd
--rw-r--r--   0        0        0    27231 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/clock.pyx
--rw-r--r--   0        0        0     2916 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/component.pxd
--rw-r--r--   0        0        0    20109 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/component.pyx
--rw-r--r--   0        0        0     1836 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/enums.pyx
--rw-r--r--   0        0        0     1518 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pxd
--rw-r--r--   0        0        0     2638 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pyx
--rw-r--r--   0        0        0     9277 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/factories.pxd
--rw-r--r--   0        0        0    56125 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/factories.pyx
--rw-r--r--   0        0        0     1320 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/functions.py
--rw-r--r--   0        0        0     2139 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/generators.pxd
--rw-r--r--   0        0        0     7837 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/generators.pyx
--rw-r--r--   0        0        0     2492 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/logging.pxd
--rw-r--r--   0        0        0    18806 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/logging.pyx
--rw-r--r--   0        0        0     2421 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/messages.pxd
--rw-r--r--   0        0        0    10632 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/messages.pyx
--rw-r--r--   0        0        0    10746 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/providers.py
--rw-r--r--   0        0        0     1566 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/queue.pxd
--rw-r--r--   0        0        0     5704 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/queue.pyx
--rw-r--r--   0        0        0     2440 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/throttler.pxd
--rw-r--r--   0        0        0     7418 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/throttler.pyx
--rw-r--r--   0        0        0     2482 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/timer.pxd
--rw-r--r--   0        0        0    11992 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/timer.pyx
--rw-r--r--   0        0        0     3793 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/config/__init__.py
--rw-r--r--   0        0        0     9913 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/backtest.py
--rw-r--r--   0        0        0    21003 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/common.py
--rw-r--r--   0        0        0     1015 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/error.py
--rw-r--r--   0        0        0     6651 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/live.py
--rw-r--r--   0        0        0     1264 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/validation.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/__init__.pxd
--rw-r--r--   0        0        0     1339 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/__init__.py
--rw-r--r--   0        0        0     1230 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/asynchronous.py
--rw-r--r--   0        0        0     3628 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/correctness.pxd
--rw-r--r--   0        0        0    37204 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/correctness.pyx
--rw-r--r--   0        0        0      897 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/data.pxd
--rw-r--r--   0        0        0     1954 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/data.pyx
--rw-r--r--   0        0        0     1680 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/datetime.pxd
--rw-r--r--   0        0        0     9479 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/datetime.pyx
--rw-r--r--   0        0        0     1230 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/fsm.pxd
--rw-r--r--   0        0        0     4364 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/fsm.pyx
--rw-r--r--   0        0        0     2511 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/algorithms.h
--rw-r--r--   0        0        0      907 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/backtest.h
--rw-r--r--   0        0        0    12998 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/common.h
--rw-r--r--   0        0        0     3027 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/core.h
--rw-r--r--   0        0        0    50013 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/model.h
--rw-r--r--   0        0        0     2325 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/inspect.py
--rw-r--r--   0        0        0     2471 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/message.pxd
--rw-r--r--   0        0        0     6720 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/message.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/__init__.pxd
--rw-r--r--   0        0        0     2635 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/algorithms.pxd
--rw-r--r--   0        0        0     1050 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/backtest.pxd
--rw-r--r--   0        0        0    12551 2023-06-17 12:53:55.864524 nautilus_trader-1.175.0/nautilus_trader/core/rust/common.pxd
--rw-r--r--   0        0        0     1222 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/common.pyx
--rw-r--r--   0        0        0     2998 2023-06-17 12:52:52.095179 nautilus_trader-1.175.0/nautilus_trader/core/rust/core.pxd
--rw-r--r--   0        0        0    46788 2023-06-17 12:53:12.008904 nautilus_trader-1.175.0/nautilus_trader/core/rust/model.pxd
--rw-r--r--   0        0        0     2618 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/model.pyx
--rw-r--r--   0        0        0     1359 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/stats.pxd
--rw-r--r--   0        0        0     5710 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/stats.pyx
--rw-r--r--   0        0        0     3698 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/string.pxd
--rw-r--r--   0        0        0     1049 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/uuid.pxd
--rw-r--r--   0        0        0     3157 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/uuid.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/__init__.pxd
--rw-r--r--   0        0        0     1360 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/__init__.py
--rw-r--r--   0        0        0     4156 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pxd
--rw-r--r--   0        0        0    24142 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pyx
--rw-r--r--   0        0        0     8386 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/client.pxd
--rw-r--r--   0        0        0    41150 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/client.pyx
--rw-r--r--   0        0        0     9166 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/engine.pxd
--rw-r--r--   0        0        0    56337 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/engine.pyx
--rw-r--r--   0        0        0     2396 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/messages.pxd
--rw-r--r--   0        0        0     8389 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/messages.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/__init__.py
--rw-r--r--   0        0        0     4133 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/blank.py
--rw-r--r--   0        0        0    11508 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/twap.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.pxd
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.py
--rw-r--r--   0        0        0     5567 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/blank.py
--rw-r--r--   0        0        0    12080 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross.py
--rw-r--r--   0        0        0    11997 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket.py
--rw-r--r--   0        0        0    14914 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py
--rw-r--r--   0        0        0    10735 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx
--rw-r--r--   0        0        0    15993 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py
--rw-r--r--   0        0        0    14375 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py
--rw-r--r--   0        0        0    12721 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_twap.py
--rw-r--r--   0        0        0     5331 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/market_maker.py
--rw-r--r--   0        0        0     8092 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/orderbook_imbalance.py
--rw-r--r--   0        0        0     2720 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/signal_strategy.py
--rw-r--r--   0        0        0     4641 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/subscribe.py
--rw-r--r--   0        0        0    13449 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/volatility_market_maker.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/__init__.pxd
--rw-r--r--   0        0        0     1353 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/__init__.py
--rw-r--r--   0        0        0     5954 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pxd
--rw-r--r--   0        0        0    38095 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pyx
--rw-r--r--   0        0        0     7458 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/client.pxd
--rw-r--r--   0        0        0    28604 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/client.pyx
--rw-r--r--   0        0        0     4418 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pxd
--rw-r--r--   0        0        0    40391 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pyx
--rw-r--r--   0        0        0     6579 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/engine.pxd
--rw-r--r--   0        0        0    41895 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/engine.pyx
--rw-r--r--   0        0        0     3485 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pxd
--rw-r--r--   0        0        0    14476 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pyx
--rw-r--r--   0        0        0     5380 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/messages.pxd
--rw-r--r--   0        0        0    30390 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/messages.pyx
--rw-r--r--   0        0        0     8370 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/reports.pxd
--rw-r--r--   0        0        0    22070 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/reports.pyx
--rw-r--r--   0        0        0     1785 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pxd
--rw-r--r--   0        0        0    16636 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.pxd
--rw-r--r--   0        0        0     1188 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.py
--rw-r--r--   0        0        0     1722 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pxd
--rw-r--r--   0        0        0     4836 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pyx
--rw-r--r--   0        0        0     1482 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pxd
--rw-r--r--   0        0        0     3474 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pyx
--rw-r--r--   0        0        0     1474 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pxd
--rw-r--r--   0        0        0     4324 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.pxd
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.py
--rw-r--r--   0        0        0     1770 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pxd
--rw-r--r--   0        0        0     5197 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pyx
--rw-r--r--   0        0        0     1063 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pxd
--rw-r--r--   0        0        0     3852 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pyx
--rw-r--r--   0        0        0     1096 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pxd
--rw-r--r--   0        0        0     3466 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pyx
--rw-r--r--   0        0        0     1247 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pxd
--rw-r--r--   0        0        0     4335 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pyx
--rw-r--r--   0        0        0     3114 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ma_factory.pyx
--rw-r--r--   0        0        0     1566 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pxd
--rw-r--r--   0        0        0     2945 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pyx
--rw-r--r--   0        0        0     1080 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pxd
--rw-r--r--   0        0        0     3478 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pyx
--rw-r--r--   0        0        0     1020 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pxd
--rw-r--r--   0        0        0     3542 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pyx
--rw-r--r--   0        0        0     1283 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pxd
--rw-r--r--   0        0        0     4604 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pyx
--rw-r--r--   0        0        0     1174 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pxd
--rw-r--r--   0        0        0     4712 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.pxd
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.py
--rw-r--r--   0        0        0     1715 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pxd
--rw-r--r--   0        0        0     2981 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pyx
--rw-r--r--   0        0        0     1315 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pxd
--rw-r--r--   0        0        0     2872 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pyx
--rw-r--r--   0        0        0     1579 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pxd
--rw-r--r--   0        0        0     5221 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pyx
--rw-r--r--   0        0        0     1639 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pxd
--rw-r--r--   0        0        0     4060 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pyx
--rw-r--r--   0        0        0     1375 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pxd
--rw-r--r--   0        0        0     3664 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pyx
--rw-r--r--   0        0        0     1662 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pxd
--rw-r--r--   0        0        0     3736 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pyx
--rw-r--r--   0        0        0     1490 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pxd
--rw-r--r--   0        0        0     4376 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pyx
--rw-r--r--   0        0        0     1231 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pxd
--rw-r--r--   0        0        0     3123 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pyx
--rw-r--r--   0        0        0     3172 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd
--rw-r--r--   0        0        0    12544 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx
--rw-r--r--   0        0        0     1347 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enum.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.py
--rw-r--r--   0        0        0      976 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd
--rw-r--r--   0        0        0      980 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx
--rw-r--r--   0        0        0      947 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd
--rw-r--r--   0        0        0      987 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx
--rw-r--r--   0        0        0     1020 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd
--rw-r--r--   0        0        0      972 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx
--rw-r--r--   0        0        0      972 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd
--rw-r--r--   0        0        0      980 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx
--rw-r--r--   0        0        0     1809 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pxd
--rw-r--r--   0        0        0     4675 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pyx
--rw-r--r--   0        0        0     1395 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pxd
--rw-r--r--   0        0        0     4284 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pyx
--rw-r--r--   0        0        0     1713 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pxd
--rw-r--r--   0        0        0     4731 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pyx
--rw-r--r--   0        0        0     1636 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pxd
--rw-r--r--   0        0        0     3843 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pyx
--rw-r--r--   0        0        0     1662 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pxd
--rw-r--r--   0        0        0     4821 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pyx
--rw-r--r--   0        0        0     1232 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pxd
--rw-r--r--   0        0        0     2962 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pyx
--rw-r--r--   0        0        0     1514 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pxd
--rw-r--r--   0        0        0     4387 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pyx
--rw-r--r--   0        0        0     1476 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pxd
--rw-r--r--   0        0        0     3315 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pyx
--rw-r--r--   0        0        0     1227 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pxd
--rw-r--r--   0        0        0     2730 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pyx
--rw-r--r--   0        0        0     1393 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pxd
--rw-r--r--   0        0        0     3771 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pyx
--rw-r--r--   0        0        0     1767 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pxd
--rw-r--r--   0        0        0     4543 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pyx
--rw-r--r--   0        0        0     1444 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pxd
--rw-r--r--   0        0        0     3384 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pyx
--rw-r--r--   0        0        0     1485 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pxd
--rw-r--r--   0        0        0     3888 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pyx
--rw-r--r--   0        0        0     2275 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pxd
--rw-r--r--   0        0        0     4682 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pyx
--rw-r--r--   0        0        0     1458 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vhf.pxd
--rw-r--r--   0        0        0     3517 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vhf.pyx
--rw-r--r--   0        0        0     1485 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pxd
--rw-r--r--   0        0        0     4486 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pyx
--rw-r--r--   0        0        0     1270 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pxd
--rw-r--r--   0        0        0     2942 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.pxd
--rw-r--r--   0        0        0     1047 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.py
--rw-r--r--   0        0        0     1362 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pxd
--rw-r--r--   0        0        0    30746 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pyx
--rw-r--r--   0        0        0     1155 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/__init__.py
--rw-r--r--   0        0        0     1849 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/__main__.py
--rw-r--r--   0        0        0    30839 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/data_client.py
--rw-r--r--   0        0        0    15072 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/data_engine.py
--rw-r--r--   0        0        0    16682 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/execution_client.py
--rw-r--r--   0        0        0    37905 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/execution_engine.py
--rw-r--r--   0        0        0     3535 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/factories.py
--rw-r--r--   0        0        0    16026 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/node.py
--rw-r--r--   0        0        0     9050 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/node_builder.py
--rw-r--r--   0        0        0     9203 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/live/risk_engine.py
--rw-r--r--   0        0        0     5505 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/__init__.pxd
--rw-r--r--   0        0        0     1141 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/__init__.py
--rw-r--r--   0        0        0     3751 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/currencies.py
--rw-r--r--   0        0        0     1375 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/currency.pxd
--rw-r--r--   0        0        0     9509 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/currency.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.pxd
--rw-r--r--   0        0        0     2125 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.py
--rw-r--r--   0        0        0     2541 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pxd
--rw-r--r--   0        0        0    26954 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pyx
--rw-r--r--   0        0        0     1178 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pxd
--rw-r--r--   0        0        0      958 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pyx
--rw-r--r--   0        0        0     1467 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/base.pxd
--rw-r--r--   0        0        0     3832 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/base.pyx
--rw-r--r--   0        0        0     3103 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/book.pxd
--rw-r--r--   0        0        0    16647 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/book.pyx
--rw-r--r--   0        0        0     3740 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pxd
--rw-r--r--   0        0        0    24661 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pyx
--rw-r--r--   0        0        0     1529 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pxd
--rw-r--r--   0        0        0     3312 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pyx
--rw-r--r--   0        0        0     3331 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pxd
--rw-r--r--   0        0        0     9886 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pyx
--rw-r--r--   0        0        0     7239 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/enums.pyx
--rw-r--r--   0        0        0     4770 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pxd
--rw-r--r--   0        0        0    10998 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/__init__.pxd
--rw-r--r--   0        0        0     2664 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/__init__.py
--rw-r--r--   0        0        0     2058 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/account.pxd
--rw-r--r--   0        0        0     5965 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/account.pyx
--rw-r--r--   0        0        0     9385 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/order.pxd
--rw-r--r--   0        0        0    88334 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/order.pyx
--rw-r--r--   0        0        0     5544 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/position.pxd
--rw-r--r--   0        0        0    34546 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/position.pyx
--rw-r--r--   0        0        0     2975 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pxd
--rw-r--r--   0        0        0    24599 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pyx
--rw-r--r--   0        0        0        0 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/__init__.pxd
--rw-r--r--   0        0        0     1752 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/__init__.py
--rw-r--r--   0        0        0     5271 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pxd
--rw-r--r--   0        0        0    19927 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pyx
--rw-r--r--   0        0        0     1745 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pxd
--rw-r--r--   0        0        0     7717 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pyx
--rw-r--r--   0        0        0     1521 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pxd
--rw-r--r--   0        0        0    11042 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pyx
--rw-r--r--   0        0        0     1491 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pxd
--rw-r--r--   0        0        0    11211 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pyx
--rw-r--r--   0        0        0     1265 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pxd
--rw-r--r--   0        0        0    11354 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pyx
--rw-r--r--   0        0        0     1108 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pxd
--rw-r--r--   0        0        0     7433 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pyx
--rw-r--r--   0        0        0     1344 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pxd
--rw-r--r--   0        0        0     6920 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pyx
--rw-r--r--   0        0        0     1386 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pxd
--rw-r--r--   0        0        0     7573 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pyx
--rw-r--r--   0        0        0     1212 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/synthetic.pxd
--rw-r--r--   0        0        0     6590 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/synthetic.pyx
--rw-r--r--   0        0        0     5402 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/objects.pxd
--rw-r--r--   0        0        0    41153 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/objects.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.pxd
--rw-r--r--   0        0        0     1270 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.py
--rw-r--r--   0        0        0     2644 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/book.pxd
--rw-r--r--   0        0        0    15327 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/book.pyx
--rw-r--r--   0        0        0     1005 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/error.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.pxd
--rw-r--r--   0        0        0     2093 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.py
--rw-r--r--   0        0        0     9208 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/base.pxd
--rw-r--r--   0        0        0    34743 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/base.pyx
--rw-r--r--   0        0        0     1705 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pxd
--rw-r--r--   0        0        0    18225 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pyx
--rw-r--r--   0        0        0     2171 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pxd
--rw-r--r--   0        0        0    17334 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pyx
--rw-r--r--   0        0        0     1849 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pxd
--rw-r--r--   0        0        0     2367 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pyx
--rw-r--r--   0        0        0     1206 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pxd
--rw-r--r--   0        0        0    13291 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pyx
--rw-r--r--   0        0        0     1608 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pxd
--rw-r--r--   0        0        0    15612 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pyx
--rw-r--r--   0        0        0     1644 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pxd
--rw-r--r--   0        0        0    13929 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pyx
--rw-r--r--   0        0        0     2161 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pxd
--rw-r--r--   0        0        0    17474 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pyx
--rw-r--r--   0        0        0     1598 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pxd
--rw-r--r--   0        0        0    15777 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pyx
--rw-r--r--   0        0        0     2641 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pxd
--rw-r--r--   0        0        0    19377 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pyx
--rw-r--r--   0        0        0     1947 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_market.pxd
--rw-r--r--   0        0        0    17026 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_market.pyx
--rw-r--r--   0        0        0     1141 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pxd
--rw-r--r--   0        0        0     3906 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pyx
--rw-r--r--   0        0        0     6860 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/position.pxd
--rw-r--r--   0        0        0    23025 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/position.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.pxd
--rw-r--r--   0        0        0     1311 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.py
--rw-r--r--   0        0        0     1581 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pxd
--rw-r--r--   0        0        0     3709 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pyx
--rw-r--r--   0        0        0     1147 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/__init__.py
--rw-r--r--   0        0        0     1371 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd
--rw-r--r--   0        0        0     4052 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx
--rw-r--r--   0        0        0     1359 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd
--rw-r--r--   0        0        0     5632 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.pxd
--rw-r--r--   0        0        0      994 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.py
--rw-r--r--   0        0        0     2718 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pxd
--rw-r--r--   0        0        0    16946 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pyx
--rw-r--r--   0        0        0     1181 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pxd
--rw-r--r--   0        0        0     3066 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/__init__.pxd
--rw-r--r--   0        0        0     1125 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/__init__.py
--rw-r--r--   0        0        0     1020 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/error.py
--rw-r--r--   0        0        0     1520 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/http.pxd
--rw-r--r--   0        0        0     9912 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/http.pyx
--rw-r--r--   0        0        0     1868 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/socket.pxd
--rw-r--r--   0        0        0     6595 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/socket.pyx
--rw-r--r--   0        0        0     7780 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/socket_pyo3.py
--rw-r--r--   0        0        0      972 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/__init__.py
--rw-r--r--   0        0        0     1079 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/__init__.py
--rw-r--r--   0        0        0     6083 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/base.py
--rw-r--r--   0        0        0    18551 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/parquet.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/__init__.py
--rw-r--r--   0        0        0    15158 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/core.py
--rw-r--r--   0        0        0     1555 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/metadata.py
--rw-r--r--   0        0        0    13281 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/readers.py
--rw-r--r--   0        0        0     4017 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/util.py
--rw-r--r--   0        0        0     2152 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/funcs.py
--rw-r--r--   0        0        0     5432 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/loaders.py
--rw-r--r--   0        0        0     1530 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/migrate.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/__init__.py
--rw-r--r--   0        0        0     5187 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/batching.py
--rw-r--r--   0        0        0     8224 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/engine.py
--rw-r--r--   0        0        0     8933 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/writer.py
--rw-r--r--   0        0        0     2564 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pxd
--rw-r--r--   0        0        0    17852 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.pxd
--rw-r--r--   0        0        0      948 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.py
--rw-r--r--   0        0        0     2132 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pxd
--rw-r--r--   0        0        0     4033 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pyx
--rw-r--r--   0        0        0     3143 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pxd
--rw-r--r--   0        0        0    37984 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/__init__.pxd
--rw-r--r--   0        0        0     1084 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/__init__.py
--rw-r--r--   0        0        0     5613 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/engine.pxd
--rw-r--r--   0        0        0    36965 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/engine.pyx
--rw-r--r--   0        0        0     1747 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/sizing.pxd
--rw-r--r--   0        0        0     7081 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/sizing.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.pxd
--rw-r--r--   0        0        0     1106 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.pxd
--rw-r--r--   0        0        0      948 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.py
--rw-r--r--   0        0        0     1408 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/__init__.py
--rw-r--r--   0        0        0     4214 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/account_state.py
--rw-r--r--   0        0        0     1369 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/bar.py
--rw-r--r--   0        0        0     1090 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/instruments.py
--rw-r--r--   0        0        0     3798 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_book.py
--rw-r--r--   0        0        0     2923 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_events.py
--rw-r--r--   0        0        0     3845 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py
--rw-r--r--   0        0        0     2837 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/position_events.py
--rw-r--r--   0        0        0    28986 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema.py
--rw-r--r--   0        0        0     3004 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema_v2.py
--rw-r--r--   0        0        0      910 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/serializer.pxd
--rw-r--r--   0        0        0     6178 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/serializer.pyx
--rw-r--r--   0        0        0     4625 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/util.py
--rw-r--r--   0        0        0     1053 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/base.pxd
--rw-r--r--   0        0        0    10114 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/base.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/__init__.pxd
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/__init__.py
--rw-r--r--   0        0        0     1097 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/serializer.pxd
--rw-r--r--   0        0        0     3649 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/serializer.pyx
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/system/__init__.py
--rw-r--r--   0        0        0    27789 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/system/kernel.py
--rw-r--r--   0        0        0     1035 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/__init__.py
--rw-r--r--   0        0        0     1746 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/functions.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/__init__.py
--rw-r--r--   0        0        0     6160 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/actors.py
--rw-r--r--   0        0        0     5825 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/cache_database.py
--rw-r--r--   0        0        0     3992 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/data.py
--rw-r--r--   0        0        0     3077 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/engines.py
--rw-r--r--   0        0        0    12905 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/exec_clients.py
--rw-r--r--   0        0        0     6069 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/strategies.py
--rw-r--r--   0        0        0     3173 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/performance.py
--rw-r--r--   0        0        0    20761 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/providers.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/__init__.py
--rw-r--r--   0        0        0     4887 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/commands.py
--rw-r--r--   0        0        0     6602 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/component.py
--rw-r--r--   0        0        0     6386 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/config.py
--rw-r--r--   0        0        0    18470 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/data.py
--rw-r--r--   0        0        0    13987 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/events.py
--rw-r--r--   0        0        0     9540 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/execution.py
--rw-r--r--   0        0        0     3651 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/identifiers.py
--rw-r--r--   0        0        0     2970 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/persistence.py
--rw-r--r--   0        0        0      869 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/__init__.pxd
--rw-r--r--   0        0        0     1145 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/__init__.py
--rw-r--r--   0        0        0     2193 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/filters.pxd
--rw-r--r--   0        0        0    16984 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/filters.pyx
--rw-r--r--   0        0        0     6774 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pxd
--rw-r--r--   0        0        0    53645 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pyx
--rw-r--r--   0        0        0     3055 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/trader.pxd
--rw-r--r--   0        0        0    20230 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/trader.pyx
--rw-r--r--   0        0        0     7502 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/pyproject.toml
--rw-r--r--   0        0        0    26388 1970-01-01 00:00:00.000000 nautilus_trader-1.175.0/PKG-INFO
+-rw-r--r--   0        0        0     7652 2023-07-31 04:06:38.176145 nautilus_trader-1.176.0/LICENSE
+-rw-r--r--   0        0        0    24247 2023-07-31 04:06:38.176145 nautilus_trader-1.176.0/README.md
+-rw-r--r--   0        0        0    12677 2023-07-31 04:06:38.176145 nautilus_trader-1.176.0/build.py
+-rw-r--r--   0        0        0      663 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/.cargo/config.toml
+-rw-r--r--   0        0        0    94933 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/Cargo.lock
+-rw-r--r--   0        0        0     1782 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/Cargo.toml
+-rw-r--r--   0        0        0     7652 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/LICENSE
+-rw-r--r--   0        0        0     1248 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/README.md
+-rw-r--r--   0        0        0      702 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/backtest/Cargo.toml
+-rw-r--r--   0        0        0     1882 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/backtest/build.rs
+-rw-r--r--   0        0        0      484 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/backtest/cbindgen.toml
+-rw-r--r--   0        0        0      810 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/backtest/cbindgen_cython.toml
+-rw-r--r--   0        0        0     5732 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/backtest/src/engine.rs
+-rw-r--r--   0        0        0      900 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/backtest/src/lib.rs
+-rw-r--r--   0        0        0       65 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/clippy.toml
+-rw-r--r--   0        0        0      715 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/Cargo.toml
+-rw-r--r--   0        0        0     2536 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/build.rs
+-rw-r--r--   0        0        0      531 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/cbindgen.toml
+-rw-r--r--   0        0        0      724 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/cbindgen_cython.toml
+-rw-r--r--   0        0        0    18863 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/clock.rs
+-rw-r--r--   0        0        0     8305 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/clock_api.rs
+-rw-r--r--   0        0        0     9689 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/enums.rs
+-rw-r--r--   0        0        0     1038 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/lib.rs
+-rw-r--r--   0        0        0    22768 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/logging.rs
+-rw-r--r--   0        0        0     4364 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/logging_api.rs
+-rw-r--r--   0        0        0     7304 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/msgbus.rs
+-rw-r--r--   0        0        0     2463 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/testing.rs
+-rw-r--r--   0        0        0     7894 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/timer.rs
+-rw-r--r--   0        0        0     1857 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/common/src/timer_api.rs
+-rw-r--r--   0        0        0      666 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/Cargo.toml
+-rw-r--r--   0        0        0     1234 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/benches/criterion_time_benchmark.rs
+-rw-r--r--   0        0        0     2532 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/build.rs
+-rw-r--r--   0        0        0      681 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/cbindgen.toml
+-rw-r--r--   0        0        0      791 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/cbindgen_cython.toml
+-rw-r--r--   0        0        0     7697 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/correctness.rs
+-rw-r--r--   0        0        0     5624 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/cvec.rs
+-rw-r--r--   0        0        0     5257 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/datetime.rs
+-rw-r--r--   0        0        0     1021 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/lib.rs
+-rw-r--r--   0        0        0     7591 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/parsing.rs
+-rw-r--r--   0        0        0     1772 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/serialization.rs
+-rw-r--r--   0        0        0     5197 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/string.rs
+-rw-r--r--   0        0        0     5118 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/time.rs
+-rw-r--r--   0        0        0     7852 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/core/src/uuid.rs
+-rw-r--r--   0        0        0      497 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/indicators/Cargo.toml
+-rw-r--r--   0        0        0     5090 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/indicators/src/ema.rs
+-rw-r--r--   0        0        0     1507 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/indicators/src/lib.rs
+-rw-r--r--   0        0        0      910 2023-07-31 04:06:38.192146 nautilus_trader-1.176.0/nautilus_core/model/Cargo.toml
+-rw-r--r--   0        0        0      399 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/benches/criterion_fixed_precision_benchmark.rs
+-rw-r--r--   0        0        0      225 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/benches/iai_fixed_precision_benchmark.rs
+-rw-r--r--   0        0        0     2534 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/build.rs
+-rw-r--r--   0        0        0     1218 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/cbindgen.toml
+-rw-r--r--   0        0        0     1427 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/cbindgen_cython.toml
+-rw-r--r--   0        0        0    19145 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/currencies.rs
+-rw-r--r--   0        0        0    19861 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/bar.rs
+-rw-r--r--   0        0        0     5318 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/bar_api.rs
+-rw-r--r--   0        0        0    10781 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/delta.rs
+-rw-r--r--   0        0        0     1834 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/delta_api.rs
+-rw-r--r--   0        0        0     2095 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/mod.rs
+-rw-r--r--   0        0        0    13461 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/order.rs
+-rw-r--r--   0        0        0     2399 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/order_api.rs
+-rw-r--r--   0        0        0    10618 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/quote.rs
+-rw-r--r--   0        0        0     2712 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/quote_api.rs
+-rw-r--r--   0        0        0     5049 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/ticker.rs
+-rw-r--r--   0        0        0     1609 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/ticker_api.rs
+-rw-r--r--   0        0        0     9989 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/trade.rs
+-rw-r--r--   0        0        0     2167 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/data/trade_api.rs
+-rw-r--r--   0        0        0    36175 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/enums.rs
+-rw-r--r--   0        0        0      936 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/events/mod.rs
+-rw-r--r--   0        0        0    11917 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/events/order.rs
+-rw-r--r--   0        0        0     4127 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/events/order_api.rs
+-rw-r--r--   0        0        0     4261 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/events/position.rs
+-rw-r--r--   0        0        0     5086 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/account_id.rs
+-rw-r--r--   0        0        0     3243 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/client_id.rs
+-rw-r--r--   0        0        0     2935 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/client_order_id.rs
+-rw-r--r--   0        0        0     2718 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/component_id.rs
+-rw-r--r--   0        0        0     2747 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs
+-rw-r--r--   0        0        0     6995 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/instrument_id.rs
+-rw-r--r--   0        0        0     1901 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/macros.rs
+-rw-r--r--   0        0        0     2991 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/mod.rs
+-rw-r--r--   0        0        0     2699 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/order_list_id.rs
+-rw-r--r--   0        0        0     2708 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/position_id.rs
+-rw-r--r--   0        0        0     2939 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/strategy_id.rs
+-rw-r--r--   0        0        0     2791 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/symbol.rs
+-rw-r--r--   0        0        0     2688 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/trade_id.rs
+-rw-r--r--   0        0        0     2887 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/trader_id.rs
+-rw-r--r--   0        0        0     3109 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/venue.rs
+-rw-r--r--   0        0        0     2842 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/venue_order_id.rs
+-rw-r--r--   0        0        0     5009 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/crypto_future.rs
+-rw-r--r--   0        0        0     5062 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/crypto_perpetual.rs
+-rw-r--r--   0        0        0     4937 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/currency_pair.rs
+-rw-r--r--   0        0        0     4784 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/equity.rs
+-rw-r--r--   0        0        0     4912 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/futures_contract.rs
+-rw-r--r--   0        0        0     4323 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/mod.rs
+-rw-r--r--   0        0        0     5099 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/options_contract.rs
+-rw-r--r--   0        0        0     7527 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/synthetic.rs
+-rw-r--r--   0        0        0     5666 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/instruments/synthetic_api.rs
+-rw-r--r--   0        0        0     2821 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/lib.rs
+-rw-r--r--   0        0        0     1562 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/macros.rs
+-rw-r--r--   0        0        0    25973 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/book.rs
+-rw-r--r--   0        0        0     7350 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/book_api.rs
+-rw-r--r--   0        0        0    21004 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/ladder.rs
+-rw-r--r--   0        0        0    12557 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/level.rs
+-rw-r--r--   0        0        0     3454 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/level_api.rs
+-rw-r--r--   0        0        0      966 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/mod.rs
+-rw-r--r--   0        0        0    26601 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/base.rs
+-rw-r--r--   0        0        0    10312 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/limit.rs
+-rw-r--r--   0        0        0    11277 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/limit_if_touched.rs
+-rw-r--r--   0        0        0     9495 2023-07-31 04:06:38.196146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/market.rs
+-rw-r--r--   0        0        0    11005 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/market_if_touched.rs
+-rw-r--r--   0        0        0    10208 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/market_to_limit.rs
+-rw-r--r--   0        0        0     1108 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/mod.rs
+-rw-r--r--   0        0        0    11168 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/stop_limit.rs
+-rw-r--r--   0        0        0    10935 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/stop_market.rs
+-rw-r--r--   0        0        0    12031 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/trailing_stop_limit.rs
+-rw-r--r--   0        0        0    11463 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/orders/trailing_stop_market.rs
+-rw-r--r--   0        0        0     7588 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/position.rs
+-rw-r--r--   0        0        0     1342 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/types/balance.rs
+-rw-r--r--   0        0        0     6504 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/types/currency.rs
+-rw-r--r--   0        0        0     6164 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/types/fixed.rs
+-rw-r--r--   0        0        0      982 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/types/mod.rs
+-rw-r--r--   0        0        0     8437 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/types/money.rs
+-rw-r--r--   0        0        0    12817 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/types/price.rs
+-rw-r--r--   0        0        0    12217 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/model/src/types/quantity.rs
+-rw-r--r--   0        0        0      864 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/Cargo.toml
+-rw-r--r--   0        0        0     1649 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/benches/test_client.rs
+-rw-r--r--   0        0        0     1652 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/benches/test_server.rs
+-rw-r--r--   0        0        0    13452 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/src/http.rs
+-rw-r--r--   0        0        0     1321 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/src/lib.rs
+-rw-r--r--   0        0        0    13746 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/src/socket.rs
+-rw-r--r--   0        0        0    21365 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/src/websocket.rs
+-rw-r--r--   0        0        0       18 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/.gitignore
+-rw-r--r--   0        0        0     2862 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md
+-rw-r--r--   0        0        0     2408 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/Cargo.toml
+-rw-r--r--   0        0        0     1093 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/LICENSE
+-rw-r--r--   0        0        0     2861 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/README.md
+-rw-r--r--   0        0        0      268 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/rustfmt.toml
+-rw-r--r--   0        0        0     6879 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/compat.rs
+-rw-r--r--   0        0        0     2747 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/connect.rs
+-rw-r--r--   0        0        0     5469 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs
+-rw-r--r--   0        0        0    14289 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/lib.rs
+-rw-r--r--   0        0        0     2854 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/stream.rs
+-rw-r--r--   0        0        0     9383 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/tls.rs
+-rw-r--r--   0        0        0     3623 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/tests/communication.rs
+-rw-r--r--   0        0        0      883 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/tests/handshakes.rs
+-rw-r--r--   0        0        0     1115 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/Cargo.toml
+-rw-r--r--   0        0        0     4196 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/benches/bench_persistence.rs
+-rw-r--r--   0        0        0    11537 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/arrow/bar.rs
+-rw-r--r--   0        0        0    13900 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/arrow/delta.rs
+-rw-r--r--   0        0        0     2802 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/arrow/mod.rs
+-rw-r--r--   0        0        0    10951 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/arrow/quote.rs
+-rw-r--r--   0        0        0    11284 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/arrow/trade.rs
+-rw-r--r--   0        0        0      922 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/backend/mod.rs
+-rw-r--r--   0        0        0    11573 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/backend/session.rs
+-rw-r--r--   0        0        0     9376 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/backend/transformer.rs
+-rw-r--r--   0        0        0     6937 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/kmerge_batch.rs
+-rw-r--r--   0        0        0     1582 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/lib.rs
+-rw-r--r--   0        0        0     2847 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/wranglers/bar.rs
+-rw-r--r--   0        0        0     3054 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/wranglers/delta.rs
+-rw-r--r--   0        0        0      942 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/wranglers/mod.rs
+-rw-r--r--   0        0        0     2979 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/wranglers/quote.rs
+-rw-r--r--   0        0        0     2976 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/src/wranglers/trade.rs
+-rw-r--r--   0        0        0     4413 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/tests/test_catalog.rs
+-rw-r--r--   0        0        0     2159 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/persistence/tests/test_util.rs
+-rw-r--r--   0        0        0      647 2023-07-31 04:06:38.200146 nautilus_trader-1.176.0/nautilus_core/pyo3/Cargo.toml
+-rw-r--r--   0        0        0     2591 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_core/pyo3/src/lib.rs
+-rw-r--r--   0        0        0       51 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_core/rust-toolchain.toml
+-rw-r--r--   0        0        0      225 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_core/rustfmt.toml
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/__init__.pxd
+-rw-r--r--   0        0        0     1267 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/__init__.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/__init__.pxd
+-rw-r--r--   0        0        0     1414 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/__init__.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/__init__.py
+-rw-r--r--   0        0        0     3975 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/base.pxd
+-rw-r--r--   0        0        0    14292 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/base.pyx
+-rw-r--r--   0        0        0     1738 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/betting.pxd
+-rw-r--r--   0        0        0     3421 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/betting.pyx
+-rw-r--r--   0        0        0     1886 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/cash.pxd
+-rw-r--r--   0        0        0    11342 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/cash.pyx
+-rw-r--r--   0        0        0     3178 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/margin.pxd
+-rw-r--r--   0        0        0    20725 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/margin.pyx
+-rw-r--r--   0        0        0     1488 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/calculators.pxd
+-rw-r--r--   0        0        0    10737 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/calculators.pyx
+-rw-r--r--   0        0        0     2112 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/error.py
+-rw-r--r--   0        0        0     1089 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/factory.pxd
+-rw-r--r--   0        0        0     4063 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/factory.pyx
+-rw-r--r--   0        0        0     2659 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/manager.pxd
+-rw-r--r--   0        0        0    22587 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/accounting/manager.pyx
+-rw-r--r--   0        0        0     1153 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/__init__.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/_template/__init__.py
+-rw-r--r--   0        0        0     1013 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/_template/core.py
+-rw-r--r--   0        0        0    13317 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/_template/data.py
+-rw-r--r--   0        0        0     6850 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/_template/execution.py
+-rw-r--r--   0        0        0     2461 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/_template/providers.py
+-rw-r--r--   0        0        0      945 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/__init__.py
+-rw-r--r--   0        0        0    12332 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/client.py
+-rw-r--r--   0        0        0     3361 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/common.py
+-rw-r--r--   0        0        0     2346 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/config.py
+-rw-r--r--   0        0        0     1871 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/constants.py
+-rw-r--r--   0        0        0    12910 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/data.py
+-rw-r--r--   0        0        0     8094 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/data_types.py
+-rw-r--r--   0        0        0    41513 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/execution.py
+-rw-r--r--   0        0        0     8329 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/factories.py
+-rw-r--r--   0        0        0     2915 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/historic.py
+-rw-r--r--   0        0        0     1267 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/orderbook.pxd
+-rw-r--r--   0        0        0     1808 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/orderbook.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/__init__.py
+-rw-r--r--   0        0        0     2564 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/common.py
+-rw-r--r--   0        0        0     2164 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/core.py
+-rw-r--r--   0        0        0    15775 2023-07-31 04:06:38.204146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/requests.py
+-rw-r--r--   0        0        0    18885 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/streaming.py
+-rw-r--r--   0        0        0    13768 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/providers.py
+-rw-r--r--   0        0        0     8794 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/sockets.py
+-rw-r--r--   0        0        0      938 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/__init__.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/__init__.py
+-rw-r--r--   0        0        0      957 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/constants.py
+-rw-r--r--   0        0        0    25433 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/data.py
+-rw-r--r--   0        0        0    19104 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/enums.py
+-rw-r--r--   0        0        0    39904 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/execution.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/__init__.py
+-rw-r--r--   0        0        0    10961 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/account.py
+-rw-r--r--   0        0        0    22118 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/market.py
+-rw-r--r--   0        0        0     2446 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/symbol.py
+-rw-r--r--   0        0        0     1209 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/user.py
+-rw-r--r--   0        0        0    14970 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/types.py
+-rw-r--r--   0        0        0     5233 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/config.py
+-rw-r--r--   0        0        0    16942 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/factories.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/__init__.py
+-rw-r--r--   0        0        0     8574 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/data.py
+-rw-r--r--   0        0        0     6430 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/enums.py
+-rw-r--r--   0        0        0    12287 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/execution.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/__init__.py
+-rw-r--r--   0        0        0    13460 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/account.py
+-rw-r--r--   0        0        0     3663 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/market.py
+-rw-r--r--   0        0        0     1962 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/user.py
+-rw-r--r--   0        0        0     4918 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/wallet.py
+-rw-r--r--   0        0        0    16763 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/providers.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py
+-rw-r--r--   0        0        0     7074 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/account.py
+-rw-r--r--   0        0        0     7670 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/market.py
+-rw-r--r--   0        0        0    15169 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/user.py
+-rw-r--r--   0        0        0     1281 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py
+-rw-r--r--   0        0        0     5070 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/types.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/__init__.py
+-rw-r--r--   0        0        0    27236 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/account.py
+-rw-r--r--   0        0        0     4917 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/client.py
+-rw-r--r--   0        0        0     3227 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/endpoint.py
+-rw-r--r--   0        0        0     1588 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/error.py
+-rw-r--r--   0        0        0    32567 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/market.py
+-rw-r--r--   0        0        0     7828 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/user.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/__init__.py
+-rw-r--r--   0        0        0     5645 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/data.py
+-rw-r--r--   0        0        0     5179 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/enums.py
+-rw-r--r--   0        0        0     9851 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/execution.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/__init__.py
+-rw-r--r--   0        0        0    26580 2023-07-31 04:06:38.208146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/account.py
+-rw-r--r--   0        0        0     6744 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/market.py
+-rw-r--r--   0        0        0     1968 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/user.py
+-rw-r--r--   0        0        0     4684 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/wallet.py
+-rw-r--r--   0        0        0    13964 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/providers.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py
+-rw-r--r--   0        0        0     3305 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/account.py
+-rw-r--r--   0        0        0     6869 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/market.py
+-rw-r--r--   0        0        0    11752 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/user.py
+-rw-r--r--   0        0        0     1262 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/websocket/__init__.py
+-rw-r--r--   0        0        0     9077 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/binance/websocket/client.py
+-rw-r--r--   0        0        0      930 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/__init__.py
+-rw-r--r--   0        0        0     1014 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py
+-rw-r--r--   0        0        0    61674 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/client/client.py
+-rw-r--r--   0        0        0     6384 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/client/common.py
+-rw-r--r--   0        0        0     6825 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/common.py
+-rw-r--r--   0        0        0     7206 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/config.py
+-rw-r--r--   0        0        0    17638 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/data.py
+-rw-r--r--   0        0        0    36273 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/execution.py
+-rw-r--r--   0        0        0     9483 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/factories.py
+-rw-r--r--   0        0        0     7122 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/gateway.py
+-rw-r--r--   0        0        0    14019 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/historic.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py
+-rw-r--r--   0        0        0     3248 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py
+-rw-r--r--   0        0        0     3843 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py
+-rw-r--r--   0        0        0    15696 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py
+-rw-r--r--   0        0        0    11932 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/providers.py
+-rw-r--r--   0        0        0     4654 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/web.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/__init__.py
+-rw-r--r--   0        0        0     1394 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/config.py
+-rw-r--r--   0        0        0     7859 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/execution.py
+-rw-r--r--   0        0        0     2693 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/factory.py
+-rw-r--r--   0        0        0      978 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/__init__.py
+-rw-r--r--   0        0        0    15197 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/analyzer.py
+-rw-r--r--   0        0        0     4780 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/reporter.py
+-rw-r--r--   0        0        0     3981 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistic.py
+-rw-r--r--   0        0        0     2255 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/__init__.py
+-rw-r--r--   0        0        0     2016 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/expectancy.py
+-rw-r--r--   0        0        0     1718 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/long_ratio.py
+-rw-r--r--   0        0        0     1481 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/loser_avg.py
+-rw-r--r--   0        0        0     1527 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/loser_max.py
+-rw-r--r--   0        0        0     1525 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/loser_min.py
+-rw-r--r--   0        0        0     1576 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/profit_factor.py
+-rw-r--r--   0        0        0     1412 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_avg.py
+-rw-r--r--   0        0        0     1427 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_avg_loss.py
+-rw-r--r--   0        0        0     1426 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_avg_win.py
+-rw-r--r--   0        0        0     1729 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_volatility.py
+-rw-r--r--   0        0        0     1336 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/risk_return_ratio.py
+-rw-r--r--   0        0        0     1789 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/sharpe_ratio.py
+-rw-r--r--   0        0        0     1896 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/sortino_ratio.py
+-rw-r--r--   0        0        0     1511 2023-07-31 04:06:38.212146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/win_rate.py
+-rw-r--r--   0        0        0     1502 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/winner_avg.py
+-rw-r--r--   0        0        0     1360 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/winner_max.py
+-rw-r--r--   0        0        0     1507 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/winner_min.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/__init__.pxd
+-rw-r--r--   0        0        0      946 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/__init__.py
+-rw-r--r--   0        0        0     1710 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/__main__.py
+-rw-r--r--   0        0        0     3840 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/auction.py
+-rw-r--r--   0        0        0     1100 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/data_client.pxd
+-rw-r--r--   0        0        0    14723 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/data_client.pyx
+-rw-r--r--   0        0        0     2164 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/engine.pxd
+-rw-r--r--   0        0        0    47992 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/engine.pyx
+-rw-r--r--   0        0        0     7307 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/exchange.pxd
+-rw-r--r--   0        0        0    29455 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/exchange.pyx
+-rw-r--r--   0        0        0     1084 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/execution_client.pxd
+-rw-r--r--   0        0        0     5182 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/execution_client.pyx
+-rw-r--r--   0        0        0    11509 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/matching_engine.pxd
+-rw-r--r--   0        0        0    86624 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/matching_engine.pyx
+-rw-r--r--   0        0        0     2075 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/models.pxd
+-rw-r--r--   0        0        0     5344 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/models.pyx
+-rw-r--r--   0        0        0     1814 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/modules.pxd
+-rw-r--r--   0        0        0     8294 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/modules.pyx
+-rw-r--r--   0        0        0    11554 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/node.py
+-rw-r--r--   0        0        0     3108 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/backtest/results.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/__init__.pxd
+-rw-r--r--   0        0        0     1052 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/__init__.py
+-rw-r--r--   0        0        0    10329 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/base.pxd
+-rw-r--r--   0        0        0    24108 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/base.pyx
+-rw-r--r--   0        0        0     7937 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/cache.pxd
+-rw-r--r--   0        0        0   127846 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/cache.pyx
+-rw-r--r--   0        0        0     4083 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/database.pxd
+-rw-r--r--   0        0        0    10156 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/cache/database.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/__init__.pxd
+-rw-r--r--   0        0        0     1571 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/__init__.py
+-rw-r--r--   0        0        0    10430 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/actor.pxd
+-rw-r--r--   0        0        0    79669 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/actor.pyx
+-rw-r--r--   0        0        0     3551 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/clock.pxd
+-rw-r--r--   0        0        0    27231 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/clock.pyx
+-rw-r--r--   0        0        0     2914 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/component.pxd
+-rw-r--r--   0        0        0    20165 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/component.pyx
+-rw-r--r--   0        0        0     1836 2023-07-31 04:06:38.216146 nautilus_trader-1.176.0/nautilus_trader/common/enums.pyx
+-rw-r--r--   0        0        0     1518 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/enums_c.pxd
+-rw-r--r--   0        0        0     2638 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/enums_c.pyx
+-rw-r--r--   0        0        0     9357 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/factories.pxd
+-rw-r--r--   0        0        0    56810 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/factories.pyx
+-rw-r--r--   0        0        0     1320 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/functions.py
+-rw-r--r--   0        0        0     2139 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/generators.pxd
+-rw-r--r--   0        0        0     7837 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/generators.pyx
+-rw-r--r--   0        0        0     2492 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/logging.pxd
+-rw-r--r--   0        0        0    19420 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/logging.pyx
+-rw-r--r--   0        0        0     2477 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/messages.pxd
+-rw-r--r--   0        0        0    10688 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/messages.pyx
+-rw-r--r--   0        0        0    10729 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/providers.py
+-rw-r--r--   0        0        0     1566 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/queue.pxd
+-rw-r--r--   0        0        0     5704 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/queue.pyx
+-rw-r--r--   0        0        0     2440 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/throttler.pxd
+-rw-r--r--   0        0        0     7418 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/throttler.pyx
+-rw-r--r--   0        0        0     2482 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/timer.pxd
+-rw-r--r--   0        0        0    11922 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/common/timer.pyx
+-rw-r--r--   0        0        0     3793 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/config/__init__.py
+-rw-r--r--   0        0        0    10024 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/config/backtest.py
+-rw-r--r--   0        0        0    22213 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/config/common.py
+-rw-r--r--   0        0        0     1015 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/config/error.py
+-rw-r--r--   0        0        0     7425 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/config/live.py
+-rw-r--r--   0        0        0     1264 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/config/validation.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/__init__.pxd
+-rw-r--r--   0        0        0     1339 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/__init__.py
+-rw-r--r--   0        0        0     1230 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/asynchronous.py
+-rw-r--r--   0        0        0     3628 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/correctness.pxd
+-rw-r--r--   0        0        0    37204 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/correctness.pyx
+-rw-r--r--   0        0        0      897 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/data.pxd
+-rw-r--r--   0        0        0     1954 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/data.pyx
+-rw-r--r--   0        0        0     1680 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/datetime.pxd
+-rw-r--r--   0        0        0     9479 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/datetime.pyx
+-rw-r--r--   0        0        0     1230 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/fsm.pxd
+-rw-r--r--   0        0        0     4364 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/fsm.pyx
+-rw-r--r--   0        0        0     2511 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/includes/algorithms.h
+-rw-r--r--   0        0        0      907 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/includes/backtest.h
+-rw-r--r--   0        0        0    12998 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/includes/common.h
+-rw-r--r--   0        0        0     2883 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/includes/core.h
+-rw-r--r--   0        0        0    48415 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/includes/model.h
+-rw-r--r--   0        0        0     2325 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/inspect.py
+-rw-r--r--   0        0        0     2471 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/message.pxd
+-rw-r--r--   0        0        0     6720 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/message.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/rust/__init__.pxd
+-rw-r--r--   0        0        0     2635 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/rust/algorithms.pxd
+-rw-r--r--   0        0        0     1050 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/rust/backtest.pxd
+-rw-r--r--   0        0        0    12551 2023-07-31 04:16:27.040408 nautilus_trader-1.176.0/nautilus_trader/core/rust/common.pxd
+-rw-r--r--   0        0        0     1222 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/rust/common.pyx
+-rw-r--r--   0        0        0     2871 2023-07-31 04:15:10.947847 nautilus_trader-1.176.0/nautilus_trader/core/rust/core.pxd
+-rw-r--r--   0        0        0    45193 2023-07-31 04:15:36.984289 nautilus_trader-1.176.0/nautilus_trader/core/rust/model.pxd
+-rw-r--r--   0        0        0     2618 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/rust/model.pyx
+-rw-r--r--   0        0        0     1359 2023-07-31 04:06:38.220146 nautilus_trader-1.176.0/nautilus_trader/core/stats.pxd
+-rw-r--r--   0        0        0     5710 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/core/stats.pyx
+-rw-r--r--   0        0        0     3872 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/core/string.pxd
+-rw-r--r--   0        0        0     1049 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/core/uuid.pxd
+-rw-r--r--   0        0        0     2893 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/core/uuid.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/__init__.pxd
+-rw-r--r--   0        0        0     1360 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/__init__.py
+-rw-r--r--   0        0        0     4156 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/aggregation.pxd
+-rw-r--r--   0        0        0    24142 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/aggregation.pyx
+-rw-r--r--   0        0        0     8386 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/client.pxd
+-rw-r--r--   0        0        0    41150 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/client.pyx
+-rw-r--r--   0        0        0    10186 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/engine.pxd
+-rw-r--r--   0        0        0    66493 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/engine.pyx
+-rw-r--r--   0        0        0     2396 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/messages.pxd
+-rw-r--r--   0        0        0     8389 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/data/messages.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/__init__.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/algorithms/__init__.py
+-rw-r--r--   0        0        0     4189 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/algorithms/blank.py
+-rw-r--r--   0        0        0    11564 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/algorithms/twap.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/__init__.py
+-rw-r--r--   0        0        0     5615 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/blank.py
+-rw-r--r--   0        0        0    12100 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross.py
+-rw-r--r--   0        0        0    12017 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_bracket.py
+-rw-r--r--   0        0        0    14934 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py
+-rw-r--r--   0        0        0    10753 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx
+-rw-r--r--   0        0        0    16005 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py
+-rw-r--r--   0        0        0    14387 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py
+-rw-r--r--   0        0        0    12741 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_twap.py
+-rw-r--r--   0        0        0     5332 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/market_maker.py
+-rw-r--r--   0        0        0     8202 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/orderbook_imbalance.py
+-rw-r--r--   0        0        0     2775 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/signal_strategy.py
+-rw-r--r--   0        0        0     4664 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/subscribe.py
+-rw-r--r--   0        0        0    14009 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/examples/strategies/volatility_market_maker.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/__init__.pxd
+-rw-r--r--   0        0        0     1353 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/__init__.py
+-rw-r--r--   0        0        0     5954 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/algorithm.pxd
+-rw-r--r--   0        0        0    37908 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/algorithm.pyx
+-rw-r--r--   0        0        0     7217 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/client.pxd
+-rw-r--r--   0        0        0    28607 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/client.pyx
+-rw-r--r--   0        0        0     4594 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/emulator.pxd
+-rw-r--r--   0        0        0    40262 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/emulator.pyx
+-rw-r--r--   0        0        0     6486 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/engine.pxd
+-rw-r--r--   0        0        0    43083 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/engine.pyx
+-rw-r--r--   0        0        0     3586 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/matching_core.pxd
+-rw-r--r--   0        0        0    15431 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/matching_core.pyx
+-rw-r--r--   0        0        0     5380 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/messages.pxd
+-rw-r--r--   0        0        0    30390 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/messages.pyx
+-rw-r--r--   0        0        0    22208 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/reports.py
+-rw-r--r--   0        0        0     1722 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/trailing.pxd
+-rw-r--r--   0        0        0    16717 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/execution/trailing.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/indicators/__init__.pxd
+-rw-r--r--   0        0        0     1188 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/indicators/__init__.py
+-rw-r--r--   0        0        0     1722 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/indicators/amat.pxd
+-rw-r--r--   0        0        0     4836 2023-07-31 04:06:38.224146 nautilus_trader-1.176.0/nautilus_trader/indicators/amat.pyx
+-rw-r--r--   0        0        0     1482 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/aroon.pxd
+-rw-r--r--   0        0        0     3474 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/aroon.pyx
+-rw-r--r--   0        0        0     1474 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/atr.pxd
+-rw-r--r--   0        0        0     4324 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/atr.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/__init__.py
+-rw-r--r--   0        0        0     1770 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/ama.pxd
+-rw-r--r--   0        0        0     5197 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/ama.pyx
+-rw-r--r--   0        0        0     1063 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/dema.pxd
+-rw-r--r--   0        0        0     3852 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/dema.pyx
+-rw-r--r--   0        0        0     1096 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/ema.pxd
+-rw-r--r--   0        0        0     3466 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/ema.pyx
+-rw-r--r--   0        0        0     1247 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/hma.pxd
+-rw-r--r--   0        0        0     4335 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/hma.pyx
+-rw-r--r--   0        0        0     3114 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/ma_factory.pyx
+-rw-r--r--   0        0        0     1566 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/moving_average.pxd
+-rw-r--r--   0        0        0     2945 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/moving_average.pyx
+-rw-r--r--   0        0        0     1080 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/rma.pxd
+-rw-r--r--   0        0        0     3478 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/rma.pyx
+-rw-r--r--   0        0        0     1020 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/sma.pxd
+-rw-r--r--   0        0        0     3542 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/sma.pyx
+-rw-r--r--   0        0        0     1283 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/vidya.pxd
+-rw-r--r--   0        0        0     4604 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/vidya.pyx
+-rw-r--r--   0        0        0     1174 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/wma.pxd
+-rw-r--r--   0        0        0     4712 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/average/wma.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/base/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/base/__init__.py
+-rw-r--r--   0        0        0     1715 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/base/indicator.pxd
+-rw-r--r--   0        0        0     2981 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/base/indicator.pyx
+-rw-r--r--   0        0        0     1315 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/bias.pxd
+-rw-r--r--   0        0        0     2872 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/bias.pyx
+-rw-r--r--   0        0        0     1579 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/bollinger_bands.pxd
+-rw-r--r--   0        0        0     5221 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/bollinger_bands.pyx
+-rw-r--r--   0        0        0     1639 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/cci.pxd
+-rw-r--r--   0        0        0     4060 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/cci.pyx
+-rw-r--r--   0        0        0     1375 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/cmo.pxd
+-rw-r--r--   0        0        0     3664 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/cmo.pyx
+-rw-r--r--   0        0        0     1662 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/dm.pxd
+-rw-r--r--   0        0        0     3736 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/dm.pyx
+-rw-r--r--   0        0        0     1490 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/donchian_channel.pxd
+-rw-r--r--   0        0        0     4376 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/donchian_channel.pyx
+-rw-r--r--   0        0        0     1231 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/efficiency_ratio.pxd
+-rw-r--r--   0        0        0     3123 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/efficiency_ratio.pyx
+-rw-r--r--   0        0        0     3172 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd
+-rw-r--r--   0        0        0    12544 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx
+-rw-r--r--   0        0        0     1347 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enum.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/__init__.py
+-rw-r--r--   0        0        0      976 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd
+-rw-r--r--   0        0        0      980 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx
+-rw-r--r--   0        0        0      947 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd
+-rw-r--r--   0        0        0      987 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx
+-rw-r--r--   0        0        0     1020 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd
+-rw-r--r--   0        0        0      972 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx
+-rw-r--r--   0        0        0      972 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd
+-rw-r--r--   0        0        0      980 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx
+-rw-r--r--   0        0        0     1809 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_channel.pxd
+-rw-r--r--   0        0        0     4675 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_channel.pyx
+-rw-r--r--   0        0        0     1395 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_position.pxd
+-rw-r--r--   0        0        0     4284 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_position.pyx
+-rw-r--r--   0        0        0     1713 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/kvo.pxd
+-rw-r--r--   0        0        0     4731 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/kvo.pyx
+-rw-r--r--   0        0        0     1636 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/linear_regression.pxd
+-rw-r--r--   0        0        0     3843 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/linear_regression.pyx
+-rw-r--r--   0        0        0     1662 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/macd.pxd
+-rw-r--r--   0        0        0     4821 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/macd.pyx
+-rw-r--r--   0        0        0     1232 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/obv.pxd
+-rw-r--r--   0        0        0     2962 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/obv.pyx
+-rw-r--r--   0        0        0     1514 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/pressure.pxd
+-rw-r--r--   0        0        0     4387 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/pressure.pyx
+-rw-r--r--   0        0        0     1476 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/psl.pxd
+-rw-r--r--   0        0        0     3315 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/psl.pyx
+-rw-r--r--   0        0        0     1227 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/roc.pxd
+-rw-r--r--   0        0        0     2730 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/roc.pyx
+-rw-r--r--   0        0        0     1393 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/rsi.pxd
+-rw-r--r--   0        0        0     3771 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/rsi.pyx
+-rw-r--r--   0        0        0     1767 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/rvi.pxd
+-rw-r--r--   0        0        0     4543 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/rvi.pyx
+-rw-r--r--   0        0        0     1444 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/spread_analyzer.pxd
+-rw-r--r--   0        0        0     3384 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/spread_analyzer.pyx
+-rw-r--r--   0        0        0     1485 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/stochastics.pxd
+-rw-r--r--   0        0        0     3888 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/stochastics.pyx
+-rw-r--r--   0        0        0     2275 2023-07-31 04:06:38.228146 nautilus_trader-1.176.0/nautilus_trader/indicators/swings.pxd
+-rw-r--r--   0        0        0     4682 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/indicators/swings.pyx
+-rw-r--r--   0        0        0     1458 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/indicators/vhf.pxd
+-rw-r--r--   0        0        0     3517 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/indicators/vhf.pyx
+-rw-r--r--   0        0        0     1485 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/indicators/volatility_ratio.pxd
+-rw-r--r--   0        0        0     4486 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/indicators/volatility_ratio.pyx
+-rw-r--r--   0        0        0     1270 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/indicators/vwap.pxd
+-rw-r--r--   0        0        0     2942 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/indicators/vwap.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/infrastructure/__init__.pxd
+-rw-r--r--   0        0        0     1047 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/infrastructure/__init__.py
+-rw-r--r--   0        0        0     1541 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/infrastructure/cache.pxd
+-rw-r--r--   0        0        0    34044 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/infrastructure/cache.pyx
+-rw-r--r--   0        0        0     1155 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/__init__.py
+-rw-r--r--   0        0        0     1858 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/__main__.py
+-rw-r--r--   0        0        0    30766 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/data_client.py
+-rw-r--r--   0        0        0    15042 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/data_engine.py
+-rw-r--r--   0        0        0    16670 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/execution_client.py
+-rw-r--r--   0        0        0    39754 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/execution_engine.py
+-rw-r--r--   0        0        0     3571 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/factories.py
+-rw-r--r--   0        0        0    18198 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/node.py
+-rw-r--r--   0        0        0     9087 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/node_builder.py
+-rw-r--r--   0        0        0     9191 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/live/risk_engine.py
+-rw-r--r--   0        0        0     5505 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/__init__.pxd
+-rw-r--r--   0        0        0     1141 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/__init__.py
+-rw-r--r--   0        0        0     3835 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/currencies.py
+-rw-r--r--   0        0        0     1375 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/currency.pxd
+-rw-r--r--   0        0        0     9156 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/currency.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/__init__.pxd
+-rw-r--r--   0        0        0     2199 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/__init__.py
+-rw-r--r--   0        0        0     2541 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/bar.pxd
+-rw-r--r--   0        0        0    26436 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/bar.pyx
+-rw-r--r--   0        0        0     1178 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/bar_aggregation.pxd
+-rw-r--r--   0        0        0      958 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/bar_aggregation.pyx
+-rw-r--r--   0        0        0     1467 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/base.pxd
+-rw-r--r--   0        0        0     3832 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/base.pyx
+-rw-r--r--   0        0        0     2793 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/book.pxd
+-rw-r--r--   0        0        0    15978 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/book.pyx
+-rw-r--r--   0        0        0     3740 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/tick.pxd
+-rw-r--r--   0        0        0    24281 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/tick.pyx
+-rw-r--r--   0        0        0     1529 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/ticker.pxd
+-rw-r--r--   0        0        0     3312 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/ticker.pyx
+-rw-r--r--   0        0        0     3331 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/venue.pxd
+-rw-r--r--   0        0        0     9886 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/data/venue.pyx
+-rw-r--r--   0        0        0     7239 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/enums.pyx
+-rw-r--r--   0        0        0     4770 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/enums_c.pxd
+-rw-r--r--   0        0        0    10998 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/enums_c.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/__init__.pxd
+-rw-r--r--   0        0        0     2665 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/__init__.py
+-rw-r--r--   0        0        0     2058 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/account.pxd
+-rw-r--r--   0        0        0     5965 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/account.pyx
+-rw-r--r--   0        0        0     9385 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/order.pxd
+-rw-r--r--   0        0        0    88060 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/order.pyx
+-rw-r--r--   0        0        0     5544 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/position.pxd
+-rw-r--r--   0        0        0    34546 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/events/position.pyx
+-rw-r--r--   0        0        0     3365 2023-07-31 04:06:38.232146 nautilus_trader-1.176.0/nautilus_trader/model/identifiers.pxd
+-rw-r--r--   0        0        0    24063 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/identifiers.pyx
+-rw-r--r--   0        0        0        0 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/__init__.pxd
+-rw-r--r--   0        0        0     1854 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/__init__.py
+-rw-r--r--   0        0        0     5279 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/base.pxd
+-rw-r--r--   0        0        0    19990 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/base.pyx
+-rw-r--r--   0        0        0     1745 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/betting.pxd
+-rw-r--r--   0        0        0     8500 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/betting.pyx
+-rw-r--r--   0        0        0     1521 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_future.pxd
+-rw-r--r--   0        0        0    11029 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_future.pyx
+-rw-r--r--   0        0        0     1491 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_perpetual.pxd
+-rw-r--r--   0        0        0    11198 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_perpetual.pyx
+-rw-r--r--   0        0        0     1265 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/currency_pair.pxd
+-rw-r--r--   0        0        0    11341 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/currency_pair.pyx
+-rw-r--r--   0        0        0     1108 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/equity.pxd
+-rw-r--r--   0        0        0     7420 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/equity.pyx
+-rw-r--r--   0        0        0     1344 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/futures_contract.pxd
+-rw-r--r--   0        0        0     6907 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/futures_contract.pyx
+-rw-r--r--   0        0        0     1386 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/options_contract.pxd
+-rw-r--r--   0        0        0     7560 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/options_contract.pyx
+-rw-r--r--   0        0        0     1555 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/synthetic.pxd
+-rw-r--r--   0        0        0    12529 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/instruments/synthetic.pyx
+-rw-r--r--   0        0        0     5402 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/objects.pxd
+-rw-r--r--   0        0        0    40615 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/objects.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orderbook/__init__.pxd
+-rw-r--r--   0        0        0     1269 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orderbook/__init__.py
+-rw-r--r--   0        0        0     3076 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orderbook/book.pxd
+-rw-r--r--   0        0        0    20003 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orderbook/book.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/__init__.pxd
+-rw-r--r--   0        0        0     2094 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/__init__.py
+-rw-r--r--   0        0        0     9351 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/base.pxd
+-rw-r--r--   0        0        0    36046 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/base.pyx
+-rw-r--r--   0        0        0     1705 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/limit.pxd
+-rw-r--r--   0        0        0    18422 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/limit.pyx
+-rw-r--r--   0        0        0     2171 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/limit_if_touched.pxd
+-rw-r--r--   0        0        0    17531 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/limit_if_touched.pyx
+-rw-r--r--   0        0        0     1849 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/list.pxd
+-rw-r--r--   0        0        0     2367 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/list.pyx
+-rw-r--r--   0        0        0     1206 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/market.pxd
+-rw-r--r--   0        0        0    13627 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/market.pyx
+-rw-r--r--   0        0        0     1608 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/market_if_touched.pxd
+-rw-r--r--   0        0        0    15818 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/market_if_touched.pyx
+-rw-r--r--   0        0        0     1644 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/market_to_limit.pxd
+-rw-r--r--   0        0        0    14265 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/market_to_limit.pyx
+-rw-r--r--   0        0        0     2161 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_limit.pxd
+-rw-r--r--   0        0        0    17671 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_limit.pyx
+-rw-r--r--   0        0        0     1598 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_market.pxd
+-rw-r--r--   0        0        0    15983 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_market.pyx
+-rw-r--r--   0        0        0     2641 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_limit.pxd
+-rw-r--r--   0        0        0    19574 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_limit.pyx
+-rw-r--r--   0        0        0     1947 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_market.pxd
+-rw-r--r--   0        0        0    17232 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_market.pyx
+-rw-r--r--   0        0        0     1141 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/unpacker.pxd
+-rw-r--r--   0        0        0     3906 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/orders/unpacker.pyx
+-rw-r--r--   0        0        0     6873 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/position.pxd
+-rw-r--r--   0        0        0    23302 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/position.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/__init__.pxd
+-rw-r--r--   0        0        0     1312 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/__init__.py
+-rw-r--r--   0        0        0     1581 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/base.pxd
+-rw-r--r--   0        0        0     3709 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/base.pyx
+-rw-r--r--   0        0        0     1147 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/__init__.py
+-rw-r--r--   0        0        0     1371 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd
+-rw-r--r--   0        0        0     4052 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx
+-rw-r--r--   0        0        0     1359 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd
+-rw-r--r--   0        0        0     5632 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/msgbus/__init__.pxd
+-rw-r--r--   0        0        0      993 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/msgbus/__init__.py
+-rw-r--r--   0        0        0     2821 2023-07-31 04:06:38.236146 nautilus_trader-1.176.0/nautilus_trader/msgbus/bus.pxd
+-rw-r--r--   0        0        0    17387 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/msgbus/bus.pyx
+-rw-r--r--   0        0        0     1181 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/msgbus/subscription.pxd
+-rw-r--r--   0        0        0     3066 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/msgbus/subscription.pyx
+-rw-r--r--   0        0        0      973 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/__init__.py
+-rw-r--r--   0        0        0     1079 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/catalog/__init__.py
+-rw-r--r--   0        0        0     6083 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/catalog/base.py
+-rw-r--r--   0        0        0    18624 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/catalog/parquet.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/external/__init__.py
+-rw-r--r--   0        0        0    15406 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/external/core.py
+-rw-r--r--   0        0        0     1555 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/external/metadata.py
+-rw-r--r--   0        0        0    13326 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/external/readers.py
+-rw-r--r--   0        0        0     4042 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/external/util.py
+-rw-r--r--   0        0        0     2152 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/funcs.py
+-rw-r--r--   0        0        0     5433 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/loaders.py
+-rw-r--r--   0        0        0     1550 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/migrate.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/__init__.py
+-rw-r--r--   0        0        0     5187 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/batching.py
+-rw-r--r--   0        0        0     8224 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/engine.py
+-rw-r--r--   0        0        0     8935 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/writer.py
+-rw-r--r--   0        0        0     2564 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/wranglers.pxd
+-rw-r--r--   0        0        0    18024 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/wranglers.pyx
+-rw-r--r--   0        0        0    15818 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/persistence/wranglers_v2.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/portfolio/__init__.pxd
+-rw-r--r--   0        0        0      949 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/portfolio/__init__.py
+-rw-r--r--   0        0        0     2132 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/portfolio/base.pxd
+-rw-r--r--   0        0        0     4033 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/portfolio/base.pyx
+-rw-r--r--   0        0        0     3143 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/portfolio/portfolio.pxd
+-rw-r--r--   0        0        0    38001 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/portfolio/portfolio.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/risk/__init__.pxd
+-rw-r--r--   0        0        0     1084 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/risk/__init__.py
+-rw-r--r--   0        0        0     5613 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/risk/engine.pxd
+-rw-r--r--   0        0        0    36947 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/risk/engine.pyx
+-rw-r--r--   0        0        0     1747 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/risk/sizing.pxd
+-rw-r--r--   0        0        0     7081 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/risk/sizing.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/__init__.pxd
+-rw-r--r--   0        0        0     1106 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/__init__.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/__init__.pxd
+-rw-r--r--   0        0        0      948 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/__init__.py
+-rw-r--r--   0        0        0     1408 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/__init__.py
+-rw-r--r--   0        0        0     4212 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/account_state.py
+-rw-r--r--   0        0        0     1369 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/bar.py
+-rw-r--r--   0        0        0     1090 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/instruments.py
+-rw-r--r--   0        0        0     3732 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/order_book.py
+-rw-r--r--   0        0        0     2923 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/order_events.py
+-rw-r--r--   0        0        0     3845 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py
+-rw-r--r--   0        0        0     2837 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/position_events.py
+-rw-r--r--   0        0        0    28790 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/schema.py
+-rw-r--r--   0        0        0     3004 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/schema_v2.py
+-rw-r--r--   0        0        0      910 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/serializer.pxd
+-rw-r--r--   0        0        0     6178 2023-07-31 04:06:38.240146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/serializer.pyx
+-rw-r--r--   0        0        0     4628 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/util.py
+-rw-r--r--   0        0        0     1053 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/serialization/base.pxd
+-rw-r--r--   0        0        0    10323 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/serialization/base.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/serialization/msgpack/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/serialization/msgpack/__init__.py
+-rw-r--r--   0        0        0     1254 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/serialization/msgpack/serializer.pxd
+-rw-r--r--   0        0        0     4932 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/serialization/msgpack/serializer.pyx
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/system/__init__.py
+-rw-r--r--   0        0        0    28079 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/system/kernel.py
+-rw-r--r--   0        0        0     1034 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/__init__.py
+-rw-r--r--   0        0        0     1746 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/functions.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/__init__.py
+-rw-r--r--   0        0        0     6160 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/actors.py
+-rw-r--r--   0        0        0     5987 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/cache_database.py
+-rw-r--r--   0        0        0     3998 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/data.py
+-rw-r--r--   0        0        0     3107 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/engines.py
+-rw-r--r--   0        0        0    12947 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/exec_clients.py
+-rw-r--r--   0        0        0     6070 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/strategies.py
+-rw-r--r--   0        0        0     3173 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/performance.py
+-rw-r--r--   0        0        0    25177 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/providers.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/__init__.py
+-rw-r--r--   0        0        0     4887 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/commands.py
+-rw-r--r--   0        0        0     6602 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/component.py
+-rw-r--r--   0        0        0     6386 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/config.py
+-rw-r--r--   0        0        0    18505 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/data.py
+-rw-r--r--   0        0        0    13987 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/events.py
+-rw-r--r--   0        0        0     9452 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/execution.py
+-rw-r--r--   0        0        0     3757 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/identifiers.py
+-rw-r--r--   0        0        0     2970 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/persistence.py
+-rw-r--r--   0        0        0      869 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/trading/__init__.pxd
+-rw-r--r--   0        0        0     1145 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/trading/__init__.py
+-rw-r--r--   0        0        0    18263 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/trading/filters.py
+-rw-r--r--   0        0        0     6847 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/trading/strategy.pxd
+-rw-r--r--   0        0        0    54274 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/trading/strategy.pyx
+-rw-r--r--   0        0        0     3055 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/trading/trader.pxd
+-rw-r--r--   0        0        0    20230 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/nautilus_trader/trading/trader.pyx
+-rw-r--r--   0        0        0     7040 2023-07-31 04:06:38.244146 nautilus_trader-1.176.0/pyproject.toml
+-rw-r--r--   0        0        0    26472 1970-01-01 00:00:00.000000 nautilus_trader-1.176.0/PKG-INFO
```

### Comparing `nautilus_trader-1.175.0/LICENSE` & `nautilus_trader-1.176.0/LICENSE`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/README.md` & `nautilus_trader-1.176.0/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -11,18 +11,18 @@
 | Branch    | Version                                                                                                                                             | Status                                                                                                                                                                                            |
 | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
 | `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json)  | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml)  |
 | `develop` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fdevelop%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=develop)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 
 | Platform           | Rust    | Python |
 | :----------------- | :------ | :----- |
-| `Linux (x86_64)`   | 1.70.0+ | 3.9+   |
-| `macOS (x86_64)`   | 1.70.0+ | 3.9+   |
-| `macOS (arm64)`    | 1.70.0+ | 3.9+   |
-| `Windows (x86_64)` | 1.70.0+ | 3.9+   |
+| `Linux (x86_64)`   | 1.71.0+ | 3.9+   |
+| `macOS (x86_64)`   | 1.71.0+ | 3.9+   |
+| `macOS (arm64)`    | 1.71.0+ | 3.9+   |
+| `Windows (x86_64)` | 1.71.0+ | 3.9+   |
 
 - **Website:** https://nautilustrader.io
 - **Docs:** https://docs.nautilustrader.io
 - **Support:** [support@nautilustrader.io](mailto:support@nautilustrader.io)
 
 ## Introduction
 
@@ -309,30 +309,34 @@
         # Create the indicators for the strategy
         self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
         self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
 
         self.instrument: Optional[Instrument] = None  # Initialized in on_start
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         # Get instrument
         self.instrument = self.cache.instrument(self.instrument_id)
 
         # Register the indicators for updating
         self.register_indicator_for_bars(self.bar_type, self.fast_ema)
         self.register_indicator_for_bars(self.bar_type, self.slow_ema)
 
         # Get historical data
         self.request_bars(self.bar_type)
 
         # Subscribe to live data
         self.subscribe_bars(self.bar_type)
 
     def on_bar(self, bar: Bar) -> None:
-        """Actions to be performed when the strategy receives a bar."""
+        """
+        Actions to be performed when the strategy receives a bar.
+        """
         # BUY LOGIC
         if self.fast_ema.value >= self.slow_ema.value:
             if self.portfolio.is_flat(self.instrument_id):
                 self.buy()
             elif self.portfolio.is_net_short(self.instrument_id):
                 self.close_all_positions(self.instrument_id)
                 self.buy()
@@ -341,44 +345,52 @@
             if self.portfolio.is_flat(self.instrument_id):
                 self.sell()
             elif self.portfolio.is_net_long(self.instrument_id):
                 self.close_all_positions(self.instrument_id)
                 self.sell()
 
     def buy(self) -> None:
-        """Users simple buy method (example)."""
+        """
+        Users simple buy method (example).
+        """
         order: MarketOrder = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             quantity=self.instrument.make_qty(self.trade_size),
         )
 
         self.submit_order(order)
 
     def sell(self) -> None:
-        """Users simple sell method (example)."""
+        """
+        Users simple sell method (example).
+        """
         order: MarketOrder = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             quantity=self.instrument.make_qty(self.trade_size),
         )
 
         self.submit_order(order)
 
     def on_stop(self) -> None:
-        """Actions to be performed when the strategy is stopped."""
+        """
+        Actions to be performed when the strategy is stopped.
+        """
         # Cleanup orders and positions
         self.cancel_all_orders(self.instrument_id)
         self.close_all_positions(self.instrument_id)
 
         # Unsubscribe from data
         self.unsubscribe_bars(self.bar_type)
 
     def on_reset(self) -> None:
-        """Actions to be performed when the strategy is reset."""
+        """
+        Actions to be performed when the strategy is reset.
+        """
         # Reset indicators here
         self.fast_ema.reset()
         self.slow_ema.reset()
 
 ```
 
 ## Development
```

### Comparing `nautilus_trader-1.175.0/build.py` & `nautilus_trader-1.176.0/build.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 #!/usr/bin/env python3
 
+from __future__ import annotations
+
 import itertools
 import os
 import platform
 import shutil
 import subprocess
 import sysconfig
 from datetime import datetime
 from pathlib import Path
-from typing import Optional
 
 import numpy as np
 from Cython.Build import build_ext
 from Cython.Build import cythonize
 from Cython.Compiler import Options
 from Cython.Compiler.Version import version as cython_compiler_version
 from setuptools import Distribution
@@ -40,18 +41,21 @@
     BUILD_DIR = "build/annotated"
 else:
     BUILD_DIR = "build/optimized"
 
 ################################################################################
 #  RUST BUILD
 ################################################################################
-if platform.system() != "Darwin":
+if platform.system() == "Linux":
     # Use clang as the default compiler
     os.environ["CC"] = "clang"
     os.environ["LDSHARED"] = "clang -shared"
+# elif platform.system() == "Windows":
+#     os.environ["CC"] = "cl"
+#     os.environ["CXX"] = "cl"
 
 TARGET_DIR = Path.cwd() / "nautilus_core" / "target" / BUILD_MODE
 
 if platform.system() == "Windows":
     # Linker error 1181
     # https://docs.microsoft.com/en-US/cpp/error-messages/tool-errors/linker-tools-error-lnk1181?view=msvc-170&viewFallbackFrom=vs-2019
     RUST_LIB_PFX = ""
@@ -129,15 +133,15 @@
 
 
 def _build_extensions() -> list[Extension]:
     # Regarding the compiler warning: #warning "Using deprecated NumPy API,
     # disable it with " "#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION"
     # https://stackoverflow.com/questions/52749662/using-deprecated-numpy-api
     # From the Cython docs: "For the time being, it is just a warning that you can ignore."
-    define_macros: list[tuple[str, Optional[str]]] = [
+    define_macros: list[tuple[str, str | None]] = [
         ("NPY_NO_DEPRECATED_API", "NPY_1_7_API_VERSION"),
     ]
     if PROFILE_MODE or ANNOTATION_MODE:
         # Profiling requires special macro directives
         define_macros.append(("CYTHON_TRACE", "1"))
 
     extra_compile_args = []
@@ -291,15 +295,17 @@
                 capture_output=True,
             )
     except subprocess.CalledProcessError as e:
         raise RuntimeError(f"Error when stripping symbols.\n{e.stderr.decode()}") from e
 
 
 def build() -> None:
-    """Construct the extensions and distribution."""
+    """
+    Construct the extensions and distribution.
+    """
     _build_rust_libs()
     _copy_rust_dylibs_to_project()
 
     if not PYO3_ONLY:
         # Create C Extensions to feed into cythonize()
         extensions = _build_extensions()
         distribution = _build_distribution(extensions)
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/.cargo/config.toml` & `nautilus_trader-1.176.0/nautilus_core/.cargo/config.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/Cargo.lock` & `nautilus_trader-1.176.0/nautilus_core/Cargo.lock`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,21 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
 version = 3
 
 [[package]]
+name = "addr2line"
+version = "0.20.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f4fa78e18c64fce05e902adecd7a5eed15a5e0a3439f7b0e169f0252214865e3"
+dependencies = [
+ "gimli",
+]
+
+[[package]]
 name = "adler"
 version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"
 
 [[package]]
 name = "ahash"
@@ -53,14 +62,20 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
 dependencies = [
  "alloc-no-stdlib",
 ]
 
 [[package]]
+name = "allocator-api2"
+version = "0.2.16"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0942ffc6dcaadf03badf6e6a2d0228460359d5e34b57ccdc720b7382dfbd5ec5"
+
+[[package]]
 name = "android-tzdata"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
 
 [[package]]
 name = "android_system_properties"
@@ -74,24 +89,30 @@
 [[package]]
 name = "anes"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4b46cbb362ab8752921c97e041f5e366ee6297bd428a31275b9fcf1e380f7299"
 
 [[package]]
+name = "anyhow"
+version = "1.0.72"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3b13c32d80ecc7ab747b80c3784bce54ee8a7a0cc4fbda9bf4cda2cf6fe90854"
+
+[[package]]
 name = "arrayvec"
-version = "0.7.3"
+version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8868f09ff8cea88b079da74ae569d9b8c62a23c68c746240b704ee6f7525c89c"
+checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"
 
 [[package]]
 name = "arrow"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6619cab21a0cdd8c9b9f1d9e09bfaa9b1974e5ef809a6566aef0b998caf38ace"
+checksum = "2feeebd77b34b0bc88f224e06d01c27da4733997cc4789a4e056196656cdc59a"
 dependencies = [
  "ahash 0.8.3",
  "arrow-arith",
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-csv",
@@ -103,76 +124,77 @@
  "arrow-schema",
  "arrow-select",
  "arrow-string",
 ]
 
 [[package]]
 name = "arrow-arith"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e0dc95485623a76e00929bda8caa40c1f838190952365c4f43a7b9ae86d03e94"
+checksum = "7173f5dc49c0ecb5135f52565af33afd3fdc9a12d13bd6f9973e8b96305e4b2e"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "chrono",
- "half 2.2.1",
+ "half 2.3.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-array"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3267847f53d3042473cfd2c769afd8d74a6d7d201fc3a34f5cb84c0282ef47a7"
+checksum = "63d7ea725f7d1f8bb2cffc53ef538557e95fc802e217d5be25122d402e22f3d0"
 dependencies = [
  "ahash 0.8.3",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "chrono",
  "chrono-tz",
- "half 2.2.1",
- "hashbrown 0.13.2",
+ "half 2.3.1",
+ "hashbrown 0.14.0",
  "num",
 ]
 
 [[package]]
 name = "arrow-buffer"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c5f66553e66e120ac4b21570368ee9ebf35ff3f5399f872b0667699e145678f5"
+checksum = "bdbe439e077f484e5000b9e1d47b5e4c0d15f2b311a8f5bcc682553d5d67a722"
 dependencies = [
- "half 2.2.1",
+ "half 2.3.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-cast"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "65e6f3579dbf0d97c683d451b2550062b0f0e62a3169bf74238b5f59f44ad6d8"
+checksum = "93913cc14875770aa1eef5e310765e855effa352c094cb1c7c00607d0f37b4e1"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
  "chrono",
  "comfy-table",
+ "half 2.3.1",
  "lexical-core",
  "num",
 ]
 
 [[package]]
 name = "arrow-csv"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "373579c4c1a8f5307d3125b7a89c700fcf8caf85821c77eb4baab3855ae0aba5"
+checksum = "ef55b67c55ed877e6fe7b923121c19dae5e31ca70249ea2779a17b58fb0fbd9a"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "chrono",
@@ -181,127 +203,128 @@
  "lazy_static",
  "lexical-core",
  "regex",
 ]
 
 [[package]]
 name = "arrow-data"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "61bc8df9912cca6642665fdf989d6fa0de2570f18a7f709bcf59d29de96d2097"
+checksum = "d4f4f4a3c54614126a71ab91f6631c9743eb4643d6e9318b74191da9dc6e028b"
 dependencies = [
  "arrow-buffer",
  "arrow-schema",
- "half 2.2.1",
+ "half 2.3.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-ipc"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0105dcf5f91daa7182d87b713ee0b32b3bfc88e0c48e7dc3e9d6f1277a07d1ae"
+checksum = "d41a3659f984a524ef1c2981d43747b24d8eec78e2425267fcd0ef34ce71cd18"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "flatbuffers",
 ]
 
 [[package]]
 name = "arrow-json"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e73134fb5b5ec8770f8cbb214c2c487b2d350081e403ca4eeeb6f8f5e19846ac"
+checksum = "10b95faa95a378f56ef32d84cc0104ea998c39ef7cd1faaa6b4cebf8ea92846d"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "chrono",
- "half 2.2.1",
- "indexmap",
+ "half 2.3.1",
+ "indexmap 2.0.0",
  "lexical-core",
  "num",
  "serde",
  "serde_json",
 ]
 
 [[package]]
 name = "arrow-ord"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "89f25bc66e18d4c2aa1fe2f9bb03e2269da60e636213210385ae41a107f9965a"
+checksum = "c68549a4284d9f8b39586afb8d5ff8158b8f0286353a4844deb1d11cf1ba1f26"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
- "half 2.2.1",
+ "half 2.3.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-row"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1095ff85ea4f5ff02d17b30b089de31b51a50be01c6b674f0a0509ab771232f1"
+checksum = "0a75a4a757afc301ce010adadff54d79d66140c4282ed3de565f6ccb716a5cf3"
 dependencies = [
  "ahash 0.8.3",
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
- "half 2.2.1",
- "hashbrown 0.13.2",
+ "half 2.3.1",
+ "hashbrown 0.14.0",
 ]
 
 [[package]]
 name = "arrow-schema"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "25187bbef474151a2e4ddec67b9e34bda5cbfba292dc571392fa3a1f71ff5a82"
+checksum = "2bebcb57eef570b15afbcf2d07d813eb476fde9f6dd69c81004d6476c197e87e"
 
 [[package]]
 name = "arrow-select"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fd0d4ee884aec3aa05e41478e3cd312bf609de9babb5d187a43fb45931da4da4"
+checksum = "f6e2943fa433a48921e914417173816af64eef61c0a3d448280e6c40a62df221"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "num",
 ]
 
 [[package]]
 name = "arrow-string"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d6d71c3ffe4c07e66ce8fdc6aed5b00e0e60c5144911879b10546f5b72d8fa1c"
+checksum = "bbc92ed638851774f6d7af1ad900b92bc1486746497511868b4298fcbcfa35af"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
+ "num",
  "regex",
- "regex-syntax 0.7.2",
+ "regex-syntax 0.7.4",
 ]
 
 [[package]]
 name = "async-compression"
-version = "0.4.0"
+version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b0122885821398cc923ece939e24d1056a2384ee719432397fa9db87230ff11"
+checksum = "62b74f44609f0f91493e3082d3734d98497e094777144380ea4db9f9905dd5b6"
 dependencies = [
  "bzip2",
  "flate2",
  "futures-core",
  "futures-io",
  "memchr",
  "pin-project-lite",
@@ -309,21 +332,21 @@
  "xz2",
  "zstd",
  "zstd-safe",
 ]
 
 [[package]]
 name = "async-trait"
-version = "0.1.68"
+version = "0.1.72"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b9ccdd8f2a161be9bd5c023df56f1b2a0bd1d83872ae53b71a84a12c9bf6e842"
+checksum = "cc6dde6e4ed435a4c1ee4e73592f5ba9da2151af10076cc04858746af9352d09"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "atty"
 version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
@@ -336,14 +359,29 @@
 [[package]]
 name = "autocfg"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
 
 [[package]]
+name = "backtrace"
+version = "0.3.68"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4319208da049c43661739c5fade2ba182f09d1dc2299b32298d3a31692b17e12"
+dependencies = [
+ "addr2line",
+ "cc",
+ "cfg-if",
+ "libc",
+ "miniz_oxide",
+ "object",
+ "rustc-demangle",
+]
+
+[[package]]
 name = "base64"
 version = "0.21.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "604178f6c5c21f02dc555784810edfb88d34ac2c73b2eae109655649ee73ce3d"
 
 [[package]]
 name = "binary-heap-plus"
@@ -357,14 +395,20 @@
 [[package]]
 name = "bitflags"
 version = "1.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"
 
 [[package]]
+name = "bitflags"
+version = "2.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "630be753d4e58660abd17930c71b647fe46c27ea6b63cc59e1e3851406972e42"
+
+[[package]]
 name = "bitvec"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
 dependencies = [
  "funty",
  "radium",
@@ -524,15 +568,15 @@
 name = "cbindgen"
 version = "0.24.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4b922faaf31122819ec80c4047cc684c6979a087366c069611e33649bf98e18d"
 dependencies = [
  "clap",
  "heck",
- "indexmap",
+ "indexmap 1.9.3",
  "log",
  "proc-macro2",
  "quote",
  "serde",
  "serde_json",
  "syn 1.0.109",
  "tempfile",
@@ -567,28 +611,28 @@
  "time",
  "wasm-bindgen",
  "winapi",
 ]
 
 [[package]]
 name = "chrono-tz"
-version = "0.8.2"
+version = "0.8.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cf9cc2b23599e6d7479755f3594285efb3f74a1bdca7a7374948bc831e23a552"
+checksum = "f1369bc6b9e9a7dfdae2055f6ec151fe9c554a9d23d357c0237cee2e25eaabb7"
 dependencies = [
  "chrono",
  "chrono-tz-build",
  "phf",
 ]
 
 [[package]]
 name = "chrono-tz-build"
-version = "0.1.0"
+version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d9998fb9f7e9b2111641485bf8beb32f92945f97f92a3d061f744cfef335f751"
+checksum = "e2f5ebdc942f57ed96d560a6d1a459bae5851102a25d5bf89dc04ae453e31ecf"
 dependencies = [
  "parse-zoneinfo",
  "phf",
  "phf_codegen",
 ]
 
 [[package]]
@@ -621,17 +665,17 @@
 [[package]]
 name = "clap"
 version = "3.2.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4ea181bf566f71cb9a5d17a59e1871af638180a18fb0035c92ae62b705207123"
 dependencies = [
  "atty",
- "bitflags",
+ "bitflags 1.3.2",
  "clap_lex",
- "indexmap",
+ "indexmap 1.9.3",
  "strsim",
  "termcolor",
  "textwrap",
 ]
 
 [[package]]
 name = "clap_lex"
@@ -640,20 +684,20 @@
 checksum = "2850f2f5a82cbf437dd5af4d49848fbdfc27c157c3d010345776f952765261c5"
 dependencies = [
  "os_str_bytes",
 ]
 
 [[package]]
 name = "comfy-table"
-version = "6.2.0"
+version = "7.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7e959d788268e3bf9d35ace83e81b124190378e4c91c9067524675e33394b8ba"
+checksum = "9ab77dbd8adecaf3f0db40581631b995f312a8a5ae3aa9993188bb8f23d83a5b"
 dependencies = [
- "strum",
- "strum_macros",
+ "strum 0.24.1",
+ "strum_macros 0.24.3",
  "unicode-width",
 ]
 
 [[package]]
 name = "compare"
 version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -695,17 +739,17 @@
 name = "core-foundation-sys"
 version = "0.8.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e496a50fda8aacccc86d7529e2c1e0892dbd0f898a6b5645b5561b89c3210efa"
 
 [[package]]
 name = "cpufeatures"
-version = "0.2.8"
+version = "0.2.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "03e69e28e9f7f77debdedbaafa2866e1de9ba56df55a8bd7cfc724c25a09987c"
+checksum = "a17b76ff3a4162b0b27f354a0c87015ddad39d35f9c0c36607a3bdd175dde1f1"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "crc32fast"
 version = "1.3.2"
@@ -723,15 +767,15 @@
 dependencies = [
  "anes",
  "atty",
  "cast",
  "ciborium",
  "clap",
  "criterion-plot",
- "itertools",
+ "itertools 0.10.5",
  "lazy_static",
  "num-traits",
  "oorandom",
  "plotters",
  "rayon",
  "regex",
  "serde",
@@ -744,15 +788,15 @@
 [[package]]
 name = "criterion-plot"
 version = "0.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6b50826342786a51a89e2da3a28f1c32b06e387201bc2d19791f622c673706b1"
 dependencies = [
  "cast",
- "itertools",
+ "itertools 0.10.5",
 ]
 
 [[package]]
 name = "crossbeam-channel"
 version = "0.5.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a33c2bf77f2df06183c3aa30d1e96c0695a313d4f9c453cc3762a6db39f99200"
@@ -777,15 +821,15 @@
 version = "0.9.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ae211234986c545741a7dc064309f67ee1e5ad243d0e48335adc0484d960bcc7"
 dependencies = [
  "autocfg",
  "cfg-if",
  "crossbeam-utils",
- "memoffset 0.9.0",
+ "memoffset",
  "scopeguard",
 ]
 
 [[package]]
 name = "crossbeam-utils"
 version = "0.8.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -864,36 +908,36 @@
  "darling_core",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "dashmap"
-version = "5.4.0"
+version = "5.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "907076dfda823b0b36d2a1bb5f90c96660a5bbcd7729e10727f07858f22c4edc"
+checksum = "6943ae99c34386c84a470c499d3414f66502a41340aa895406e0d2e4a207b91d"
 dependencies = [
  "cfg-if",
- "hashbrown 0.12.3",
+ "hashbrown 0.14.0",
  "lock_api",
  "once_cell",
  "parking_lot_core",
 ]
 
 [[package]]
 name = "data-encoding"
 version = "2.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c2e66c9d817f1720209181c316d28635c050fa304f9c79e47a520882661b7308"
 
 [[package]]
 name = "datafusion"
-version = "26.0.0"
+version = "28.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9992c267436551d40b52d65289b144712e7b0ebdc62c8c859fd1574e5f73efbb"
+checksum = "5ddbcb2dda5b5033537457992ebde78938014390b2b19f9f4282e3be0e18b0c3"
 dependencies = [
  "ahash 0.8.3",
  "arrow",
  "arrow-array",
  "arrow-schema",
  "async-compression",
  "async-trait",
@@ -902,155 +946,142 @@
  "chrono",
  "dashmap",
  "datafusion-common",
  "datafusion-execution",
  "datafusion-expr",
  "datafusion-optimizer",
  "datafusion-physical-expr",
- "datafusion-row",
  "datafusion-sql",
  "flate2",
  "futures",
  "glob",
- "hashbrown 0.13.2",
- "indexmap",
- "itertools",
+ "half 2.3.1",
+ "hashbrown 0.14.0",
+ "indexmap 2.0.0",
+ "itertools 0.11.0",
  "lazy_static",
  "log",
  "num_cpus",
  "object_store",
  "parking_lot",
  "parquet",
  "percent-encoding",
  "pin-project-lite",
  "rand",
  "smallvec",
  "sqlparser",
  "tempfile",
  "tokio",
- "tokio-stream",
  "tokio-util",
  "url",
  "uuid",
  "xz2",
  "zstd",
 ]
 
 [[package]]
 name = "datafusion-common"
-version = "26.0.0"
+version = "28.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c3be97f7a7c720cdbb71e9eeabf814fa6ad8102b9022390f6cac74d3b4af6392"
+checksum = "85fbb7b4da925031311743ab96662d55f0f7342d3692744f184f99b2257ef435"
 dependencies = [
  "arrow",
  "arrow-array",
  "chrono",
  "num_cpus",
  "object_store",
  "parquet",
  "sqlparser",
 ]
 
 [[package]]
 name = "datafusion-execution"
-version = "26.0.0"
+version = "28.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c77c4b14b809b0e4c5bb101b6834504f06cdbb0d3c643400c61d0d844b33264e"
+checksum = "5bb3617466d894eb0ad11d06bab1e6e89c571c0a27d660685d327d0c6e1e1ccd"
 dependencies = [
  "dashmap",
  "datafusion-common",
  "datafusion-expr",
- "hashbrown 0.13.2",
+ "hashbrown 0.14.0",
  "log",
  "object_store",
  "parking_lot",
  "rand",
  "tempfile",
  "url",
 ]
 
 [[package]]
 name = "datafusion-expr"
-version = "26.0.0"
+version = "28.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e6ec7409bd45cf4fae6395d7d1024c8a97e543cadc88363e405d2aad5330e5e7"
+checksum = "3bd8220a0dfcdfddcc785cd7e71770ef1ce54fbe1e08984e5adf537027ecb6de"
 dependencies = [
  "ahash 0.8.3",
  "arrow",
  "datafusion-common",
  "lazy_static",
  "sqlparser",
- "strum",
- "strum_macros",
+ "strum 0.25.0",
+ "strum_macros 0.25.1",
 ]
 
 [[package]]
 name = "datafusion-optimizer"
-version = "26.0.0"
+version = "28.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "64b537c93f87989c212db92a448a0f5eb4f0995e27199bb7687ae94f8b64a7a8"
+checksum = "1d685a100c66952aaadd0cbe766df46d1887d58fc8bcf3589e6387787f18492b"
 dependencies = [
  "arrow",
  "async-trait",
  "chrono",
  "datafusion-common",
  "datafusion-expr",
  "datafusion-physical-expr",
- "hashbrown 0.13.2",
- "itertools",
+ "hashbrown 0.14.0",
+ "itertools 0.11.0",
  "log",
- "regex-syntax 0.7.2",
+ "regex-syntax 0.7.4",
 ]
 
 [[package]]
 name = "datafusion-physical-expr"
-version = "26.0.0"
+version = "28.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f60ee3f53340fdef36ee54d9e12d446ae2718b1d0196ac581f791d34808ec876"
+checksum = "0f2c635da9b05b4b4c6c8d935f46fd99f9b6225f834091cf4e3c8a045b68beab"
 dependencies = [
  "ahash 0.8.3",
  "arrow",
  "arrow-array",
  "arrow-buffer",
  "arrow-schema",
  "chrono",
  "datafusion-common",
  "datafusion-expr",
- "datafusion-row",
- "half 2.2.1",
- "hashbrown 0.13.2",
- "indexmap",
- "itertools",
+ "half 2.3.1",
+ "hashbrown 0.14.0",
+ "indexmap 2.0.0",
+ "itertools 0.11.0",
  "lazy_static",
  "libc",
+ "log",
  "paste",
  "petgraph",
  "rand",
  "regex",
  "unicode-segmentation",
  "uuid",
 ]
 
 [[package]]
-name = "datafusion-row"
-version = "26.0.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d58fc64058aa3bcb00077a0d19474a0d584d31dec8c7ac3406868f485f659af9"
-dependencies = [
- "arrow",
- "datafusion-common",
- "paste",
- "rand",
-]
-
-[[package]]
 name = "datafusion-sql"
-version = "26.0.0"
+version = "28.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1531f0314151a34bf6c0a83c7261525688b7c729876f53e7896b8f4ca8f57d07"
+checksum = "b3ef8abf4dd84d3f20c910822b52779c035ab7f4f2d5e7125ede3bae618e9de8"
 dependencies = [
  "arrow",
  "arrow-schema",
  "datafusion-common",
  "datafusion-expr",
  "log",
  "sqlparser",
@@ -1101,17 +1132,17 @@
 name = "doc-comment"
 version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fea41bba32d969b513997752735605054bc0dfa92b4c56bf1189f2e174be7a10"
 
 [[package]]
 name = "either"
-version = "1.8.1"
+version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"
+checksum = "a26ae43d7bcc3b814de94796a5e736d4029efb0ee900c12e2d54c993ad1a1e07"
 
 [[package]]
 name = "env_logger"
 version = "0.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "85cdab6a89accf66733ad5a1693a4dcced6aeff64602b634530dd73c1f3ee9f0"
 dependencies = [
@@ -1119,62 +1150,65 @@
  "is-terminal",
  "log",
  "regex",
  "termcolor",
 ]
 
 [[package]]
+name = "equivalent"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"
+
+[[package]]
 name = "errno"
-version = "0.3.1"
+version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4bcfec3a70f97c962c307b2d2c56e358cf1d00b558d74262b5f929ee8cc7e73a"
+checksum = "6b30f669a7961ef1631673d2766cc92f52d64f7ef354d4fe0ddfd30ed52f0f4f"
 dependencies = [
  "errno-dragonfly",
  "libc",
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "errno-dragonfly"
 version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf"
 dependencies = [
  "cc",
  "libc",
 ]
 
 [[package]]
 name = "evalexpr"
-version = "11.0.0"
+version = "11.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ec3b4e80fd8edee77d6fc35d59862d5765dae7512a95f49fd7bf03847c85b26a"
+checksum = "8adeb24130b6ffd6a2f4d2768c8cbf28d98b115c9f576896bb3d6926c2296927"
 
 [[package]]
 name = "fastrand"
-version = "1.9.0"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
-dependencies = [
- "instant",
-]
+checksum = "6999dc1837253364c2ebb0704ba97994bd874e8f195d665c50b7548f6ea92764"
 
 [[package]]
 name = "fixedbitset"
 version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"
 
 [[package]]
 name = "flatbuffers"
 version = "23.5.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4dac53e22462d78c16d64a1cd22371b54cc3fe94aa15e7886a2fa6e5d1ab8640"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "rustc_version",
 ]
 
 [[package]]
 name = "flate2"
 version = "1.0.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -1272,15 +1306,15 @@
 name = "futures-macro"
 version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "89ca545a94061b6365f2c7355b4b32bd20df3ff95f02da9329b34ccc3bd6ee72"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "futures-sink"
 version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f43be4fe21a13b9781a69afa4985b0f6ee0e1afab2c6f454a8cf30e2b2237b6e"
@@ -1333,31 +1367,38 @@
 dependencies = [
  "cfg-if",
  "libc",
  "wasi 0.11.0+wasi-snapshot-preview1",
 ]
 
 [[package]]
+name = "gimli"
+version = "0.27.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b6c80984affa11d98d1b88b66ac8853f143217b399d3c74116778ff8fdb4ed2e"
+
+[[package]]
 name = "glob"
 version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"
 
 [[package]]
 name = "half"
 version = "1.8.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "eabb4a44450da02c90444cf74558da904edde8fb4e9035a9a6a4e15445af0bd7"
 
 [[package]]
 name = "half"
-version = "2.2.1"
+version = "2.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "02b4af3693f1b705df946e9fe5631932443781d0aabb423b62fcd4d73f6d2fd0"
+checksum = "bc52e53916c08643f1b56ec082790d1e86a32e58dc5268f897f313fbae7b4872"
 dependencies = [
+ "cfg-if",
  "crunchy",
  "num-traits",
 ]
 
 [[package]]
 name = "hashbrown"
 version = "0.12.3"
@@ -1373,14 +1414,24 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "43a3c133739dddd0d2990f9a4bdf8eb4b21ef50e4851ca85ab661199821d510e"
 dependencies = [
  "ahash 0.8.3",
 ]
 
 [[package]]
+name = "hashbrown"
+version = "0.14.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2c6201b9ff9fd90a5a3bac2e56a830d0caa509576f0e503818ee82c181b3437a"
+dependencies = [
+ "ahash 0.8.3",
+ "allocator-api2",
+]
+
+[[package]]
 name = "heck"
 version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"
 
 [[package]]
 name = "hermit-abi"
@@ -1389,26 +1440,17 @@
 checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "hermit-abi"
-version = "0.2.6"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7"
-dependencies = [
- "libc",
-]
-
-[[package]]
-name = "hermit-abi"
-version = "0.3.1"
+version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286"
+checksum = "443144c8cdadd93ebf52ddb4056d257f5b52c04d3c804e657d19eb73fc33668b"
 
 [[package]]
 name = "http"
 version = "0.2.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bd6effc99afb63425aff9b05836f029929e345a6148a14b7ecd5ab67af944482"
 dependencies = [
@@ -1444,17 +1486,17 @@
 name = "humantime"
 version = "2.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"
 
 [[package]]
 name = "hyper"
-version = "0.14.26"
+version = "0.14.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ab302d72a6f11a3b910431ff93aae7e773078c769f0a3ef15fb9ec692ed147d4"
+checksum = "ffb1cfd654a8219eaef89881fdb3bb3b1cdc5fa75ded05d6933b2b382e395468"
 dependencies = [
  "bytes",
  "futures-channel",
  "futures-core",
  "futures-util",
  "http",
  "http-body",
@@ -1534,71 +1576,69 @@
 checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
 dependencies = [
  "autocfg",
  "hashbrown 0.12.3",
 ]
 
 [[package]]
-name = "indoc"
-version = "1.0.9"
+name = "indexmap"
+version = "2.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bfa799dd5ed20a7e349f3b4639aa80d74549c81716d9ec4f994c9b5815598306"
+checksum = "d5477fe2230a79769d8dc68e0eabf5437907c0457a5614a9e8dddb67f65eb65d"
+dependencies = [
+ "equivalent",
+ "hashbrown 0.14.0",
+]
 
 [[package]]
-name = "instant"
-version = "0.1.12"
+name = "indoc"
+version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c"
-dependencies = [
- "cfg-if",
-]
+checksum = "bfa799dd5ed20a7e349f3b4639aa80d74549c81716d9ec4f994c9b5815598306"
 
 [[package]]
 name = "integer-encoding"
 version = "3.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8bb03732005da905c88227371639bf1ad885cc712789c011c31c5fb3ab3ccf02"
 
 [[package]]
-name = "io-lifetimes"
-version = "1.0.11"
+name = "is-terminal"
+version = "0.4.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eae7b9aee968036d54dce06cebaefd919e4472e753296daccd6d344e3e2df0c2"
+checksum = "cb0889898416213fab133e1d33a0e5858a48177452750691bde3666d0fdbaf8b"
 dependencies = [
- "hermit-abi 0.3.1",
- "libc",
- "windows-sys 0.48.0",
+ "hermit-abi 0.3.2",
+ "rustix",
+ "windows-sys",
 ]
 
 [[package]]
-name = "is-terminal"
-version = "0.4.7"
+name = "itertools"
+version = "0.10.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "adcf93614601c8129ddf72e2d5633df827ba6551541c6d8c59520a371475be1f"
+checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
 dependencies = [
- "hermit-abi 0.3.1",
- "io-lifetimes",
- "rustix",
- "windows-sys 0.48.0",
+ "either",
 ]
 
 [[package]]
 name = "itertools"
-version = "0.10.5"
+version = "0.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
+checksum = "b1c173a5686ce8bfa551b3563d0c2170bf24ca44da99c7ca4bfdab5418c3fe57"
 dependencies = [
  "either",
 ]
 
 [[package]]
 name = "itoa"
-version = "1.0.6"
+version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6"
+checksum = "af150ab688ff2122fcef229be89cb50dd66af9e01a4ff320cc137eecc9bacc38"
 
 [[package]]
 name = "jobserver"
 version = "0.1.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2"
 dependencies = [
@@ -1682,29 +1722,29 @@
 dependencies = [
  "lexical-util",
  "static_assertions",
 ]
 
 [[package]]
 name = "libc"
-version = "0.2.146"
+version = "0.2.147"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f92be4933c13fd498862a9e02a3055f8a8d9c039ce33db97306fd5a6caa7f29b"
+checksum = "b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3"
 
 [[package]]
 name = "libm"
 version = "0.2.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f7012b1bbb0719e1097c47611d3898568c546d597c2e74d66f6087edd5233ff4"
 
 [[package]]
 name = "linux-raw-sys"
-version = "0.3.8"
+version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ef53942eb7bf7ff43a617b3e2c1c4a5ecf5944a7c1bc12d7ee39bbb15e5c1519"
+checksum = "09fc20d2ca12cb9f044c93e3bd6d32d523e6e2ec3db4f7b2939cd99026ecd3f0"
 
 [[package]]
 name = "lock_api"
 version = "0.4.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c1cc9717a20b1bb222f333e6a92fd32f7d8a18ddc5a3191a11af45dcbf4dcd16"
 dependencies = [
@@ -1751,34 +1791,25 @@
 
 [[package]]
 name = "matchers"
 version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
 dependencies = [
- "regex-automata",
+ "regex-automata 0.1.10",
 ]
 
 [[package]]
 name = "memchr"
 version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
 
 [[package]]
 name = "memoffset"
-version = "0.8.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d61c719bcfbcf5d62b3a09efa6088de8c54bc0bfcd3ea7ae39fcc186108b8de1"
-dependencies = [
- "autocfg",
-]
-
-[[package]]
-name = "memoffset"
 version = "0.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c"
 dependencies = [
  "autocfg",
 ]
 
@@ -1795,15 +1826,15 @@
 name = "mio"
 version = "0.8.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "927a765cd3fc26206e66b296465fa9d3e5ab003e651c1b3c060e7956d96b19d2"
 dependencies = [
  "libc",
  "wasi 0.11.0+wasi-snapshot-preview1",
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "native-tls"
 version = "0.2.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "07226173c32f2926027b63cce4bcd8076c3552846cbe7925f3aaffeac0a3b92e"
@@ -1818,89 +1849,93 @@
  "security-framework",
  "security-framework-sys",
  "tempfile",
 ]
 
 [[package]]
 name = "nautilus-backtest"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
  "cbindgen",
  "nautilus-common",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
  "tempfile",
 ]
 
 [[package]]
 name = "nautilus-common"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
  "cbindgen",
  "chrono",
  "nautilus-core",
  "nautilus-model",
  "pyo3",
  "serde",
  "serde_json",
- "strum",
+ "strum 0.25.0",
  "tempfile",
 ]
 
 [[package]]
 name = "nautilus-core"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
  "cbindgen",
  "chrono",
  "criterion",
  "iai",
  "pyo3",
+ "rmp-serde",
  "rstest",
  "serde",
  "serde_json",
  "uuid",
 ]
 
 [[package]]
 name = "nautilus-indicators"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
  "nautilus-core",
  "nautilus-model",
  "pyo3",
 ]
 
 [[package]]
 name = "nautilus-model"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
+ "anyhow",
  "cbindgen",
  "criterion",
  "derive_builder",
  "evalexpr",
  "iai",
  "lazy_static",
  "nautilus-core",
  "pyo3",
  "rmp-serde",
  "rstest",
  "rust_decimal",
  "serde",
  "serde_json",
- "strum",
+ "strum 0.25.0",
  "tabled",
  "thiserror",
+ "ustr",
 ]
 
 [[package]]
 name = "nautilus-network"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
+ "anyhow",
  "criterion",
  "futures",
  "futures-util",
  "hyper",
  "hyper-tls",
  "nautilus-core",
  "pyo3",
@@ -1910,33 +1945,35 @@
  "tokio-tungstenite",
  "tracing",
  "tracing-test",
 ]
 
 [[package]]
 name = "nautilus-persistence"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
  "binary-heap-plus",
+ "chrono",
  "compare",
  "criterion",
  "datafusion",
  "futures",
  "nautilus-core",
  "nautilus-model",
  "pin-project-lite",
  "pyo3",
  "pyo3-asyncio",
  "rand",
+ "thiserror",
  "tokio",
 ]
 
 [[package]]
 name = "nautilus-pyo3"
-version = "0.6.0"
+version = "0.7.0"
 dependencies = [
  "nautilus-indicators",
  "nautilus-model",
  "nautilus-network",
  "nautilus-persistence",
  "pyo3",
 ]
@@ -1949,17 +1986,17 @@
 dependencies = [
  "overload",
  "winapi",
 ]
 
 [[package]]
 name = "num"
-version = "0.4.0"
+version = "0.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "43db66d1170d347f9a065114077f7dccb00c1b9478c89384490a3425279a4606"
+checksum = "b05180d69e3da0e530ba2a1dae5110317e49e3b7f3d41be227dc5f92e49ee7af"
 dependencies = [
  "num-bigint",
  "num-complex",
  "num-integer",
  "num-iter",
  "num-rational",
  "num-traits",
@@ -2016,43 +2053,53 @@
  "num-bigint",
  "num-integer",
  "num-traits",
 ]
 
 [[package]]
 name = "num-traits"
-version = "0.2.15"
+version = "0.2.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "578ede34cf02f8924ab9447f50c28075b4d3e5b269972345e7e0372b38c6cdcd"
+checksum = "f30b0abd723be7e2ffca1272140fac1a2f084c77ec3e123c192b66af1ee9e6c2"
 dependencies = [
  "autocfg",
  "libm",
 ]
 
 [[package]]
 name = "num_cpus"
-version = "1.15.0"
+version = "1.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0fac9e2da13b5eb447a6ce3d392f23a29d8694bff781bf03a16cd9ac8697593b"
+checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
 dependencies = [
- "hermit-abi 0.2.6",
+ "hermit-abi 0.3.2",
  "libc",
 ]
 
 [[package]]
+name = "object"
+version = "0.31.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8bda667d9f2b5051b8833f59f3bf748b28ef54f850f4fcb389a252aa383866d1"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
 name = "object_store"
-version = "0.5.6"
+version = "0.6.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ec9cd6ca25e796a49fa242876d1c4de36a24a6da5258e9f0bc062dbf5e81c53b"
+checksum = "27c776db4f332b571958444982ff641d2531417a326ca368995073b639205d58"
 dependencies = [
  "async-trait",
  "bytes",
  "chrono",
  "futures",
- "itertools",
+ "humantime",
+ "itertools 0.10.5",
  "parking_lot",
  "percent-encoding",
  "snafu",
  "tokio",
  "tracing",
  "url",
  "walkdir",
@@ -2068,19 +2115,19 @@
 name = "oorandom"
 version = "11.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575"
 
 [[package]]
 name = "openssl"
-version = "0.10.54"
+version = "0.10.55"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "69b3f656a17a6cbc115b5c7a40c616947d213ba182135b014d6051b73ab6f019"
+checksum = "345df152bc43501c5eb9e4654ff05f794effb78d4efe3d53abc158baddc0703d"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "cfg-if",
  "foreign-types",
  "libc",
  "once_cell",
  "openssl-macros",
  "openssl-sys",
 ]
@@ -2089,15 +2136,15 @@
 name = "openssl-macros"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "openssl-probe"
 version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"
@@ -2109,17 +2156,17 @@
 checksum = "efc62c9f12b22b8f5208c23a7200a442b2e5999f8bdf80233852122b5a4f6f37"
 dependencies = [
  "cc",
 ]
 
 [[package]]
 name = "openssl-sys"
-version = "0.9.88"
+version = "0.9.90"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c2ce0f250f34a308dcfdbb351f511359857d4ed2134ba715a4eadd46e1ffd617"
+checksum = "374533b0e45f3a7ced10fcaeccca020e66656bc03dac384f852e4e5a7a8104a6"
 dependencies = [
  "cc",
  "libc",
  "openssl-src",
  "pkg-config",
  "vcpkg",
 ]
@@ -2177,17 +2224,17 @@
  "redox_syscall",
  "smallvec",
  "windows-targets",
 ]
 
 [[package]]
 name = "parquet"
-version = "40.0.0"
+version = "43.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d6a656fcc17e641657c955742c689732684e096f790ff30865d9f8dcc39f7c4a"
+checksum = "ec7267a9607c3f955d4d0ac41b88a67cecc0d8d009173ad3da390699a6cb3750"
 dependencies = [
  "ahash 0.8.3",
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-ipc",
@@ -2195,15 +2242,15 @@
  "arrow-select",
  "base64",
  "brotli",
  "bytes",
  "chrono",
  "flate2",
  "futures",
- "hashbrown 0.13.2",
+ "hashbrown 0.14.0",
  "lz4",
  "num",
  "num-bigint",
  "object_store",
  "paste",
  "seq-macro",
  "snap",
@@ -2220,77 +2267,77 @@
 checksum = "c705f256449c60da65e11ff6626e0c16a0a0b96aaa348de61376b249bc340f41"
 dependencies = [
  "regex",
 ]
 
 [[package]]
 name = "paste"
-version = "1.0.12"
+version = "1.0.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9f746c4065a8fa3fe23974dd82f15431cc8d40779821001404d10d2e79ca7d79"
+checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"
 
 [[package]]
 name = "percent-encoding"
 version = "2.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9b2a4787296e9989611394c33f193f676704af1686e70b8f8033ab5ba9a35a94"
 
 [[package]]
 name = "petgraph"
 version = "0.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4dd7d28ee937e54fe3080c91faa1c3a46c06de6252988a7f4592ba2310ef22a4"
 dependencies = [
  "fixedbitset",
- "indexmap",
+ "indexmap 1.9.3",
 ]
 
 [[package]]
 name = "phf"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "928c6535de93548188ef63bb7c4036bd415cd8f36ad25af44b9789b2ee72a48c"
+checksum = "ade2d8b8f33c7333b51bcf0428d37e217e9f32192ae4772156f65063b8ce03dc"
 dependencies = [
  "phf_shared",
 ]
 
 [[package]]
 name = "phf_codegen"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a56ac890c5e3ca598bbdeaa99964edb5b0258a583a9eb6ef4e89fc85d9224770"
+checksum = "e8d39688d359e6b34654d328e262234662d16cc0f60ec8dcbe5e718709342a5a"
 dependencies = [
  "phf_generator",
  "phf_shared",
 ]
 
 [[package]]
 name = "phf_generator"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b1181c94580fa345f50f19d738aaa39c0ed30a600d95cb2d3e23f94266f14fbf"
+checksum = "48e4cc64c2ad9ebe670cb8fd69dd50ae301650392e81c05f9bfcb2d5bdbc24b0"
 dependencies = [
  "phf_shared",
  "rand",
 ]
 
 [[package]]
 name = "phf_shared"
-version = "0.11.1"
+version = "0.11.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e1fb5f6f826b772a8d4c0394209441e7d37cbbb967ae9c7e0e8134365c9ee676"
+checksum = "90fcb95eef784c2ac79119d1dd819e162b5da872ce6f3c3abe1e8ca1c082f72b"
 dependencies = [
  "siphasher",
 ]
 
 [[package]]
 name = "pin-project-lite"
-version = "0.2.9"
+version = "0.2.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116"
+checksum = "4c40d25201921e5ff0c862a505c6557ea88568a4e3ace775ab55e93f2f4f9d57"
 
 [[package]]
 name = "pin-utils"
 version = "0.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"
 
@@ -2371,17 +2418,17 @@
 name = "proc-macro-hack"
 version = "0.5.20+deprecated"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "dc375e1527247fe1a97d8b7156678dfe7c1af2fc075c9a4db3690ecd2a148068"
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.60"
+version = "1.0.66"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dec2b086b7a862cf4de201096214fa870344cf922b2b30c167badb3af3195406"
+checksum = "18fb31db3f9bddb2ea821cde30a9f70117e3f119938b5ee630b7403aa6e2ead9"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "ptr_meta"
 version = "0.1.4"
@@ -2400,102 +2447,100 @@
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "pyo3"
-version = "0.18.3"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e3b1ac5b3731ba34fdaa9785f8d74d17448cd18f30cf19e0c7e7b1fdb5272109"
+checksum = "ffb88ae05f306b4bfcde40ac4a51dc0b05936a9207a4b75b798c7729c4258a59"
 dependencies = [
  "cfg-if",
  "indoc",
  "libc",
- "memoffset 0.8.0",
+ "memoffset",
  "parking_lot",
  "pyo3-build-config",
  "pyo3-ffi",
  "pyo3-macros",
  "unindent",
 ]
 
 [[package]]
 name = "pyo3-asyncio"
-version = "0.18.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d3564762e37035cfc486228e10b0528460fa026d681b5763873c693aa0d5c260"
+version = "0.19.0"
+source = "git+https://github.com/nautechsystems/pyo3-asyncio.git#2cdf4d7ed932b6d0a3dc2756189bdd17a050e7f7"
 dependencies = [
  "futures",
  "once_cell",
  "pin-project-lite",
  "pyo3",
  "pyo3-asyncio-macros",
  "tokio",
 ]
 
 [[package]]
 name = "pyo3-asyncio-macros"
-version = "0.18.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "be72d4cd43a27530306bd0d20d3932182fbdd072c6b98d3638bc37efb9d559dd"
+version = "0.19.0"
+source = "git+https://github.com/nautechsystems/pyo3-asyncio.git#2cdf4d7ed932b6d0a3dc2756189bdd17a050e7f7"
 dependencies = [
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "pyo3-build-config"
-version = "0.18.3"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9cb946f5ac61bb61a5014924910d936ebd2b23b705f7a4a3c40b05c720b079a3"
+checksum = "554db24f0b3c180a9c0b1268f91287ab3f17c162e15b54caaae5a6b3773396b0"
 dependencies = [
  "once_cell",
  "target-lexicon",
 ]
 
 [[package]]
 name = "pyo3-ffi"
-version = "0.18.3"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fd4d7c5337821916ea2a1d21d1092e8443cf34879e53a0ac653fbb98f44ff65c"
+checksum = "922ede8759e8600ad4da3195ae41259654b9c55da4f7eec84a0ccc7d067a70a4"
 dependencies = [
  "libc",
  "pyo3-build-config",
 ]
 
 [[package]]
 name = "pyo3-macros"
-version = "0.18.3"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a9d39c55dab3fc5a4b25bbd1ac10a2da452c4aca13bb450f22818a002e29648d"
+checksum = "8a5caec6a1dd355964a841fcbeeb1b89fe4146c87295573f94228911af3cc5a2"
 dependencies = [
  "proc-macro2",
  "pyo3-macros-backend",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "pyo3-macros-backend"
-version = "0.18.3"
+version = "0.19.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "97daff08a4c48320587b5224cc98d609e3c27b6d437315bd40b605c98eeb5918"
+checksum = "e0b78ccbb160db1556cdb6fd96c50334c5d4ec44dc5e0a968d0a1208fa0efa8b"
 dependencies = [
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "quote"
-version = "1.0.28"
+version = "1.0.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1b9ab9c7eadfd8df19006f1cf1a4aed13540ed5cbc047010ece5826e10825488"
+checksum = "50f3b39ccfb720540debaa0164757101c08ecb8d326b15358ce76a62c7e85965"
 dependencies = [
  "proc-macro2",
 ]
 
 [[package]]
 name = "radium"
 version = "0.7.0"
@@ -2556,48 +2601,60 @@
 
 [[package]]
 name = "redox_syscall"
 version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
 ]
 
 [[package]]
 name = "regex"
-version = "1.8.4"
+version = "1.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d0ab3ca65655bb1e41f2a8c8cd662eb4fb035e67c3f78da1d61dffe89d07300f"
+checksum = "b2eae68fc220f7cf2532e4494aded17545fce192d59cd996e0fe7887f4ceb575"
 dependencies = [
  "aho-corasick",
  "memchr",
- "regex-syntax 0.7.2",
+ "regex-automata 0.3.4",
+ "regex-syntax 0.7.4",
 ]
 
 [[package]]
 name = "regex-automata"
 version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
 dependencies = [
  "regex-syntax 0.6.29",
 ]
 
 [[package]]
+name = "regex-automata"
+version = "0.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b7b6d6190b7594385f61bd3911cd1be99dfddcfc365a4160cc2ab5bff4aed294"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax 0.7.4",
+]
+
+[[package]]
 name = "regex-syntax"
 version = "0.6.29"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"
 
 [[package]]
 name = "regex-syntax"
-version = "0.7.2"
+version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "436b050e76ed2903236f032a59761c1eb99e1b0aead2c257922771dab1fc8c78"
+checksum = "e5ea92a5b6195c6ef2a0295ea818b312502c6fc94dde986c5553242e18fd4ce2"
 
 [[package]]
 name = "rend"
 version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "581008d2099240d37fb08d77ad713bcaec2c4d89d50b5b21a8bb1996bbab68ab"
 dependencies = [
@@ -2645,28 +2702,28 @@
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "rmp"
-version = "0.8.11"
+version = "0.8.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "44519172358fd6d58656c86ab8e7fbc9e1490c3e8f14d35ed78ca0dd07403c9f"
+checksum = "7f9860a6cc38ed1da53456442089b4dfa35e7cedaa326df63017af88385e6b20"
 dependencies = [
  "byteorder",
  "num-traits",
  "paste",
 ]
 
 [[package]]
 name = "rmp-serde"
-version = "1.1.1"
+version = "1.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c5b13be192e0220b8afb7222aa5813cb62cc269ebb5cac346ca6487681d2913e"
+checksum = "bffea85eea980d8a74453e5d02a8d93028f3c34725de143085a844ebe953258a"
 dependencies = [
  "byteorder",
  "rmp",
  "serde",
 ]
 
 [[package]]
@@ -2693,62 +2750,66 @@
  "rustc_version",
  "syn 1.0.109",
  "unicode-ident",
 ]
 
 [[package]]
 name = "rust_decimal"
-version = "1.30.0"
+version = "1.31.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d0446843641c69436765a35a5a77088e28c2e6a12da93e84aa3ab1cd4aa5a042"
+checksum = "4a2ab0025103a60ecaaf3abf24db1db240a4e1c15837090d2c32f625ac98abea"
 dependencies = [
  "arrayvec",
  "borsh",
- "bytecheck",
  "byteorder",
  "bytes",
  "num-traits",
  "rand",
  "rkyv",
  "serde",
  "serde_json",
 ]
 
 [[package]]
+name = "rustc-demangle"
+version = "0.1.23"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76"
+
+[[package]]
 name = "rustc_version"
 version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
 dependencies = [
  "semver",
 ]
 
 [[package]]
 name = "rustix"
-version = "0.37.20"
+version = "0.38.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b96e891d04aa506a6d1f318d2771bcb1c7dfda84e126660ace067c9b474bb2c0"
+checksum = "0a962918ea88d644592894bc6dc55acc6c0956488adcebbfb6e273506b7fd6e5"
 dependencies = [
- "bitflags",
+ "bitflags 2.3.3",
  "errno",
- "io-lifetimes",
  "libc",
  "linux-raw-sys",
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "rustls"
-version = "0.21.2"
+version = "0.21.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e32ca28af694bc1bbf399c33a516dbdf1c90090b8ab23c2bc24f834aa2247f5f"
+checksum = "79ea77c539259495ce8ca47f53e66ae0330a8819f67e23ac96ca02f50e7b7d36"
 dependencies = [
  "log",
  "ring",
- "rustls-webpki",
+ "rustls-webpki 0.101.2",
  "sct",
 ]
 
 [[package]]
 name = "rustls-native-certs"
 version = "0.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -2758,17 +2819,17 @@
  "rustls-pemfile",
  "schannel",
  "security-framework",
 ]
 
 [[package]]
 name = "rustls-pemfile"
-version = "1.0.2"
+version = "1.0.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d194b56d58803a43635bdc398cd17e383d6f71f9182b9a192c127ca42494a59b"
+checksum = "2d3987094b1d07b653b7dfdc3f70ce9a1da9c51ac18c1b06b662e4f9a0e9f4b2"
 dependencies = [
  "base64",
 ]
 
 [[package]]
 name = "rustls-webpki"
 version = "0.100.1"
@@ -2776,48 +2837,58 @@
 checksum = "d6207cd5ed3d8dca7816f8f3725513a34609c0c765bf652b8c3cb4cfd87db46b"
 dependencies = [
  "ring",
  "untrusted",
 ]
 
 [[package]]
+name = "rustls-webpki"
+version = "0.101.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "513722fd73ad80a71f72b61009ea1b584bcfa1483ca93949c8f290298837fa59"
+dependencies = [
+ "ring",
+ "untrusted",
+]
+
+[[package]]
 name = "rustversion"
-version = "1.0.12"
+version = "1.0.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4f3208ce4d8448b3f3e7d168a73f5e0c43a61e32930de3bceeccedb388b6bf06"
+checksum = "7ffc183a10b4478d04cbbbfc96d0873219d962dd5accaff2ffbd4ceb7df837f4"
 
 [[package]]
 name = "ryu"
-version = "1.0.13"
+version = "1.0.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f91339c0467de62360649f8d3e185ca8de4224ff281f66000de5eb2a77a79041"
+checksum = "1ad4cc8da4ef723ed60bced201181d83791ad433213d8c24efffda1eec85d741"
 
 [[package]]
 name = "same-file"
 version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
 dependencies = [
  "winapi-util",
 ]
 
 [[package]]
 name = "schannel"
-version = "0.1.21"
+version = "0.1.22"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "713cfb06c7059f3588fb8044c0fad1d09e3c01d225e25b9220dbfdcf16dbb1b3"
+checksum = "0c3733bf4cf7ea0880754e19cb5a462007c4a8c1914bff372ccc95b464f1df88"
 dependencies = [
- "windows-sys 0.42.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "scopeguard"
-version = "1.1.0"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
+checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"
 
 [[package]]
 name = "sct"
 version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d53dcdb7c9f8158937a7981b48accfd39a43af418591a5d008c7b22b5e1b7ca4"
 dependencies = [
@@ -2829,72 +2900,72 @@
 name = "seahash"
 version = "4.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1c107b6f4780854c8b126e228ea8869f4d7b71260f962fefb57b996b8959ba6b"
 
 [[package]]
 name = "security-framework"
-version = "2.9.1"
+version = "2.9.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1fc758eb7bffce5b308734e9b0c1468893cae9ff70ebf13e7090be8dcbcc83a8"
+checksum = "05b64fb303737d99b81884b2c63433e9ae28abebe5eb5045dcdd175dc2ecf4de"
 dependencies = [
- "bitflags",
+ "bitflags 1.3.2",
  "core-foundation",
  "core-foundation-sys",
  "libc",
  "security-framework-sys",
 ]
 
 [[package]]
 name = "security-framework-sys"
-version = "2.9.0"
+version = "2.9.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f51d0c0d83bec45f16480d0ce0058397a69e48fcdc52d1dc8855fb68acbd31a7"
+checksum = "e932934257d3b408ed8f30db49d85ea163bfe74961f017f405b025af298f0c7a"
 dependencies = [
  "core-foundation-sys",
  "libc",
 ]
 
 [[package]]
 name = "semver"
-version = "1.0.17"
+version = "1.0.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bebd363326d05ec3e2f532ab7660680f3b02130d780c299bca73469d521bc0ed"
+checksum = "b0293b4b29daaf487284529cc2f5675b8e57c61f70167ba415a463651fd6a918"
 
 [[package]]
 name = "seq-macro"
-version = "0.3.3"
+version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e6b44e8fc93a14e66336d230954dda83d18b4605ccace8fe09bc7514a71ad0bc"
+checksum = "a3f0bf26fd526d2a95683cd0f87bf103b8539e2ca1ef48ce002d67aad59aa0b4"
 
 [[package]]
 name = "serde"
-version = "1.0.164"
+version = "1.0.178"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9e8c8cf938e98f769bc164923b06dce91cea1751522f46f8466461af04c9027d"
+checksum = "60363bdd39a7be0266a520dab25fdc9241d2f987b08a01e01f0ec6d06a981348"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.164"
+version = "1.0.178"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d9735b638ccc51c28bf6914d90a2e9725b377144fc612c49a611fddd1b631d68"
+checksum = "f28482318d6641454cb273da158647922d1be6b5a2fcc6165cd89ebdd7ed576b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.97"
+version = "1.0.104"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bdf3bf93142acad5821c99197022e170842cdbc1c30482b98750c688c640842a"
+checksum = "076066c5f1078eac5b722a31827a8832fe108bed65dfa75e233c89f8206e976c"
 dependencies = [
  "itoa",
  "ryu",
  "serde",
 ]
 
 [[package]]
@@ -2945,33 +3016,33 @@
 checksum = "6528351c9bc8ab22353f9d776db39a20288e8d6c37ef8cfe3317cf875eecfc2d"
 dependencies = [
  "autocfg",
 ]
 
 [[package]]
 name = "smallvec"
-version = "1.10.0"
+version = "1.11.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0"
+checksum = "62bb4feee49fdd9f707ef802e22365a35de4b7b299de4763d44bfea899442ff9"
 
 [[package]]
 name = "snafu"
-version = "0.7.4"
+version = "0.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cb0656e7e3ffb70f6c39b3c2a86332bb74aa3c679da781642590f3c1118c5045"
+checksum = "e4de37ad025c587a29e8f3f5605c00f70b98715ef90b9061a815b9e59e9042d6"
 dependencies = [
  "doc-comment",
  "snafu-derive",
 ]
 
 [[package]]
 name = "snafu-derive"
-version = "0.7.4"
+version = "0.7.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "475b3bbe5245c26f2d8a6f62d67c1f30eb9fffeccee721c45d162c3ebbdf81b2"
+checksum = "990079665f075b699031e9c08fd3ab99be5029b96f3b78dc0709e8f77e4efebf"
 dependencies = [
  "heck",
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
@@ -2995,17 +3066,17 @@
 name = "spin"
 version = "0.5.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
 
 [[package]]
 name = "sqlparser"
-version = "0.34.0"
+version = "0.35.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "37d3706eefb17039056234df6b566b0014f303f867f2656108334a55b8096f59"
+checksum = "ca597d77c98894be1f965f2e4e2d2a61575d4998088e655476c73715c54b2b43"
 dependencies = [
  "log",
  "sqlparser_derive",
 ]
 
 [[package]]
 name = "sqlparser_derive"
@@ -3031,16 +3102,22 @@
 checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"
 
 [[package]]
 name = "strum"
 version = "0.24.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "063e6045c0e62079840579a7e47a355ae92f60eb74daaf156fb1e84ba164e63f"
+
+[[package]]
+name = "strum"
+version = "0.25.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "290d54ea6f91c969195bdbcd7442c8c2a2ba87da8bf60a7ee86a235d4bc1e125"
 dependencies = [
- "strum_macros",
+ "strum_macros 0.25.1",
 ]
 
 [[package]]
 name = "strum_macros"
 version = "0.24.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1e385be0d24f186b4ce2f9982191e7101bb737312ad61c1f2f984f34bcf85d59"
@@ -3049,29 +3126,42 @@
  "proc-macro2",
  "quote",
  "rustversion",
  "syn 1.0.109",
 ]
 
 [[package]]
+name = "strum_macros"
+version = "0.25.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6069ca09d878a33f883cc06aaa9718ede171841d3832450354410b718b097232"
+dependencies = [
+ "heck",
+ "proc-macro2",
+ "quote",
+ "rustversion",
+ "syn 2.0.27",
+]
+
+[[package]]
 name = "syn"
 version = "1.0.109"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
 name = "syn"
-version = "2.0.18"
+version = "2.0.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "32d41677bcbe24c20c52e7c70b0d8db04134c5d1066bf98662e2871ad200ea3e"
+checksum = "b60f673f44a8255b9c8c657daf66a596d435f2da81a555b06dc644d080ba45e0"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
@@ -3102,30 +3192,29 @@
 name = "tap"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"
 
 [[package]]
 name = "target-lexicon"
-version = "0.12.7"
+version = "0.12.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fd1ba337640d60c3e96bc6f0638a939b9c9a7f2c316a1598c279828b3d1dc8c5"
+checksum = "1d2faeef5759ab89935255b1a4cd98e0baf99d1085e37d36599c625dac49ae8e"
 
 [[package]]
 name = "tempfile"
-version = "3.6.0"
+version = "3.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "31c0432476357e58790aaa47a8efb0c5138f137343f3b5f23bd36a27e3b0a6d6"
+checksum = "5486094ee78b2e5038a6382ed7645bc084dc2ec433426ca4c3cb61e2007b8998"
 dependencies = [
- "autocfg",
  "cfg-if",
  "fastrand",
  "redox_syscall",
  "rustix",
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "termcolor"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6"
@@ -3137,30 +3226,30 @@
 name = "textwrap"
 version = "0.16.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "222a222a5bfe1bba4a77b45ec488a741b3cb8872e5e499451fd7d0129c9c7c3d"
 
 [[package]]
 name = "thiserror"
-version = "1.0.40"
+version = "1.0.44"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "978c9a314bd8dc99be594bc3c175faaa9794be04a5a5e153caba6915336cebac"
+checksum = "611040a08a0439f8248d1990b111c95baa9c704c805fa1f62104b39655fd7f90"
 dependencies = [
  "thiserror-impl",
 ]
 
 [[package]]
 name = "thiserror-impl"
-version = "1.0.40"
+version = "1.0.44"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f9456a42c5b0d803c8cd86e73dd7cc9edd429499f37a3550d286d5e86720569f"
+checksum = "090198534930841fab3a5d1bb637cde49e339654e606195f8d9c76eeb081dc96"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "thread_local"
 version = "1.1.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3fdd6f064ccff2d6567adcb3873ca630700f00b5ad3f060c25b5dcfd9a4ce152"
@@ -3223,40 +3312,41 @@
 name = "tinyvec_macros"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
 name = "tokio"
-version = "1.28.2"
+version = "1.29.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "94d7b1cfd2aa4011f2de74c2c4c63665e27a71006b0a192dcd2710272e73dfa2"
+checksum = "532826ff75199d5833b9d2c5fe410f29235e25704ee5f0ef599fb51c21f4a4da"
 dependencies = [
  "autocfg",
+ "backtrace",
  "bytes",
  "libc",
  "mio",
  "num_cpus",
  "parking_lot",
  "pin-project-lite",
  "signal-hook-registry",
  "socket2",
  "tokio-macros",
- "windows-sys 0.48.0",
+ "windows-sys",
 ]
 
 [[package]]
 name = "tokio-macros"
 version = "2.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "630bdcf245f78637c13ec01ffae6187cca34625e8c63150d424b59e55af2675e"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "tokio-native-tls"
 version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
@@ -3272,25 +3362,14 @@
 checksum = "c28327cf380ac148141087fbfb9de9d7bd4e84ab5d2c28fbc911d753de8a7081"
 dependencies = [
  "rustls",
  "tokio",
 ]
 
 [[package]]
-name = "tokio-stream"
-version = "0.1.14"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "397c988d37662c7dda6d2208364a706264bf3d6138b11d436cbac0ad38832842"
-dependencies = [
- "futures-core",
- "pin-project-lite",
- "tokio",
-]
-
-[[package]]
 name = "tokio-tungstenite"
 version = "0.19.0"
 dependencies = [
  "env_logger",
  "futures-channel",
  "futures-util",
  "hyper",
@@ -3344,21 +3423,21 @@
  "pin-project-lite",
  "tracing-attributes",
  "tracing-core",
 ]
 
 [[package]]
 name = "tracing-attributes"
-version = "0.1.24"
+version = "0.1.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0f57e3ca2a01450b1a921183a9c9cbfda207fd822cef4ccb00a65402cbba7a74"
+checksum = "5f4f31f56159e98206da9efd823404b79b6ef3143b4a7ab76e67b1751b25a4ab"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
 ]
 
 [[package]]
 name = "tracing-core"
 version = "0.1.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0955b8137a1df6f1a2e9a37d8a6656291ff0297c1a97c24e0d8425fe2312f79a"
@@ -3423,16 +3502,16 @@
 name = "try-lock"
 version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3528ecfd12c466c6f163363caf2d02a71161dd5e1cc6ae7b34207ea2d42d81ed"
 
 [[package]]
 name = "tungstenite"
-version = "0.19.0"
-source = "git+https://github.com/snapview/tungstenite-rs#d7b559d724eb156590f9b739245499d6bdce41a3"
+version = "0.20.0"
+source = "git+https://github.com/snapview/tungstenite-rs#53914c1180dfb40e2286fc7929d68a1a92f80971"
 dependencies = [
  "byteorder",
  "bytes",
  "data-encoding",
  "http",
  "httparse",
  "log",
@@ -3465,17 +3544,17 @@
 name = "unicode-bidi"
 version = "0.3.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460"
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.9"
+version = "1.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b15811caf2415fb889178633e7724bad2509101cde276048e013b9def5e51fa0"
+checksum = "301abaae475aa91687eb82514b328ab47a211a533026cb25fc3e519b86adfc3c"
 
 [[package]]
 name = "unicode-normalization"
 version = "0.1.22"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
 dependencies = [
@@ -3514,24 +3593,36 @@
 dependencies = [
  "form_urlencoded",
  "idna",
  "percent-encoding",
 ]
 
 [[package]]
+name = "ustr"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b050b13c1933490b043b8238a75bc7676cb49292f49768c9350eabb284eaeb87"
+dependencies = [
+ "ahash 0.8.3",
+ "byteorder",
+ "lazy_static",
+ "parking_lot",
+]
+
+[[package]]
 name = "utf-8"
 version = "0.7.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"
 
 [[package]]
 name = "uuid"
-version = "1.3.4"
+version = "1.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0fa2982af2eec27de306107c027578ff7f423d65f7250e40ce0fea8f45248b81"
+checksum = "79daa5ed5740825c40b389c5e50312b9c86df53fccd33f281df655642b43869d"
 dependencies = [
  "getrandom",
 ]
 
 [[package]]
 name = "valuable"
 version = "0.1.0"
@@ -3598,15 +3689,15 @@
 checksum = "5ef2b6d3c510e9625e5fe6f509ab07d66a760f0885d858736483c32ed7809abd"
 dependencies = [
  "bumpalo",
  "log",
  "once_cell",
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
 version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -3620,15 +3711,15 @@
 name = "wasm-bindgen-macro-support"
 version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "54681b18a46765f095758388f2d0cf16eb8d4169b639ab575a8f5693af210c7b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.18",
+ "syn 2.0.27",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
 version = "0.2.87"
@@ -3647,15 +3738,15 @@
 
 [[package]]
 name = "webpki-roots"
 version = "0.23.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b03058f88386e5ff5310d9111d53f48b17d732b401aeb83a8d5190f2ac459338"
 dependencies = [
- "rustls-webpki",
+ "rustls-webpki 0.100.1",
 ]
 
 [[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
@@ -3692,131 +3783,74 @@
 checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
 dependencies = [
  "windows-targets",
 ]
 
 [[package]]
 name = "windows-sys"
-version = "0.42.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7"
-dependencies = [
- "windows_aarch64_gnullvm 0.42.2",
- "windows_aarch64_msvc 0.42.2",
- "windows_i686_gnu 0.42.2",
- "windows_i686_msvc 0.42.2",
- "windows_x86_64_gnu 0.42.2",
- "windows_x86_64_gnullvm 0.42.2",
- "windows_x86_64_msvc 0.42.2",
-]
-
-[[package]]
-name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
 dependencies = [
  "windows-targets",
 ]
 
 [[package]]
 name = "windows-targets"
-version = "0.48.0"
+version = "0.48.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7b1eb6f0cd7c80c79759c929114ef071b87354ce476d9d94271031c0497adfd5"
+checksum = "05d4b17490f70499f20b9e791dcf6a299785ce8af4d709018206dc5b4953e95f"
 dependencies = [
- "windows_aarch64_gnullvm 0.48.0",
- "windows_aarch64_msvc 0.48.0",
- "windows_i686_gnu 0.48.0",
- "windows_i686_msvc 0.48.0",
- "windows_x86_64_gnu 0.48.0",
- "windows_x86_64_gnullvm 0.48.0",
- "windows_x86_64_msvc 0.48.0",
+ "windows_aarch64_gnullvm",
+ "windows_aarch64_msvc",
+ "windows_i686_gnu",
+ "windows_i686_msvc",
+ "windows_x86_64_gnu",
+ "windows_x86_64_gnullvm",
+ "windows_x86_64_msvc",
 ]
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"
-
-[[package]]
-name = "windows_aarch64_gnullvm"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "91ae572e1b79dba883e0d315474df7305d12f569b400fcf90581b06062f7e1bc"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"
-
-[[package]]
-name = "windows_aarch64_msvc"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b2ef27e0d7bdfcfc7b868b317c1d32c641a6fe4629c171b8928c7b08d98d7cf3"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"
-
-[[package]]
-name = "windows_i686_gnu"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "622a1962a7db830d6fd0a69683c80a18fda201879f0f447f065a3b7467daa241"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"
-
-[[package]]
-name = "windows_i686_msvc"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4542c6e364ce21bf45d69fdd2a8e455fa38d316158cfd43b3ac1c5b1b19f8e00"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"
-
-[[package]]
-name = "windows_x86_64_gnu"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ca2b8a661f7628cbd23440e50b05d705db3686f894fc9580820623656af974b1"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"
-
-[[package]]
-name = "windows_x86_64_gnullvm"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7896dbc1f41e08872e9d5e8f8baa8fdd2677f29468c4e156210174edc7f7b953"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"
-
-[[package]]
-name = "windows_x86_64_msvc"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1a515f5799fe4961cb532f983ce2b23082366b898e52ffbce459c86f67c8378a"
 
 [[package]]
 name = "wyz"
 version = "0.5.1"
@@ -3833,26 +3867,26 @@
 checksum = "388c44dc09d76f1536602ead6d325eb532f5c122f17782bd57fb47baeeb767e2"
 dependencies = [
  "lzma-sys",
 ]
 
 [[package]]
 name = "zstd"
-version = "0.12.3+zstd.1.5.2"
+version = "0.12.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "76eea132fb024e0e13fd9c2f5d5d595d8a967aa72382ac2f9d39fcc95afd0806"
+checksum = "1a27595e173641171fc74a1232b7b1c7a7cb6e18222c11e9dfb9888fa424c53c"
 dependencies = [
  "zstd-safe",
 ]
 
 [[package]]
 name = "zstd-safe"
-version = "6.0.5+zstd.1.5.4"
+version = "6.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d56d9e60b4b1758206c238a10165fbcae3ca37b01744e394c463463f6529d23b"
+checksum = "ee98ffd0b48ee95e6c5168188e44a54550b1564d9d530ee21d5f0eaed1069581"
 dependencies = [
  "libc",
  "zstd-sys",
 ]
 
 [[package]]
 name = "zstd-sys"
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/Cargo.toml`

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,47 @@
 [workspace]
+resolver = "2"
 members = [
     "backtest",
     "common",
     "core",
     "indicators",
     "model",
     "network",
     "network/tokio-tungstenite",
     "persistence",
     "pyo3"
 ]
 
 [workspace.package]
-rust-version = "1.70.0"
-version = "0.6.0"
+rust-version = "1.71.0"
+version = "0.7.0"
 edition = "2021"
 authors = ["Nautech Systems <info@nautechsystems.io>"]
 description = "A high-performance algorithmic trading platform and event-driven backtester"
 documentation = "https://docs.nautilustrader.io"
 
 [workspace.dependencies]
+anyhow = "1.0.72"
 chrono = "0.4.26"
 futures = "0.3.28"
-pyo3 = "0.18.3"
-pyo3-asyncio = { version = "0.18.0", features = [ "tokio-runtime", "tokio", "attributes" ] }
-pyo3-macros = "0.18.3"
+pyo3 = "0.19.1"
+pyo3-asyncio = { git = "https://github.com/nautechsystems/pyo3-asyncio.git", features = ["tokio-runtime", "tokio", "attributes"] }
+pyo3-macros = "0.19.1"
 rand = "0.8.5"
-rmp-serde = "1.1.1"
-rust_decimal = "1.30.0"
+rmp-serde = "1.1.2"
+rust_decimal = "1.31.0"
 rust_decimal_macros = "1.29.1"
-serde = { version = "1.0.164", features = ["derive"] }
-serde_json = "1.0.97"
-strum = { version = "0.24.1", features = ["derive"] }
-thiserror = "1.0.40"
-tokio = { version = "1.28.2", features = ["full"] }
-uuid = { version = "1.3.4", features = ["v4"] }
+serde = { version = "1.0.178", features = ["derive"] }
+serde_json = "1.0.104"
+strum = { version = "0.25.0", features = ["derive"] }
+thiserror = "1.0.44"
+tracing = "0.1.37"
+tokio = { version = "1.29.1", features = ["full"] }
+uuid = { version = "1.4.1", features = ["v4"] }
 
 # dev-dependencies
 criterion = "0.4.0"
 iai = "0.1"
 rstest = "0.17.0"
 tempfile = "3.6.0"
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/LICENSE` & `nautilus_trader-1.176.0/nautilus_core/LICENSE`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/README.md` & `nautilus_trader-1.176.0/nautilus_core/README.md`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/backtest/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/backtest/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/backtest/build.rs` & `nautilus_trader-1.176.0/nautilus_core/backtest/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/backtest/cbindgen_cython.toml` & `nautilus_trader-1.176.0/nautilus_core/backtest/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/backtest/src/engine.rs` & `nautilus_trader-1.176.0/nautilus_core/backtest/src/engine.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/backtest/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/backtest/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/common/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/build.rs` & `nautilus_trader-1.176.0/nautilus_core/common/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/cbindgen.toml` & `nautilus_trader-1.176.0/nautilus_core/common/cbindgen.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/cbindgen_cython.toml` & `nautilus_trader-1.176.0/nautilus_core/common/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/clock.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/clock.rs`

 * *Files 4% similar despite different names*

```diff
@@ -20,15 +20,15 @@
     datetime::{nanos_to_micros, nanos_to_millis, nanos_to_secs},
     time::{duration_since_unix_epoch, UnixNanos},
 };
 use pyo3::{prelude::*, AsPyPointer};
 
 use crate::timer::{TestTimer, TimeEvent, TimeEventHandler};
 
-const ONE_NANOSECOND_DURATION: Duration = Duration::from_nanos(1);
+const ONE_NANOSECOND: Duration = Duration::from_nanos(1);
 
 pub struct MonotonicClock {
     /// The last recorded duration value from the clock.
     last: Duration,
 }
 
 /// Provides a monotonic clock.
@@ -36,15 +36,15 @@
 /// Always produces unique and monotonically increasing timestamps.
 impl MonotonicClock {
     /// Returns a monotonic `Duration` since the UNIX epoch, ensuring that the returned value is
     /// always greater than the previously returned value.
     fn monotonic_duration_since_unix_epoch(&mut self) -> Duration {
         let now = duration_since_unix_epoch();
         let output = if now <= self.last {
-            self.last + ONE_NANOSECOND_DURATION
+            self.last + ONE_NANOSECOND
         } else {
             now
         };
         self.last = output;
         output
     }
 
@@ -105,30 +105,30 @@
 
     /// Return the names of active timers in the clock.
     fn timer_names(&self) -> Vec<&str>;
 
     /// Return the count of active timers in the clock.
     fn timer_count(&self) -> usize;
 
-    /// Register a default event handler for the clock. If a [Timer]
+    /// Register a default event handler for the clock. If a [`Timer`]
     /// does not have an event handler, then this handler is used.
     fn register_default_handler(&mut self, callback: Box<dyn Fn(TimeEvent)>);
 
     fn register_default_handler_py(&mut self, callback_py: PyObject);
 
-    /// Set a [Timer] to alert at a particular time. Optional
+    /// Set a [`Timer`] to alert at a particular time. Optional
     /// callback gets used to handle generated events.
     fn set_time_alert_ns_py(
         &mut self,
         name: String,
         alert_time_ns: UnixNanos,
         callback_py: Option<PyObject>,
     );
 
-    /// Set a [Timer] to start alerting at every interval
+    /// Set a [`Timer`] to start alerting at every interval
     /// between start and stop time. Optional callback gets
     /// used to handle generated event.
     fn set_timer_ns_py(
         &mut self,
         name: String,
         interval_ns: u64,
         start_time_ns: UnixNanos,
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/clock_api.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/clock_api.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/enums.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/enums.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/logging.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/logging.rs`

 * *Files 0% similar despite different names*

```diff
@@ -105,15 +105,15 @@
                         eprintln!("Error parsing log level: {:?}", e);
                     }
                 }
             }
         }
 
         let trader_id_clone = trader_id.value.to_string();
-        let instance_id_clone = instance_id.value.to_string();
+        let instance_id_clone = instance_id.to_string();
 
         thread::spawn(move || {
             Self::handle_messages(
                 &trader_id_clone,
                 &instance_id_clone,
                 level_stdout,
                 level_file,
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/logging_api.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/logging_api.rs`

 * *Files 0% similar despite different names*

```diff
@@ -108,15 +108,15 @@
 #[no_mangle]
 pub extern "C" fn logger_get_machine_id_cstr(logger: &Logger_API) -> *const c_char {
     str_to_cstr(&logger.machine_id)
 }
 
 #[no_mangle]
 pub extern "C" fn logger_get_instance_id(logger: &Logger_API) -> UUID4 {
-    logger.instance_id.clone()
+    logger.instance_id
 }
 
 #[no_mangle]
 pub extern "C" fn logger_is_bypassed(logger: &Logger_API) -> u8 {
     logger.is_bypassed as u8
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/msgbus.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/msgbus.rs`

 * *Files 2% similar despite different names*

```diff
@@ -117,15 +117,15 @@
     #[allow(unused_variables)]
     fn request(&mut self, endpoint: &String, request: &Message, callback: Handler) {
         match request {
             Message::Request { id, ts_init } => {
                 if self.correlation_index.contains_key(id) {
                     todo!()
                 } else {
-                    self.correlation_index.insert(id.clone(), callback);
+                    self.correlation_index.insert(*id, callback);
                     if let Some(handler) = self.endpoints.get(endpoint) {
                         handler(request)
                     } else {
                         // TODO: log error
                     }
                 }
             }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/testing.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/testing.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/timer.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/timer.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/common/src/timer_api.rs` & `nautilus_trader-1.176.0/nautilus_core/common/src/timer_api.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/core/Cargo.toml`

 * *Files 18% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 [lib]
 name = "nautilus_core"
 crate-type = ["rlib", "staticlib"]
 
 [dependencies]
 chrono.workspace = true
 pyo3.workspace = true
+rmp-serde.workspace = true
 serde.workspace = true
 serde_json.workspace = true
 uuid.workspace = true
 
 [features]
 extension-module = ["pyo3/extension-module"]
 default = []
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/benches/criterion_time_benchmark.rs` & `nautilus_trader-1.176.0/nautilus_core/core/benches/criterion_time_benchmark.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/build.rs` & `nautilus_trader-1.176.0/nautilus_core/core/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/cbindgen.toml` & `nautilus_trader-1.176.0/nautilus_core/core/cbindgen.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/cbindgen_cython.toml` & `nautilus_trader-1.176.0/nautilus_core/core/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/correctness.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/correctness.rs`

 * *Files 7% similar despite different names*

```diff
@@ -34,83 +34,90 @@
 
 /// Check string `s` contains pattern `pat`.
 ///
 /// # Panics
 ///
 /// - If `s` does not contain `pat`.
 pub fn string_contains(s: &str, pat: &str, desc: &str) {
-    if !s.contains(pat) {
-        panic!("{FAILED} invalid string for {desc} did not contain '{pat}', was '{s}'");
-    }
+    assert!(
+        s.contains(pat),
+        "{FAILED} invalid string for {desc} did not contain '{pat}', was '{s}'"
+    );
 }
 
 /// Check `u8`s are equal.
 ///
 /// # Panics
 ///
 /// - If `lhs` is not equal to `rhs`.
 pub fn u8_equal(lhs: u8, rhs: u8, lhs_param: &str, rhs_param: &str) {
-    if lhs != rhs {
-        panic!("{FAILED} '{lhs_param}' u8 of {lhs} was not equal to '{rhs_param}' `u8` of {rhs}");
-    }
+    assert!(
+        lhs == rhs,
+        "{FAILED} '{lhs_param}' u8 of {lhs} was not equal to '{rhs_param}' `u8` of {rhs}"
+    );
 }
 
 /// Check `u8` value is in range (inclusive).
 ///
 /// # Panics
 ///
 /// - If `value` is not within range [`l`, `r`].
 pub fn u8_in_range_inclusive(value: u8, l: u8, r: u8, desc: &str) {
-    if !(value.ge(&l) && value.le(&r)) {
-        panic!("{FAILED} invalid u8 for {desc} not in range [{l}, {r}], was {value}");
-    }
+    assert!(
+        (value.ge(&l) && value.le(&r)),
+        "{FAILED} invalid u8 for {desc} not in range [{l}, {r}], was {value}"
+    );
 }
 
 /// Check `u64` value is in range (inclusive).
 ///
 /// # Panics
 ///
 /// - If `value` is not within range [`l`, `r`].
 pub fn u64_in_range_inclusive(value: u64, l: u64, r: u64, desc: &str) {
-    if !(value.ge(&l) && value.le(&r)) {
-        panic!("{FAILED} invalid u64 for {desc} not in range [{l}, {r}], was {value}");
-    }
+    assert!(
+        (value.ge(&l) && value.le(&r)),
+        "{FAILED} invalid u64 for {desc} not in range [{l}, {r}], was {value}"
+    );
 }
 
 /// Check `i64` value is in range (inclusive).
 ///
 /// # Panics
 ///
 /// - If `value` is not within range [`l`, `r`].
 pub fn i64_in_range_inclusive(value: i64, l: i64, r: i64, desc: &str) {
-    if !(value.ge(&l) && value.le(&r)) {
-        panic!("{FAILED} invalid i64 for {desc} not in range [{l}, {r}], was {value}");
-    }
+    assert!(
+        (value.ge(&l) && value.le(&r)),
+        "{FAILED} invalid i64 for {desc} not in range [{l}, {r}], was {value}"
+    );
 }
 
 /// Check `f64` value is in range (inclusive).
 ///
 /// # Panics
 ///
 /// - If `value` is not within range [`l`, `r`].
 pub fn f64_in_range_inclusive(value: f64, l: f64, r: f64, desc: &str) {
-    if !(value.ge(&l) && value.le(&r)) {
-        panic!("{FAILED} invalid f64 for {desc} not in range [{l}, {r}], was {value}");
-    }
+    assert!(
+        (value.ge(&l) && value.le(&r)),
+        "{FAILED} invalid f64 for {desc} not in range [{l}, {r}], was {value}"
+    );
 }
 
 /// Check `f64` value is non negative.
 ///
 /// # Panics
 ///
 /// - If `value` is negative.
 pub fn f64_non_negative(value: f64, desc: &str) {
-    if value < 0.0 {
-        panic!("{FAILED} invalid f64 for {desc} negative, was {value}");
-    }
+    assert!(
+        value >= 0.0,
+        "{FAILED} invalid f64 for {desc} negative, was {value}"
+    );
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/cvec.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/cvec.rs`

 * *Files 2% similar despite different names*

```diff
@@ -38,39 +38,42 @@
 }
 
 /// Empty derivation for Send to satisfy `pyclass` requirements
 /// however this is only designed for single threaded use for now
 unsafe impl Send for CVec {}
 
 impl CVec {
+    #[must_use]
     pub fn empty() -> Self {
         Self {
             // Explicitly type cast the pointer to some type to satisfy the
             // compiler. Since the pointer is null it works for any type.
-            ptr: null() as *const bool as *mut c_void,
+            ptr: null::<bool>() as *mut c_void,
             len: 0,
             cap: 0,
         }
     }
 }
 
 /// Consumes and leaks the Vec, returning a mutable pointer to the contents as
 /// a [`CVec`]. The memory has been leaked and now exists for the lifetime of the
 /// program unless dropped manually.
 /// Note: drop the memory by reconstructing the vec using `from_raw_parts` method
 /// as shown in the test below.
 impl<T> From<Vec<T>> for CVec {
-    fn from(data: Vec<T>) -> Self {
+    fn from(mut data: Vec<T>) -> Self {
         if data.is_empty() {
             Self::empty()
         } else {
             let len = data.len();
             let cap = data.capacity();
+            let ptr = data.as_mut_ptr();
+            std::mem::forget(data);
             Self {
-                ptr: (&mut data.leak()[0] as *mut T).cast::<c_void>(),
+                ptr: ptr.cast::<std::ffi::c_void>(),
                 len,
                 cap,
             }
         }
     }
 }
 
@@ -128,15 +131,15 @@
             assert_eq!(*data, test_data[0]);
             assert_eq!(*data.add(1), test_data[1]);
             assert_eq!(*data.add(2), test_data[2]);
         }
 
         unsafe {
             // reconstruct the struct and drop the memory to deallocate
-            Vec::from_raw_parts(ptr as *mut u64, len, cap);
+            let _ = Vec::from_raw_parts(ptr as *mut u64, len, cap);
         }
     }
 
     /// After deallocating the vector the block of memory may not
     /// contain the same values.
     /// NOTE: This test maybe flaky depending on the platform
     #[test]
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/datetime.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/datetime.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/lib.rs`

 * *Files 12% similar despite different names*

```diff
@@ -13,10 +13,11 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod correctness;
 pub mod cvec;
 pub mod datetime;
 pub mod parsing;
+pub mod serialization;
 pub mod string;
 pub mod time;
 pub mod uuid;
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/parsing.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/parsing.rs`

 * *Files 3% similar despite different names*

```diff
@@ -23,15 +23,18 @@
 use crate::string::cstr_to_string;
 
 /// Convert a C bytes pointer into an owned `Vec<String>`.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
+#[must_use]
 pub unsafe fn bytes_to_string_vec(ptr: *const c_char) -> Vec<String> {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
+
     let c_str = CStr::from_ptr(ptr);
     let bytes = c_str.to_bytes();
     let json_string = std::str::from_utf8(bytes).unwrap();
     let parsed_value: serde_json::Value = serde_json::from_str(json_string).unwrap();
 
     match parsed_value {
         serde_json::Value::Array(arr) => arr
@@ -41,14 +44,15 @@
                 _ => None,
             })
             .collect(),
         _ => Vec::new(),
     }
 }
 
+#[must_use]
 pub fn string_vec_to_bytes(strings: Vec<String>) -> *const c_char {
     let json_string = serde_json::to_string(&strings).unwrap();
     let c_string = CString::new(json_string).unwrap();
     c_string.into_raw()
 }
 
 /// Convert a C bytes pointer into an owned `Option<HashMap<String, Value>>`.
@@ -64,22 +68,23 @@
         let c_str = CStr::from_ptr(ptr);
         let bytes = c_str.to_bytes();
         let json_string = std::str::from_utf8(bytes).unwrap();
         let result: Result<HashMap<String, Value>> = serde_json::from_str(json_string);
         match result {
             Ok(map) => Some(map),
             Err(err) => {
-                eprintln!("Error parsing JSON: {}", err);
+                eprintln!("Error parsing JSON: {err}");
                 None
             }
         }
     }
 }
 
 /// Return the decimal precision inferred from the given string.
+#[must_use]
 pub fn precision_from_str(s: &str) -> u8 {
     let lower_s = s.to_lowercase();
     // Handle scientific notation
     if lower_s.contains("e-") {
         return lower_s.split("e-").last().unwrap().parse::<u8>().unwrap();
     }
     if !lower_s.contains('.') {
@@ -95,14 +100,15 @@
 /// - Assumes `ptr` is a valid C string pointer.
 ///
 /// # Panics
 ///
 /// - If `ptr` is null.
 #[no_mangle]
 pub unsafe extern "C" fn precision_from_cstr(ptr: *const c_char) -> u8 {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
     precision_from_str(&cstr_to_string(ptr))
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/string.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/string.rs`

 * *Files 2% similar despite different names*

```diff
@@ -78,15 +78,15 @@
 ///
 /// # Panics
 ///
 /// - If `ptr` is null.
 #[no_mangle]
 pub unsafe extern "C" fn cstr_drop(ptr: *const c_char) {
     assert!(!ptr.is_null(), "`ptr` was NULL");
-    let cstring = CString::from_raw(ptr as *mut c_char);
+    let cstring = CString::from_raw(ptr.cast_mut());
     drop(cstring);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
@@ -105,15 +105,17 @@
     }
 
     #[test]
     #[should_panic]
     fn test_pystr_to_string_with_null_ptr() {
         // Create a null Python object pointer
         let ptr: *mut ffi::PyObject = std::ptr::null_mut();
-        unsafe { pystr_to_string(ptr) };
+        unsafe {
+            let _ = pystr_to_string(ptr);
+        };
     }
 
     #[test]
     fn test_cstr_to_string() {
         // Create a valid C string pointer
         let c_string = CString::new("test string2").expect("CString::new failed");
         let ptr = c_string.as_ptr();
@@ -122,15 +124,17 @@
     }
 
     #[test]
     #[should_panic]
     fn test_cstr_to_string_with_null_ptr() {
         // Create a null C string pointer
         let ptr: *const c_char = std::ptr::null();
-        unsafe { cstr_to_string(ptr) };
+        unsafe {
+            let _ = cstr_to_string(ptr);
+        };
     }
 
     #[test]
     fn test_optional_cstr_to_string_with_null_ptr() {
         // Call optional_cstr_to_string with null pointer
         let ptr = std::ptr::null();
         let result = unsafe { optional_cstr_to_string(ptr) };
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/time.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/time.rs`

 * *Files 0% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 
 /// Represents a timestamp in nanoseconds since UNIX epoch.
 pub type UnixNanos = u64;
 
 /// Represents a timedelta in nanoseconds.
 pub type TimedeltaNanos = i64;
 
+#[must_use]
 pub fn duration_since_unix_epoch() -> Duration {
     SystemTime::now()
         .duration_since(UNIX_EPOCH)
         .expect("Error calling `SystemTime::now.duration_since`")
 }
 
 ////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/core/src/uuid.rs` & `nautilus_trader-1.176.0/nautilus_core/core/src/uuid.rs`

 * *Files 8% similar despite different names*

```diff
@@ -11,50 +11,59 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     collections::hash_map::DefaultHasher,
-    ffi::{c_char, CStr},
+    ffi::{c_char, CStr, CString},
     fmt::{Debug, Display, Formatter},
     hash::{Hash, Hasher},
     str::FromStr,
-    sync::Arc,
 };
 
 use serde::{Deserialize, Deserializer, Serialize, Serializer};
 use uuid::Uuid;
 
-use crate::string::str_to_cstr;
-
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
 pub struct UUID4 {
-    pub value: Box<Arc<String>>,
+    value: [u8; 37],
 }
 
 impl UUID4 {
     #[must_use]
     pub fn new() -> Self {
         let uuid = Uuid::new_v4();
-        UUID4 {
-            value: Box::new(Arc::new(uuid.to_string())),
-        }
+        let c_string = CString::new(uuid.to_string()).expect("`CString` conversion failed");
+        let bytes = c_string.as_bytes_with_nul();
+        let mut value = [0; 37];
+        value[..bytes.len()].copy_from_slice(bytes);
+
+        Self { value }
+    }
+
+    #[must_use]
+    pub fn to_cstr(&self) -> &CStr {
+        // Safety: unwrap is safe here as we always store valid C strings
+        CStr::from_bytes_with_nul(&self.value).unwrap()
     }
 }
 
 impl FromStr for UUID4 {
     type Err = &'static str;
 
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         let uuid = Uuid::parse_str(s).map_err(|_| "Invalid UUID string")?;
-        Ok(Self {
-            value: Box::new(Arc::new(uuid.to_string())),
-        })
+        let c_string = CString::new(uuid.to_string()).expect("`CString` conversion failed");
+        let bytes = c_string.as_bytes_with_nul();
+        let mut value = [0; 37];
+        value[..bytes.len()].copy_from_slice(bytes);
+
+        Ok(Self { value })
     }
 }
 
 impl From<&str> for UUID4 {
     fn from(input: &str) -> Self {
         input.parse().unwrap_or_else(|err| panic!("{}", err))
     }
@@ -64,15 +73,15 @@
     fn default() -> Self {
         Self::new()
     }
 }
 
 impl Display for UUID4 {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{}", self.to_cstr().to_string_lossy())
     }
 }
 
 impl Serialize for UUID4 {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: Serializer,
@@ -83,57 +92,49 @@
 
 impl<'de> Deserialize<'de> for UUID4 {
     fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>
     where
         D: Deserializer<'de>,
     {
         let uuid4_str: &str = Deserialize::deserialize(_deserializer)?;
-        let uuid4: UUID4 = uuid4_str.into();
+        let uuid4: Self = uuid4_str.into();
         Ok(uuid4)
     }
 }
+
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 #[no_mangle]
 pub extern "C" fn uuid4_new() -> UUID4 {
     UUID4::new()
 }
 
-#[no_mangle]
-pub extern "C" fn uuid4_clone(uuid4: &UUID4) -> UUID4 {
-    uuid4.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn uuid4_drop(uuid4: UUID4) {
-    drop(uuid4); // Memory freed here
-}
-
 /// Returns a [`UUID4`] from C string pointer.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
 ///
 /// # Panics
 ///
 /// - If `ptr` cannot be cast to a valid C string.
 #[no_mangle]
 pub unsafe extern "C" fn uuid4_from_cstr(ptr: *const c_char) -> UUID4 {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
     UUID4::from(
         CStr::from_ptr(ptr)
             .to_str()
             .unwrap_or_else(|_| panic!("CStr::from_ptr failed")),
     )
 }
 
 #[no_mangle]
 pub extern "C" fn uuid4_to_cstr(uuid: &UUID4) -> *const c_char {
-    str_to_cstr(&uuid.value)
+    uuid.to_cstr().as_ptr()
 }
 
 #[no_mangle]
 pub extern "C" fn uuid4_eq(lhs: &UUID4, rhs: &UUID4) -> u8 {
     u8::from(lhs == rhs)
 }
 
@@ -154,33 +155,33 @@
     use uuid;
 
     use super::*;
 
     #[test]
     fn test_uuid4_new() {
         let uuid = UUID4::new();
-        let uuid_string = uuid.value.to_string();
+        let uuid_string = uuid.to_string();
         let uuid_parsed = Uuid::parse_str(&uuid_string).expect("Uuid::parse_str failed");
         assert_eq!(uuid_parsed.get_version().unwrap(), uuid::Version::Random);
         assert_eq!(uuid_parsed.to_string().len(), 36);
     }
 
     #[test]
     fn test_uuid4_default() {
         let uuid: UUID4 = UUID4::default();
-        let uuid_string = uuid.value.to_string();
+        let uuid_string = uuid.to_string();
         let uuid_parsed = Uuid::parse_str(&uuid_string).expect("Uuid::parse_str failed");
         assert_eq!(uuid_parsed.get_version().unwrap(), uuid::Version::Random);
     }
 
     #[test]
     fn test_uuid4_from_str() {
         let uuid_string = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
         let uuid = UUID4::from(uuid_string);
-        let result_string = uuid.value.to_string();
+        let result_string = uuid.to_string();
         let result_parsed = Uuid::parse_str(&result_string).expect("Uuid::parse_str failed");
         let expected_parsed = Uuid::parse_str(uuid_string).expect("Uuid::parse_str failed");
         assert_eq!(result_parsed, expected_parsed);
     }
 
     #[test]
     fn test_equality() {
@@ -197,41 +198,26 @@
         let result_string = format!("{uuid}");
         assert_eq!(result_string, uuid_string);
     }
 
     #[test]
     fn test_c_api_uuid4_new() {
         let uuid = uuid4_new();
-        let uuid_string = uuid.value.to_string();
+        let uuid_string = uuid.to_string();
         let uuid_parsed = Uuid::parse_str(&uuid_string).expect("Uuid::parse_str failed");
         assert_eq!(uuid_parsed.get_version().unwrap(), uuid::Version::Random);
     }
 
     #[test]
-    fn test_c_api_uuid4_clone() {
-        let uuid_string = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
-        let uuid = UUID4::from(uuid_string);
-        let uuid_cloned = uuid4_clone(&uuid);
-        assert_eq!(uuid.value.to_string(), uuid_cloned.value.to_string());
-    }
-
-    #[test]
-    fn test_c_api_uuid4_drop() {
-        let uuid_string = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
-        let uuid = UUID4::from(uuid_string);
-        uuid4_drop(uuid);
-    }
-
-    #[test]
     fn test_c_api_uuid4_from_cstr() {
         let uuid_string = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
         let uuid_cstring = CString::new(uuid_string).expect("CString::new failed");
         let uuid_ptr = uuid_cstring.as_ptr();
         let uuid = unsafe { uuid4_from_cstr(uuid_ptr) };
-        assert_eq!(uuid_string, uuid.value.to_string());
+        assert_eq!(uuid_string, uuid.to_string());
     }
 
     #[test]
     fn test_c_api_uuid4_to_cstr() {
         let uuid_string = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
         let uuid = UUID4::from(uuid_string);
         let uuid_ptr = uuid4_to_cstr(&uuid);
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/indicators/src/ema.rs` & `nautilus_trader-1.176.0/nautilus_core/indicators/src/ema.rs`

 * *Files 2% similar despite different names*

```diff
@@ -10,18 +10,15 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use nautilus_model::{
-    data::{
-        bar::Bar,
-        tick::{QuoteTick, TradeTick},
-    },
+    data::{bar::Bar, quote::QuoteTick, trade::TradeTick},
     enums::PriceType,
 };
 use pyo3::prelude::*;
 
 use crate::Indicator;
 
 #[repr(C)]
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/indicators/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/indicators/src/lib.rs`

 * *Files 4% similar despite different names*

```diff
@@ -11,18 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod ema;
 
-use nautilus_model::data::{
-    bar::Bar,
-    tick::{QuoteTick, TradeTick},
-};
+use nautilus_model::data::{bar::Bar, quote::QuoteTick, trade::TradeTick};
 use pyo3::{prelude::*, types::PyModule, Python};
 
 /// Loaded as nautilus_pyo3.indicators
 #[pymodule]
 pub fn indicators(_: Python<'_>, m: &PyModule) -> PyResult<()> {
     m.add_class::<ema::ExponentialMovingAverage>()?;
     Ok(())
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/model/Cargo.toml`

 * *Files 13% similar despite different names*

```diff
@@ -8,31 +8,30 @@
 
 [lib]
 name = "nautilus_model"
 crate-type = ["rlib", "staticlib"]
 
 [dependencies]
 nautilus-core = { path = "../core" }
+anyhow.workspace = true
 pyo3.workspace = true
 rmp-serde.workspace = true
 rust_decimal.workspace = true
 serde.workspace = true
 serde_json.workspace = true
 strum.workspace = true
 thiserror.workspace = true
 derive_builder = "0.12.0"
 evalexpr = "11.0.0"
 lazy_static = "1.4.0"
 tabled = "0.12.2"
+ustr = "0.10.0"
 
 [features]
-extension-module = [
-    "pyo3/extension-module",
-    "nautilus-core/extension-module",
-]
+extension-module = ["pyo3/extension-module", "nautilus-core/extension-module"]
 default = []
 
 [dev-dependencies]
 criterion.workspace = true
 iai.workspace = true
 rstest.workspace = true
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/build.rs` & `nautilus_trader-1.176.0/nautilus_core/model/build.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/cbindgen.toml` & `nautilus_trader-1.176.0/nautilus_core/model/cbindgen.toml`

 * *Files 7% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 
 [export]
 exclude = [
     "BarAggregation",
 ]
 
 [export.rename]
+"Ustr" = "char*"
 "AccountId" = "AccountId_t"
 "Bar" = "Bar_t"
 "BarAggregation" = "uint8_t"
 "BarSpecification" = "BarSpecification_t"
 "BarType" = "BarType_t"
 "BookOrder" = "BookOrder_t"
 "ClientId" = "ClientId_t"
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/cbindgen_cython.toml` & `nautilus_trader-1.176.0/nautilus_core/model/cbindgen_cython.toml`

 * *Files 1% similar despite different names*

```diff
@@ -27,14 +27,15 @@
 
 [export]
 exclude = [
     "BarAggregation",
 ]
 
 [export.rename]
+"Ustr" = "char*"
 "AccountId" = "AccountId_t"
 "Bar" = "Bar_t"
 "BarAggregation" = "uint8_t"
 "BarSpecification" = "BarSpecification_t"
 "BarType" = "BarType_t"
 "BookOrder" = "BookOrder_t"
 "ClientId" = "ClientId_t"
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/data/bar_api.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/data/bar_api.rs`

 * *Files 4% similar despite different names*

```diff
@@ -94,24 +94,14 @@
         instrument_id,
         spec,
         aggregation_source,
     }
 }
 
 #[no_mangle]
-pub extern "C" fn bar_type_drop(bar_type: BarType) {
-    drop(bar_type); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_clone(bar_type: &BarType) -> BarType {
-    bar_type.clone()
-}
-
-#[no_mangle]
 pub extern "C" fn bar_type_eq(lhs: &BarType, rhs: &BarType) -> u8 {
     u8::from(lhs == rhs)
 }
 
 #[no_mangle]
 pub extern "C" fn bar_type_lt(lhs: &BarType, rhs: &BarType) -> u8 {
     u8::from(lhs < rhs)
@@ -190,33 +180,23 @@
         volume: Quantity::from_raw(volume, size_prec),
         ts_event,
         ts_init,
     }
 }
 
 #[no_mangle]
-pub extern "C" fn bar_drop(bar: Bar) {
-    drop(bar); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn bar_clone(bar: &Bar) -> Bar {
-    bar.clone()
-}
-
-/// Returns a [`Bar`] as a C string.
-#[no_mangle]
-pub extern "C" fn bar_to_cstr(bar: &Bar) -> *const c_char {
-    str_to_cstr(&bar.to_string())
-}
-
-#[no_mangle]
 pub extern "C" fn bar_eq(lhs: &Bar, rhs: &Bar) -> u8 {
     u8::from(lhs == rhs)
 }
 
 #[no_mangle]
 pub extern "C" fn bar_hash(bar: &Bar) -> u64 {
     let mut h = DefaultHasher::new();
     bar.hash(&mut h);
     h.finish()
 }
+
+/// Returns a [`Bar`] as a C string.
+#[no_mangle]
+pub extern "C" fn bar_to_cstr(bar: &Bar) -> *const c_char {
+    str_to_cstr(&bar.to_string())
+}
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/data/book.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orders/limit_if_touched.rs`

 * *Files 21% similar despite different names*

```diff
@@ -10,381 +10,391 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
-    fmt::{Display, Formatter},
-    hash::{Hash, Hasher},
+    collections::HashMap,
+    ops::{Deref, DerefMut},
 };
 
-use nautilus_core::time::UnixNanos;
+use nautilus_core::{time::UnixNanos, uuid::UUID4};
 
-use super::tick::{QuoteTick, TradeTick};
+use super::base::{Order, OrderCore};
 use crate::{
-    enums::{BookAction, OrderSide},
-    identifiers::instrument_id::InstrumentId,
-    orderbook::{book::BookIntegrityError, ladder::BookPrice},
+    enums::{
+        ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, TimeInForce, TriggerType,
+    },
+    events::order::{OrderEvent, OrderInitialized},
+    identifiers::{
+        account_id::AccountId, client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
+        instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
+        strategy_id::StrategyId, trade_id::TradeId, trader_id::TraderId,
+        venue_order_id::VenueOrderId,
+    },
     types::{price::Price, quantity::Quantity},
 };
 
-/// Represents an order in a book.
-#[repr(C)]
-#[derive(Copy, Clone, Eq, Debug)]
-pub struct BookOrder {
-    pub side: OrderSide,
+pub struct LimitIfTouchedOrder {
+    core: OrderCore,
     pub price: Price,
-    pub size: Quantity,
-    pub order_id: u64,
+    pub trigger_price: Price,
+    pub trigger_type: TriggerType,
+    pub expire_time: Option<UnixNanos>,
+    pub display_qty: Option<Quantity>,
+    pub is_triggered: bool,
+    pub ts_triggered: Option<UnixNanos>,
 }
 
-impl BookOrder {
+impl LimitIfTouchedOrder {
     #[must_use]
-    pub fn new(side: OrderSide, price: Price, size: Quantity, order_id: u64) -> Self {
+    #[allow(clippy::too_many_arguments)]
+    pub fn new(
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        quantity: Quantity,
+        price: Price,
+        trigger_price: Price,
+        trigger_type: TriggerType,
+        time_in_force: TimeInForce,
+        expire_time: Option<UnixNanos>,
+        post_only: bool,
+        reduce_only: bool,
+        quote_quantity: bool,
+        display_qty: Option<Quantity>,
+        emulation_trigger: Option<TriggerType>,
+        contingency_type: Option<ContingencyType>,
+        order_list_id: Option<OrderListId>,
+        linked_order_ids: Option<Vec<ClientOrderId>>,
+        parent_order_id: Option<ClientOrderId>,
+        exec_algorithm_id: Option<ExecAlgorithmId>,
+        exec_algorithm_params: Option<HashMap<String, String>>,
+        exec_spawn_id: Option<ClientOrderId>,
+        tags: Option<String>,
+        init_id: UUID4,
+        ts_init: UnixNanos,
+    ) -> Self {
         Self {
-            side,
+            core: OrderCore::new(
+                trader_id,
+                strategy_id,
+                instrument_id,
+                client_order_id,
+                order_side,
+                OrderType::LimitIfTouched,
+                quantity,
+                time_in_force,
+                post_only,
+                reduce_only,
+                quote_quantity,
+                emulation_trigger,
+                contingency_type,
+                order_list_id,
+                linked_order_ids,
+                parent_order_id,
+                exec_algorithm_id,
+                exec_algorithm_params,
+                exec_spawn_id,
+                tags,
+                init_id,
+                ts_init,
+            ),
             price,
-            size,
-            order_id,
+            trigger_price,
+            trigger_type,
+            expire_time,
+            display_qty,
+            is_triggered: false,
+            ts_triggered: None,
         }
     }
+}
 
-    #[must_use]
-    pub fn to_book_price(&self) -> BookPrice {
-        BookPrice::new(self.price, self.side)
+/// Provides a default [`LimitIfTouchedOrder`] used for testing.
+impl Default for LimitIfTouchedOrder {
+    fn default() -> Self {
+        LimitIfTouchedOrder::new(
+            TraderId::default(),
+            StrategyId::default(),
+            InstrumentId::default(),
+            ClientOrderId::default(),
+            OrderSide::Buy,
+            Quantity::new(100_000.0, 0),
+            Price::new(1.0, 5),
+            Price::new(1.0, 5),
+            TriggerType::BidAsk,
+            TimeInForce::Gtc,
+            None,
+            false,
+            false,
+            false,
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            None,
+            UUID4::default(),
+            0,
+        )
     }
+}
 
-    #[must_use]
-    pub fn exposure(&self) -> f64 {
-        self.price.as_f64() * self.size.as_f64()
+impl Deref for LimitIfTouchedOrder {
+    type Target = OrderCore;
+
+    fn deref(&self) -> &Self::Target {
+        &self.core
     }
+}
 
-    #[must_use]
-    pub fn signed_size(&self) -> f64 {
-        match self.side {
-            OrderSide::Buy => self.size.as_f64(),
-            OrderSide::Sell => -(self.size.as_f64()),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
+impl DerefMut for LimitIfTouchedOrder {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.core
     }
+}
 
-    #[must_use]
-    pub fn from_quote_tick(tick: &QuoteTick, side: OrderSide) -> Self {
-        match side {
-            OrderSide::Buy => {
-                Self::new(OrderSide::Buy, tick.bid, tick.bid_size, tick.bid.raw as u64)
-            }
-            OrderSide::Sell => Self::new(
-                OrderSide::Sell,
-                tick.ask,
-                tick.ask_size,
-                tick.ask.raw as u64,
-            ),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
+impl Order for LimitIfTouchedOrder {
+    fn status(&self) -> OrderStatus {
+        self.status
     }
 
-    #[must_use]
-    pub fn from_trade_tick(tick: &TradeTick, side: OrderSide) -> Self {
-        match side {
-            OrderSide::Buy => {
-                Self::new(OrderSide::Buy, tick.price, tick.size, tick.price.raw as u64)
-            }
-            OrderSide::Sell => Self::new(
-                OrderSide::Sell,
-                tick.price,
-                tick.size,
-                tick.price.raw as u64,
-            ),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
+    fn trader_id(&self) -> TraderId {
+        self.trader_id
     }
-}
 
-impl PartialEq for BookOrder {
-    fn eq(&self, other: &Self) -> bool {
-        self.order_id == other.order_id
+    fn strategy_id(&self) -> StrategyId {
+        self.strategy_id
     }
-}
 
-impl Hash for BookOrder {
-    fn hash<H: Hasher>(&self, state: &mut H) {
-        self.order_id.hash(state);
+    fn instrument_id(&self) -> InstrumentId {
+        self.instrument_id
     }
-}
 
-impl Display for BookOrder {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(
-            f,
-            "{},{},{},{}",
-            self.price, self.size, self.side, self.order_id,
-        )
+    fn client_order_id(&self) -> ClientOrderId {
+        self.client_order_id
     }
-}
 
-/// Represents a single change/delta in an order book.
-#[repr(C)]
-#[derive(Clone, Debug, PartialEq, Eq, Hash)]
-pub struct OrderBookDelta {
-    pub instrument_id: InstrumentId,
-    pub action: BookAction,
-    pub order: BookOrder,
-    pub flags: u8,
-    pub sequence: u64,
-    pub ts_event: UnixNanos,
-    pub ts_init: UnixNanos,
-}
+    fn venue_order_id(&self) -> Option<VenueOrderId> {
+        self.venue_order_id
+    }
 
-impl OrderBookDelta {
-    #[allow(clippy::too_many_arguments)]
-    #[must_use]
-    pub fn new(
-        instrument_id: InstrumentId,
-        action: BookAction,
-        order: BookOrder,
-        flags: u8,
-        sequence: u64,
-        ts_event: UnixNanos,
-        ts_init: UnixNanos,
-    ) -> Self {
-        Self {
-            instrument_id,
-            action,
-            order,
-            flags,
-            sequence,
-            ts_event,
-            ts_init,
-        }
+    fn position_id(&self) -> Option<PositionId> {
+        self.position_id
     }
-}
 
-impl Display for OrderBookDelta {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(
-            f,
-            "{},{},{},{},{},{},{}",
-            self.instrument_id,
-            self.action,
-            self.order,
-            self.flags,
-            self.sequence,
-            self.ts_event,
-            self.ts_init
-        )
+    fn account_id(&self) -> Option<AccountId> {
+        self.account_id
+    }
+
+    fn last_trade_id(&self) -> Option<TradeId> {
+        self.last_trade_id
     }
-}
 
-////////////////////////////////////////////////////////////////////////////////
-// Tests
-////////////////////////////////////////////////////////////////////////////////
+    fn side(&self) -> OrderSide {
+        self.side
+    }
 
-#[cfg(test)]
-mod tests {
-    use std::str::FromStr;
+    fn order_type(&self) -> OrderType {
+        self.order_type
+    }
 
-    use rstest::rstest;
+    fn quantity(&self) -> Quantity {
+        self.quantity
+    }
 
-    use super::*;
-    use crate::{enums::AggressorSide, identifiers::trade_id::TradeId};
+    fn time_in_force(&self) -> TimeInForce {
+        self.time_in_force
+    }
 
-    #[test]
-    fn test_book_order_new() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123456;
+    fn price(&self) -> Option<Price> {
+        Some(self.price)
+    }
 
-        let order = BookOrder::new(side, price.clone(), size.clone(), order_id);
+    fn trigger_price(&self) -> Option<Price> {
+        Some(self.trigger_price)
+    }
 
-        assert_eq!(order.price, price);
-        assert_eq!(order.size, size);
-        assert_eq!(order.side, side);
-        assert_eq!(order.order_id, order_id);
+    fn trigger_type(&self) -> Option<TriggerType> {
+        Some(self.trigger_type)
     }
 
-    #[test]
-    fn test_book_order_to_book_price() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123456;
+    fn liquidity_side(&self) -> Option<LiquiditySide> {
+        self.liquidity_side
+    }
 
-        let order = BookOrder::new(side, price.clone(), size.clone(), order_id);
-        let book_price = order.to_book_price();
+    fn is_post_only(&self) -> bool {
+        self.is_post_only
+    }
 
-        assert_eq!(book_price.value, price);
-        assert_eq!(book_price.side, side);
+    fn is_reduce_only(&self) -> bool {
+        self.is_reduce_only
     }
 
-    #[test]
-    fn test_book_order_exposure() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123456;
+    fn is_quote_quantity(&self) -> bool {
+        self.is_quote_quantity
+    }
 
-        let order = BookOrder::new(side, price.clone(), size.clone(), order_id);
-        let exposure = order.exposure();
+    fn emulation_trigger(&self) -> Option<TriggerType> {
+        self.emulation_trigger
+    }
 
-        assert_eq!(exposure, price.as_f64() * size.as_f64());
+    fn contingency_type(&self) -> Option<ContingencyType> {
+        self.contingency_type
     }
 
-    #[test]
-    fn test_book_order_signed_size() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let order_id = 123456;
+    fn order_list_id(&self) -> Option<OrderListId> {
+        self.order_list_id
+    }
 
-        let order_buy = BookOrder::new(OrderSide::Buy, price.clone(), size.clone(), order_id);
-        let signed_size_buy = order_buy.signed_size();
-        assert_eq!(signed_size_buy, size.as_f64());
+    fn linked_order_ids(&self) -> Option<Vec<ClientOrderId>> {
+        self.linked_order_ids.clone()
+    }
 
-        let order_sell = BookOrder::new(OrderSide::Sell, price.clone(), size.clone(), order_id);
-        let signed_size_sell = order_sell.signed_size();
-        assert_eq!(signed_size_sell, -(size.as_f64()));
+    fn parent_order_id(&self) -> Option<ClientOrderId> {
+        self.parent_order_id
     }
 
-    #[test]
-    fn test_book_order_display() {
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123456;
+    fn exec_algorithm_id(&self) -> Option<ExecAlgorithmId> {
+        self.exec_algorithm_id
+    }
 
-        let order = BookOrder::new(side, price.clone(), size.clone(), order_id);
-        let display = format!("{}", order);
+    fn exec_algorithm_params(&self) -> Option<HashMap<String, String>> {
+        self.exec_algorithm_params.clone()
+    }
 
-        let expected = format!("{},{},{},{}", price, size, side, order_id);
-        assert_eq!(display, expected);
+    fn exec_spawn_id(&self) -> Option<ClientOrderId> {
+        self.exec_spawn_id
     }
 
-    #[rstest(side, case(OrderSide::Buy), case(OrderSide::Sell))]
-    fn book_order_from_quote_tick(side: OrderSide) {
-        let tick = QuoteTick::new(
-            InstrumentId::from_str("ETHUSDT-PERP.BINANCE").unwrap(),
-            Price::new(5000.0, 2),
-            Price::new(5001.0, 2),
-            Quantity::new(100.0, 3),
-            Quantity::new(99.0, 3),
-            0,
-            0,
-        );
+    fn tags(&self) -> Option<String> {
+        self.tags.clone()
+    }
 
-        let book_order = BookOrder::from_quote_tick(&tick, side.clone());
+    fn filled_qty(&self) -> Quantity {
+        self.filled_qty
+    }
 
-        assert_eq!(book_order.side, side);
-        assert_eq!(
-            book_order.price,
-            match side {
-                OrderSide::Buy => tick.bid,
-                OrderSide::Sell => tick.ask,
-                _ => panic!("Invalid test"),
-            }
-        );
-        assert_eq!(
-            book_order.size,
-            match side {
-                OrderSide::Buy => tick.bid_size,
-                OrderSide::Sell => tick.ask_size,
-                _ => panic!("Invalid test"),
-            }
-        );
-        assert_eq!(
-            book_order.order_id,
-            match side {
-                OrderSide::Buy => tick.bid.raw as u64,
-                OrderSide::Sell => tick.ask.raw as u64,
-                _ => panic!("Invalid test"),
-            }
-        );
-    }
-
-    #[test]
-    fn test_orderbook_delta_new() {
-        let instrument_id = InstrumentId::from_str("AAPL.NASDAQ").unwrap();
-        let action = BookAction::Add;
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123456;
-        let flags = 0;
-        let sequence = 1;
-        let ts_event = 1;
-        let ts_init = 2;
-
-        let order = BookOrder::new(side, price.clone(), size.clone(), order_id);
-        let delta = OrderBookDelta::new(
-            instrument_id.clone(),
-            action,
-            order,
-            flags,
-            sequence,
-            ts_event,
-            ts_init,
-        );
-
-        assert_eq!(delta.instrument_id, instrument_id);
-        assert_eq!(delta.action, action);
-        assert_eq!(delta.order.price, price);
-        assert_eq!(delta.order.size, size);
-        assert_eq!(delta.order.side, side);
-        assert_eq!(delta.order.order_id, order_id);
-        assert_eq!(delta.flags, flags);
-        assert_eq!(delta.sequence, sequence);
-        assert_eq!(delta.ts_event, ts_event);
-        assert_eq!(delta.ts_init, ts_init);
-    }
-
-    #[test]
-    fn test_order_book_delta_display() {
-        let instrument_id = InstrumentId::from_str("AAPL.NASDAQ").unwrap();
-        let action = BookAction::Add;
-        let price = Price::from("100.00");
-        let size = Quantity::from("10");
-        let side = OrderSide::Buy;
-        let order_id = 123456;
-        let flags = 0;
-        let sequence = 1;
-        let ts_event = 1;
-        let ts_init = 2;
-
-        let order = BookOrder::new(side, price.clone(), size.clone(), order_id);
-
-        let delta = OrderBookDelta::new(
-            instrument_id.clone(),
-            action,
-            order.clone(),
-            flags,
-            sequence,
-            ts_event,
-            ts_init,
-        );
-
-        assert_eq!(
-            format!("{}", delta),
-            "AAPL.NASDAQ,ADD,100.00,10,BUY,123456,0,1,1,2".to_string()
-        );
-    }
-
-    #[rstest(side, case(OrderSide::Buy), case(OrderSide::Sell))]
-    fn book_order_from_trade_tick(side: OrderSide) {
-        let tick = TradeTick::new(
-            InstrumentId::from_str("ETHUSDT-PERP.BINANCE").unwrap(),
-            Price::new(5000.0, 2),
-            Quantity::new(100.0, 2),
-            AggressorSide::Buyer,
-            TradeId::new("1"),
-            0,
-            0,
-        );
+    fn leaves_qty(&self) -> Quantity {
+        self.leaves_qty
+    }
 
-        let book_order = BookOrder::from_trade_tick(&tick, side);
+    fn avg_px(&self) -> Option<f64> {
+        self.avg_px
+    }
 
-        assert_eq!(book_order.side, side);
-        assert_eq!(book_order.price, tick.price);
-        assert_eq!(book_order.size, tick.size);
-        assert_eq!(book_order.order_id, tick.price.raw as u64);
+    fn slippage(&self) -> Option<f64> {
+        self.slippage
+    }
+
+    fn init_id(&self) -> UUID4 {
+        self.init_id
+    }
+
+    fn ts_init(&self) -> UnixNanos {
+        self.ts_init
+    }
+
+    fn ts_last(&self) -> UnixNanos {
+        self.ts_last
+    }
+
+    fn events(&self) -> Vec<&OrderEvent> {
+        self.events.iter().collect()
+    }
+
+    fn venue_order_ids(&self) -> Vec<&VenueOrderId> {
+        self.venue_order_ids.iter().collect()
+    }
+
+    fn trade_ids(&self) -> Vec<&TradeId> {
+        self.trade_ids.iter().collect()
+    }
+}
+
+impl From<OrderInitialized> for LimitIfTouchedOrder {
+    fn from(event: OrderInitialized) -> Self {
+        LimitIfTouchedOrder::new(
+            event.trader_id,
+            event.strategy_id,
+            event.instrument_id,
+            event.client_order_id,
+            event.order_side,
+            event.quantity,
+            event
+                .price // TODO: Improve this error, model order domain errors
+                .expect("Error initializing order: `price` was `None` for `LimitIfTouchedOrder"),
+            event
+                .trigger_price // TODO: Improve this error, model order domain errors
+                .expect(
+                    "Error initializing order: `trigger_price` was `None` for `LimitIfTouchedOrder",
+                ),
+            event
+                .trigger_type
+                .expect("Error initializing order: `trigger_type` was `None`"),
+            event.time_in_force,
+            event.expire_time,
+            event.post_only,
+            event.reduce_only,
+            event.quote_quantity,
+            event.display_qty,
+            event.emulation_trigger,
+            event.contingency_type,
+            event.order_list_id,
+            event.linked_order_ids,
+            event.parent_order_id,
+            event.exec_algorithm_id,
+            event.exec_algorithm_params,
+            event.exec_spawn_id,
+            event.tags,
+            event.event_id,
+            event.ts_event,
+        )
+    }
+}
+
+impl From<&LimitIfTouchedOrder> for OrderInitialized {
+    fn from(order: &LimitIfTouchedOrder) -> Self {
+        Self {
+            trader_id: order.trader_id,
+            strategy_id: order.strategy_id,
+            instrument_id: order.instrument_id,
+            client_order_id: order.client_order_id,
+            order_side: order.side,
+            order_type: order.order_type,
+            quantity: order.quantity,
+            price: Some(order.price),
+            trigger_price: Some(order.trigger_price),
+            trigger_type: Some(order.trigger_type),
+            time_in_force: order.time_in_force,
+            expire_time: order.expire_time,
+            post_only: order.is_post_only,
+            reduce_only: order.is_reduce_only,
+            quote_quantity: order.is_quote_quantity,
+            display_qty: order.display_qty,
+            limit_offset: None,
+            trailing_offset: None,
+            trailing_offset_type: None,
+            emulation_trigger: order.emulation_trigger,
+            contingency_type: order.contingency_type,
+            order_list_id: order.order_list_id,
+            linked_order_ids: order.linked_order_ids.clone(),
+            parent_order_id: order.parent_order_id,
+            exec_algorithm_id: order.exec_algorithm_id,
+            exec_algorithm_params: order.exec_algorithm_params.clone(),
+            exec_spawn_id: order.exec_spawn_id,
+            tags: order.tags.clone(),
+            event_id: order.init_id,
+            ts_event: order.ts_init,
+            ts_init: order.ts_init,
+            reconciliation: false,
+        }
     }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/data/book_api.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/data/order_api.rs`

 * *Files 21% similar despite different names*

```diff
@@ -15,20 +15,19 @@
 
 use std::{
     collections::hash_map::DefaultHasher,
     ffi::c_char,
     hash::{Hash, Hasher},
 };
 
-use nautilus_core::{string::str_to_cstr, time::UnixNanos};
+use nautilus_core::string::str_to_cstr;
 
-use super::book::{BookOrder, OrderBookDelta};
+use super::order::BookOrder;
 use crate::{
-    enums::{BookAction, OrderSide},
-    identifiers::instrument_id::InstrumentId,
+    enums::OrderSide,
     types::{price::Price, quantity::Quantity},
 };
 
 #[no_mangle]
 pub extern "C" fn book_order_from_raw(
     order_side: OrderSide,
     price_raw: i64,
@@ -74,50 +73,7 @@
 }
 
 /// Returns a [`BookOrder`] debug string as a C string pointer.
 #[no_mangle]
 pub extern "C" fn book_order_debug_to_cstr(order: &BookOrder) -> *const c_char {
     str_to_cstr(&format!("{:?}", order))
 }
-
-#[no_mangle]
-pub extern "C" fn orderbook_delta_drop(delta: OrderBookDelta) {
-    drop(delta); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn orderbook_delta_clone(delta: &OrderBookDelta) -> OrderBookDelta {
-    delta.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn orderbook_delta_new(
-    instrument_id: InstrumentId,
-    action: BookAction,
-    order: BookOrder,
-    flags: u8,
-    sequence: u64,
-    ts_event: UnixNanos,
-    ts_init: UnixNanos,
-) -> OrderBookDelta {
-    OrderBookDelta::new(
-        instrument_id,
-        action,
-        order,
-        flags,
-        sequence,
-        ts_event,
-        ts_init,
-    )
-}
-
-#[no_mangle]
-pub extern "C" fn orderbook_delta_eq(lhs: &OrderBookDelta, rhs: &OrderBookDelta) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn orderbook_delta_hash(delta: &OrderBookDelta) -> u64 {
-    let mut hasher = DefaultHasher::new();
-    delta.hash(&mut hasher);
-    hasher.finish()
-}
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/data/mod.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/data/mod.rs`

 * *Files 6% similar despite different names*

```diff
@@ -11,29 +11,29 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod bar;
 pub mod bar_api;
-pub mod book;
-pub mod book_api;
-pub mod tick;
-pub mod tick_api;
+pub mod delta;
+pub mod delta_api;
+pub mod order;
+pub mod order_api;
+pub mod quote;
+pub mod quote_api;
+pub mod trade;
+pub mod trade_api;
 
 use nautilus_core::time::UnixNanos;
 
-use self::{
-    bar::Bar,
-    book::OrderBookDelta,
-    tick::{QuoteTick, TradeTick},
-};
+use self::{bar::Bar, delta::OrderBookDelta, quote::QuoteTick, trade::TradeTick};
 
 #[repr(C)]
-#[derive(Debug, Clone)]
+#[derive(Debug, Clone, Copy)]
 pub enum Data {
     Delta(OrderBookDelta),
     Quote(QuoteTick),
     Trade(TradeTick),
     Bar(Bar),
 }
 
@@ -68,7 +68,12 @@
 }
 
 impl From<Bar> for Data {
     fn from(value: Bar) -> Self {
         Self::Bar(value)
     }
 }
+
+#[no_mangle]
+pub extern "C" fn data_clone(data: &Data) -> Data {
+    *data
+}
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/data/tick_api.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/data/trade_api.rs`

 * *Files 19% similar despite different names*

```diff
@@ -9,70 +9,30 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::ffi::c_char;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::c_char,
+    hash::{Hash, Hasher},
+};
 
-use nautilus_core::{string::str_to_cstr, time::UnixNanos};
+use nautilus_core::string::str_to_cstr;
 
-use super::{
-    tick::{QuoteTick, TradeTick},
-    Data,
-};
+use super::trade::TradeTick;
 use crate::{
     enums::AggressorSide,
     identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
     types::{price::Price, quantity::Quantity},
 };
 
 #[no_mangle]
-pub extern "C" fn quote_tick_new(
-    instrument_id: InstrumentId,
-    bid_price_raw: i64,
-    ask_price_raw: i64,
-    bid_price_prec: u8,
-    ask_price_prec: u8,
-    bid_size_raw: u64,
-    ask_size_raw: u64,
-    bid_size_prec: u8,
-    ask_size_prec: u8,
-    ts_event: UnixNanos,
-    ts_init: UnixNanos,
-) -> QuoteTick {
-    QuoteTick::new(
-        instrument_id,
-        Price::from_raw(bid_price_raw, bid_price_prec),
-        Price::from_raw(ask_price_raw, ask_price_prec),
-        Quantity::from_raw(bid_size_raw, bid_size_prec),
-        Quantity::from_raw(ask_size_raw, ask_size_prec),
-        ts_event,
-        ts_init,
-    )
-}
-
-#[no_mangle]
-pub extern "C" fn quote_tick_drop(tick: QuoteTick) {
-    drop(tick); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn quote_tick_clone(tick: &QuoteTick) -> QuoteTick {
-    tick.clone()
-}
-
-/// Returns a [`QuoteTick`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn quote_tick_to_cstr(tick: &QuoteTick) -> *const c_char {
-    str_to_cstr(&tick.to_string())
-}
-
-#[no_mangle]
 pub extern "C" fn trade_tick_new(
     instrument_id: InstrumentId,
     price_raw: i64,
     price_prec: u8,
     size_raw: u64,
     size_prec: u8,
     aggressor_side: AggressorSide,
@@ -88,31 +48,23 @@
         trade_id,
         ts_event,
         ts_init,
     )
 }
 
 #[no_mangle]
-pub extern "C" fn trade_tick_drop(tick: TradeTick) {
-    drop(tick); // Memory freed here
+pub extern "C" fn trade_tick_eq(lhs: &TradeTick, rhs: &TradeTick) -> u8 {
+    u8::from(lhs == rhs)
 }
 
 #[no_mangle]
-pub extern "C" fn trade_tick_clone(tick: &TradeTick) -> TradeTick {
-    tick.clone()
+pub extern "C" fn trade_tick_hash(delta: &TradeTick) -> u64 {
+    let mut hasher = DefaultHasher::new();
+    delta.hash(&mut hasher);
+    hasher.finish()
 }
 
 /// Returns a [`TradeTick`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn trade_tick_to_cstr(tick: &TradeTick) -> *const c_char {
     str_to_cstr(&tick.to_string())
 }
-
-#[no_mangle]
-pub extern "C" fn data_drop(data: Data) {
-    drop(data); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn data_clone(data: &Data) -> Data {
-    data.clone()
-}
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/enums.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/enums.rs`

 * *Files 8% similar despite different names*

```diff
@@ -11,31 +11,44 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 //! Defines enumerations for the trading domain model.
 
-use std::{ffi::c_char, fmt::Debug, str::FromStr};
+use std::{ffi::c_char, str::FromStr};
 
 use nautilus_core::string::{cstr_to_string, str_to_cstr};
 use pyo3::prelude::*;
-use serde::{Deserialize, Serialize};
-use strum::{Display, EnumString, FromRepr};
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
+use strum::{AsRefStr, Display, EnumString, FromRepr};
+
+use crate::strum_serde;
 
 pub trait FromU8 {
     fn from_u8(value: u8) -> Option<Self>
     where
         Self: Sized;
 }
 
 /// An account type provided by a trading venue or broker.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum AccountType {
     /// An account with unleveraged cash assets only.
     Cash = 1,
@@ -44,30 +57,52 @@
     /// An account specific to betting markets.
     Betting = 3,
 }
 
 /// An aggregation source for derived data.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum AggregationSource {
     /// The data is externally aggregated (outside the Nautilus system boundary).
     External = 1,
     /// The data is internally aggregated (inside the Nautilus system boundary).
     Internal = 2,
 }
 
 /// The side for the aggressing order of a trade in a market.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum AggressorSide {
     /// There was no specific aggressor for the trade.
     NoAggressor = 0, // Will be replaced by `Option`
@@ -76,15 +111,26 @@
     /// The SELL order was the aggressor for the trade.
     Seller = 2,
 }
 
 /// A broad financial market asset class.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 #[allow(non_camel_case_types)]
 pub enum AssetClass {
     /// Foreign exchange (FOREX) assets.
@@ -106,15 +152,26 @@
     /// Sports betting instruments.
     SportsBetting = 9,
 }
 
 /// The asset type for a financial market product.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum AssetType {
     /// A spot market asset type. The current market price of an asset that is bought or sold for immediate delivery and payment.
     Spot = 1,
@@ -131,15 +188,26 @@
     /// A warrant asset type. A derivative that gives the holder the right, but not the obligation, to buy or sell a securitymost commonly an equityat a certain price before expiration.
     Warrant = 7,
 }
 
 /// The aggregation method through which a bar is generated and closed.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum BarAggregation {
     /// Based on a number of ticks.
     Tick = 1,
@@ -174,15 +242,26 @@
     /// Based on time intervals with month granularity.
     Month = 16,
 }
 
 /// The type of order book action for an order book event.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum BookAction {
     /// An order is added to the book.
     Add = 1,
@@ -205,15 +284,26 @@
         }
     }
 }
 
 /// The order book type, representing the type of levels granularity and delta updating heuristics.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[allow(non_camel_case_types)]
 #[pyclass]
 pub enum BookType {
     /// Top-of-book best bid/offer, one level per side.
@@ -236,15 +326,26 @@
 }
 
 /// The order contigency type which specifies the behaviour of linked orders.
 ///
 /// [FIX 5.0 SP2 : ContingencyType <1385> field](https://www.onixs.biz/fix-dictionary/5.0.sp2/tagnum_1385.html).
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum ContingencyType {
     /// Not a contingent order.
     NoContingency = 0, // Will be replaced by `Option`
@@ -255,45 +356,78 @@
     /// One-Updates-the-Other (by proportional quantity).
     Ouo = 3,
 }
 
 /// The broad currency type.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum CurrencyType {
     /// A type of cryptocurrency or crypto token.
     Crypto = 1,
     /// A type of currency issued by governments which is not backed by a commodity.
     Fiat = 2,
 }
 
 /// The type of event for an instrument close.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum InstrumentCloseType {
     /// When the market session ended.
     EndOfSession = 1,
     /// When the instrument expiration was reached.
     ContractExpired = 2,
 }
 
 /// The liqudity side for a trade in a financial market.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[allow(clippy::enum_variant_names)]
 #[pyclass]
 pub enum LiquiditySide {
     /// No specific liqudity side.
@@ -303,15 +437,26 @@
     /// The order aggressively took liqudity from the market to complete the trade.
     Taker = 2,
 }
 
 /// The status of an individual market on a trading venue.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum MarketStatus {
     /// The market is closed.
     Closed = 1,
@@ -324,15 +469,26 @@
     /// The market is in the pre-close session.
     PreClose = 5,
 }
 
 /// The order management system (OMS) type for a trading venue or trading strategy.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum OmsType {
     /// There is no specific type of order management specified (will defer to the venue).
     Unspecified = 0, // Will be replaced by `Option`
@@ -343,30 +499,52 @@
     /// Nautilus.
     Hedging = 2,
 }
 
 /// The kind of options contract.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum OptionKind {
     /// A Call option gives the holder the right, but not the obligation, to buy an underlying asset at a specified strike price within a specified period of time.
     Call = 1,
     /// A Put option gives the holder the right, but not the obligation, to sell an underlying asset at a specified strike price within a specified period of time.
     Put = 2,
 }
 
 /// The order side for a specific order, or action related to orders.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[allow(clippy::enum_variant_names)]
 #[pyclass]
 pub enum OrderSide {
     /// No order side is specified (only valid in the context of a filter for actions involving orders).
@@ -407,15 +585,26 @@
 ///  - `DENIED`
 ///  - `REJECTED`
 ///  - `CANCELED`
 ///  - `EXPIRED`
 ///  - `FILLED`
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum OrderStatus {
     /// The order is initialized (instantiated) within the Nautilus system.
     Initialized = 1,
@@ -442,15 +631,26 @@
     /// The order has been completely filled at the trading venue (closed/done).
     Filled = 12,
 }
 
 /// The type of order.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum OrderType {
     /// A market order to buy or sell at the best available price in the current market.
     Market = 1,
@@ -471,15 +671,26 @@
     /// A trailing stop limit order combines the features of a trailing stop order with those of a limit order.
     TrailingStopLimit = 9,
 }
 
 /// The market side for a specific position, or action related to positions.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[allow(clippy::enum_variant_names)]
 #[pyclass]
 pub enum PositionSide {
     /// No position side is specified (only valid in the context of a filter for actions involving positions).
@@ -491,15 +702,26 @@
     /// A short position in the market, typically acquired through one or many SELL orders.
     Short = 3,
 }
 
 /// The type of price for an instrument in a financial market.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum PriceType {
     /// A quoted order price where a buyer is willing to buy a quantity of an instrument.
     Bid = 1,
@@ -510,15 +732,26 @@
     /// The last price at which a trade was made for an instrument.
     Last = 4,
 }
 
 /// The 'Time in Force' instruction for an order in the financial market.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum TimeInForce {
     /// Good Till Canceled (GTC) - the order remains active until canceled.
     Gtc = 1,
@@ -535,15 +768,26 @@
     /// At the Closing (ATC) - the order is scheduled to be executed at the market's closing.
     AtTheClose = 7,
 }
 
 /// The trading state for a node.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum TradingState {
     /// Normal trading operations.
     Active = 1,
@@ -552,15 +796,26 @@
     /// Only order commands which would cancel order, or reduce position sizes are permitted.
     Reducing = 3,
 }
 
 /// The trailing offset type for an order type which specifies a trailing stop/trigger or limit price.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum TrailingOffsetType {
     /// No trailing offset type is specified (invalid for trailing type orders).
     NoTrailingOffset = 0, // Will be replaced by `Option`
@@ -573,15 +828,26 @@
     /// The trailing offset is based on a price tier set by a specific trading venue.
     PriceTier = 4,
 }
 
 /// The trigger type for the stop/trigger price of an order.
 #[repr(C)]
 #[derive(
-    Copy, Clone, Debug, Hash, PartialEq, Eq, FromRepr, EnumString, Display, Serialize, Deserialize,
+    Copy,
+    Clone,
+    Debug,
+    Display,
+    Hash,
+    PartialEq,
+    Eq,
+    PartialOrd,
+    Ord,
+    AsRefStr,
+    FromRepr,
+    EnumString,
 )]
 #[strum(ascii_case_insensitive)]
 #[strum(serialize_all = "SCREAMING_SNAKE_CASE")]
 #[pyclass]
 pub enum TriggerType {
     /// No trigger type is specified (invalid for orders with a trigger).
     NoTrigger = 0, // Will be replaced by `Option`
@@ -601,17 +867,42 @@
     MidPoint = 7,
     /// Based on the mark price for the instrument.
     MarkPrice = 8,
     /// Based on the index price for the instrument.
     IndexPrice = 9,
 }
 
+strum_serde!(AccountType);
+strum_serde!(AggregationSource);
+strum_serde!(AggressorSide);
+strum_serde!(AssetClass);
+strum_serde!(AssetType);
+strum_serde!(BarAggregation);
+strum_serde!(BookAction);
+strum_serde!(BookType);
+strum_serde!(ContingencyType);
+strum_serde!(CurrencyType);
+strum_serde!(InstrumentCloseType);
+strum_serde!(LiquiditySide);
+strum_serde!(MarketStatus);
+strum_serde!(OmsType);
+strum_serde!(OptionKind);
+strum_serde!(OrderSide);
+strum_serde!(OrderStatus);
+strum_serde!(OrderType);
+strum_serde!(PositionSide);
+strum_serde!(PriceType);
+strum_serde!(TimeInForce);
+strum_serde!(TradingState);
+strum_serde!(TrailingOffsetType);
+strum_serde!(TriggerType);
+
 #[no_mangle]
 pub extern "C" fn account_type_to_cstr(value: AccountType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -619,15 +910,15 @@
     let value = cstr_to_string(ptr);
     AccountType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `AccountType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn aggregation_source_to_cstr(value: AggregationSource) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -635,15 +926,15 @@
     let value = cstr_to_string(ptr);
     AggregationSource::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `AggregationSource` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn aggressor_side_to_cstr(value: AggressorSide) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -651,15 +942,15 @@
     let value = cstr_to_string(ptr);
     AggressorSide::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `AggressorSide` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn asset_class_to_cstr(value: AssetClass) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -667,15 +958,15 @@
     let value = cstr_to_string(ptr);
     AssetClass::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `AssetClass` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn asset_type_to_cstr(value: AssetType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -683,15 +974,15 @@
     let value = cstr_to_string(ptr);
     AssetType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `AssetType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn bar_aggregation_to_cstr(value: BarAggregation) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -699,15 +990,15 @@
     let value = cstr_to_string(ptr);
     BarAggregation::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `BarAggregation` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn book_action_to_cstr(value: BookAction) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -715,15 +1006,15 @@
     let value = cstr_to_string(ptr);
     BookAction::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `BookAction` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn book_type_to_cstr(value: BookType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -731,15 +1022,15 @@
     let value = cstr_to_string(ptr);
     BookType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `BookType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn contingency_type_to_cstr(value: ContingencyType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -747,15 +1038,15 @@
     let value = cstr_to_string(ptr);
     ContingencyType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `ContingencyType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn currency_type_to_cstr(value: CurrencyType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -777,20 +1068,20 @@
     InstrumentCloseType::from_str(&value).unwrap_or_else(|_| {
         panic!("invalid `InstrumentCloseType` enum string value, was '{value}'")
     })
 }
 
 #[no_mangle]
 pub extern "C" fn instrument_close_type_to_cstr(value: InstrumentCloseType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 #[no_mangle]
 pub extern "C" fn liquidity_side_to_cstr(value: LiquiditySide) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -798,15 +1089,15 @@
     let value = cstr_to_string(ptr);
     LiquiditySide::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `LiquiditySide` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn market_status_to_cstr(value: MarketStatus) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -814,15 +1105,15 @@
     let value = cstr_to_string(ptr);
     MarketStatus::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `MarketStatus` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn oms_type_to_cstr(value: OmsType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -830,15 +1121,15 @@
     let value = cstr_to_string(ptr);
     OmsType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `OmsType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn option_kind_to_cstr(value: OptionKind) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -846,15 +1137,15 @@
     let value = cstr_to_string(ptr);
     OptionKind::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `OptionKind` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn order_side_to_cstr(value: OrderSide) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -862,15 +1153,15 @@
     let value = cstr_to_string(ptr);
     OrderSide::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `OrderSide` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn order_status_to_cstr(value: OrderStatus) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -878,15 +1169,15 @@
     let value = cstr_to_string(ptr);
     OrderStatus::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `OrderStatus` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn order_type_to_cstr(value: OrderType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -894,15 +1185,15 @@
     let value = cstr_to_string(ptr);
     OrderType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `OrderType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn position_side_to_cstr(value: PositionSide) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -910,15 +1201,15 @@
     let value = cstr_to_string(ptr);
     PositionSide::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `PositionSide` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn price_type_to_cstr(value: PriceType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -926,15 +1217,15 @@
     let value = cstr_to_string(ptr);
     PriceType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `PriceType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn time_in_force_to_cstr(value: TimeInForce) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -942,15 +1233,15 @@
     let value = cstr_to_string(ptr);
     TimeInForce::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `TimeInForce` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn trading_state_to_cstr(value: TradingState) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -958,15 +1249,15 @@
     let value = cstr_to_string(ptr);
     TradingState::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `TradingState` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn trailing_offset_type_to_cstr(value: TrailingOffsetType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
@@ -974,15 +1265,15 @@
     let value = cstr_to_string(ptr);
     TrailingOffsetType::from_str(&value)
         .unwrap_or_else(|_| panic!("invalid `TrailingOffsetType` enum string value, was '{value}'"))
 }
 
 #[no_mangle]
 pub extern "C" fn trigger_type_to_cstr(value: TriggerType) -> *const c_char {
-    str_to_cstr(&value.to_string())
+    str_to_cstr(value.as_ref())
 }
 
 /// Returns an enum from a Python string.
 ///
 /// # Safety
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/events/mod.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/events/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/events/order.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/events/order.rs`

 * *Files 4% similar despite different names*

```diff
@@ -9,29 +9,35 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+use std::collections::HashMap;
+
 use derive_builder::{self, Builder};
 use nautilus_core::{time::UnixNanos, uuid::UUID4};
 use serde::{Deserialize, Serialize};
 
 use crate::{
-    enums::{ContingencyType, LiquiditySide, OrderSide, OrderType, TimeInForce, TriggerType},
+    enums::{
+        ContingencyType, LiquiditySide, OrderSide, OrderType, TimeInForce, TrailingOffsetType,
+        TriggerType,
+    },
     identifiers::{
-        account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
-        order_list_id::OrderListId, position_id::PositionId, strategy_id::StrategyId,
-        trade_id::TradeId, trader_id::TraderId, venue_order_id::VenueOrderId,
+        account_id::AccountId, client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
+        instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
+        strategy_id::StrategyId, trade_id::TradeId, trader_id::TraderId,
+        venue_order_id::VenueOrderId,
     },
     types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
 
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
+#[derive(Clone, PartialEq, Eq, Debug)]
 pub enum OrderEvent {
     OrderInitialized(OrderInitialized),
     OrderDenied(OrderDenied),
     OrderSubmitted(OrderSubmitted),
     OrderAccepted(OrderAccepted),
     OrderRejected(OrderRejected),
     OrderCanceled(OrderCanceled),
@@ -43,15 +49,15 @@
     OrderCancelRejected(OrderCancelRejected),
     OrderUpdated(OrderUpdated),
     OrderPartiallyFilled(OrderFilled),
     OrderFilled(OrderFilled),
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Builder, Serialize, Deserialize)]
+#[derive(Clone, PartialEq, Eq, Debug, Builder, Serialize, Deserialize)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderInitialized {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -65,20 +71,23 @@
     pub expire_time: Option<UnixNanos>,
     pub post_only: bool,
     pub reduce_only: bool,
     pub quote_quantity: bool,
     pub display_qty: Option<Quantity>,
     pub limit_offset: Option<Price>,
     pub trailing_offset: Option<Price>,
-    pub trailing_offset_type: Option<TriggerType>,
+    pub trailing_offset_type: Option<TrailingOffsetType>,
     pub emulation_trigger: Option<TriggerType>,
     pub contingency_type: Option<ContingencyType>,
     pub order_list_id: Option<OrderListId>,
     pub linked_order_ids: Option<Vec<ClientOrderId>>,
     pub parent_order_id: Option<ClientOrderId>,
+    pub exec_algorithm_id: Option<ExecAlgorithmId>,
+    pub exec_algorithm_params: Option<HashMap<String, String>>,
+    pub exec_spawn_id: Option<ClientOrderId>,
     pub tags: Option<String>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
@@ -105,55 +114,58 @@
             trailing_offset: Default::default(),
             trailing_offset_type: Default::default(),
             emulation_trigger: Default::default(),
             contingency_type: Default::default(),
             order_list_id: Default::default(),
             linked_order_ids: Default::default(),
             parent_order_id: Default::default(),
+            exec_algorithm_id: Default::default(),
+            exec_algorithm_params: Default::default(),
+            exec_spawn_id: Default::default(),
             tags: Default::default(),
             event_id: Default::default(),
             ts_event: Default::default(),
             ts_init: Default::default(),
             reconciliation: Default::default(),
         }
     }
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderDenied {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
     pub reason: Box<String>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderSubmitted {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
     pub account_id: AccountId,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderAccepted {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -162,15 +174,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderRejected {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -180,15 +192,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderCanceled {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -197,15 +209,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderExpired {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -214,15 +226,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderTriggered {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -231,15 +243,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderPendingUpdate {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -248,15 +260,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderPendingCancel {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -265,15 +277,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderModifyRejected {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -283,15 +295,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderCancelRejected {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -301,15 +313,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
 #[serde(tag = "type")]
 pub struct OrderUpdated {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
@@ -321,15 +333,15 @@
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Serialize, Deserialize, Builder)]
+#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize, Builder)]
 #[serde(tag = "type")]
 pub struct OrderFilled {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
     pub venue_order_id: VenueOrderId,
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/events/order_api.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/events/order_api.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/events/position.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/events/position.rs`

 * *Files 11% similar despite different names*

```diff
@@ -76,14 +76,41 @@
     pub ts_opened: UnixNanos,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
 }
 
 #[repr(C)]
 #[derive(Clone, PartialEq, Debug)]
+pub struct PositionState {
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub position_id: PositionId,
+    pub account_id: AccountId,
+    pub opening_order_id: ClientOrderId,
+    pub entry: OrderSide,
+    pub side: PositionSide,
+    pub signed_qty: f64,
+    pub quantity: Quantity,
+    pub peak_quantity: Quantity,
+    pub last_qty: Quantity,
+    pub last_px: Price,
+    pub currency: Currency,
+    pub avg_px_open: f64,
+    pub avg_px_closed: f64,
+    pub realized_return: f64,
+    pub realized_pnl: Money,
+    pub unrealized_pnl: Money,
+    pub ts_opened: UnixNanos,
+    pub ts_event: UnixNanos,
+    pub ts_init: UnixNanos,
+}
+
+#[repr(C)]
+#[derive(Clone, PartialEq, Debug)]
 pub struct PositionClosed {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub position_id: PositionId,
     pub account_id: AccountId,
     pub opening_order_id: ClientOrderId,
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/instrument_id.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/instrument_id.rs`

 * *Files 10% similar despite different names*

```diff
@@ -20,32 +20,43 @@
     hash::{Hash, Hasher},
     str::FromStr,
 };
 
 use nautilus_core::string::{cstr_to_string, str_to_cstr};
 use pyo3::prelude::*;
 use serde::{Deserialize, Deserializer, Serialize};
-use thiserror::Error;
+use thiserror;
 
 use crate::identifiers::{symbol::Symbol, venue::Venue};
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Default)]
+#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord, Default)]
 #[pyclass]
 pub struct InstrumentId {
     pub symbol: Symbol,
     pub venue: Venue,
 }
 
-#[derive(Debug, Error)]
+#[derive(thiserror::Error, Debug)]
 #[error("Error parsing `InstrumentId` from '{input}'")]
 pub struct InstrumentIdParseError {
     input: String,
 }
 
+impl InstrumentId {
+    #[must_use]
+    pub fn new(symbol: Symbol, venue: Venue) -> Self {
+        Self { symbol, venue }
+    }
+
+    pub fn is_synthetic(&self) -> bool {
+        self.venue.is_synthetic()
+    }
+}
+
 impl FromStr for InstrumentId {
     type Err = InstrumentIdParseError;
 
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         match s.rsplit_once('.') {
             Some((symbol_part, venue_part)) => Ok(Self {
                 symbol: Symbol::new(symbol_part),
@@ -66,27 +77,20 @@
 
 impl Display for InstrumentId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}.{}", self.symbol, self.venue)
     }
 }
 
-impl InstrumentId {
-    #[must_use]
-    pub fn new(symbol: Symbol, venue: Venue) -> Self {
-        Self { symbol, venue }
-    }
-}
-
 impl Serialize for InstrumentId {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: serde::Serializer,
     {
-        serializer.serialize_str(&format!("{}", self))
+        serializer.serialize_str(&self.to_string())
     }
 }
 
 impl<'de> Deserialize<'de> for InstrumentId {
     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
     where
         D: Deserializer<'de>,
@@ -97,69 +101,60 @@
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 #[no_mangle]
-pub extern "C" fn instrument_id_new(symbol: &Symbol, venue: &Venue) -> InstrumentId {
-    let symbol = symbol.clone();
-    let venue = venue.clone();
+pub extern "C" fn instrument_id_new(symbol: Symbol, venue: Venue) -> InstrumentId {
     InstrumentId::new(symbol, venue)
 }
 
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn instrument_id_new_from_cstr(ptr: *const c_char) -> InstrumentId {
     InstrumentId::from_str(cstr_to_string(ptr).as_str()).unwrap()
 }
 
-#[no_mangle]
-pub extern "C" fn instrument_id_clone(instrument_id: &InstrumentId) -> InstrumentId {
-    instrument_id.clone()
-}
-
-/// Frees the memory for the given `instrument_id` by dropping.
-#[no_mangle]
-pub extern "C" fn instrument_id_drop(instrument_id: InstrumentId) {
-    drop(instrument_id); // Memory freed here
-}
-
 /// Returns an [`InstrumentId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn instrument_id_to_cstr(instrument_id: &InstrumentId) -> *const c_char {
     str_to_cstr(&instrument_id.to_string())
 }
 
 #[no_mangle]
-pub extern "C" fn instrument_id_eq(lhs: &InstrumentId, rhs: &InstrumentId) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
 pub extern "C" fn instrument_id_hash(instrument_id: &InstrumentId) -> u64 {
     let mut h = DefaultHasher::new();
     instrument_id.hash(&mut h);
     h.finish()
 }
 
+#[no_mangle]
+pub extern "C" fn instrument_id_is_synthetic(instrument_id: &InstrumentId) -> u8 {
+    u8::from(instrument_id.is_synthetic())
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use std::{ffi::CStr, str::FromStr};
 
     use super::InstrumentId;
-    use crate::identifiers::instrument_id::{
-        instrument_id_drop, instrument_id_to_cstr, InstrumentIdParseError,
+    use crate::identifiers::{
+        instrument_id::{
+            instrument_id_new_from_cstr, instrument_id_to_cstr, InstrumentIdParseError,
+        },
+        symbol::Symbol,
+        venue::Venue,
     };
 
     #[test]
     fn test_instrument_id_parse_success() {
         let instrument_id = InstrumentId::from_str("ETH/USDT.BINANCE").unwrap();
         assert_eq!(instrument_id.symbol.to_string(), "ETH/USDT");
         assert_eq!(instrument_id.venue.to_string(), "BINANCE");
@@ -189,22 +184,14 @@
         assert_eq!(
             error.to_string(),
             "Error parsing `InstrumentId` from 'ETH.USDT.BINANCE'"
         );
     }
 
     #[test]
-    fn test_equality() {
-        let id1 = InstrumentId::from_str("ETH/USDT.BINANCE").unwrap();
-        let id2 = InstrumentId::from_str("XBT/USD.BITMEX").unwrap();
-        assert_eq!(id1, id1);
-        assert_ne!(id1, id2);
-    }
-
-    #[test]
     fn test_string_reprs() {
         let id = InstrumentId::from_str("ETH/USDT.BINANCE").unwrap();
         assert_eq!(id.to_string(), "ETH/USDT.BINANCE");
         assert_eq!(format!("{id}"), "ETH/USDT.BINANCE");
     }
 
     #[test]
@@ -213,13 +200,26 @@
             let id = InstrumentId::from_str("ETH/USDT.BINANCE").unwrap();
             let result = instrument_id_to_cstr(&id);
             assert_eq!(CStr::from_ptr(result).to_str().unwrap(), "ETH/USDT.BINANCE");
         }
     }
 
     #[test]
-    fn test_instrument_id_drop() {
-        let id = InstrumentId::from_str("ETH/USDT.BINANCE").unwrap();
+    fn test_to_cstr_and_back() {
+        unsafe {
+            let id = InstrumentId::from_str("ETH/USDT.BINANCE").unwrap();
+            let result = instrument_id_to_cstr(&id);
+            let id2 = instrument_id_new_from_cstr(result);
+            assert_eq!(id, id2);
+        }
+    }
 
-        instrument_id_drop(id); // No panic
+    #[test]
+    fn test_from_symbol_and_back() {
+        unsafe {
+            let id = InstrumentId::new(Symbol::new("ETH/USDT"), Venue::new("BINANCE"));
+            let result = instrument_id_to_cstr(&id);
+            let id2 = instrument_id_new_from_cstr(result);
+            assert_eq!(id, id2);
+        }
     }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/macros.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/macros.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/mod.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/mod.rs`

 * *Files 13% similar despite different names*

```diff
@@ -58,7 +58,15 @@
 impl_serialization_for_identifier!(position_id::PositionId);
 impl_serialization_for_identifier!(strategy_id::StrategyId);
 impl_serialization_for_identifier!(symbol::Symbol);
 impl_serialization_for_identifier!(trade_id::TradeId);
 impl_serialization_for_identifier!(trader_id::TraderId);
 impl_serialization_for_identifier!(venue::Venue);
 impl_serialization_for_identifier!(venue_order_id::VenueOrderId);
+
+#[no_mangle]
+pub extern "C" fn interned_string_stats() {
+    dbg!(ustr::total_allocated());
+    dbg!(ustr::total_capacity());
+
+    ustr::string_cache_iter().for_each(|s| println!("{}", s));
+}
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/position_id.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/level_api.rs`

 * *Files 27% similar despite different names*

```diff
@@ -9,118 +9,103 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    collections::hash_map::DefaultHasher,
-    ffi::{c_char, CStr},
-    fmt::{Debug, Display, Formatter},
-    hash::{Hash, Hasher},
-    sync::Arc,
-};
+use std::ops::{Deref, DerefMut};
 
-use nautilus_core::{correctness, string::str_to_cstr};
-use pyo3::prelude::*;
+use nautilus_core::cvec::CVec;
 
+use super::{ladder::BookPrice, level::Level};
+use crate::{data::order::BookOrder, enums::OrderSide, types::price::Price};
+
+/// Provides a C compatible Foreign Function Interface (FFI) for an underlying order book[`Level`].
+///
+/// This struct wraps `Level` in a way that makes it compatible with C function
+/// calls, enabling interaction with `Level` in a C environment.
+///
+/// It implements the `Deref` trait, allowing instances of `Level_API` to be
+/// dereferenced to `Level`, providing access to `Level`'s methods without
+/// having to manually acce wss the underlying `Level` instance.
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq)]
-#[pyclass]
-pub struct PositionId {
-    pub value: Box<Arc<String>>,
-}
+#[derive(Clone)]
+#[allow(non_camel_case_types)]
+pub struct Level_API(Box<Level>);
 
-impl Debug for PositionId {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+impl Level_API {
+    pub fn new(level: Level) -> Self {
+        Self(Box::new(level))
     }
 }
-impl Display for PositionId {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+
+impl Deref for Level_API {
+    type Target = Level;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
     }
 }
 
-impl PositionId {
-    #[must_use]
-    pub fn new(s: &str) -> Self {
-        correctness::valid_string(s, "`PositionId` value");
-
-        Self {
-            value: Box::new(Arc::new(s.to_string())),
-        }
+impl DerefMut for Level_API {
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.0
     }
 }
 
-////////////////////////////////////////////////////////////////////////////////
-// C API
-////////////////////////////////////////////////////////////////////////////////
-/// Returns a Nautilus identifier from a C string pointer.
-///
-/// # Safety
-///
-/// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
-pub unsafe extern "C" fn position_id_new(ptr: *const c_char) -> PositionId {
-    PositionId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
+pub extern "C" fn level_new(order_side: OrderSide, price: Price, orders: CVec) -> Level_API {
+    let CVec { ptr, len, cap } = orders;
+    let orders: Vec<BookOrder> = unsafe { Vec::from_raw_parts(ptr as *mut BookOrder, len, cap) };
+    let price = BookPrice {
+        value: price,
+        side: order_side,
+    };
+    Level_API::new(Level { price, orders })
 }
 
 #[no_mangle]
-pub extern "C" fn position_id_clone(position_id: &PositionId) -> PositionId {
-    position_id.clone()
+pub extern "C" fn level_drop(level: Level_API) {
+    drop(level); // Memory freed here
 }
 
-/// Frees the memory for the given `position_id` by dropping.
 #[no_mangle]
-pub extern "C" fn position_id_drop(position_id: PositionId) {
-    drop(position_id); // Memory freed here
+pub extern "C" fn level_clone(level: &Level_API) -> Level_API {
+    level.clone()
 }
 
-/// Returns a [`PositionId`] identifier as a C string pointer.
 #[no_mangle]
-pub extern "C" fn position_id_to_cstr(position_id: &PositionId) -> *const c_char {
-    str_to_cstr(&position_id.value)
+pub extern "C" fn level_price(level: &Level_API) -> Price {
+    level.price.value
 }
 
 #[no_mangle]
-pub extern "C" fn position_id_eq(lhs: &PositionId, rhs: &PositionId) -> u8 {
-    u8::from(lhs == rhs)
+pub extern "C" fn level_orders(level: &Level_API) -> CVec {
+    level.orders.to_vec().into()
 }
 
 #[no_mangle]
-pub extern "C" fn position_id_hash(position_id: &PositionId) -> u64 {
-    let mut h = DefaultHasher::new();
-    position_id.hash(&mut h);
-    h.finish()
+pub extern "C" fn level_volume(level: &Level_API) -> f64 {
+    level.volume()
 }
 
-////////////////////////////////////////////////////////////////////////////////
-// Tests
-////////////////////////////////////////////////////////////////////////////////
-#[cfg(test)]
-mod tests {
-    use super::PositionId;
-    use crate::identifiers::position_id::position_id_drop;
-
-    #[test]
-    fn test_equality() {
-        let id1 = PositionId::new("P-123456789");
-        let id2 = PositionId::new("P-234567890");
-        assert_eq!(id1, id1);
-        assert_ne!(id1, id2);
-    }
+#[no_mangle]
+pub extern "C" fn level_exposure(level: &Level_API) -> f64 {
+    level.exposure()
+}
 
-    #[test]
-    fn test_string_reprs() {
-        let id = PositionId::new("P-123456789");
-        assert_eq!(id.to_string(), "P-123456789");
-        assert_eq!(format!("{id}"), "P-123456789");
-    }
+#[allow(clippy::drop_non_drop)]
+#[no_mangle]
+pub extern "C" fn vec_levels_drop(v: CVec) {
+    let CVec { ptr, len, cap } = v;
+    let data: Vec<Level> = unsafe { Vec::from_raw_parts(ptr as *mut Level, len, cap) };
+    drop(data); // Memory freed here
+}
 
-    #[test]
-    fn test_position_id_drop() {
-        let id = PositionId::new("001");
-        position_id_drop(id); // No panic
-    }
+#[allow(clippy::drop_non_drop)]
+#[no_mangle]
+pub extern "C" fn vec_orders_drop(v: CVec) {
+    let CVec { ptr, len, cap } = v;
+    let orders: Vec<BookOrder> = unsafe { Vec::from_raw_parts(ptr as *mut BookOrder, len, cap) };
+    drop(orders); // Memory freed here
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/strategy_id.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/trader_id.rs`

 * *Files 23% similar despite different names*

```diff
@@ -12,113 +12,85 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
     ffi::{c_char, CStr},
     fmt::{Debug, Display, Formatter},
-    sync::Arc,
 };
 
-use nautilus_core::{correctness, string::str_to_cstr};
+use nautilus_core::correctness;
 use pyo3::prelude::*;
+use ustr::Ustr;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq)]
+#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[pyclass]
-pub struct StrategyId {
-    pub value: Box<Arc<String>>,
+pub struct TraderId {
+    pub value: Ustr,
 }
 
-impl Debug for StrategyId {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
-    }
-}
+impl TraderId {
+    #[must_use]
+    pub fn new(s: &str) -> Self {
+        correctness::valid_string(s, "`TraderId` value");
+        correctness::string_contains(s, "-", "`TraderId` value");
 
-impl Display for StrategyId {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        Self {
+            value: Ustr::from(s),
+        }
     }
 }
 
-impl Default for StrategyId {
+impl Default for TraderId {
     fn default() -> Self {
         Self {
-            value: Box::new(Arc::new(String::from("S-001"))),
+            value: Ustr::from("TRADER-000"),
         }
     }
 }
 
-impl StrategyId {
-    #[must_use]
-    pub fn new(s: &str) -> Self {
-        correctness::valid_string(s, "`StrategyId` value");
-        if s != "EXTERNAL" {
-            correctness::string_contains(s, "-", "`StrategyId` value");
-        }
+impl Debug for TraderId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
+}
 
-        Self {
-            value: Box::new(Arc::new(s.to_string())),
-        }
+impl Display for TraderId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.value)
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
-pub unsafe extern "C" fn strategy_id_new(ptr: *const c_char) -> StrategyId {
-    StrategyId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
-}
-
-#[no_mangle]
-pub extern "C" fn strategy_id_clone(strategy_id: &StrategyId) -> StrategyId {
-    strategy_id.clone()
-}
-
-/// Frees the memory for the given `strategy_id` by dropping.
-#[no_mangle]
-pub extern "C" fn strategy_id_drop(strategy_id: StrategyId) {
-    drop(strategy_id); // Memory freed here
+pub unsafe extern "C" fn trader_id_new(ptr: *const c_char) -> TraderId {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
+    TraderId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
-/// Returns a [`StrategyId`] as a C string pointer.
 #[no_mangle]
-pub extern "C" fn strategy_id_to_cstr(strategy_id: &StrategyId) -> *const c_char {
-    str_to_cstr(&strategy_id.value)
+pub extern "C" fn trader_id_hash(id: &TraderId) -> u64 {
+    id.value.precomputed_hash()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::StrategyId;
-    use crate::identifiers::strategy_id::strategy_id_drop;
-
-    #[test]
-    fn test_equality() {
-        let id1 = StrategyId::new("EMACross-001");
-        let id2 = StrategyId::new("EMACross-002");
-        assert_eq!(id1, id1);
-        assert_ne!(id1, id2);
-    }
+    use super::TraderId;
 
     #[test]
     fn test_string_reprs() {
-        let id = StrategyId::new("EMACross-001");
-        assert_eq!(id.to_string(), "EMACross-001");
-        assert_eq!(format!("{id}"), "EMACross-001");
-    }
-
-    #[test]
-    fn test_strategy_id_drop() {
-        let id = StrategyId::new("EMACross-001");
-        strategy_id_drop(id); // No panic
+        let trader_id = TraderId::new("TRADER-001");
+        assert_eq!(trader_id.to_string(), "TRADER-001");
+        assert_eq!(format!("{trader_id}"), "TRADER-001");
     }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/symbol.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/symbol.rs`

 * *Files 22% similar despite different names*

```diff
@@ -10,126 +10,87 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
-    collections::hash_map::DefaultHasher,
     ffi::{c_char, CStr},
     fmt::{Debug, Display, Formatter},
-    hash::{Hash, Hasher},
-    sync::Arc,
+    hash::Hash,
 };
 
-use nautilus_core::{correctness, string::str_to_cstr};
+use nautilus_core::correctness;
 use pyo3::prelude::*;
+use ustr::Ustr;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq)]
+#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[pyclass]
 pub struct Symbol {
-    pub value: Box<Arc<String>>,
+    pub value: Ustr,
 }
 
-impl Debug for Symbol {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
-    }
-}
+impl Symbol {
+    #[must_use]
+    pub fn new(s: &str) -> Self {
+        correctness::valid_string(s, "`Symbol` value");
 
-impl Display for Symbol {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        Self {
+            value: Ustr::from(s),
+        }
     }
 }
 
 impl Default for Symbol {
     fn default() -> Self {
         Self {
-            value: Box::new(Arc::new(String::from("AUD/USD"))),
+            value: Ustr::from("AUD/USD"),
         }
     }
 }
 
-impl Symbol {
-    #[must_use]
-    pub fn new(s: &str) -> Self {
-        correctness::valid_string(s, "`Symbol` value");
+impl Debug for Symbol {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
+}
 
-        Self {
-            value: Box::new(Arc::new(s.to_string())),
-        }
+impl Display for Symbol {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.value)
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn symbol_new(ptr: *const c_char) -> Symbol {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
     Symbol::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
-pub extern "C" fn symbol_clone(symbol: &Symbol) -> Symbol {
-    symbol.clone()
-}
-
-/// Frees the memory for the given [Symbol] by dropping.
-#[no_mangle]
-pub extern "C" fn symbol_drop(symbol: Symbol) {
-    drop(symbol); // Memory freed here
-}
-
-/// Returns a [`Symbol`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn symbol_to_cstr(symbol: &Symbol) -> *const c_char {
-    str_to_cstr(&symbol.value)
-}
-
-#[no_mangle]
-pub extern "C" fn symbol_eq(lhs: &Symbol, rhs: &Symbol) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn symbol_hash(symbol: &Symbol) -> u64 {
-    let mut h = DefaultHasher::new();
-    symbol.hash(&mut h);
-    h.finish()
+pub extern "C" fn symbol_hash(id: &Symbol) -> u64 {
+    id.value.precomputed_hash()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use super::Symbol;
-    use crate::identifiers::symbol::symbol_drop;
-
-    #[test]
-    fn test_equality() {
-        let symbol1 = Symbol::new("XRD/USD");
-        let symbol2 = Symbol::new("BTC/USD");
-        assert_eq!(symbol1, symbol1);
-        assert_ne!(symbol1, symbol2);
-    }
 
     #[test]
     fn test_string_reprs() {
         let symbol = Symbol::new("ETH-PERP");
         assert_eq!(symbol.to_string(), "ETH-PERP");
         assert_eq!(format!("{symbol}"), "ETH-PERP");
     }
-
-    #[test]
-    fn test_symbol_drop() {
-        let id = Symbol::new("ETH-PERP");
-        symbol_drop(id); // No panic
-    }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/trade_id.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/client_id.rs`

 * *Files 21% similar despite different names*

```diff
@@ -10,118 +10,96 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
-    collections::hash_map::DefaultHasher,
     ffi::{c_char, CStr},
     fmt::{Debug, Display, Formatter},
-    hash::{Hash, Hasher},
-    sync::Arc,
+    hash::Hash,
 };
 
-use nautilus_core::{correctness, string::str_to_cstr};
+use nautilus_core::correctness;
 use pyo3::prelude::*;
+use ustr::Ustr;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq)]
+#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[pyclass]
-pub struct TradeId {
-    pub value: Box<Arc<String>>,
+pub struct ClientId {
+    pub value: Ustr,
 }
 
-impl Debug for TradeId {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+impl ClientId {
+    #[must_use]
+    pub fn new(s: &str) -> Self {
+        correctness::valid_string(s, "`ClientId` value");
+
+        Self {
+            value: Ustr::from(s),
+        }
     }
 }
 
-impl Display for TradeId {
+impl Debug for ClientId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+        write!(f, "{:?}", self.value)
     }
 }
 
-impl TradeId {
-    #[must_use]
-    pub fn new(s: &str) -> Self {
-        correctness::valid_string(s, "`TradeId` value");
-
-        Self {
-            value: Box::new(Arc::new(s.to_string())),
-        }
+impl Display for ClientId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.value)
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
-/// Returns a Nautilus identifier from a C string pointer.
+/// Returns a Nautilus identifier from C string pointer.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
-pub unsafe extern "C" fn trade_id_new(ptr: *const c_char) -> TradeId {
-    TradeId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
-}
-
-#[no_mangle]
-pub extern "C" fn trade_id_clone(trade_id: &TradeId) -> TradeId {
-    trade_id.clone()
+pub unsafe extern "C" fn client_id_new(ptr: *const c_char) -> ClientId {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
+    ClientId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
-/// Frees the memory for the given `trade_id` by dropping.
 #[no_mangle]
-pub extern "C" fn trade_id_drop(trade_id: TradeId) {
-    drop(trade_id); // Memory freed here
-}
-
-/// Returns [`TradeId`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn trade_id_to_cstr(trade_id: &TradeId) -> *const c_char {
-    str_to_cstr(&trade_id.value)
-}
-
-#[no_mangle]
-pub extern "C" fn trade_id_eq(lhs: &TradeId, rhs: &TradeId) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn trade_id_hash(trade_id: &TradeId) -> u64 {
-    let mut h = DefaultHasher::new();
-    trade_id.hash(&mut h);
-    h.finish()
+pub extern "C" fn client_id_hash(id: &ClientId) -> u64 {
+    id.value.precomputed_hash()
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::TradeId;
-    use crate::identifiers::trade_id::trade_id_drop;
+    use super::*;
 
     #[test]
-    fn test_equality() {
-        let trade_id1 = TradeId::new("123456789");
-        let trade_id2 = TradeId::new("234567890");
-        assert_eq!(trade_id1, trade_id1);
-        assert_ne!(trade_id1, trade_id2);
+    fn test_string_reprs() {
+        let id = ClientId::new("BINANCE");
+        assert_eq!(id.to_string(), "BINANCE");
+        assert_eq!(format!("{id}"), "BINANCE");
     }
 
     #[test]
-    fn test_string_reprs() {
-        let trade_id = TradeId::new("1234567890");
-        assert_eq!(trade_id.to_string(), "1234567890");
-        assert_eq!(format!("{trade_id}"), "1234567890");
+    fn test_client_id_to_cstr_c() {
+        let id = ClientId::new("BINANCE");
+        let c_string = id.value.as_char_ptr();
+        let rust_string = unsafe { CStr::from_ptr(c_string) }.to_str().unwrap();
+        assert_eq!(rust_string, "BINANCE");
     }
 
     #[test]
-    fn test_trade_id_drop() {
-        let id = TradeId::new("123456789");
-        trade_id_drop(id); // No panic
+    fn test_client_id_hash_c() {
+        let id1 = ClientId::new("BINANCE");
+        let id2 = ClientId::new("BINANCE");
+        let id3 = ClientId::new("DYDX");
+        assert_eq!(client_id_hash(&id1), client_id_hash(&id2));
+        assert_ne!(client_id_hash(&id1), client_id_hash(&id3));
     }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/venue.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/identifiers/venue.rs`

 * *Files 22% similar despite different names*

```diff
@@ -10,126 +10,103 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
-    collections::hash_map::DefaultHasher,
     ffi::{c_char, CStr},
     fmt::{Debug, Display, Formatter},
-    hash::{Hash, Hasher},
-    sync::Arc,
+    hash::Hash,
 };
 
-use nautilus_core::{correctness, string::str_to_cstr};
+use nautilus_core::correctness;
 use pyo3::prelude::*;
+use ustr::Ustr;
+
+pub const SYNTHETIC_VENUE: &str = "SYNTH";
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq)]
+#[derive(Clone, Copy, Hash, PartialEq, Eq, PartialOrd, Ord)]
 #[pyclass]
 pub struct Venue {
-    pub value: Box<Arc<String>>,
+    pub value: Ustr,
 }
 
-impl Debug for Venue {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{:?}", self.value)
+impl Venue {
+    #[must_use]
+    pub fn new(s: &str) -> Self {
+        correctness::valid_string(s, "`Venue` value");
+
+        Self {
+            value: Ustr::from(s),
+        }
     }
-}
 
-impl Display for Venue {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "{}", self.value)
+    #[must_use]
+    pub fn synthetic() -> Self {
+        Self::new(SYNTHETIC_VENUE)
+    }
+
+    pub fn is_synthetic(&self) -> bool {
+        self.value.as_str() == SYNTHETIC_VENUE
     }
 }
 
 impl Default for Venue {
     fn default() -> Self {
         Self {
-            value: Box::new(Arc::new(String::from("SIM"))),
+            value: Ustr::from("SIM"),
         }
     }
 }
 
-impl Venue {
-    #[must_use]
-    pub fn new(s: &str) -> Self {
-        correctness::valid_string(s, "`Venue` value");
+impl Debug for Venue {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
+}
 
-        Self {
-            value: Box::new(Arc::new(s.to_string())),
-        }
+impl Display for Venue {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{}", self.value)
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
 ///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn venue_new(ptr: *const c_char) -> Venue {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
     Venue::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
-pub extern "C" fn venue_clone(venue: &Venue) -> Venue {
-    venue.clone()
-}
-
-/// Frees the memory for the given `venue` by dropping.
-#[no_mangle]
-pub extern "C" fn venue_drop(venue: Venue) {
-    drop(venue); // Memory freed here
+pub extern "C" fn venue_hash(id: &Venue) -> u64 {
+    id.value.precomputed_hash()
 }
 
-/// Returns a [`Venue`] identifier as a C string pointer.
 #[no_mangle]
-pub extern "C" fn venue_to_cstr(venue: &Venue) -> *const c_char {
-    str_to_cstr(&venue.value)
-}
-
-#[no_mangle]
-pub extern "C" fn venue_eq(lhs: &Venue, rhs: &Venue) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn venue_hash(venue: &Venue) -> u64 {
-    let mut h = DefaultHasher::new();
-    venue.hash(&mut h);
-    h.finish()
+pub extern "C" fn venue_is_synthetic(venue: &Venue) -> u8 {
+    u8::from(venue.is_synthetic())
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use super::Venue;
-    use crate::identifiers::venue::venue_drop;
-
-    #[test]
-    fn test_equality() {
-        let venue1 = Venue::new("BINANCE");
-        let venue2 = Venue::new("IDEALPRO");
-        assert_eq!(venue1, venue1);
-        assert_ne!(venue1, venue2);
-    }
 
     #[test]
     fn test_string_reprs() {
         let venue = Venue::new("BINANCE");
         assert_eq!(venue.to_string(), "BINANCE");
         assert_eq!(format!("{venue}"), "BINANCE");
     }
-
-    #[test]
-    fn test_venue_drop() {
-        let id = Venue::new("BINANCE");
-        venue_drop(id); // No panic
-    }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/instruments/mod.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/types/balance.rs`

 * *Files 26% similar despite different names*

```diff
@@ -9,42 +9,27 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-mod synthetic;
-mod synthetic_api;
+use std::fmt::{Display, Formatter};
 
-use rust_decimal::Decimal;
+use crate::types::{currency::Currency, money::Money};
 
-use crate::{
-    enums::{AssetClass, AssetType},
-    identifiers::{instrument_id::InstrumentId, symbol::Symbol},
-    types::{currency::Currency, price::Price, quantity::Quantity},
-};
+pub struct AccountBalance {
+    pub currency: Currency,
+    pub total: Money,
+    pub locked: Money,
+    pub free: Money,
+}
 
-pub struct Instrument {
-    pub id: InstrumentId,
-    pub native_symbol: Symbol,
-    pub asset_class: AssetClass,
-    pub asset_type: AssetType,
-    pub quote_currency: Currency,
-    pub base_currency: Option<Currency>,
-    pub cost_currency: Currency,
-    pub is_inverse: bool,
-    pub price_precision: u8,
-    pub size_precision: u8,
-    pub price_increment: Price,
-    pub size_increment: Quantity,
-    pub multiplier: Quantity,
-    pub lot_size: Option<Quantity>,
-    pub max_quantity: Option<Quantity>,
-    pub min_quantity: Option<Quantity>,
-    pub max_price: Option<Price>,
-    pub min_price: Option<Price>,
-    pub margin_init: Decimal,
-    pub margin_maint: Decimal,
-    pub maker_fee: Decimal,
-    pub taker_fee: Decimal,
+impl Display for AccountBalance {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(
+            f,
+            "{} {} {} {}",
+            self.currency.code, self.total, self.locked, self.free,
+        )
+    }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/instruments/synthetic.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/instruments/synthetic.rs`

 * *Files 21% similar despite different names*

```diff
@@ -9,83 +9,97 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::HashMap;
+use std::{
+    collections::HashMap,
+    hash::{Hash, Hasher},
+};
 
+use anyhow;
 use evalexpr::{ContextWithMutableVariables, HashMapContext, Node, Value};
+use nautilus_core::time::UnixNanos;
+use pyo3::prelude::*;
 
 use crate::{
     identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue},
     types::price::Price,
 };
 
-pub const SYNTHETIC_VENUE: &str = "SYNTH";
-
 /// Represents a synthetic instrument with prices derived from component instruments using a
 /// formula.
+#[derive(Clone, Debug)]
+#[pyclass]
 pub struct SyntheticInstrument {
     pub id: InstrumentId,
-    pub precision: u8,
+    pub price_precision: u8,
+    pub price_increment: Price,
     pub components: Vec<InstrumentId>,
     pub formula: String,
-    pub variables: Vec<String>,
     pub context: HashMapContext,
+    pub ts_event: UnixNanos,
+    pub ts_init: UnixNanos,
+    variables: Vec<String>,
     operator_tree: Node,
 }
 
 impl SyntheticInstrument {
     pub fn new(
         symbol: Symbol,
-        precision: u8,
+        price_precision: u8,
         components: Vec<InstrumentId>,
         formula: String,
-    ) -> Result<Self, Box<dyn std::error::Error>> {
-        let context = HashMapContext::new();
+        ts_event: UnixNanos,
+        ts_init: UnixNanos,
+    ) -> Result<Self, anyhow::Error> {
+        let price_increment = Price::new(10f64.powi(-i32::from(price_precision)), price_precision);
 
         // Extract variables from the component instruments
         let variables: Vec<String> = components
             .iter()
             .map(|component| component.to_string())
             .collect();
 
         let operator_tree = evalexpr::build_operator_tree(&formula)?;
 
         Ok(SyntheticInstrument {
-            id: InstrumentId::new(symbol, Venue::new(SYNTHETIC_VENUE)),
-            precision,
+            id: InstrumentId::new(symbol, Venue::synthetic()),
+            price_precision,
+            price_increment,
             components,
             formula,
+            context: HashMapContext::new(),
             variables,
-            context,
             operator_tree,
+            ts_event,
+            ts_init,
         })
     }
 
     pub fn is_valid_formula(&self, formula: &str) -> bool {
         evalexpr::build_operator_tree(formula).is_ok()
     }
 
-    pub fn change_formula(&mut self, formula: String) -> Result<(), Box<dyn std::error::Error>> {
+    pub fn change_formula(&mut self, formula: String) -> Result<(), anyhow::Error> {
         let operator_tree = evalexpr::build_operator_tree(&formula)?;
         self.formula = formula;
         self.operator_tree = operator_tree;
         Ok(())
     }
 
     /// Calculates the price of the synthetic instrument based on the given component input prices
     /// provided as a map.
     #[allow(dead_code)]
     pub fn calculate_from_map(
         &mut self,
         inputs: &HashMap<String, f64>,
-    ) -> Result<Price, Box<dyn std::error::Error>> {
+    ) -> Result<Price, anyhow::Error> {
         let mut input_values = Vec::new();
 
         for variable in &self.variables {
             if let Some(&value) = inputs.get(variable) {
                 input_values.push(value);
                 self.context
                     .set_value(variable.clone(), Value::from(value))?;
@@ -95,33 +109,49 @@
         }
 
         self.calculate(&input_values)
     }
 
     /// Calculates the price of the synthetic instrument based on the given component input prices
     /// provided as an array of `f64` values.
-    pub fn calculate(&mut self, inputs: &[f64]) -> Result<Price, Box<dyn std::error::Error>> {
+    pub fn calculate(&mut self, inputs: &[f64]) -> Result<Price, anyhow::Error> {
         if inputs.len() != self.variables.len() {
-            return Err("Invalid number of input values".into());
+            return Err(anyhow::anyhow!("Invalid number of input values"));
         }
 
         for (variable, input) in self.variables.iter().zip(inputs) {
             self.context
                 .set_value(variable.clone(), Value::from(*input))?;
         }
 
         let result: Value = self.operator_tree.eval_with_context(&self.context)?;
 
         match result {
-            Value::Float(price) => Ok(Price::new(price, self.precision)),
-            _ => Err("Failed to evaluate formula to a floating point number".into()),
+            Value::Float(price) => Ok(Price::new(price, self.price_precision)),
+            _ => Err(anyhow::anyhow!(
+                "Failed to evaluate formula to a floating point number"
+            )),
         }
     }
 }
 
+impl PartialEq<Self> for SyntheticInstrument {
+    fn eq(&self, other: &Self) -> bool {
+        self.id == other.id
+    }
+}
+
+impl Eq for SyntheticInstrument {}
+
+impl Hash for SyntheticInstrument {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        self.id.hash(state);
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use std::str::FromStr;
 
     use super::*;
     use crate::identifiers::{instrument_id::InstrumentId, symbol::Symbol};
 
@@ -131,14 +161,16 @@
         let ltc_binance = InstrumentId::from_str("LTC.BINANCE").unwrap();
         let formula = "(BTC.BINANCE + LTC.BINANCE) / 2".to_string();
         let mut synth = SyntheticInstrument::new(
             Symbol::new("BTC-LTC"),
             2,
             vec![btc_binance.clone(), ltc_binance],
             formula.clone(),
+            0,
+            0,
         )
         .unwrap();
 
         let mut inputs = HashMap::new();
         inputs.insert("BTC.BINANCE".to_string(), 100.0);
         inputs.insert("LTC.BINANCE".to_string(), 200.0);
 
@@ -154,14 +186,16 @@
         let ltc_binance = InstrumentId::from_str("LTC.BINANCE").unwrap();
         let formula = "(BTC.BINANCE + LTC.BINANCE) / 2.0".to_string();
         let mut synth = SyntheticInstrument::new(
             Symbol::new("BTC-LTC"),
             2,
             vec![btc_binance.clone(), ltc_binance],
             formula.clone(),
+            0,
+            0,
         )
         .unwrap();
 
         let inputs = vec![100.0, 200.0];
         let price = synth.calculate(&inputs).unwrap();
 
         assert_eq!(price.as_f64(), 150.0);
@@ -174,14 +208,16 @@
         let ltc_binance = InstrumentId::from_str("LTC.BINANCE").unwrap();
         let formula = "(BTC.BINANCE + LTC.BINANCE) / 2".to_string();
         let mut synth = SyntheticInstrument::new(
             Symbol::new("BTC-LTC"),
             2,
             vec![btc_binance, ltc_binance],
             formula.clone(),
+            0,
+            0,
         )
         .unwrap();
 
         let new_formula = "(BTC.BINANCE + LTC.BINANCE) / 4".to_string();
         synth.change_formula(new_formula.clone()).unwrap();
 
         let mut inputs = HashMap::new();
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/instruments/synthetic_api.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/instruments/synthetic_api.rs`

 * *Files 23% similar despite different names*

```diff
@@ -19,20 +19,21 @@
     str::FromStr,
 };
 
 use nautilus_core::{
     cvec::CVec,
     parsing::{bytes_to_string_vec, string_vec_to_bytes},
     string::{cstr_to_string, str_to_cstr},
+    time::UnixNanos,
 };
 
 use super::synthetic::SyntheticInstrument;
 use crate::{
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
-    types::price::Price,
+    types::price::{Price, ERROR_PRICE},
 };
 
 /// Provides a C compatible Foreign Function Interface (FFI) for an underlying
 /// [`SyntheticInstrument`].
 ///
 /// This struct wraps `SyntheticInstrument` in a way that makes it compatible with C function
 /// calls, enabling interaction with `SyntheticInstrument` in a C environment.
@@ -61,42 +62,56 @@
 /// # Safety
 ///
 /// - Assumes `components_ptr` is a valid C string pointer of a JSON format list of strings.
 /// - Assumes `formula_ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn synthetic_instrument_new(
     symbol: Symbol,
-    precision: u8,
+    price_precision: u8,
     components_ptr: *const c_char,
     formula_ptr: *const c_char,
+    ts_event: u64,
+    ts_init: u64,
 ) -> SyntheticInstrument_API {
     // TODO: There is absolutely no error handling here yet
     let components = bytes_to_string_vec(components_ptr)
         .into_iter()
         .map(|s| InstrumentId::from_str(&s).unwrap())
         .collect::<Vec<InstrumentId>>();
     let formula = cstr_to_string(formula_ptr);
-    let synth = SyntheticInstrument::new(symbol, precision, components, formula);
+    let synth = SyntheticInstrument::new(
+        symbol,
+        price_precision,
+        components,
+        formula,
+        ts_event,
+        ts_init,
+    );
 
     SyntheticInstrument_API(Box::new(synth.unwrap()))
 }
 
 #[no_mangle]
 pub extern "C" fn synthetic_instrument_drop(synth: SyntheticInstrument_API) {
     drop(synth); // Memory freed here
 }
 
 #[no_mangle]
 pub extern "C" fn synthetic_instrument_id(synth: &SyntheticInstrument_API) -> InstrumentId {
-    synth.id.clone()
+    synth.id
 }
 
 #[no_mangle]
-pub extern "C" fn synthetic_instrument_precision(synth: &SyntheticInstrument_API) -> u8 {
-    synth.precision
+pub extern "C" fn synthetic_instrument_price_precision(synth: &SyntheticInstrument_API) -> u8 {
+    synth.price_precision
+}
+
+#[no_mangle]
+pub extern "C" fn synthetic_instrument_price_increment(synth: &SyntheticInstrument_API) -> Price {
+    synth.price_increment
 }
 
 #[no_mangle]
 pub extern "C" fn synthetic_instrument_formula_to_cstr(
     synth: &SyntheticInstrument_API,
 ) -> *const c_char {
     str_to_cstr(&synth.formula)
@@ -111,24 +126,42 @@
         .iter()
         .map(|c| c.to_string())
         .collect::<Vec<String>>();
 
     string_vec_to_bytes(components_vec)
 }
 
+#[no_mangle]
+pub extern "C" fn synthetic_instrument_components_count(synth: &SyntheticInstrument_API) -> usize {
+    synth.components.len()
+}
+
+#[no_mangle]
+pub extern "C" fn synthetic_instrument_ts_event(synth: &SyntheticInstrument_API) -> UnixNanos {
+    synth.ts_event
+}
+
+#[no_mangle]
+pub extern "C" fn synthetic_instrument_ts_init(synth: &SyntheticInstrument_API) -> UnixNanos {
+    synth.ts_init
+}
+
 /// # Safety
 ///
 /// - Assumes `formula_ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn synthetic_instrument_is_valid_formula(
     synth: &SyntheticInstrument_API,
     formula_ptr: *const c_char,
 ) -> u8 {
+    if formula_ptr.is_null() {
+        return false as u8;
+    }
     let formula = cstr_to_string(formula_ptr);
-    synth.is_valid_formula(&formula) as u8
+    u8::from(synth.is_valid_formula(&formula))
 }
 
 /// # Safety
 ///
 /// - Assumes `formula_ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn synthetic_instrument_change_formula(
@@ -144,10 +177,12 @@
 pub extern "C" fn synthetic_instrument_calculate(
     synth: &mut SyntheticInstrument_API,
     inputs_ptr: &CVec,
 ) -> Price {
     let CVec { ptr, len, .. } = inputs_ptr;
     let inputs: &[f64] = unsafe { std::slice::from_raw_parts(*ptr as *mut f64, *len) };
 
-    // TODO: There is absolutely no error handling here yet
-    synth.calculate(inputs).unwrap()
+    match synth.calculate(inputs) {
+        Ok(price) => price,
+        Err(_) => ERROR_PRICE,
+    }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/lib.rs`

 * *Files 17% similar despite different names*

```diff
@@ -21,22 +21,30 @@
 
 pub mod currencies;
 pub mod data;
 pub mod enums;
 pub mod events;
 pub mod identifiers;
 pub mod instruments;
+pub mod macros;
 pub mod orderbook;
 pub mod orders;
 pub mod position;
 pub mod types;
 
 /// Loaded as nautilus_pyo3.model
 #[pymodule]
 pub fn model(_: Python<'_>, m: &PyModule) -> PyResult<()> {
+    m.add_class::<data::bar::BarSpecification>()?;
+    m.add_class::<data::bar::BarType>()?;
+    m.add_class::<data::bar::Bar>()?;
+    m.add_class::<data::order::BookOrder>()?;
+    m.add_class::<data::delta::OrderBookDelta>()?;
+    m.add_class::<data::quote::QuoteTick>()?;
+    m.add_class::<data::trade::TradeTick>()?;
     m.add_class::<enums::AccountType>()?;
     m.add_class::<enums::AggregationSource>()?;
     m.add_class::<enums::BarAggregation>()?;
     m.add_class::<enums::PriceType>()?;
     m.add_class::<identifiers::account_id::AccountId>()?;
     m.add_class::<identifiers::client_id::ClientId>()?;
     m.add_class::<identifiers::client_order_id::ClientOrderId>()?;
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/book.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/book.rs`

 * *Files 8% similar despite different names*

```diff
@@ -14,18 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 use tabled::{settings::Style, Table, Tabled};
 use thiserror::Error;
 
 use super::{ladder::BookPrice, level::Level};
 use crate::{
-    data::{
-        book::{BookOrder, OrderBookDelta},
-        tick::{QuoteTick, TradeTick},
-    },
+    data::{delta::OrderBookDelta, order::BookOrder, quote::QuoteTick, trade::TradeTick},
     enums::{BookAction, BookType, OrderSide},
     identifiers::instrument_id::InstrumentId,
     orderbook::ladder::Ladder,
     types::{price::Price, quantity::Quantity},
 };
 
 pub struct OrderBook {
@@ -34,15 +31,15 @@
     pub instrument_id: InstrumentId,
     pub book_type: BookType,
     pub sequence: u64,
     pub ts_last: u64,
     pub count: u64,
 }
 
-#[derive(Error, Debug)]
+#[derive(thiserror::Error, Debug)]
 pub enum InvalidBookOperation {
     #[error("Invalid book operation: cannot pre-process order for {0} book")]
     PreProcessOrder(BookType),
     #[error("Invalid book operation: cannot add for {0} book")]
     Add(BookType),
 }
 
@@ -161,14 +158,22 @@
             BookAction::Add => self.add(delta.order, delta.ts_event, delta.sequence),
             BookAction::Update => self.update(delta.order, delta.ts_event, delta.sequence),
             BookAction::Delete => self.delete(delta.order, delta.ts_event, delta.sequence),
             BookAction::Clear => self.clear(delta.ts_event, delta.sequence),
         }
     }
 
+    pub fn bids(&self) -> Vec<&Level> {
+        self.bids.levels.values().collect()
+    }
+
+    pub fn asks(&self) -> Vec<&Level> {
+        self.asks.levels.values().collect()
+    }
+
     pub fn has_bid(&self) -> bool {
         match self.bids.top() {
             Some(top) => !top.orders.is_empty(),
             None => false,
         }
     }
 
@@ -211,14 +216,40 @@
     pub fn midpoint(&self) -> Option<f64> {
         match (self.best_ask_price(), self.best_bid_price()) {
             (Some(ask), Some(bid)) => Some((ask.as_f64() + bid.as_f64()) / 2.0),
             _ => None,
         }
     }
 
+    pub fn get_avg_px_for_quantity(&self, qty: Quantity, order_side: OrderSide) -> f64 {
+        let levels = match order_side {
+            OrderSide::Buy => &self.asks.levels,
+            OrderSide::Sell => &self.bids.levels,
+            _ => panic!("Invalid `OrderSide` {}", order_side),
+        };
+        let mut cumulative_volume_raw = 0u64;
+        let mut cumulative_value = 0.0;
+
+        for (book_price, level) in levels {
+            let volume_this_level = level.volume_raw().min(qty.raw - cumulative_volume_raw);
+            cumulative_volume_raw += volume_this_level;
+            cumulative_value += book_price.value.as_f64() * volume_this_level as f64;
+
+            if cumulative_volume_raw >= qty.raw {
+                break;
+            }
+        }
+
+        if cumulative_volume_raw == 0 {
+            0.0
+        } else {
+            cumulative_value / cumulative_volume_raw as f64
+        }
+    }
+
     pub fn update_quote_tick(&mut self, tick: &QuoteTick) {
         self.update_bid(BookOrder::from_quote_tick(tick, OrderSide::Buy));
         self.update_ask(BookOrder::from_quote_tick(tick, OrderSide::Sell));
     }
 
     pub fn update_trade_tick(&mut self, tick: &TradeTick) {
         self.update_bid(BookOrder::from_trade_tick(tick, OrderSide::Buy));
@@ -238,18 +269,15 @@
             self.asks.levels.iter().take(num_levels).collect();
 
         let bid_levels: Vec<(&BookPrice, &Level)> =
             self.bids.levels.iter().take(num_levels).collect();
 
         ask_levels.reverse();
 
-        let levels: Vec<(&BookPrice, &Level)> = ask_levels
-            .into_iter()
-            .chain(bid_levels.into_iter())
-            .collect();
+        let levels: Vec<(&BookPrice, &Level)> = ask_levels.into_iter().chain(bid_levels).collect();
 
         let data: Vec<OrderLevelDisplay> = levels
             .iter()
             .map(|(_, level)| {
                 let bid_sizes: Vec<String> = level
                     .orders
                     .iter()
@@ -438,15 +466,15 @@
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use std::str::FromStr;
 
     use super::*;
     use crate::{
-        data::book::BookOrder,
+        data::order::BookOrder,
         enums::{AggressorSide, OrderSide},
         identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
         types::{price::Price, quantity::Quantity},
     };
 
     fn create_stub_book(book_type: BookType) -> OrderBook {
         let instrument_id = InstrumentId::from_str("ETHUSDT-PERP.BINANCE").unwrap();
@@ -575,14 +603,69 @@
         book.add(bid1.clone(), 100, 1);
         book.add(ask1.clone(), 200, 2);
 
         assert_eq!(book.midpoint(), Some(1.5));
     }
 
     #[test]
+    fn test_get_price_for_quantity_no_market() {
+        let book = create_stub_book(BookType::L2_MBP);
+        let qty = Quantity::new(1.0, 0);
+
+        assert_eq!(book.get_avg_px_for_quantity(qty, OrderSide::Buy), 0.0);
+        assert_eq!(book.get_avg_px_for_quantity(qty, OrderSide::Sell), 0.0);
+    }
+
+    #[test]
+    fn test_get_price_for_quantity() {
+        let instrument_id = InstrumentId::from_str("ETHUSDT-PERP.BINANCE").unwrap();
+        let mut book = OrderBook::new(instrument_id, BookType::L2_MBP);
+
+        let ask2 = BookOrder::new(
+            OrderSide::Sell,
+            Price::from("2.010"),
+            Quantity::from("2.0"),
+            0, // order_id not applicable
+        );
+        let ask1 = BookOrder::new(
+            OrderSide::Sell,
+            Price::from("2.000"),
+            Quantity::from("1.0"),
+            0, // order_id not applicable
+        );
+        let bid1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::from("1.000"),
+            Quantity::from("1.0"),
+            0, // order_id not applicable
+        );
+        let bid2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::from("0.990"),
+            Quantity::from("2.0"),
+            0, // order_id not applicable
+        );
+        book.add(bid1.clone(), 0, 1);
+        book.add(bid2.clone(), 0, 1);
+        book.add(ask1.clone(), 0, 1);
+        book.add(ask2.clone(), 0, 1);
+
+        let qty = Quantity::from("1.5");
+
+        assert_eq!(
+            book.get_avg_px_for_quantity(qty, OrderSide::Buy),
+            2.0033333333333334
+        );
+        assert_eq!(
+            book.get_avg_px_for_quantity(qty, OrderSide::Sell),
+            0.9966666666666667
+        );
+    }
+
+    #[test]
     fn test_update_quote_tick_l1() {
         let instrument_id = InstrumentId::from_str("ETHUSDT-PERP.BINANCE").unwrap();
         let mut book = OrderBook::new(instrument_id.clone(), BookType::L1_TBBO);
         let tick = QuoteTick::new(
             InstrumentId::from_str("ETHUSDT-PERP.BINANCE").unwrap(),
             Price::new(5000.0, 3),
             Price::new(5100.0, 3),
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/book_api.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/book_api.rs`

 * *Files 6% similar despite different names*

```diff
@@ -16,21 +16,18 @@
 use std::{
     ffi::c_char,
     ops::{Deref, DerefMut},
 };
 
 use nautilus_core::{cvec::CVec, string::str_to_cstr};
 
-use super::book::OrderBook;
+use super::{book::OrderBook, level_api::Level_API};
 use crate::{
-    data::{
-        book::{BookOrder, OrderBookDelta},
-        tick::{QuoteTick, TradeTick},
-    },
-    enums::BookType,
+    data::{delta::OrderBookDelta, order::BookOrder, quote::QuoteTick, trade::TradeTick},
+    enums::{BookType, OrderSide},
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
 };
 
 /// Provides a C compatible Foreign Function Interface (FFI) for an underlying [`OrderBook`].
 ///
 /// This struct wraps `OrderBook` in a way that makes it compatible with C function
@@ -70,15 +67,15 @@
 #[no_mangle]
 pub extern "C" fn orderbook_reset(book: &mut OrderBook_API) {
     book.reset()
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_instrument_id(book: &OrderBook_API) -> InstrumentId {
-    book.instrument_id.clone()
+    book.instrument_id
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_book_type(book: &OrderBook_API) -> BookType {
     book.book_type
 }
 
@@ -144,14 +141,32 @@
 
 #[no_mangle]
 pub extern "C" fn orderbook_apply_delta(book: &mut OrderBook_API, delta: OrderBookDelta) {
     book.apply_delta(delta)
 }
 
 #[no_mangle]
+pub extern "C" fn orderbook_bids(book: &mut OrderBook_API) -> CVec {
+    book.bids()
+        .iter()
+        .map(|l| Level_API::new(l.to_owned().clone()))
+        .collect::<Vec<Level_API>>()
+        .into()
+}
+
+#[no_mangle]
+pub extern "C" fn orderbook_asks(book: &mut OrderBook_API) -> CVec {
+    book.asks()
+        .iter()
+        .map(|l| Level_API::new(l.to_owned().clone()))
+        .collect::<Vec<Level_API>>()
+        .into()
+}
+
+#[no_mangle]
 pub extern "C" fn orderbook_has_bid(book: &mut OrderBook_API) -> u8 {
     book.has_bid() as u8
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_has_ask(book: &mut OrderBook_API) -> u8 {
     book.has_ask() as u8
@@ -190,14 +205,23 @@
 #[no_mangle]
 pub extern "C" fn orderbook_midpoint(book: &mut OrderBook_API) -> f64 {
     book.midpoint()
         .expect("Error: Unable to calculate `midpoint` (no bid or ask)")
 }
 
 #[no_mangle]
+pub extern "C" fn orderbook_get_avg_px_for_quantity(
+    book: &mut OrderBook_API,
+    qty: Quantity,
+    order_side: OrderSide,
+) -> f64 {
+    book.get_avg_px_for_quantity(qty, order_side)
+}
+
+#[no_mangle]
 pub extern "C" fn orderbook_update_quote_tick(book: &mut OrderBook_API, tick: &QuoteTick) {
     book.update_quote_tick(tick);
 }
 
 #[no_mangle]
 pub extern "C" fn orderbook_update_trade_tick(book: &mut OrderBook_API, tick: &TradeTick) {
     book.update_trade_tick(tick);
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/ladder.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/ladder.rs`

 * *Files 14% similar despite different names*

```diff
@@ -17,15 +17,15 @@
     cmp::Ordering,
     collections::{BTreeMap, HashMap},
     fmt::{Display, Formatter},
 };
 
 use super::book::BookIntegrityError;
 use crate::{
-    data::book::BookOrder,
+    data::order::BookOrder,
     enums::OrderSide,
     orderbook::level::Level,
     types::{price::Price, quantity::Quantity},
 };
 
 #[derive(Copy, Clone, Debug, Eq)]
 pub struct BookPrice {
@@ -38,19 +38,15 @@
     pub fn new(value: Price, side: OrderSide) -> Self {
         Self { value, side }
     }
 }
 
 impl PartialOrd for BookPrice {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        match self.side {
-            OrderSide::Buy => Some(other.value.cmp(&self.value)),
-            OrderSide::Sell => Some(self.value.cmp(&other.value)),
-            _ => panic!("{}", BookIntegrityError::NoOrderSide),
-        }
+        Some(self.cmp(other))
     }
 }
 
 impl PartialEq for BookPrice {
     fn eq(&self, other: &Self) -> bool {
         self.value == other.value
     }
@@ -192,15 +188,17 @@
             }
 
             for book_order in &level.orders {
                 let current = book_order.size;
                 if cumulative_denominator + current >= target {
                     // This order has filled us, add fill and return
                     let remainder = target - cumulative_denominator;
-                    fills.push((book_order.price, remainder));
+                    if remainder.is_positive() {
+                        fills.push((book_order.price, remainder));
+                    }
                     return fills;
                 } else {
                     // Add this fill and continue
                     fills.push((book_order.price, current));
                     cumulative_denominator += current;
                 }
             }
@@ -211,16 +209,18 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
+    use rstest::rstest;
+
     use crate::{
-        data::book::BookOrder,
+        data::order::BookOrder,
         enums::OrderSide,
         orderbook::ladder::{BookPrice, Ladder},
         types::{
             price::{Price, PRICE_MAX, PRICE_MIN},
             quantity::Quantity,
         },
     };
@@ -495,29 +495,56 @@
         ladder.delete(order);
         assert_eq!(ladder.len(), 0);
         assert_eq!(ladder.volumes(), 0.0);
         assert_eq!(ladder.exposures(), 0.0);
         assert_eq!(ladder.top(), None)
     }
 
-    #[test]
-    fn test_simulate_order_fills_buy_when_far_from_market() {
-        let mut ladder = Ladder::new(OrderSide::Sell);
+    #[rstest]
+    #[case(OrderSide::Buy, Price::max(2), OrderSide::Sell)]
+    #[case(OrderSide::Sell, Price::min(2), OrderSide::Buy)]
+    fn test_simulate_order_fills_with_no_size(
+        #[case] side: OrderSide,
+        #[case] price: Price,
+        #[case] ladder_side: OrderSide,
+    ) {
+        let ladder = Ladder::new(ladder_side);
+        let order = BookOrder {
+            price, // <-- Simulate a MARKET order
+            size: Quantity::new(500.0, 0),
+            side,
+            order_id: 2,
+        };
+
+        let fills = ladder.simulate_fills(&order);
+
+        assert!(fills.is_empty());
+    }
+
+    #[rstest]
+    #[case(OrderSide::Buy, OrderSide::Sell, Price::new(60.0, 2))]
+    #[case(OrderSide::Sell, OrderSide::Buy, Price::new(40.0, 2))]
+    fn test_simulate_order_fills_buy_when_far_from_market(
+        #[case] order_side: OrderSide,
+        #[case] ladder_side: OrderSide,
+        #[case] ladder_price: Price,
+    ) {
+        let mut ladder = Ladder::new(ladder_side);
 
         ladder.add(BookOrder {
-            price: Price::new(100.00, 2),
+            price: ladder_price,
             size: Quantity::new(100.0, 0),
-            side: OrderSide::Sell,
+            side: ladder_side,
             order_id: 1,
         });
 
         let order = BookOrder {
-            price: Price::new(50.00, 2), // <-- Simulate a MARKET order
+            price: Price::new(50.00, 2),
             size: Quantity::new(500.0, 0),
-            side: OrderSide::Buy,
+            side: order_side,
             order_id: 2,
         };
 
         let fills = ladder.simulate_fills(&order);
 
         assert!(fills.is_empty());
     }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/level.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/level.rs`

 * *Files 10% similar despite different names*

```diff
@@ -12,16 +12,17 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::cmp::Ordering;
 
 use crate::{
-    data::book::BookOrder,
+    data::order::BookOrder,
     orderbook::{book::BookIntegrityError, ladder::BookPrice},
+    types::fixed::FIXED_SCALAR,
 };
 
 #[derive(Clone, Debug, Eq)]
 pub struct Level {
     pub price: BookPrice,
     pub orders: Vec<BookOrder>,
 }
@@ -103,32 +104,50 @@
         for o in self.orders.iter() {
             sum += o.size.as_f64()
         }
         sum
     }
 
     #[must_use]
+    pub fn volume_raw(&self) -> u64 {
+        let mut sum = 0u64;
+        for o in self.orders.iter() {
+            sum += o.size.raw
+        }
+        sum
+    }
+
+    #[must_use]
     pub fn exposure(&self) -> f64 {
         let mut sum: f64 = 0.0;
         for o in self.orders.iter() {
             sum += o.price.as_f64() * o.size.as_f64()
         }
         sum
     }
+
+    #[must_use]
+    pub fn exposure_raw(&self) -> u64 {
+        let mut sum = 0u64;
+        for o in self.orders.iter() {
+            sum += ((o.price.as_f64() * o.size.as_f64()) * FIXED_SCALAR) as u64
+        }
+        sum
+    }
 }
 
 impl PartialEq for Level {
     fn eq(&self, other: &Self) -> bool {
         self.price == other.price
     }
 }
 
 impl PartialOrd for Level {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        self.price.partial_cmp(&other.price)
+        Some(self.cmp(other))
     }
 
     fn lt(&self, other: &Self) -> bool {
         self.price.lt(&other.price)
     }
 
     fn le(&self, other: &Self) -> bool {
@@ -152,15 +171,15 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use crate::{
-        data::book::BookOrder,
+        data::order::BookOrder,
         enums::OrderSide,
         orderbook::{ladder::BookPrice, level::Level},
         types::{price::Price, quantity::Quantity},
     };
 
     #[test]
     fn test_comparisons_bid_side() {
@@ -245,20 +264,15 @@
         let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
         let order1 = BookOrder::new(
             OrderSide::Buy,
             Price::new(1.00, 2),
             Quantity::new(10.0, 0),
             0,
         );
-        let order2 = BookOrder::new(
-            OrderSide::Buy,
-            Price::new(1.00, 2),
-            Quantity::new(0.0, 0),
-            0,
-        );
+        let order2 = BookOrder::new(OrderSide::Buy, Price::new(1.00, 2), Quantity::zero(0), 0);
 
         level.add(order1);
         level.update(order2);
         assert_eq!(level.len(), 0);
         assert_eq!(level.volume(), 0.0);
         assert_eq!(level.exposure(), 0.0);
     }
@@ -344,8 +358,92 @@
 
     #[test]
     #[should_panic(expected = "Invalid book operation: order ID 1 not found")]
     fn test_remove_nonexistent_order() {
         let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
         level.remove(1);
     }
+
+    #[test]
+    fn test_volume() {
+        let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
+        let order1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(1.00, 2),
+            Quantity::new(10.0, 0),
+            0,
+        );
+        let order2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(1.00, 2),
+            Quantity::new(15.0, 0),
+            1,
+        );
+
+        level.add(order1);
+        level.add(order2);
+        assert_eq!(level.volume(), 25.0);
+    }
+
+    #[test]
+    fn test_volume_raw() {
+        let mut level = Level::new(BookPrice::new(Price::new(2.00, 2), OrderSide::Buy));
+        let order1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(10.0, 0),
+            0,
+        );
+        let order2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(20.0, 0),
+            1,
+        );
+
+        level.add(order1);
+        level.add(order2);
+        assert_eq!(level.volume_raw(), 30_000_000_000);
+    }
+
+    #[test]
+    fn test_exposure() {
+        let mut level = Level::new(BookPrice::new(Price::new(2.00, 2), OrderSide::Buy));
+        let order1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(10.0, 0),
+            0,
+        );
+        let order2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(20.0, 0),
+            1,
+        );
+
+        level.add(order1);
+        level.add(order2);
+        assert_eq!(level.exposure(), 60.0);
+    }
+
+    #[test]
+    fn test_exposure_raw() {
+        let mut level = Level::new(BookPrice::new(Price::new(2.00, 2), OrderSide::Buy));
+        let order1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(10.0, 0),
+            0,
+        );
+        let order2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(20.0, 0),
+            1,
+        );
+
+        level.add(order1);
+        level.add(order2);
+        assert_eq!(level.exposure_raw(), 60_000_000_000);
+    }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/mod.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orderbook/mod.rs`

 * *Files 11% similar despite different names*

```diff
@@ -13,7 +13,8 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod book;
 pub mod book_api;
 pub mod ladder;
 pub mod level;
+pub mod level_api;
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/orders/mod.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/orders/base.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,40 +9,39 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-#![allow(dead_code)]
-
-pub mod limit;
+use std::collections::HashMap;
 
 use nautilus_core::{time::UnixNanos, uuid::UUID4};
-use thiserror::Error;
+use thiserror;
 
 use crate::{
     enums::{
         ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, PositionSide,
         TimeInForce, TriggerType,
     },
     events::order::{
         OrderAccepted, OrderCancelRejected, OrderCanceled, OrderDenied, OrderEvent, OrderExpired,
-        OrderFilled, OrderInitialized, OrderModifyRejected, OrderPendingCancel, OrderPendingUpdate,
-        OrderRejected, OrderSubmitted, OrderTriggered, OrderUpdated,
+        OrderFilled, OrderModifyRejected, OrderPendingCancel, OrderPendingUpdate, OrderRejected,
+        OrderSubmitted, OrderTriggered, OrderUpdated,
     },
     identifiers::{
-        account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
-        order_list_id::OrderListId, position_id::PositionId, strategy_id::StrategyId,
-        trade_id::TradeId, trader_id::TraderId, venue_order_id::VenueOrderId,
+        account_id::AccountId, client_order_id::ClientOrderId, exec_algorithm_id::ExecAlgorithmId,
+        instrument_id::InstrumentId, order_list_id::OrderListId, position_id::PositionId,
+        strategy_id::StrategyId, trade_id::TradeId, trader_id::TraderId,
+        venue_order_id::VenueOrderId,
     },
-    types::{fixed::fixed_i64_to_f64, price::Price, quantity::Quantity},
+    types::{price::Price, quantity::Quantity},
 };
 
-#[derive(Error, Debug)]
+#[derive(thiserror::Error, Debug)]
 pub enum OrderError {
     #[error("Invalid state transition")]
     InvalidStateTransition,
     #[error("Unrecognized event")]
     UnrecognizedEvent,
 }
 
@@ -83,14 +82,15 @@
             (OrderStatus::PendingUpdate, OrderEvent::OrderPendingUpdate(_)) => OrderStatus::PendingUpdate,  // Allow multiple requests
             (OrderStatus::PendingUpdate, OrderEvent::OrderPendingCancel(_)) => OrderStatus::PendingCancel,
             (OrderStatus::PendingUpdate, OrderEvent::OrderPartiallyFilled(_)) => OrderStatus::PartiallyFilled,
             (OrderStatus::PendingUpdate, OrderEvent::OrderFilled(_)) => OrderStatus::Filled,
             (OrderStatus::PendingCancel, OrderEvent::OrderRejected(_)) => OrderStatus::Rejected,
             (OrderStatus::PendingCancel, OrderEvent::OrderPendingCancel(_)) => OrderStatus::PendingCancel,  // Allow multiple requests
             (OrderStatus::PendingCancel, OrderEvent::OrderCanceled(_)) => OrderStatus::Canceled,
+            (OrderStatus::PendingCancel, OrderEvent::OrderExpired(_)) => OrderStatus::Expired,
             (OrderStatus::PendingCancel, OrderEvent::OrderAccepted(_)) => OrderStatus::Accepted,  // Allow failed cancel requests
             (OrderStatus::PendingCancel, OrderEvent::OrderPartiallyFilled(_)) => OrderStatus::PartiallyFilled,
             (OrderStatus::PendingCancel, OrderEvent::OrderFilled(_)) => OrderStatus::Filled,
             (OrderStatus::Triggered, OrderEvent::OrderRejected(_)) => OrderStatus::Rejected,
             (OrderStatus::Triggered, OrderEvent::OrderPendingUpdate(_)) => OrderStatus::PendingUpdate,
             (OrderStatus::Triggered, OrderEvent::OrderPendingCancel(_)) => OrderStatus::PendingCancel,
             (OrderStatus::Triggered, OrderEvent::OrderCanceled(_)) => OrderStatus::Canceled,
@@ -105,280 +105,255 @@
             (OrderStatus::PartiallyFilled, OrderEvent::OrderFilled(_)) => OrderStatus::Filled,
             _ => return Err(OrderError::InvalidStateTransition),
         };
         Ok(new_state)
     }
 }
 
-struct Order {
-    events: Vec<OrderEvent>,
-    venue_order_ids: Vec<VenueOrderId>, // TODO(cs): Should be `Vec<&VenueOrderId>` or similar
-    trade_ids: Vec<TradeId>,            // TODO(cs): Should be `Vec<&TradeId>` or similar
-    previous_status: Option<OrderStatus>,
-    triggered_price: Option<Price>,
+pub trait Order {
+    fn status(&self) -> OrderStatus;
+    fn trader_id(&self) -> TraderId;
+    fn strategy_id(&self) -> StrategyId;
+    fn instrument_id(&self) -> InstrumentId;
+    fn client_order_id(&self) -> ClientOrderId;
+    fn venue_order_id(&self) -> Option<VenueOrderId>;
+    fn position_id(&self) -> Option<PositionId>;
+    fn account_id(&self) -> Option<AccountId>;
+    fn last_trade_id(&self) -> Option<TradeId>;
+    fn side(&self) -> OrderSide;
+    fn order_type(&self) -> OrderType;
+    fn quantity(&self) -> Quantity;
+    fn time_in_force(&self) -> TimeInForce;
+    fn price(&self) -> Option<Price>;
+    fn trigger_price(&self) -> Option<Price>;
+    fn trigger_type(&self) -> Option<TriggerType>;
+    fn liquidity_side(&self) -> Option<LiquiditySide>;
+    fn is_post_only(&self) -> bool;
+    fn is_reduce_only(&self) -> bool;
+    fn is_quote_quantity(&self) -> bool;
+    fn emulation_trigger(&self) -> Option<TriggerType>;
+    fn contingency_type(&self) -> Option<ContingencyType>;
+    fn order_list_id(&self) -> Option<OrderListId>;
+    fn linked_order_ids(&self) -> Option<Vec<ClientOrderId>>;
+    fn parent_order_id(&self) -> Option<ClientOrderId>;
+    fn exec_algorithm_id(&self) -> Option<ExecAlgorithmId>;
+    fn exec_algorithm_params(&self) -> Option<HashMap<String, String>>;
+    fn exec_spawn_id(&self) -> Option<ClientOrderId>;
+    fn tags(&self) -> Option<String>;
+    fn filled_qty(&self) -> Quantity;
+    fn leaves_qty(&self) -> Quantity;
+    fn avg_px(&self) -> Option<f64>;
+    fn slippage(&self) -> Option<f64>;
+    fn init_id(&self) -> UUID4;
+    fn ts_init(&self) -> UnixNanos;
+    fn ts_last(&self) -> UnixNanos;
+
+    fn events(&self) -> Vec<&OrderEvent>;
+
+    fn last_event(&self) -> &OrderEvent {
+        // Safety: `Order` specification guarantees at least one event (`OrderInitialized`)
+        self.events().last().unwrap()
+    }
+
+    fn event_count(&self) -> usize {
+        self.events().len()
+    }
+
+    fn venue_order_ids(&self) -> Vec<&VenueOrderId>;
+
+    fn trade_ids(&self) -> Vec<&TradeId>;
+
+    fn is_buy(&self) -> bool {
+        self.side() == OrderSide::Buy
+    }
+
+    fn is_sell(&self) -> bool {
+        self.side() == OrderSide::Sell
+    }
+
+    fn is_passive(&self) -> bool {
+        self.order_type() != OrderType::Market
+    }
+
+    fn is_aggressive(&self) -> bool {
+        self.order_type() == OrderType::Market
+    }
+
+    fn is_emulated(&self) -> bool {
+        self.emulation_trigger().is_some()
+    }
+
+    fn is_contingency(&self) -> bool {
+        self.contingency_type().is_some()
+    }
+
+    fn is_parent_order(&self) -> bool {
+        match self.contingency_type() {
+            Some(c) => c == ContingencyType::Oto,
+            None => false,
+        }
+    }
+
+    fn is_child_order(&self) -> bool {
+        self.parent_order_id().is_some()
+    }
+
+    fn is_open(&self) -> bool {
+        self.emulation_trigger().is_none()
+            && matches!(
+                self.status(),
+                OrderStatus::Accepted
+                    | OrderStatus::Triggered
+                    | OrderStatus::PendingCancel
+                    | OrderStatus::PendingUpdate
+                    | OrderStatus::PartiallyFilled
+            )
+    }
+
+    fn is_closed(&self) -> bool {
+        matches!(
+            self.status(),
+            OrderStatus::Denied
+                | OrderStatus::Rejected
+                | OrderStatus::Canceled
+                | OrderStatus::Expired
+                | OrderStatus::Filled
+        )
+    }
+
+    fn is_inflight(&self) -> bool {
+        self.emulation_trigger().is_none()
+            && matches!(
+                self.status(),
+                OrderStatus::Submitted | OrderStatus::PendingCancel | OrderStatus::PendingUpdate
+            )
+    }
+
+    fn is_pending_update(&self) -> bool {
+        self.status() == OrderStatus::PendingUpdate
+    }
+
+    fn is_pending_cancel(&self) -> bool {
+        self.status() == OrderStatus::PendingCancel
+    }
+}
+
+pub struct OrderCore {
+    pub events: Vec<OrderEvent>,
+    pub venue_order_ids: Vec<VenueOrderId>,
+    pub trade_ids: Vec<TradeId>,
+    pub previous_status: Option<OrderStatus>,
+    pub has_price: bool,
+    pub has_trigger_price: bool,
     pub status: OrderStatus,
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub position_id: Option<PositionId>,
     pub account_id: Option<AccountId>,
     pub last_trade_id: Option<TradeId>,
     pub side: OrderSide,
     pub order_type: OrderType,
     pub quantity: Quantity,
-    pub price: Option<Price>,
-    pub trigger_price: Option<Price>,
-    pub trigger_type: Option<TriggerType>,
     pub time_in_force: TimeInForce,
-    pub expire_time: Option<UnixNanos>,
     pub liquidity_side: Option<LiquiditySide>,
     pub is_post_only: bool,
     pub is_reduce_only: bool,
     pub is_quote_quantity: bool,
-    pub display_qty: Option<Quantity>,
-    pub limit_offset: Option<Price>,
-    pub trailing_offset: Option<Price>,
-    pub trailing_offset_type: Option<TriggerType>,
     pub emulation_trigger: Option<TriggerType>,
     pub contingency_type: Option<ContingencyType>,
     pub order_list_id: Option<OrderListId>,
     pub linked_order_ids: Option<Vec<ClientOrderId>>,
     pub parent_order_id: Option<ClientOrderId>,
+    pub exec_algorithm_id: Option<ExecAlgorithmId>,
+    pub exec_algorithm_params: Option<HashMap<String, String>>,
+    pub exec_spawn_id: Option<ClientOrderId>,
     pub tags: Option<String>,
     pub filled_qty: Quantity,
     pub leaves_qty: Quantity,
     pub avg_px: Option<f64>,
     pub slippage: Option<f64>,
     pub init_id: UUID4,
-    pub ts_triggered: Option<UnixNanos>,
     pub ts_init: UnixNanos,
     pub ts_last: UnixNanos,
 }
 
-impl PartialEq<Self> for Order {
-    fn eq(&self, other: &Self) -> bool {
-        self.client_order_id == other.client_order_id
-    }
-}
-
-impl Eq for Order {}
-
-impl From<OrderInitialized> for Order {
-    fn from(value: OrderInitialized) -> Self {
+impl OrderCore {
+    #[must_use]
+    #[allow(clippy::too_many_arguments)]
+    pub fn new(
+        trader_id: TraderId,
+        strategy_id: StrategyId,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        order_side: OrderSide,
+        order_type: OrderType,
+        quantity: Quantity,
+        time_in_force: TimeInForce,
+        post_only: bool,
+        reduce_only: bool,
+        quote_quantity: bool,
+        emulation_trigger: Option<TriggerType>,
+        contingency_type: Option<ContingencyType>,
+        order_list_id: Option<OrderListId>,
+        linked_order_ids: Option<Vec<ClientOrderId>>,
+        parent_order_id: Option<ClientOrderId>,
+        exec_algorithm_id: Option<ExecAlgorithmId>,
+        exec_algorithm_params: Option<HashMap<String, String>>,
+        exec_spawn_id: Option<ClientOrderId>,
+        tags: Option<String>,
+        init_id: UUID4,
+        ts_init: UnixNanos,
+    ) -> Self {
         Self {
             events: Vec::new(),
             venue_order_ids: Vec::new(),
             trade_ids: Vec::new(),
             previous_status: None,
-            triggered_price: None,
+            has_price: true,          // TODO
+            has_trigger_price: false, // TODO
             status: OrderStatus::Initialized,
-            trader_id: value.trader_id,
-            strategy_id: value.strategy_id,
-            instrument_id: value.instrument_id,
-            client_order_id: value.client_order_id,
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
             venue_order_id: None,
             position_id: None,
             account_id: None,
             last_trade_id: None,
-            side: value.order_side,
-            order_type: value.order_type,
-            quantity: value.quantity,
-            price: value.price,
-            trigger_price: value.trigger_price,
-            trigger_type: value.trigger_type,
-            time_in_force: value.time_in_force,
-            expire_time: None,
+            side: order_side,
+            order_type,
+            quantity,
+            time_in_force,
             liquidity_side: None,
-            is_post_only: value.post_only,
-            is_reduce_only: value.reduce_only,
-            is_quote_quantity: value.quote_quantity,
-            display_qty: None,
-            limit_offset: None,
-            trailing_offset: None,
-            trailing_offset_type: None,
-            emulation_trigger: value.emulation_trigger,
-            contingency_type: value.contingency_type,
-            order_list_id: value.order_list_id,
-            linked_order_ids: value.linked_order_ids,
-            parent_order_id: value.parent_order_id,
-            tags: value.tags,
-            filled_qty: Quantity::new(0.0, 0),
-            leaves_qty: value.quantity,
+            is_post_only: post_only,
+            is_reduce_only: reduce_only,
+            is_quote_quantity: quote_quantity,
+            emulation_trigger,
+            contingency_type,
+            order_list_id,
+            linked_order_ids,
+            parent_order_id,
+            exec_algorithm_id,
+            exec_algorithm_params,
+            exec_spawn_id,
+            tags,
+            filled_qty: Quantity::zero(quantity.precision),
+            leaves_qty: quantity,
             avg_px: None,
             slippage: None,
-            init_id: value.event_id,
-            ts_triggered: None,
-            ts_init: value.ts_event,
-            ts_last: value.ts_event,
-        }
-    }
-}
-
-impl From<&Order> for OrderInitialized {
-    fn from(value: &Order) -> Self {
-        Self {
-            trader_id: value.trader_id.clone(),
-            strategy_id: value.strategy_id.clone(),
-            instrument_id: value.instrument_id.clone(),
-            client_order_id: value.client_order_id.clone(),
-            order_side: value.side,
-            order_type: value.order_type,
-            quantity: value.quantity,
-            price: value.price,
-            trigger_price: value.triggered_price,
-            trigger_type: value.trigger_type,
-            time_in_force: value.time_in_force,
-            expire_time: value.expire_time,
-            post_only: value.is_post_only,
-            reduce_only: value.is_reduce_only,
-            quote_quantity: value.is_quote_quantity,
-            display_qty: value.display_qty,
-            limit_offset: value.limit_offset,
-            trailing_offset: value.trailing_offset,
-            trailing_offset_type: value.trailing_offset_type,
-            emulation_trigger: value.emulation_trigger,
-            contingency_type: value.contingency_type,
-            order_list_id: value.order_list_id.clone(),
-            linked_order_ids: value.linked_order_ids.clone(),
-            parent_order_id: value.parent_order_id.clone(),
-            tags: value.tags.clone(),
-            event_id: value.init_id.clone(),
-            ts_event: value.ts_init,
-            ts_init: value.ts_init,
-            reconciliation: false,
-        }
-    }
-}
-
-impl Order {
-    pub fn last_event(&self) -> Option<&OrderEvent> {
-        self.events.last()
-    }
-
-    pub fn events(&self) -> Vec<OrderEvent> {
-        self.events.clone()
-    }
-
-    pub fn event_count(&self) -> usize {
-        self.events.len()
-    }
-
-    pub fn venue_order_ids(&self) -> Vec<VenueOrderId> {
-        self.venue_order_ids.clone()
-    }
-
-    pub fn trade_ids(&self) -> Vec<TradeId> {
-        self.trade_ids.clone()
-    }
-
-    pub fn is_buy(&self) -> bool {
-        self.side == OrderSide::Buy
-    }
-
-    pub fn is_sell(&self) -> bool {
-        self.side == OrderSide::Sell
-    }
-
-    pub fn is_passive(&self) -> bool {
-        self.order_type != OrderType::Market
-    }
-
-    pub fn is_aggressive(&self) -> bool {
-        self.order_type == OrderType::Market
-    }
-
-    pub fn is_emulated(&self) -> bool {
-        self.emulation_trigger.is_some()
-    }
-
-    pub fn is_contingency(&self) -> bool {
-        self.contingency_type.is_some()
-    }
-
-    pub fn is_parent_order(&self) -> bool {
-        match self.contingency_type {
-            Some(c) => c == ContingencyType::Oto,
-            None => false,
-        }
-    }
-
-    pub fn is_child_order(&self) -> bool {
-        self.parent_order_id.is_some()
-    }
-
-    pub fn is_open(&self) -> bool {
-        if self.emulation_trigger.is_some() {
-            return false;
-        }
-        self.status == OrderStatus::Accepted
-            || self.status == OrderStatus::Triggered
-            || self.status == OrderStatus::PendingCancel
-            || self.status == OrderStatus::PendingUpdate
-            || self.status == OrderStatus::PartiallyFilled
-    }
-
-    pub fn is_closed(&self) -> bool {
-        self.status == OrderStatus::Denied
-            || self.status == OrderStatus::Rejected
-            || self.status == OrderStatus::Canceled
-            || self.status == OrderStatus::Expired
-            || self.status == OrderStatus::Filled
-    }
-
-    pub fn is_inflight(&self) -> bool {
-        if self.emulation_trigger.is_some() {
-            return false;
-        }
-        self.status == OrderStatus::Submitted
-            || self.status == OrderStatus::PendingCancel
-            || self.status == OrderStatus::PendingUpdate
-    }
-
-    pub fn is_pending_update(&self) -> bool {
-        self.status == OrderStatus::PendingUpdate
-    }
-
-    pub fn is_pending_cancel(&self) -> bool {
-        self.status == OrderStatus::PendingCancel
-    }
-
-    pub fn opposite_side(side: OrderSide) -> OrderSide {
-        match side {
-            OrderSide::Buy => OrderSide::Sell,
-            OrderSide::Sell => OrderSide::Buy,
-            OrderSide::NoOrderSide => OrderSide::NoOrderSide,
+            init_id,
+            ts_init,
+            ts_last: ts_init,
         }
     }
 
-    pub fn closing_side(side: PositionSide) -> OrderSide {
-        match side {
-            PositionSide::Long => OrderSide::Sell,
-            PositionSide::Short => OrderSide::Buy,
-            PositionSide::Flat => OrderSide::NoOrderSide,
-            PositionSide::NoPositionSide => OrderSide::NoOrderSide,
-        }
-    }
-
-    pub fn would_reduce_only(&self, side: PositionSide, position_qty: Quantity) -> bool {
-        if side == PositionSide::Flat {
-            return false;
-        }
-
-        match (self.side, side) {
-            (OrderSide::Buy, PositionSide::Long) => false,
-            (OrderSide::Buy, PositionSide::Short) => self.leaves_qty <= position_qty,
-            (OrderSide::Sell, PositionSide::Short) => false,
-            (OrderSide::Sell, PositionSide::Long) => self.leaves_qty <= position_qty,
-            _ => true,
-        }
-    }
-
-    pub fn apply(&mut self, event: OrderEvent) -> Result<(), OrderError> {
+    fn apply(&mut self, event: OrderEvent) -> Result<(), OrderError> {
         let new_status = self.status.transition(&event)?;
         self.previous_status = Some(self.status);
         self.status = new_status;
 
         match &event {
             OrderEvent::OrderDenied(event) => self.denied(event),
             OrderEvent::OrderSubmitted(event) => self.submitted(event),
@@ -400,19 +375,19 @@
     }
 
     fn denied(&self, _event: &OrderDenied) {
         // Do nothing else
     }
 
     fn submitted(&mut self, event: &OrderSubmitted) {
-        self.account_id = Some(event.account_id.clone())
+        self.account_id = Some(event.account_id)
     }
 
     fn accepted(&mut self, event: &OrderAccepted) {
-        self.venue_order_id = Some(event.venue_order_id.clone());
+        self.venue_order_id = Some(event.venue_order_id);
     }
 
     fn rejected(&self, _event: &OrderRejected) {
         // Do nothing else
     }
 
     fn pending_update(&self, _event: &OrderPendingUpdate) {
@@ -439,54 +414,53 @@
 
     fn updated(&mut self, event: &OrderUpdated) {
         match &event.venue_order_id {
             Some(venue_order_id) => {
                 if self.venue_order_id.is_some()
                     && venue_order_id != self.venue_order_id.as_ref().unwrap()
                 {
-                    self.venue_order_id = Some(venue_order_id.clone());
-                    self.venue_order_ids.push(venue_order_id.clone()); // TODO(cs): Temporary clone
+                    self.venue_order_id = Some(*venue_order_id);
+                    self.venue_order_ids.push(*venue_order_id);
                 }
             }
             None => {}
         }
-        if let Some(price) = &event.price {
-            if self.price.is_some() {
-                self.price.replace(*price);
-            } else {
-                panic!("invalid update of `price` when None")
-            }
-        }
 
-        if let Some(trigger_price) = &event.trigger_price {
-            if self.trigger_price.is_some() {
-                self.trigger_price.replace(*trigger_price);
-            } else {
-                panic!("invalid update of `trigger_price` when None")
-            }
-        }
+        // TODO
+        // if let Some(price) = &event.price {
+        //     if self.price.is_some() {
+        //         self.price.replace(*price);
+        //     } else {
+        //         panic!("invalid update of `price` when None")
+        //     }
+        // }
+        //
+        // if let Some(trigger_price) = &event.trigger_price {
+        //     if self.trigger_price.is_some() {
+        //         self.trigger_price.replace(*trigger_price);
+        //     } else {
+        //         panic!("invalid update of `trigger_price` when None")
+        //     }
+        // }
 
-        self.quantity.raw = event.quantity.raw;
-        self.leaves_qty = Quantity::from_raw(
-            self.quantity.raw - self.filled_qty.raw,
-            self.quantity.precision,
-        );
+        self.quantity = event.quantity;
+        self.leaves_qty = self.quantity - self.filled_qty;
     }
 
     fn filled(&mut self, event: &OrderFilled) {
-        self.venue_order_id = Some(event.venue_order_id.clone());
-        self.position_id = event.position_id.clone();
-        self.trade_ids.push(event.trade_id.clone());
-        self.last_trade_id = Some(event.trade_id.clone());
+        self.venue_order_id = Some(event.venue_order_id);
+        self.position_id = event.position_id;
+        self.trade_ids.push(event.trade_id);
+        self.last_trade_id = Some(event.trade_id);
         self.liquidity_side = Some(event.liquidity_side);
         self.filled_qty += &event.last_qty;
         self.leaves_qty -= &event.last_qty;
         self.ts_last = event.ts_event;
         self.set_avg_px(&event.last_qty, &event.last_px);
-        self.set_slippage();
+        // self.set_slippage(); // TODO
     }
 
     fn set_avg_px(&mut self, last_qty: &Quantity, last_px: &Price) {
         if self.avg_px.is_none() {
             self.avg_px = Some(last_px.as_f64());
         }
 
@@ -497,89 +471,99 @@
             .avg_px
             .unwrap()
             .mul_add(filled_qty, last_px.as_f64() * last_qty.as_f64())
             / total_qty;
         self.avg_px = Some(avg_px);
     }
 
-    fn set_slippage(&mut self) {
-        self.slippage = self.avg_px.and_then(|avg_px| {
-            self.price
-                .as_ref()
-                .map(|price| fixed_i64_to_f64(price.raw))
-                .and_then(|price| match self.side {
-                    OrderSide::Buy if avg_px > price => Some(avg_px - price),
-                    OrderSide::Sell if avg_px < price => Some(price - avg_px),
-                    _ => None,
-                })
-        })
+    // TODO
+    // fn set_slippage(&mut self) {
+    //     if self.has_price {
+    //         self.slippage = self.avg_px.and_then(|avg_px| {
+    //             self.price
+    //                 .as_ref()
+    //                 .map(|price| fixed_i64_to_f64(price.raw))
+    //                 .and_then(|price| match self.side() {
+    //                     OrderSide::Buy if avg_px > price => Some(avg_px - price),
+    //                     OrderSide::Sell if avg_px < price => Some(price - avg_px),
+    //                     _ => None,
+    //                 })
+    //         })
+    //     }
+    // }
+
+    fn opposite_side(&self, side: OrderSide) -> OrderSide {
+        match side {
+            OrderSide::Buy => OrderSide::Sell,
+            OrderSide::Sell => OrderSide::Buy,
+            OrderSide::NoOrderSide => OrderSide::NoOrderSide,
+        }
+    }
+
+    fn closing_side(&self, side: PositionSide) -> OrderSide {
+        match side {
+            PositionSide::Long => OrderSide::Sell,
+            PositionSide::Short => OrderSide::Buy,
+            PositionSide::Flat => OrderSide::NoOrderSide,
+            PositionSide::NoPositionSide => OrderSide::NoOrderSide,
+        }
+    }
+
+    fn would_reduce_only(&self, side: PositionSide, position_qty: Quantity) -> bool {
+        if side == PositionSide::Flat {
+            return false;
+        }
+
+        match (self.side, side) {
+            (OrderSide::Buy, PositionSide::Long) => false,
+            (OrderSide::Buy, PositionSide::Short) => self.leaves_qty <= position_qty,
+            (OrderSide::Sell, PositionSide::Short) => false,
+            (OrderSide::Sell, PositionSide::Long) => self.leaves_qty <= position_qty,
+            _ => true,
+        }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use rstest::rstest;
 
     use super::*;
     use crate::{
         enums::{OrderSide, OrderStatus, PositionSide},
-        events::order::{
-            OrderAcceptedBuilder, OrderDeniedBuilder, OrderEvent, OrderInitializedBuilder,
-            OrderSubmittedBuilder,
-        },
+        events::order::{OrderDeniedBuilder, OrderEvent, OrderInitializedBuilder},
+        orders::market::MarketOrder,
     };
 
-    #[test]
-    fn test_order_initialized() {
-        let order: Order = OrderInitializedBuilder::default().build().unwrap().into();
-
-        assert_eq!(order.status, OrderStatus::Initialized);
-        assert_eq!(order.last_event(), None);
-        assert_eq!(order.event_count(), 0);
-        assert!(order.venue_order_ids.is_empty());
-        assert!(order.trade_ids.is_empty());
-        assert!(order.is_buy());
-        assert!(!order.is_sell());
-        assert!(!order.is_passive());
-        assert!(order.is_aggressive());
-        assert!(!order.is_emulated());
-        assert!(!order.is_contingency());
-        assert!(!order.is_parent_order());
-        assert!(!order.is_child_order());
-        assert!(!order.is_open());
-        assert!(!order.is_closed());
-        assert!(!order.is_inflight());
-        assert!(!order.is_pending_update());
-        assert!(!order.is_pending_cancel());
-    }
-
     #[rstest(
         order_side,
         expected_side,
         case(OrderSide::Buy, OrderSide::Sell),
         case(OrderSide::Sell, OrderSide::Buy),
         case(OrderSide::NoOrderSide, OrderSide::NoOrderSide)
     )]
     fn test_order_opposite_side(order_side: OrderSide, expected_side: OrderSide) {
-        let result = Order::opposite_side(order_side);
+        let order = MarketOrder::default();
+        let result = order.opposite_side(order_side);
         assert_eq!(result, expected_side)
     }
 
     #[rstest(
         position_side,
         expected_side,
         case(PositionSide::Long, OrderSide::Sell),
         case(PositionSide::Short, OrderSide::Buy),
         case(PositionSide::NoPositionSide, OrderSide::NoOrderSide)
     )]
     fn test_closing_side(position_side: PositionSide, expected_side: OrderSide) {
-        let result = Order::closing_side(position_side);
+        let order = MarketOrder::default();
+        let result = order.closing_side(position_side);
         assert_eq!(result, expected_side)
     }
 
     #[rustfmt::skip]
     #[rstest(
         order_side, order_qty, position_side, position_qty, expected,
         case(OrderSide::Buy, Quantity::from(100), PositionSide::Long, Quantity::from(50), false),
@@ -594,15 +578,15 @@
     fn test_would_reduce_only(
         order_side: OrderSide,
         order_qty: Quantity,
         position_side: PositionSide,
         position_qty: Quantity,
         expected: bool,
     ) {
-        let order: Order = OrderInitializedBuilder::default()
+        let order: MarketOrder = OrderInitializedBuilder::default()
             .order_side(order_side)
             .quantity(order_qty)
             .build()
             .unwrap()
             .into();
 
         assert_eq!(
@@ -611,47 +595,53 @@
         );
     }
 
     #[test]
     fn test_order_state_transition_denied() {
         let init = OrderInitializedBuilder::default().build().unwrap();
         let denied = OrderDeniedBuilder::default().build().unwrap();
-        let mut order: Order = init.into();
+        let mut order: MarketOrder = init.into();
         let event = OrderEvent::OrderDenied(denied);
 
         let _ = order.apply(event.clone());
 
         assert_eq!(order.status, OrderStatus::Denied);
         assert!(order.is_closed());
         assert!(!order.is_open());
         assert_eq!(order.event_count(), 1);
-        assert_eq!(order.last_event(), Some(&event));
+        assert_eq!(order.last_event(), &event);
     }
 
-    #[test]
-    fn test_buy_order_life_cyle_to_filled() {
-        // TODO: We should be able to derive defaults for the below?
-        let init = OrderInitializedBuilder::default().build().unwrap();
-        let submitted = OrderSubmittedBuilder::default().build().unwrap();
-        let accepted = OrderAcceptedBuilder::default().build().unwrap();
-        // let filled = OrderFilledBuilder::default()
-        //     .ids(init.ids.clone())
-        //     .account_id(AccountId::default())
-        //     .venue_order_id(VenueOrderId::default())
-        //     .position_id(None)
-        //     .trade_id(TradeId::new("001"))
-        //     .event_id(UUID4::default())
-        //     .ts_event(UnixNanos::default())
-        //     .ts_init(UnixNanos::default())
-        //     .reconciliation(false)
-        //     .build()
-        //     .unwrap();
-
-        let client_order_id = init.client_order_id.clone();
-        let mut order: Order = init.into();
-        let _ = order.apply(OrderEvent::OrderSubmitted(submitted));
-        let _ = order.apply(OrderEvent::OrderAccepted(accepted));
-        // let _ = order.apply(OrderEvent::OrderFilled(filled));
-
-        assert_eq!(order.client_order_id, client_order_id);
-    }
+    // #[test]
+    // fn test_buy_order_life_cycle_to_filled() {
+    //     let init = OrderInitializedBuilder::default().build().unwrap();
+    //     let submitted = OrderSubmittedBuilder::default().build().unwrap();
+    //     let accepted = OrderAcceptedBuilder::default().build().unwrap();
+    //
+    //     // TODO: We should derive defaults for the below
+    //     let filled = OrderFilledBuilder::default()
+    //         .trader_id(TraderId::default())
+    //         .strategy_id(StrategyId::default())
+    //         .instrument_id(InstrumentId::default())
+    //         .account_id(AccountId::default())
+    //         .client_order_id(ClientOrderId::default())
+    //         .venue_order_id(VenueOrderId::default())
+    //         .position_id(None)
+    //         .order_side(OrderSide::Buy)
+    //         .order_type(OrderType::Market)
+    //         .trade_id(TradeId::new("001"))
+    //         .event_id(UUID4::default())
+    //         .ts_event(UnixNanos::default())
+    //         .ts_init(UnixNanos::default())
+    //         .reconciliation(false)
+    //         .build()
+    //         .unwrap();
+    //
+    //     let client_order_id = init.client_order_id;
+    //     let mut order: MarketOrder = init.into();
+    //     let _ = order.apply(OrderEvent::OrderSubmitted(submitted));
+    //     let _ = order.apply(OrderEvent::OrderAccepted(accepted));
+    //     let _ = order.apply(OrderEvent::OrderFilled(filled));
+    //
+    //     assert_eq!(order.client_order_id, client_order_id);
+    // }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/position.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/position.rs`

 * *Files 7% similar despite different names*

```diff
@@ -56,61 +56,61 @@
     pub signed_qty: f64,
     pub quantity: Quantity,
     pub peak_qty: Quantity,
     pub price_precision: u8,
     pub size_precision: u8,
     pub multiplier: Quantity,
     pub is_inverse: bool,
-    pub quote_currency: Currency,
     pub base_currency: Option<Currency>,
-    pub cost_currency: Currency,
+    pub quote_currency: Currency,
+    pub settlement_currency: Currency,
     pub ts_init: UnixNanos,
     pub ts_opened: UnixNanos,
     pub ts_last: UnixNanos,
     pub ts_closed: Option<UnixNanos>,
     pub duration_ns: Option<u64>,
     pub avg_px_open: f64,
     pub avg_px_close: Option<f64>,
     pub realized_return: Option<f64>,
     pub realized_pnl: Option<Money>,
 }
 
 impl Position {
-    pub fn new(instrument: &Instrument, fill: &OrderFilled) -> Self {
-        assert_eq!(instrument.id, fill.instrument_id);
+    pub fn new<T: Instrument>(instrument: &T, fill: &OrderFilled) -> Self {
+        assert_eq!(instrument.id(), &fill.instrument_id);
         assert!(fill.position_id.is_some());
         assert!(fill.order_side != OrderSide::NoOrderSide);
 
         Self {
             events: Vec::<OrderFilled>::new(),
             client_order_ids: Vec::<ClientOrderId>::new(),
             venue_order_ids: Vec::<VenueOrderId>::new(),
             trade_ids: Vec::<TradeId>::new(),
-            buy_qty: Quantity::new(0.0, instrument.size_precision),
-            sell_qty: Quantity::new(0.0, instrument.size_precision),
+            buy_qty: Quantity::zero(instrument.size_precision()),
+            sell_qty: Quantity::zero(instrument.size_precision()),
             commissions: HashMap::<Currency, Money>::new(),
-            trader_id: fill.trader_id.clone(),
-            strategy_id: fill.strategy_id.clone(),
-            instrument_id: fill.instrument_id.clone(),
-            id: fill.position_id.clone().unwrap(), // TODO: Improve validation
-            account_id: fill.account_id.clone(),
-            opening_order_id: fill.client_order_id.clone(),
+            trader_id: fill.trader_id,
+            strategy_id: fill.strategy_id,
+            instrument_id: fill.instrument_id,
+            id: fill.position_id.unwrap(), // TODO: Improve validation
+            account_id: fill.account_id,
+            opening_order_id: fill.client_order_id,
             closing_order_id: None,
             entry: fill.order_side,
             side: PositionSide::Flat,
             signed_qty: 0.0,
             quantity: fill.last_qty,
             peak_qty: fill.last_qty,
-            price_precision: instrument.price_precision,
-            size_precision: instrument.size_precision,
-            multiplier: instrument.multiplier,
-            is_inverse: instrument.is_inverse,
-            quote_currency: instrument.quote_currency.clone(),
-            base_currency: instrument.base_currency.clone(),
-            cost_currency: instrument.cost_currency.clone(),
+            price_precision: instrument.price_precision(),
+            size_precision: instrument.size_precision(),
+            multiplier: instrument.multiplier(),
+            is_inverse: instrument.is_inverse(),
+            base_currency: instrument.base_currency().to_owned().copied(),
+            quote_currency: *instrument.quote_currency(),
+            settlement_currency: *instrument.settlement_currency(),
             ts_init: fill.ts_init,
             ts_opened: fill.ts_event,
             ts_last: fill.ts_event,
             ts_closed: None,
             duration_ns: None,
             avg_px_open: fill.last_px.as_f64(),
             avg_px_close: None,
@@ -125,41 +125,41 @@
             "`fill.trade_id` already contained in `trade_ids",
         );
 
         if self.side == PositionSide::Flat {
             // Reset position
             self.events.clear();
             self.trade_ids.clear();
-            self.buy_qty = Quantity::new(0.0, self.size_precision);
-            self.sell_qty = Quantity::new(0.0, self.size_precision);
+            self.buy_qty = Quantity::zero(self.size_precision);
+            self.sell_qty = Quantity::zero(self.size_precision);
             self.commissions.clear();
-            self.opening_order_id = fill.client_order_id.clone();
+            self.opening_order_id = fill.client_order_id;
             self.closing_order_id = None;
-            self.peak_qty = Quantity::new(0.0, self.size_precision);
+            self.peak_qty = Quantity::zero(self.size_precision);
             self.ts_init = fill.ts_init;
             self.ts_opened = fill.ts_event;
             self.duration_ns = None;
             self.avg_px_open = fill.last_px.as_f64();
             self.avg_px_close = None;
             self.realized_return = None;
             self.realized_pnl = None;
         }
 
         self.events.push(fill.clone()); // Potentially do this last
-        self.trade_ids.push(fill.trade_id.clone());
+        self.trade_ids.push(fill.trade_id);
 
         // Calculate cumulative commissions
-        let commission_currency = fill.commission.currency.clone();
-        let commission_clone = fill.commission.clone();
+        let commission_currency = fill.commission.currency;
+        let commission_clone = fill.commission;
 
         if let Some(existing_commission) = self.commissions.get_mut(&commission_currency) {
             *existing_commission += commission_clone;
         } else {
             self.commissions
-                .insert(commission_currency, fill.commission.clone());
+                .insert(commission_currency, fill.commission);
         }
 
         // Calculate avg prices, points, return, PnL
         match fill.order_side {
             OrderSide::Buy => {}
             OrderSide::Sell => {}
             _ => panic!("invalid order side"),
@@ -176,15 +176,15 @@
             self.entry = OrderSide::Buy;
             self.side = PositionSide::Long;
         } else if self.signed_qty < 0.0 {
             self.entry = OrderSide::Sell;
             self.side = PositionSide::Short;
         } else {
             self.side = PositionSide::Flat;
-            self.closing_order_id = Some(fill.client_order_id.clone());
+            self.closing_order_id = Some(fill.client_order_id);
             self.ts_closed = Some(fill.ts_event);
             self.duration_ns = Some(self.ts_closed.unwrap() - self.ts_opened);
         }
 
         self.ts_last = fill.ts_event;
     }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/types/balance.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/src/backend/mod.rs`

 * *Files 22% similar despite different names*

```diff
@@ -9,27 +9,9 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::fmt::{Display, Formatter};
-
-use crate::types::{currency::Currency, money::Money};
-
-pub struct AccountBalance {
-    pub currency: Currency,
-    pub total: Money,
-    pub locked: Money,
-    pub free: Money,
-}
-
-impl Display for AccountBalance {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(
-            f,
-            "{} {} {} {}",
-            self.currency.code, self.total, self.locked, self.free,
-        )
-    }
-}
+pub mod session;
+pub mod transformer;
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/types/currency.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/types/currency.rs`

 * *Files 6% similar despite different names*

```diff
@@ -10,38 +10,37 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{
-    collections::hash_map::DefaultHasher,
-    ffi::c_char,
+    ffi::{c_char, CStr},
     hash::{Hash, Hasher},
     str::FromStr,
-    sync::Arc,
 };
 
 use nautilus_core::{
     correctness,
     string::{cstr_to_string, str_to_cstr},
 };
 use pyo3::prelude::*;
 use serde::{Deserialize, Serialize, Serializer};
+use ustr::Ustr;
 
 use crate::{currencies::CURRENCY_MAP, enums::CurrencyType};
 
 #[repr(C)]
-#[derive(Clone, Debug, Eq)]
+#[derive(Clone, Copy, Debug, Eq)]
 #[pyclass]
 pub struct Currency {
-    pub code: Box<Arc<String>>,
+    pub code: Ustr,
     pub precision: u8,
     pub iso4217: u16,
-    pub name: Box<Arc<String>>,
+    pub name: Ustr,
     pub currency_type: CurrencyType,
 }
 
 impl Currency {
     #[must_use]
     pub fn new(
         code: &str,
@@ -51,18 +50,18 @@
         currency_type: CurrencyType,
     ) -> Self {
         correctness::valid_string(code, "`Currency` code");
         correctness::valid_string(name, "`Currency` name");
         correctness::u8_in_range_inclusive(precision, 0, 9, "`Currency` precision");
 
         Self {
-            code: Box::new(Arc::new(code.to_string())),
+            code: Ustr::from(code),
             precision,
             iso4217,
-            name: Box::new(Arc::new(name.to_string())),
+            name: Ustr::from(name),
             currency_type,
         }
     }
 }
 
 impl PartialEq for Currency {
     fn eq(&self, other: &Self) -> bool {
@@ -127,31 +126,28 @@
 pub unsafe extern "C" fn currency_from_py(
     code_ptr: *const c_char,
     precision: u8,
     iso4217: u16,
     name_ptr: *const c_char,
     currency_type: CurrencyType,
 ) -> Currency {
-    Currency {
-        code: Box::from(Arc::new(cstr_to_string(code_ptr))),
+    assert!(!code_ptr.is_null(), "`code_ptr` was NULL");
+    assert!(!name_ptr.is_null(), "`name_ptr` was NULL");
+
+    Currency::new(
+        CStr::from_ptr(code_ptr)
+            .to_str()
+            .expect("CStr::from_ptr failed for `code_ptr`"),
         precision,
         iso4217,
-        name: Box::from(Arc::new(cstr_to_string(name_ptr))),
+        CStr::from_ptr(name_ptr)
+            .to_str()
+            .expect("CStr::from_ptr failed for `name_ptr`"),
         currency_type,
-    }
-}
-
-#[no_mangle]
-pub extern "C" fn currency_clone(currency: &Currency) -> Currency {
-    currency.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn currency_drop(currency: Currency) {
-    drop(currency); // Memory freed here
+    )
 }
 
 #[no_mangle]
 pub extern "C" fn currency_to_cstr(currency: &Currency) -> *const c_char {
     str_to_cstr(format!("{currency:?}").as_str())
 }
 
@@ -162,23 +158,16 @@
 
 #[no_mangle]
 pub extern "C" fn currency_name_to_cstr(currency: &Currency) -> *const c_char {
     str_to_cstr(&currency.name)
 }
 
 #[no_mangle]
-pub extern "C" fn currency_eq(lhs: &Currency, rhs: &Currency) -> u8 {
-    u8::from(lhs.code == rhs.code)
-}
-
-#[no_mangle]
 pub extern "C" fn currency_hash(currency: &Currency) -> u64 {
-    let mut h = DefaultHasher::new();
-    currency.hash(&mut h);
-    h.finish()
+    currency.code.precomputed_hash()
 }
 
 #[no_mangle]
 pub extern "C" fn currency_register(currency: Currency) {
     CURRENCY_MAP
         .lock()
         .unwrap()
@@ -204,34 +193,19 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use crate::{
-        enums::CurrencyType,
-        types::currency::{currency_eq, Currency},
-    };
-
-    #[test]
-    fn test_currency_equality() {
-        let currency1 = Currency::new("AUD", 2, 36, "Australian dollar", CurrencyType::Fiat);
-        let currency2 = Currency::new("AUD", 2, 36, "Australian dollar", CurrencyType::Fiat);
-        let currency3 = Currency::new("ETH", 8, 0, "Ether", CurrencyType::Crypto);
-        assert_eq!(currency1, currency2);
-        assert_ne!(currency1, currency3);
-        assert_eq!(currency_eq(&currency1, &currency2), 1);
-        assert_ne!(currency_eq(&currency1, &currency2), 0);
-    }
+    use crate::{enums::CurrencyType, types::currency::Currency};
 
     #[test]
     fn test_currency_new_for_fiat() {
         let currency = Currency::new("AUD", 2, 36, "Australian dollar", CurrencyType::Fiat);
-        assert_ne!(currency_eq(&currency, &currency), 0);
         assert_eq!(currency, currency);
         assert_eq!(currency.code.as_str(), "AUD");
         assert_eq!(currency.precision, 2);
         assert_eq!(currency.iso4217, 36);
         assert_eq!(currency.name.as_str(), "Australian dollar");
         assert_eq!(currency.currency_type, CurrencyType::Fiat);
     }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/types/fixed.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/types/fixed.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/types/mod.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/types/mod.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/types/money.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/types/money.rs`

 * *Files 2% similar despite different names*

```diff
@@ -30,15 +30,15 @@
     fixed::{f64_to_fixed_i64, fixed_i64_to_f64},
 };
 
 pub const MONEY_MAX: f64 = 9_223_372_036.0;
 pub const MONEY_MIN: f64 = -9_223_372_036.0;
 
 #[repr(C)]
-#[derive(Eq, Clone, Debug)]
+#[derive(Clone, Copy, Debug, Eq)]
 #[pyclass]
 pub struct Money {
     raw: i64,
     pub currency: Currency,
 }
 
 impl Money {
@@ -78,15 +78,15 @@
     fn eq(&self, other: &Self) -> bool {
         self.raw == other.raw && self.currency == other.currency
     }
 }
 
 impl PartialOrd for Money {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        self.raw.partial_cmp(&other.raw)
+        Some(self.cmp(other))
     }
 
     fn lt(&self, other: &Self) -> bool {
         assert_eq!(self.currency, other.currency);
         self.raw.lt(&other.raw)
     }
 
@@ -210,15 +210,15 @@
 }
 
 impl Serialize for Money {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: serde::Serializer,
     {
-        serializer.serialize_str(&format!("{}", self))
+        serializer.serialize_str(&self.to_string())
     }
 }
 
 impl<'de> Deserialize<'de> for Money {
     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
     where
         D: Deserializer<'de>,
@@ -254,19 +254,14 @@
 
 #[no_mangle]
 pub extern "C" fn money_from_raw(raw: i64, currency: Currency) -> Money {
     Money::from_raw(raw, currency)
 }
 
 #[no_mangle]
-pub extern "C" fn money_drop(money: Money) {
-    drop(money); // Memory freed here
-}
-
-#[no_mangle]
 pub extern "C" fn money_as_f64(money: &Money) -> f64 {
     money.as_f64()
 }
 
 #[no_mangle]
 pub extern "C" fn money_add_assign(mut a: Money, b: Money) {
     a.add_assign(b);
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/types/price.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/types/price.rs`

 * *Files 4% similar despite different names*

```diff
@@ -27,14 +27,20 @@
 
 use super::fixed::FIXED_SCALAR;
 use crate::types::fixed::{f64_to_fixed_i64, fixed_i64_to_f64};
 
 pub const PRICE_MAX: f64 = 9_223_372_036.0;
 pub const PRICE_MIN: f64 = -9_223_372_036.0;
 
+/// Sentinel Price for errors.
+pub const ERROR_PRICE: Price = Price {
+    raw: i64::MAX,
+    precision: 0,
+};
+
 #[repr(C)]
 #[derive(Copy, Clone, Eq, Default)]
 #[pyclass]
 pub struct Price {
     pub raw: i64,
     pub precision: u8,
 }
@@ -52,14 +58,35 @@
 
     #[must_use]
     pub fn from_raw(raw: i64, precision: u8) -> Self {
         Self { raw, precision }
     }
 
     #[must_use]
+    pub fn max(precision: u8) -> Self {
+        Self {
+            raw: (PRICE_MAX * FIXED_SCALAR) as i64,
+            precision,
+        }
+    }
+
+    #[must_use]
+    pub fn min(precision: u8) -> Self {
+        Self {
+            raw: (PRICE_MIN * FIXED_SCALAR) as i64,
+            precision,
+        }
+    }
+
+    #[must_use]
+    pub fn zero(precision: u8) -> Self {
+        Self { raw: 0, precision }
+    }
+
+    #[must_use]
     pub fn is_zero(&self) -> bool {
         self.raw == 0
     }
 
     #[must_use]
     pub fn as_f64(&self) -> f64 {
         fixed_i64_to_f64(self.raw)
@@ -106,15 +133,15 @@
     fn eq(&self, other: &Self) -> bool {
         self.raw == other.raw
     }
 }
 
 impl PartialOrd for Price {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        self.raw.partial_cmp(&other.raw)
+        Some(self.cmp(other))
     }
 
     fn lt(&self, other: &Self) -> bool {
         self.raw.lt(&other.raw)
     }
 
     fn le(&self, other: &Self) -> bool {
@@ -236,15 +263,15 @@
 }
 
 impl Serialize for Price {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: serde::Serializer,
     {
-        serializer.serialize_str(&format!("{}", self))
+        serializer.serialize_str(&self.to_string())
     }
 }
 
 impl<'de> Deserialize<'de> for Price {
     fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>
     where
         D: Deserializer<'de>,
@@ -289,75 +316,112 @@
 #[cfg(test)]
 mod tests {
     use std::str::FromStr;
 
     use super::*;
 
     #[test]
-    fn test_price_new() {
+    fn test_new() {
         let price = Price::new(0.00812, 8);
         assert_eq!(price, price);
         assert_eq!(price.raw, 8_120_000);
         assert_eq!(price.precision, 8);
         assert_eq!(price.as_f64(), 0.00812);
         assert_eq!(price.to_string(), "0.00812000");
+        assert!(!price.is_zero());
     }
 
     #[test]
-    fn test_price_minimum() {
+    fn test_with_maximum_value() {
+        let price = Price::new(PRICE_MAX, 9);
+        assert_eq!(price.raw, 9_223_372_036_000_000_000);
+        assert_eq!(price.to_string(), "9223372036.000000000");
+    }
+
+    #[test]
+    fn test_with_minimum_positive_value() {
         let price = Price::new(0.000_000_001, 9);
         assert_eq!(price.raw, 1);
         assert_eq!(price.to_string(), "0.000000001");
     }
 
     #[test]
-    fn test_price_is_zero() {
+    fn test_with_minimum_value() {
+        let price = Price::new(PRICE_MIN, 9);
+        assert_eq!(price.raw, -9_223_372_036_000_000_000);
+        assert_eq!(price.to_string(), "-9223372036.000000000");
+    }
+
+    #[test]
+    fn test_max() {
+        let price = Price::max(9);
+        assert_eq!(price.raw, 9_223_372_036_000_000_000);
+        assert_eq!(price.to_string(), "9223372036.000000000");
+    }
+
+    #[test]
+    fn test_min() {
+        let price = Price::min(9);
+        assert_eq!(price.raw, -9_223_372_036_000_000_000);
+        assert_eq!(price.to_string(), "-9223372036.000000000");
+    }
+
+    #[test]
+    fn test_zero() {
+        let price = Price::zero(0);
+        assert_eq!(price.raw, 0);
+        assert_eq!(price.to_string(), "0");
+        assert!(price.is_zero());
+    }
+
+    #[test]
+    fn test_is_zero() {
         let price = Price::new(0.0, 8);
         assert_eq!(price, price);
         assert_eq!(price.raw, 0);
         assert_eq!(price.precision, 8);
         assert_eq!(price.as_f64(), 0.0);
         assert_eq!(price.to_string(), "0.00000000");
         assert!(price.is_zero());
     }
 
     #[test]
-    fn test_price_precision() {
+    fn test_precision() {
         let price = Price::new(1.001, 2);
         assert_eq!(price.raw, 1_000_000_000);
         assert_eq!(price.to_string(), "1.00");
     }
 
     #[test]
-    fn test_price_new_from_str() {
+    fn test_new_from_str() {
         let price = Price::from_str("0.00812000").unwrap();
         assert_eq!(price, price);
         assert_eq!(price.raw, 8_120_000);
         assert_eq!(price.precision, 8);
         assert_eq!(price.as_f64(), 0.00812);
         assert_eq!(price.to_string(), "0.00812000");
     }
 
     #[test]
-    fn test_price_from_str_valid_input() {
+    fn test_from_str_valid_input() {
         let input = "10.5";
         let expected_price = Price::new(10.5, precision_from_str(input));
         let result = Price::from_str(input).unwrap();
         assert_eq!(result, expected_price);
     }
 
     #[test]
-    fn test_price_from_str_invalid_input() {
+    fn test_from_str_invalid_input() {
         let input = "invalid";
         let result = Price::from_str(input);
         assert!(result.is_err());
     }
 
     #[test]
-    fn test_price_equality() {
+    fn test_equality() {
         assert_eq!(Price::new(1.0, 1), Price::new(1.0, 1));
         assert_eq!(Price::new(1.0, 1), Price::new(1.0, 2));
         assert_ne!(Price::new(1.1, 1), Price::new(1.0, 1));
         assert!(Price::new(1.0, 1) <= Price::new(1.0, 2));
         assert!(Price::new(1.1, 1) > Price::new(1.0, 1));
         assert!(Price::new(1.0, 1) >= Price::new(1.0, 1));
         assert!(Price::new(1.0, 1) >= Price::new(1.0, 2));
@@ -410,25 +474,25 @@
         let mut price1 = Price::new(1.000, 3);
         let price2 = Price::new(1.011, 3);
         price1 *= price2;
         assert_eq!(price1.raw, 1_011_000_000_000_000_000);
     }
 
     #[test]
-    fn test_price_display_works() {
+    fn test_display_works() {
         use std::fmt::Write as FmtWrite;
         let input_string = "44.12";
         let price = Price::from_str(input_string).unwrap();
         let mut res = String::new();
         write!(&mut res, "{price}").unwrap();
         assert_eq!(res, input_string);
     }
 
     #[test]
-    fn test_price_display() {
+    fn test_display() {
         let input_string = "44.123456";
         let price = Price::from_str(input_string).unwrap();
         assert_eq!(price.raw, 44_123_456_000);
         assert_eq!(price.precision, 6);
         assert_eq!(price.as_f64(), 44.123_456_000_000_004);
         assert_eq!(price.to_string(), input_string);
     }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/model/src/types/quantity.rs` & `nautilus_trader-1.176.0/nautilus_core/model/src/types/quantity.rs`

 * *Files 6% similar despite different names*

```diff
@@ -60,14 +60,20 @@
         Self { raw: 0, precision }
     }
 
     #[must_use]
     pub fn is_zero(&self) -> bool {
         self.raw == 0
     }
+
+    #[must_use]
+    pub fn is_positive(&self) -> bool {
+        self.raw > 0
+    }
+
     #[must_use]
     pub fn as_f64(&self) -> f64 {
         fixed_u64_to_f64(self.raw)
     }
 }
 
 impl From<Quantity> for f64 {
@@ -116,15 +122,15 @@
     fn eq(&self, other: &Self) -> bool {
         self.raw == other.raw
     }
 }
 
 impl PartialOrd for Quantity {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        self.raw.partial_cmp(&other.raw)
+        Some(self.cmp(other))
     }
 
     fn lt(&self, other: &Self) -> bool {
         self.raw.lt(&other.raw)
     }
 
     fn le(&self, other: &Self) -> bool {
@@ -227,15 +233,15 @@
 }
 
 impl Serialize for Quantity {
     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
     where
         S: serde::Serializer,
     {
-        serializer.serialize_str(&format!("{}", self))
+        serializer.serialize_str(&self.to_string())
     }
 }
 
 impl<'de> Deserialize<'de> for Quantity {
     fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>
     where
         D: Deserializer<'de>,
@@ -297,76 +303,94 @@
     fn test_new() {
         let qty = Quantity::new(0.00812, 8);
         assert_eq!(qty, qty);
         assert_eq!(qty.raw, 8_120_000);
         assert_eq!(qty.precision, 8);
         assert_eq!(qty.as_f64(), 0.00812);
         assert_eq!(qty.to_string(), "0.00812000");
+        assert!(!qty.is_zero());
+        assert!(qty.is_positive());
     }
 
     #[test]
     fn test_zero() {
         let qty = Quantity::zero(8);
         assert_eq!(qty.raw, 0);
         assert_eq!(qty.precision, 8);
+        assert!(qty.is_zero());
+        assert!(!qty.is_positive());
     }
 
     #[test]
-    fn test_qty_from_i64() {
+    fn test_from_i64() {
         let qty = Quantity::from(100_000);
         assert_eq!(qty, qty);
         assert_eq!(qty.raw, 100_000_000_000_000);
         assert_eq!(qty.precision, 0);
     }
 
     #[test]
-    fn test_qty_minimum() {
-        let qty = Quantity::new(0.000_000_001, 9);
+    fn test_with_maximum_value() {
+        let qty = Quantity::new(QUANTITY_MAX, 0);
+        assert_eq!(qty.raw, 18_446_744_073_000_000_000);
+        assert_eq!(qty.to_string(), "18446744073");
+    }
+
+    #[test]
+    fn test_with_minimum_positive_value() {
+        let qty = Quantity::new(0.000000001, 9);
         assert_eq!(qty.raw, 1);
         assert_eq!(qty.to_string(), "0.000000001");
     }
 
     #[test]
-    fn test_qty_is_zero() {
-        let qty = Quantity::new(0.0, 8);
+    fn test_with_minimum_value() {
+        let qty = Quantity::new(QUANTITY_MIN, 9);
+        assert_eq!(qty.raw, 0);
+        assert_eq!(qty.to_string(), "0.000000000");
+    }
+
+    #[test]
+    fn test_is_zero() {
+        let qty = Quantity::zero(8);
         assert_eq!(qty, qty);
         assert_eq!(qty.raw, 0);
         assert_eq!(qty.precision, 8);
         assert_eq!(qty.as_f64(), 0.0);
         assert_eq!(qty.to_string(), "0.00000000");
         assert!(qty.is_zero());
     }
 
     #[test]
-    fn test_qty_precision() {
+    fn test_precision() {
         let qty = Quantity::new(1.001, 2);
         assert_eq!(qty.raw, 1_000_000_000);
         assert_eq!(qty.to_string(), "1.00");
     }
 
     #[test]
-    fn test_qty_new_from_str() {
+    fn test_new_from_str() {
         let qty = Quantity::from_str("0.00812000").unwrap();
         assert_eq!(qty, qty);
         assert_eq!(qty.raw, 8_120_000);
         assert_eq!(qty.precision, 8);
         assert_eq!(qty.as_f64(), 0.00812);
         assert_eq!(qty.to_string(), "0.00812000");
     }
 
     #[test]
-    fn test_quantity_from_str_valid_input() {
+    fn test_from_str_valid_input() {
         let input = "1000.25";
         let expected_quantity = Quantity::new(1000.25, precision_from_str(input));
         let result = Quantity::from_str(input).unwrap();
         assert_eq!(result, expected_quantity);
     }
 
     #[test]
-    fn test_quantity_from_str_invalid_input() {
+    fn test_from_str_invalid_input() {
         let input = "invalid";
         let result = Quantity::from_str(input);
         assert!(result.is_err());
     }
 
     #[test]
     fn test_add() {
@@ -405,38 +429,38 @@
         let quantity1 = Quantity::new(2.0, 1);
         let quantity2 = Quantity::new(2.0, 1);
         let quantity3 = quantity1 * quantity2;
         assert_eq!(quantity3.raw, 4_000_000_000);
     }
 
     #[test]
-    fn test_quantity_mul_assign() {
+    fn test_mul_assign() {
         let mut q = Quantity::from_raw(100, 0);
         q *= 2u64;
 
         assert_eq!(q.raw, 200);
     }
 
     #[test]
-    fn test_qty_equality() {
+    fn test_equality() {
         assert_eq!(Quantity::new(1.0, 1), Quantity::new(1.0, 1));
         assert_eq!(Quantity::new(1.0, 1), Quantity::new(1.0, 2));
         assert_ne!(Quantity::new(1.1, 1), Quantity::new(1.0, 1));
         assert!(Quantity::new(1.0, 1) <= Quantity::new(1.0, 2));
         assert!(Quantity::new(1.1, 1) > Quantity::new(1.0, 1));
         assert!(Quantity::new(1.0, 1) >= Quantity::new(1.0, 1));
         assert!(Quantity::new(1.0, 1) >= Quantity::new(1.0, 2));
         assert!(Quantity::new(1.0, 1) >= Quantity::new(1.0, 2));
         assert!(Quantity::new(0.9, 1) < Quantity::new(1.0, 1));
         assert!(Quantity::new(0.9, 1) <= Quantity::new(1.0, 2));
         assert!(Quantity::new(0.9, 1) <= Quantity::new(1.0, 1));
     }
 
     #[test]
-    fn test_qty_display() {
+    fn test_display() {
         use std::fmt::Write as FmtWrite;
         let input_string = "44.12";
         let qty = Quantity::from_str(input_string).unwrap();
         let mut res = String::new();
         write!(&mut res, "{qty}").unwrap();
         assert_eq!(res, input_string);
         assert_eq!(qty.to_string(), input_string);
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/network/Cargo.toml`

 * *Files 26% similar despite different names*

```diff
@@ -4,28 +4,29 @@
 edition.workspace = true
 authors.workspace = true
 description.workspace = true
 documentation.workspace = true
 
 [lib]
 name = "nautilus_network"
-crate-type = ["rlib", "staticlib", "cdylib" ]
+crate-type = ["rlib", "staticlib", "cdylib"]
 
 [dependencies]
 nautilus-core = { path = "../core" }
+anyhow.workspace = true
 criterion.workspace = true
 futures.workspace = true
 pyo3.workspace = true
 pyo3-asyncio.workspace = true
+tracing.workspace = true
 tokio.workspace = true
-hyper = { version = "0.14.26", features = ["client", "http1", "server"] }
+futures-util = "0.3.28"
+hyper = { version = "0.14.27", features = ["client", "http1", "server"] }
 hyper-tls = "0.5.0"
 tokio-tungstenite = { path = "./tokio-tungstenite", features = ["rustls-tls-native-roots"] }
-futures-util = "0.3.28"
-tracing = "0.1.37"
 
 [dev-dependencies]
 serde_json.workspace = true
 tracing-test = "0.2.4"
 
 [features]
 extension-module = ["pyo3/extension-module", "nautilus-core/extension-module"]
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/benches/test_client.rs` & `nautilus_trader-1.176.0/nautilus_core/network/benches/test_client.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/benches/test_server.rs` & `nautilus_trader-1.176.0/nautilus_core/network/benches/test_server.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/src/http.rs` & `nautilus_trader-1.176.0/nautilus_core/network/src/http.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/network/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/src/socket.rs` & `nautilus_trader-1.176.0/nautilus_core/network/src/socket.rs`

 * *Files 24% similar despite different names*

```diff
@@ -9,178 +9,275 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{io, sync::Arc};
+use std::{io, sync::Arc, time::Duration};
 
 use pyo3::{prelude::*, types::PyBytes, PyObject, Python};
 use tokio::{
-    io::{AsyncReadExt, AsyncWriteExt},
+    io::{split, AsyncReadExt, AsyncWriteExt, ReadHalf, WriteHalf},
     net::TcpStream,
     sync::Mutex,
     task,
+    time::sleep,
 };
 use tokio_tungstenite::{
     tls::tcp_tls,
     tungstenite::{client::IntoClientRequest, stream::Mode},
     MaybeTlsStream,
 };
-use tracing::debug;
+use tracing::{debug, error};
 
+type TcpWriter = WriteHalf<MaybeTlsStream<TcpStream>>;
+type SharedTcpWriter = Arc<Mutex<WriteHalf<MaybeTlsStream<TcpStream>>>>;
+type TcpReader = ReadHalf<MaybeTlsStream<TcpStream>>;
+
+/// Creates a TcpStream with the server
+///
+/// The stream can be encrypted with TLS or Plain. The stream is split into
+/// read and write ends.
+/// * The read end is passed to task that keeps receiving
+///   messages from the server and passing them to a handler.
+/// * The write end is wrapped in an Arc Mutex and used to send messages
+///   or heart beats
+///
+/// The heartbeat is optional and can be configured with an interval and message.
+///
+/// The client uses a suffix to separate messages on the byte stream. It is
+/// appended to all sent messages and heartbeats. It is also used the split
+/// the received byte stream.
 #[pyclass]
 pub struct SocketClient {
-    read_task: task::JoinHandle<io::Result<()>>,
-    inner: Arc<Mutex<MaybeTlsStream<TcpStream>>>,
-    suffix: Box<[u8]>,
+    read_task: task::JoinHandle<()>,
+    heartbeat_task: Option<task::JoinHandle<()>>,
+    writer: SharedTcpWriter,
+    suffix: Vec<u8>,
 }
 
 impl SocketClient {
     pub async fn connect_url(
         url: &str,
         handler: PyObject,
         mode: Mode,
         suffix: Vec<u8>,
+        heartbeat: Option<(u64, Vec<u8>)>,
     ) -> io::Result<Self> {
-        debug!("socket: Connecting to server");
-        let stream = TcpStream::connect(url).await?;
+        let (reader, writer) = Self::tls_connect_with_server(url, mode).await;
+        let shared_writer = Arc::new(Mutex::new(writer));
 
-        let request = url.into_client_request().unwrap();
-        debug!("socket: {:?}", request);
-        let inner = Arc::new(Mutex::new(
-            tcp_tls(&request, mode, stream, None).await.unwrap(),
-        ));
-        let reader = inner.clone();
+        // Keep receiving messages from socket pass them as arguments to handler
+        let read_task = Self::spawn_read_task(reader, handler, suffix.clone());
+
+        // Optionally create heartbeat task
+        let heartbeat_task =
+            Self::spawn_heartbeat_task(heartbeat, shared_writer.clone(), suffix.clone());
+
+        Ok(Self {
+            read_task,
+            heartbeat_task,
+            writer: shared_writer,
+            suffix,
+        })
+    }
 
-        let suffix_slice = suffix.clone().into_boxed_slice();
+    // TODO: handle unwraps properly
+    pub async fn tls_connect_with_server(url: &str, mode: Mode) -> (TcpReader, TcpWriter) {
+        debug!("Connecting to server");
+        let stream = TcpStream::connect(url).await.unwrap();
+        debug!("Making TLS connection");
+        let request = url.into_client_request().unwrap();
+        tcp_tls(&request, mode, stream, None)
+            .await
+            .map(split)
+            .unwrap()
+    }
 
+    #[must_use]
+    pub fn spawn_read_task(
+        mut reader: TcpReader,
+        handler: PyObject,
+        suffix: Vec<u8>,
+    ) -> task::JoinHandle<()> {
         // Keep receiving messages from socket pass them as arguments to handler
-        let read_task = task::spawn(async move {
+        task::spawn(async move {
             let mut buf = Vec::new();
 
             loop {
-                let mut locked_reader = reader.lock().await;
-                let bytes = locked_reader.read_buf(&mut buf).await?;
-                drop(locked_reader);
-                debug!("socket: Received {bytes} bytes of data");
-
-                // Terminate if 0 bytes have been read
-                // Connection has been terminated or vector buffer is completely
-                if bytes == 0 {
-                    break;
-                } else {
-                    // While received data has a line break,
-                    // drain and write it to the stream.
-                    while let Some((i, _)) = &buf
-                        .windows(suffix.len())
-                        .enumerate()
-                        .find(|(_, pair)| pair.eq(&suffix))
-                    {
-                        let mut data: Vec<u8> = buf.drain(0..i + suffix.len()).collect();
-                        data.truncate(data.len() - suffix.len());
+                match reader.read_buf(&mut buf).await {
+                    // Connection has been terminated or vector buffer is completely
+                    Ok(bytes) if bytes == 0 => error!("Cannot read anymore bytes"),
+                    Err(err) => error!("Failed with error: {err}"),
+                    // Received bytes of data
+                    Ok(bytes) => {
+                        debug!("Received {bytes} bytes of data");
+
+                        // While received data has a line break
+                        // drain it and pass it to the handler
+                        while let Some((i, _)) = &buf
+                            .windows(suffix.len())
+                            .enumerate()
+                            .find(|(_, pair)| pair.eq(&suffix))
+                        {
+                            let mut data: Vec<u8> = buf.drain(0..i + suffix.len()).collect();
+                            data.truncate(data.len() - suffix.len());
 
-                        Python::with_gil(|py| handler.call1(py, (data.as_slice(),))).unwrap();
+                            if let Err(err) =
+                                Python::with_gil(|py| handler.call1(py, (data.as_slice(),)))
+                            {
+                                error!("Call to handler failed: {}", err);
+                                break;
+                            }
+                        }
                     }
-                }
+                };
             }
-            Ok(())
-        });
+        })
+    }
 
-        Ok(Self {
-            read_task,
-            inner,
-            suffix: suffix_slice,
+    /// Optionally spawn a hearbeat task to periodically ping the server.
+    pub fn spawn_heartbeat_task(
+        heartbeat: Option<(u64, Vec<u8>)>,
+        writer: SharedTcpWriter,
+        suffix: Vec<u8>,
+    ) -> Option<task::JoinHandle<()>> {
+        heartbeat.map(|(duration, mut message)| {
+            task::spawn(async move {
+                let duration = Duration::from_secs(duration);
+                message.extend(suffix);
+                loop {
+                    sleep(duration).await;
+                    debug!("Sending heartbeat");
+                    let mut guard = writer.lock().await;
+                    match guard.write_all(&message).await {
+                        Ok(_) => debug!("Sent heartbeat"),
+                        Err(err) => error!("Failed to send heartbeat: {}", err),
+                    }
+                }
+            })
         })
     }
 
     /// Shutdown read task and the connection.
     ///
     /// The client must be explicitly shutdown before dropping otherwise
     /// the connection might still be alive for some time before terminating.
     /// Closing the connection is an async call which cannot be done by the
     /// drop method so it must be done explicitly.
     pub async fn shutdown(&mut self) {
-        self.read_task.abort();
+        debug!("Abort read task");
+        if !self.read_task.is_finished() {
+            self.read_task.abort();
+        }
 
-        let mut inner = self.inner.lock().await;
-        inner.shutdown().await.unwrap();
+        // Cancel heart beat task
+        if let Some(ref handle) = self.heartbeat_task.take() {
+            if !handle.is_finished() {
+                debug!("Abort heart beat task");
+                handle.abort();
+            }
+        }
+
+        debug!("Shutdown writer");
+        let mut writer = self.writer.lock().await;
+        writer.shutdown().await.unwrap();
+        debug!("Closed connection");
     }
 
     pub async fn send_bytes(&mut self, data: &[u8]) {
-        let mut writer = self.inner.lock().await;
+        let mut writer = self.writer.lock().await;
         writer.write_all(data).await.unwrap();
         writer.write_all(&self.suffix).await.unwrap();
     }
 
     /// Checks if the client is still connected.
     #[inline]
+    #[must_use]
     pub fn is_alive(&self) -> bool {
         !self.read_task.is_finished()
     }
 }
 
 #[pymethods]
 impl SocketClient {
     #[staticmethod]
     fn connect(
         url: String,
         handler: PyObject,
         ssl: bool,
         suffix: Py<PyBytes>,
+        heartbeat: Option<(u64, Vec<u8>)>,
         py: Python<'_>,
     ) -> PyResult<&PyAny> {
         let mode = if ssl { Mode::Tls } else { Mode::Plain };
         let suffix = suffix.as_ref(py).as_bytes().to_vec();
 
         pyo3_asyncio::tokio::future_into_py(py, async move {
-            Ok(Self::connect_url(&url, handler, mode, suffix)
+            Ok(Self::connect_url(&url, handler, mode, suffix, heartbeat)
                 .await
                 .unwrap())
         })
     }
 
-    fn send<'py>(slf: PyRef<'_, Self>, data: Vec<u8>, py: Python<'py>) -> PyResult<&'py PyAny> {
-        let inner = slf.inner.clone();
+    fn send<'py>(slf: PyRef<'_, Self>, mut data: Vec<u8>, py: Python<'py>) -> PyResult<&'py PyAny> {
+        let writer = slf.writer.clone();
+        data.extend(&slf.suffix);
         pyo3_asyncio::tokio::future_into_py(py, async move {
-            let mut writer = inner.lock().await;
+            let mut writer = writer.lock().await;
             writer.write_all(&data).await?;
             Ok(())
         })
     }
 
     /// Closing the client aborts the reading task and shuts down the connection.
     ///
     /// # Safety
     ///
     /// - The client should not send after being closed
     /// - The client should be dropped after being closed
     fn close<'py>(slf: PyRef<'_, Self>, py: Python<'py>) -> PyResult<&'py PyAny> {
-        // cancel reading task
-        slf.read_task.abort();
+        if !slf.read_task.is_finished() {
+            slf.read_task.abort();
+        }
+
+        // Cancel heart beat task
+        if let Some(ref handle) = slf.heartbeat_task {
+            if !handle.is_finished() {
+                handle.abort();
+            }
+        }
 
         // Shut down writer
-        let inner = slf.inner.clone();
+        let writer = slf.writer.clone();
         pyo3_asyncio::tokio::future_into_py(py, async move {
-            let mut inner = inner.lock().await;
-            inner.shutdown().await.unwrap();
+            let mut writer = writer.lock().await;
+            writer.shutdown().await.unwrap();
             Ok(())
         })
     }
 
     fn is_connected(slf: PyRef<'_, Self>) -> bool {
         slf.is_alive()
     }
 }
 
 impl Drop for SocketClient {
     fn drop(&mut self) {
-        // Cancel reading task
-        self.read_task.abort();
+        if !self.read_task.is_finished() {
+            self.read_task.abort();
+        }
+
+        // Cancel heart beat task
+        if let Some(ref handle) = self.heartbeat_task.take() {
+            if !handle.is_finished() {
+                handle.abort();
+            }
+        }
     }
 }
 
 #[cfg(test)]
 mod tests {
     use pyo3::{prelude::*, prepare_freethreaded_python};
     use tokio::{
@@ -223,15 +320,15 @@
                         // if received data has a line break
                         // extract and write it to the stream
                         while let Some((i, _)) =
                             &buf.windows(2).enumerate().find(|(_, pair)| pair == b"\r\n")
                         {
                             debug!("socket:test Server sending message");
                             stream
-                                .write_all(&buf.drain(0..i + 2).as_slice())
+                                .write_all(buf.drain(0..i + 2).as_slice())
                                 .await
                                 .unwrap();
                         }
                     }
                 }
             });
 
@@ -279,14 +376,15 @@
         });
 
         let mut client = SocketClient::connect_url(
             &format!("127.0.0.1:{}", server.port),
             handler.clone(),
             Mode::Plain,
             b"\r\n".to_vec(),
+            None,
         )
         .await
         .unwrap();
 
         // Check that socket read task is running
         assert!(client.is_alive());
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/src/websocket.rs` & `nautilus_trader-1.176.0/nautilus_core/network/src/websocket.rs`

 * *Files 3% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 use tracing::{debug, error};
 
 type MessageWriter = SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>;
 type SharedMessageWriter =
     Arc<Mutex<SplitSink<WebSocketStream<MaybeTlsStream<TcpStream>>, Message>>>;
 type MessageReader = SplitStream<WebSocketStream<MaybeTlsStream<TcpStream>>>;
 
-/// WebSocketClient connects to a websocket server to read and send messages.
+/// `WebSocketClient` connects to a websocket server to read and send messages.
 ///
 /// The client is opinionated about how messages are read and written. It
 /// assumes that data can only have one reader but multiple writers.
 ///
 /// The client splits the connection into read and write halves. It moves
 /// the read half into a tokio task which keeps receiving messages from the
 /// server and calls a handler - a Python function that takes the data
@@ -60,22 +60,22 @@
 impl WebSocketClientInner {
     /// Create an inner websocket client.
     pub async fn connect_url(
         url: &str,
         handler: PyObject,
         heartbeat: Option<u64>,
     ) -> Result<Self, Error> {
-        let (writer, reader) = WebSocketClientInner::connect_with_server(url).await?;
+        let (writer, reader) = Self::connect_with_server(url).await?;
         let writer = Arc::new(Mutex::new(writer));
         let handler_clone = handler.clone();
 
         // Keep receiving messages from socket and pass them as arguments to handler
-        let read_task = WebSocketClientInner::spawn_read_task(reader, handler);
+        let read_task = Self::spawn_read_task(reader, handler);
 
-        let heartbeat_task = WebSocketClientInner::spawn_heartbeat_task(heartbeat, writer.clone());
+        let heartbeat_task = Self::spawn_heartbeat_task(heartbeat, writer.clone());
 
         Ok(Self {
             read_task,
             heartbeat_task,
             writer,
             url: url.to_string(),
             handler: handler_clone,
@@ -183,22 +183,21 @@
     }
 
     /// Reconnect with server
     ///
     /// Make a new connection with server. Use the new read and write halves
     /// to update self writer and read and heartbeat tasks.
     pub async fn reconnect(&mut self) -> Result<(), Error> {
-        let (new_writer, reader) = WebSocketClientInner::connect_with_server(&self.url).await?;
+        let (new_writer, reader) = Self::connect_with_server(&self.url).await?;
         let mut guard = self.writer.lock().await;
         *guard = new_writer;
         drop(guard);
 
-        self.read_task = WebSocketClientInner::spawn_read_task(reader, self.handler.clone());
-        self.heartbeat_task =
-            WebSocketClientInner::spawn_heartbeat_task(self.heartbeat, self.writer.clone());
+        self.read_task = Self::spawn_read_task(reader, self.handler.clone());
+        self.heartbeat_task = Self::spawn_heartbeat_task(self.heartbeat, self.writer.clone());
 
         Ok(())
     }
 
     /// Check if the client is still connected.
     ///
     /// The client is connected if the read task has not finished. It is expected
@@ -245,15 +244,15 @@
         post_connection: Option<PyObject>,
         post_reconnection: Option<PyObject>,
         post_disconnection: Option<PyObject>,
     ) -> Result<Self, Error> {
         let inner = WebSocketClientInner::connect_url(url, handler, heartbeat).await?;
         let writer = inner.writer.clone();
         let disconnect_mode = Arc::new(Mutex::new(false));
-        let controller_task = WebSocketClient::spawn_controller_task(
+        let controller_task = Self::spawn_controller_task(
             inner,
             disconnect_mode.clone(),
             post_reconnection,
             post_disconnection,
         );
 
         if let Some(handler) = post_connection {
@@ -279,14 +278,15 @@
     }
 
     pub async fn send_bytes_client(&self, data: Vec<u8>) -> Result<(), Error> {
         let mut guard = self.writer.lock().await;
         guard.send(Message::Binary(data)).await
     }
 
+    #[must_use]
     pub fn is_disconnected(&self) -> bool {
         self.controller_task.is_finished()
     }
 
     pub async fn send_close_message(&self) {
         let mut guard = self.writer.lock().await;
         match guard.send(Message::Close(None)).await {
@@ -363,15 +363,15 @@
         heartbeat: Option<u64>,
         post_connection: Option<PyObject>,
         post_reconnection: Option<PyObject>,
         post_disconnection: Option<PyObject>,
         py: Python<'_>,
     ) -> PyResult<&PyAny> {
         pyo3_asyncio::tokio::future_into_py(py, async move {
-            WebSocketClient::connect_client(
+            Self::connect_client(
                 &url,
                 handler,
                 heartbeat,
                 post_connection,
                 post_reconnection,
                 post_disconnection,
             )
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/LICENSE` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/LICENSE`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/README.md` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/README.md`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/compat.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/compat.rs`

 * *Files 9% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-use log::*;
+use log::trace;
 use std::{
     io::{Read, Write},
     pin::Pin,
     task::{Context, Poll},
 };
 
 use futures_util::task;
 use std::sync::Arc;
 use tokio::io::{AsyncRead, AsyncWrite, ReadBuf};
 use tungstenite::Error as WsError;
 
-pub(crate) enum ContextWaker {
+pub enum ContextWaker {
     Read,
     Write,
 }
 
 #[derive(Debug)]
-pub(crate) struct AllowStd<S> {
+pub struct AllowStd<S> {
     inner: S,
     // We have the problem that external read operations (i.e. the Stream impl)
     // can trigger both read (AsyncRead) and write (AsyncWrite) operations on
     // the underyling stream. At the same time write operations (i.e. the Sink
     // impl) can trigger write operations (AsyncWrite) too.
     // Both the Stream and the Sink can be used on two different tasks, but it
     // is required that AsyncRead and AsyncWrite are only ever used by a single
@@ -46,15 +46,15 @@
 }
 
 // Internal trait used only in the Handshake module for registering
 // the waker for the context used during handshaking. We're using the
 // read waker slot for this, but any would do.
 //
 // Don't ever use this from multiple tasks at the same time!
-pub(crate) trait SetWaker {
+pub trait SetWaker {
     fn set_waker(&self, waker: &task::Waker);
 }
 
 impl<S> SetWaker for AllowStd<S> {
     fn set_waker(&self, waker: &task::Waker) {
         self.set_waker(ContextWaker::Read, waker);
     }
@@ -182,15 +182,15 @@
         }) {
             Poll::Ready(r) => r,
             Poll::Pending => Err(std::io::Error::from(std::io::ErrorKind::WouldBlock)),
         }
     }
 }
 
-pub(crate) fn cvt<T>(r: Result<T, WsError>) -> Poll<Result<T, WsError>> {
+pub fn cvt<T>(r: Result<T, WsError>) -> Poll<Result<T, WsError>> {
     match r {
         Ok(v) => Poll::Ready(Ok(v)),
         Err(WsError::Io(ref e)) if e.kind() == std::io::ErrorKind::WouldBlock => {
             trace!("WouldBlock");
             Poll::Pending
         }
         Err(e) => Poll::Ready(Err(e)),
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/connect.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/connect.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 #[cfg(feature = "handshake")]
 use crate::compat::SetWaker;
 use crate::{compat::AllowStd, WebSocketStream};
-use log::*;
+use log::trace;
 use std::{
     future::Future,
     io::{Read, Write},
     pin::Pin,
     task::{Context, Poll},
 };
 use tokio::io::{AsyncRead, AsyncWrite};
@@ -15,15 +15,15 @@
     handshake::{
         client::Response, server::Callback, HandshakeError as Error, HandshakeRole,
         MidHandshake as WsHandshake,
     },
     ClientHandshake, ServerHandshake,
 };
 
-pub(crate) async fn without_handshake<F, S>(stream: S, f: F) -> WebSocketStream<S>
+pub async fn without_handshake<F, S>(stream: S, f: F) -> WebSocketStream<S>
 where
     F: FnOnce(AllowStd<S>) -> WebSocket<AllowStd<S>> + Unpin,
     S: AsyncRead + AsyncWrite + Unpin,
 {
     let start = SkippedHandshakeFuture(Some(SkippedHandshakeFutureInner { f, stream }));
 
     let ws = start.await;
@@ -87,15 +87,15 @@
             let res: Result<Role::FinalResult, Error<Role>> = MidHandshake::<Role>(Some(s)).await;
             res
         }
     }
 }
 
 #[cfg(feature = "handshake")]
-pub(crate) async fn client_handshake<F, S>(
+pub async fn client_handshake<F, S>(
     stream: S,
     f: F,
 ) -> Result<(WebSocketStream<S>, Response), Error<ClientHandshake<AllowStd<S>>>>
 where
     F: FnOnce(
             AllowStd<S>,
         ) -> Result<
@@ -106,15 +106,15 @@
 {
     let result = handshake(stream, f).await?;
     let (s, r) = result;
     Ok((WebSocketStream::new(s), r))
 }
 
 #[cfg(feature = "handshake")]
-pub(crate) async fn server_handshake<C, F, S>(
+pub async fn server_handshake<C, F, S>(
     stream: S,
     f: F,
 ) -> Result<WebSocketStream<S>, Error<ServerHandshake<AllowStd<S>, C>>>
 where
     C: Callback + Unpin,
     F: FnOnce(
             AllowStd<S>,
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/lib.rs`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-//! Async WebSocket usage.
+//! Async `WebSocket` usage.
 //!
-//! This library is an implementation of WebSocket handshakes and streams. It
-//! is based on the crate which implements all required WebSocket protocol
+//! This library is an implementation of `WebSocket` handshakes and streams. It
+//! is based on the crate which implements all required `WebSocket` protocol
 //! logic. So this crate basically just brings tokio support / tokio integration
 //! to it.
 //!
-//! Each WebSocket stream implements the required `Stream` and `Sink` traits,
+//! Each `WebSocket` stream implements the required `Stream` and `Sink` traits,
 //! so the socket is just a stream of messages coming in and going out.
 
 #![deny(missing_docs, unused_must_use, unused_mut, unused_imports, unused_import_braces)]
 
 pub use tungstenite;
 
 mod compat;
@@ -24,15 +24,15 @@
 use std::io::{Read, Write};
 
 use compat::{cvt, AllowStd, ContextWaker};
 use futures_util::{
     sink::{Sink, SinkExt},
     stream::{FusedStream, Stream},
 };
-use log::*;
+use log::{debug, trace};
 use std::{
     pin::Pin,
     task::{Context, Poll},
 };
 use tokio::io::{AsyncRead, AsyncWrite};
 
 #[cfg(feature = "handshake")]
@@ -61,21 +61,21 @@
 pub use connect::connect_async_tls_with_config;
 
 #[cfg(feature = "stream")]
 pub use stream::MaybeTlsStream;
 
 use tungstenite::protocol::CloseFrame;
 
-/// Creates a WebSocket handshake from a request and a stream.
+/// Creates a `WebSocket` handshake from a request and a stream.
 /// For convenience, the user may call this with a url string, a URL,
 /// or a `Request`. Calling with `Request` allows the user to add
-/// a WebSocket protocol or other custom headers.
+/// a `WebSocket` protocol or other custom headers.
 ///
 /// Internally, this custom creates a handshake representation and returns
-/// a future representing the resolution of the WebSocket handshake. The
+/// a future representing the resolution of the `WebSocket` handshake. The
 /// returned future will resolve to either `WebSocketStream<S>` or `Error`
 /// depending on whether the handshake is successful.
 ///
 /// This is typically used for clients who have already established, for
 /// example, a TCP connection to the remote server.
 #[cfg(feature = "handshake")]
 pub async fn client_async<'a, R, S>(
@@ -108,19 +108,19 @@
     });
     f.await.map_err(|e| match e {
         HandshakeError::Failure(e) => e,
         e => WsError::Io(std::io::Error::new(std::io::ErrorKind::Other, e.to_string())),
     })
 }
 
-/// Accepts a new WebSocket connection with the provided stream.
+/// Accepts a new `WebSocket` connection with the provided stream.
 ///
 /// This function will internally call `server::accept` to create a
 /// handshake representation and returns a future representing the
-/// resolution of the WebSocket handshake. The returned future will resolve
+/// resolution of the `WebSocket` handshake. The returned future will resolve
 /// to either `WebSocketStream<S>` or `Error` depending if it's successful
 /// or not.
 ///
 /// This is typically used after a socket has been accepted from a
 /// `TcpListener`. That socket is then passed to this function to perform
 /// the server half of the accepting a client's websocket connection.
 #[cfg(feature = "handshake")]
@@ -140,15 +140,15 @@
 ) -> Result<WebSocketStream<S>, WsError>
 where
     S: AsyncRead + AsyncWrite + Unpin,
 {
     accept_hdr_async_with_config(stream, NoCallback, config).await
 }
 
-/// Accepts a new WebSocket connection with the provided stream.
+/// Accepts a new `WebSocket` connection with the provided stream.
 ///
 /// This function does the same as `accept_async()` but accepts an extra callback
 /// for header processing. The callback receives headers of the incoming
 /// requests and is able to add extra headers to the reply.
 #[cfg(feature = "handshake")]
 pub async fn accept_hdr_async<S, C>(stream: S, callback: C) -> Result<WebSocketStream<S>, WsError>
 where
@@ -175,15 +175,15 @@
     });
     f.await.map_err(|e| match e {
         HandshakeError::Failure(e) => e,
         e => WsError::Io(std::io::Error::new(std::io::ErrorKind::Other, e.to_string())),
     })
 }
 
-/// A wrapper around an underlying raw stream which implements the WebSocket
+/// A wrapper around an underlying raw stream which implements the `WebSocket`
 /// protocol.
 ///
 /// A `WebSocketStream<S>` represents a handshake that has been completed
 /// successfully and both the server and the client are ready for receiving
 /// and sending data. Message from a `WebSocketStream<S>` are accessible
 /// through the respective `Stream` and `Sink`. Check more information about
 /// them in `futures-rs` crate documentation or have a look on the examples
@@ -192,27 +192,27 @@
 pub struct WebSocketStream<S> {
     inner: WebSocket<AllowStd<S>>,
     closing: bool,
     ended: bool,
 }
 
 impl<S> WebSocketStream<S> {
-    /// Convert a raw socket into a WebSocketStream without performing a
+    /// Convert a raw socket into a `WebSocketStream` without performing a
     /// handshake.
     pub async fn from_raw_socket(stream: S, role: Role, config: Option<WebSocketConfig>) -> Self
     where
         S: AsyncRead + AsyncWrite + Unpin,
     {
         handshake::without_handshake(stream, move |allow_std| {
             WebSocket::from_raw_socket(allow_std, role, config)
         })
         .await
     }
 
-    /// Convert a raw socket into a WebSocketStream without performing a
+    /// Convert a raw socket into a `WebSocketStream` without performing a
     /// handshake.
     pub async fn from_partially_read(
         stream: S,
         part: Vec<u8>,
         role: Role,
         config: Option<WebSocketConfig>,
     ) -> Self
@@ -222,15 +222,15 @@
         handshake::without_handshake(stream, move |allow_std| {
             WebSocket::from_partially_read(allow_std, part, role, config)
         })
         .await
     }
 
     pub(crate) fn new(ws: WebSocket<AllowStd<S>>) -> Self {
-        WebSocketStream { inner: ws, closing: false, ended: false }
+        Self { inner: ws, closing: false, ended: false }
     }
 
     fn with_context<F, R>(&mut self, ctx: Option<(ContextWaker, &mut Context<'_>)>, f: F) -> R
     where
         S: Unpin,
         F: FnOnce(&mut WebSocket<AllowStd<S>>) -> R,
         AllowStd<S>: Read + Write,
@@ -264,15 +264,15 @@
     }
 
     /// Close the underlying web socket
     pub async fn close(&mut self, msg: Option<CloseFrame<'_>>) -> Result<(), WsError>
     where
         S: AsyncRead + AsyncWrite + Unpin,
     {
-        let msg = msg.map(|msg| msg.into_owned());
+        let msg = msg.map(tungstenite::protocol::CloseFrame::into_owned);
         self.send(Message::Close(msg)).await
     }
 }
 
 impl<T> Stream for WebSocketStream<T>
 where
     T: AsyncRead + AsyncWrite + Unpin,
@@ -349,15 +349,15 @@
             }
         })
     }
 
     fn poll_close(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
         let res = if self.closing {
             // After queueing it, we call `flush` to drive the close handshake to completion.
-            (*self).with_context(Some((ContextWaker::Write, cx)), |s| s.flush())
+            (*self).with_context(Some((ContextWaker::Write, cx)), tungstenite::WebSocket::flush)
         } else {
             (*self).with_context(Some((ContextWaker::Write, cx)), |s| s.close(None))
         };
 
         match res {
             Ok(()) => Poll::Ready(Ok(())),
             Err(WsError::ConnectionClosed) => Poll::Ready(Ok(())),
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/stream.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/stream.rs`

 * *Files 12% similar despite different names*

```diff
@@ -28,54 +28,54 @@
 impl<S: AsyncRead + AsyncWrite + Unpin> AsyncRead for MaybeTlsStream<S> {
     fn poll_read(
         self: Pin<&mut Self>,
         cx: &mut Context<'_>,
         buf: &mut ReadBuf<'_>,
     ) -> Poll<std::io::Result<()>> {
         match self.get_mut() {
-            MaybeTlsStream::Plain(ref mut s) => Pin::new(s).poll_read(cx, buf),
+            Self::Plain(ref mut s) => Pin::new(s).poll_read(cx, buf),
             #[cfg(feature = "native-tls")]
-            MaybeTlsStream::NativeTls(s) => Pin::new(s).poll_read(cx, buf),
+            Self::NativeTls(s) => Pin::new(s).poll_read(cx, buf),
             #[cfg(feature = "__rustls-tls")]
-            MaybeTlsStream::Rustls(s) => Pin::new(s).poll_read(cx, buf),
+            Self::Rustls(s) => Pin::new(s).poll_read(cx, buf),
         }
     }
 }
 
 impl<S: AsyncRead + AsyncWrite + Unpin> AsyncWrite for MaybeTlsStream<S> {
     fn poll_write(
         self: Pin<&mut Self>,
         cx: &mut Context<'_>,
         buf: &[u8],
     ) -> Poll<Result<usize, std::io::Error>> {
         match self.get_mut() {
-            MaybeTlsStream::Plain(ref mut s) => Pin::new(s).poll_write(cx, buf),
+            Self::Plain(ref mut s) => Pin::new(s).poll_write(cx, buf),
             #[cfg(feature = "native-tls")]
-            MaybeTlsStream::NativeTls(s) => Pin::new(s).poll_write(cx, buf),
+            Self::NativeTls(s) => Pin::new(s).poll_write(cx, buf),
             #[cfg(feature = "__rustls-tls")]
-            MaybeTlsStream::Rustls(s) => Pin::new(s).poll_write(cx, buf),
+            Self::Rustls(s) => Pin::new(s).poll_write(cx, buf),
         }
     }
 
     fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), std::io::Error>> {
         match self.get_mut() {
-            MaybeTlsStream::Plain(ref mut s) => Pin::new(s).poll_flush(cx),
+            Self::Plain(ref mut s) => Pin::new(s).poll_flush(cx),
             #[cfg(feature = "native-tls")]
-            MaybeTlsStream::NativeTls(s) => Pin::new(s).poll_flush(cx),
+            Self::NativeTls(s) => Pin::new(s).poll_flush(cx),
             #[cfg(feature = "__rustls-tls")]
-            MaybeTlsStream::Rustls(s) => Pin::new(s).poll_flush(cx),
+            Self::Rustls(s) => Pin::new(s).poll_flush(cx),
         }
     }
 
     fn poll_shutdown(
         self: Pin<&mut Self>,
         cx: &mut Context<'_>,
     ) -> Poll<Result<(), std::io::Error>> {
         match self.get_mut() {
-            MaybeTlsStream::Plain(ref mut s) => Pin::new(s).poll_shutdown(cx),
+            Self::Plain(ref mut s) => Pin::new(s).poll_shutdown(cx),
             #[cfg(feature = "native-tls")]
-            MaybeTlsStream::NativeTls(s) => Pin::new(s).poll_shutdown(cx),
+            Self::NativeTls(s) => Pin::new(s).poll_shutdown(cx),
             #[cfg(feature = "__rustls-tls")]
-            MaybeTlsStream::Rustls(s) => Pin::new(s).poll_shutdown(cx),
+            Self::Rustls(s) => Pin::new(s).poll_shutdown(cx),
         }
     }
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/tls.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/src/tls.rs`

 * *Files 2% similar despite different names*

```diff
@@ -166,15 +166,15 @@
                 Mode::Plain => Ok(MaybeTlsStream::Plain(socket)),
                 Mode::Tls => Err(Error::Url(UrlError::TlsFeatureNotEnabled)),
             }
         }
     }
 }
 
-/// Creates a WebSocket handshake from a request and a stream,
+/// Creates a `WebSocket` handshake from a request and a stream,
 /// upgrading the stream to TLS if required.
 #[cfg(any(feature = "native-tls", feature = "__rustls-tls"))]
 pub async fn client_async_tls<R, S>(
     request: R,
     stream: S,
 ) -> Result<(WebSocketStream<MaybeTlsStream<S>>, Response), Error>
 where
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/tests/communication.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/tests/communication.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/tests/handshakes.rs` & `nautilus_trader-1.176.0/nautilus_core/network/tokio-tungstenite/tests/handshakes.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/persistence/Cargo.toml`

 * *Files 12% similar despite different names*

```diff
@@ -4,28 +4,30 @@
 edition.workspace = true
 authors.workspace = true
 description.workspace = true
 documentation.workspace = true
 
 [lib]
 name = "nautilus_persistence"
-crate-type = ["rlib", "staticlib", "cdylib" ]
+crate-type = ["rlib", "staticlib", "cdylib"]
 
 [dependencies]
 nautilus-core = { path = "../core" }
 nautilus-model = { path = "../model" }
+chrono.workspace = true
 futures.workspace = true
 pyo3.workspace = true
 pyo3-asyncio.workspace = true
 rand.workspace = true
 tokio.workspace = true
+thiserror.workspace = true
 binary-heap-plus = "0.5.0"
 compare = "0.1.0"
 # FIX: default feature "crypto_expressions" using using blake3 fails build on windows: https://github.com/BLAKE3-team/BLAKE3/issues/298
-datafusion = { version = "26.0.0", default-features = false, features = ["compression", "regex_expressions", "unicode_expressions"] }
+datafusion = { version = "28.0.0", default-features = false, features = ["compression", "regex_expressions", "unicode_expressions"] }
 pin-project-lite = "0.2.9"
 
 [features]
 extension-module = [
   "pyo3/extension-module", 
   "nautilus-core/extension-module", 
   "nautilus-model/extension-module",
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/benches/bench_persistence.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/benches/bench_persistence.rs`

 * *Files 2% similar despite different names*

```diff
@@ -12,16 +12,16 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fs;
 
 use criterion::{criterion_group, criterion_main, BatchSize, Criterion};
-use nautilus_model::data::tick::{QuoteTick, TradeTick};
-use nautilus_persistence::session::{DataBackendSession, QueryResult};
+use nautilus_model::data::{quote::QuoteTick, trade::TradeTick};
+use nautilus_persistence::backend::session::{DataBackendSession, QueryResult};
 use pyo3_asyncio::tokio::get_runtime;
 
 fn single_stream_bench(c: &mut Criterion) {
     let mut group = c.benchmark_group("single_stream");
     group.sample_size(10);
     let chunk_size = 5000;
     // about 10 M records
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/src/kmerge_batch.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/src/kmerge_batch.rs`

 * *Files 16% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::{task::Poll, vec::IntoIter};
 
 use binary_heap_plus::BinaryHeap;
 use compare::Compare;
-use futures::{ready, FutureExt, Stream, StreamExt};
+use futures::{future::join_all, ready, FutureExt, Stream, StreamExt};
 use pin_project_lite::pin_project;
 
 pub struct PeekElementBatchStream<S, I>
 where
     S: Stream<Item = IntoIter<I>>,
 {
     pub item: I,
@@ -59,28 +59,52 @@
     {
         heap: BinaryHeap<PeekElementBatchStream<S, I>, C>,
     }
 }
 
 impl<S, I, C> KMerge<S, I, C>
 where
-    S: Stream<Item = IntoIter<I>> + Unpin,
+    S: Stream<Item = IntoIter<I>> + Unpin + Send + 'static,
     C: Compare<PeekElementBatchStream<S, I>>,
+    I: Send + 'static,
 {
     pub fn new(cmp: C) -> Self {
         Self {
             heap: BinaryHeap::from_vec_cmp(Vec::new(), cmp),
         }
     }
 
-    pub async fn push_stream(&mut self, s: S) {
+    #[cfg(test)]
+    async fn push_stream(&mut self, s: S) {
         if let Some(heap_elem) = PeekElementBatchStream::new_from_stream(s).await {
             self.heap.push(heap_elem)
         }
     }
+
+    /// Push elements on to the heap
+    ///
+    /// Takes a Iterator of Streams. It concurrently converts all the streams
+    /// to heap elements and then pushes them onto the heap.
+    pub async fn push_iter_stream<L>(&mut self, l: L)
+    where
+        L: Iterator<Item = S>,
+    {
+        let tasks = l.map(|batch| {
+            tokio::spawn(async move { PeekElementBatchStream::new_from_stream(batch).await })
+        });
+
+        join_all(tasks)
+            .await
+            .into_iter()
+            .for_each(|heap_elem| match heap_elem {
+                Ok(Some(heap_elem)) => self.heap.push(heap_elem),
+                Ok(None) => (),
+                Err(err) => panic!("Failed to create heap element because of error: {}", err),
+            });
+    }
 }
 
 impl<S, I, C> Stream for KMerge<S, I, C>
 where
     S: Stream<Item = IntoIter<I>> + Unpin,
     C: Compare<PeekElementBatchStream<S, I>>,
 {
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/src/lib.rs`

 * *Files 20% similar despite different names*

```diff
@@ -9,23 +9,27 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+pub mod arrow;
+pub mod backend;
 mod kmerge_batch;
-pub mod parquet;
-pub mod session;
+pub mod wranglers;
 
-use parquet::ParquetType;
 use pyo3::prelude::*;
-use session::{DataBackendSession, DataQueryResult};
 
 /// Loaded as nautilus_pyo3.persistence
 #[pymodule]
 pub fn persistence(_: Python<'_>, m: &PyModule) -> PyResult<()> {
-    m.add_class::<ParquetType>()?;
-    m.add_class::<DataBackendSession>()?;
-    m.add_class::<DataQueryResult>()?;
+    m.add_class::<arrow::NautilusDataType>()?;
+    m.add_class::<backend::session::DataBackendSession>()?;
+    m.add_class::<backend::session::DataQueryResult>()?;
+    m.add_class::<backend::transformer::DataTransformer>()?;
+    m.add_class::<wranglers::bar::BarDataWrangler>()?;
+    m.add_class::<wranglers::delta::OrderBookDeltaDataWrangler>()?;
+    m.add_class::<wranglers::quote::QuoteTickDataWrangler>()?;
+    m.add_class::<wranglers::trade::TradeTickDataWrangler>()?;
     Ok(())
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/bar.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/src/arrow/bar.rs`

 * *Files 26% similar despite different names*

```diff
@@ -9,71 +9,30 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{collections::HashMap, str::FromStr};
+use std::{collections::HashMap, str::FromStr, sync::Arc};
 
 use datafusion::arrow::{
     array::{Array, Int64Array, UInt64Array},
     datatypes::{DataType, Field, Schema, SchemaRef},
     record_batch::RecordBatch,
 };
 use nautilus_model::{
     data::bar::{Bar, BarType},
     types::{price::Price, quantity::Quantity},
 };
 
-use crate::parquet::{Data, DecodeDataFromRecordBatch};
-
-impl DecodeDataFromRecordBatch for Bar {
-    fn decode_batch(metadata: &HashMap<String, String>, record_batch: RecordBatch) -> Vec<Data> {
-        // Parse and validate metadata
-        let (bar_type, price_precision, size_precision) = parse_metadata(metadata);
-
-        // Extract field value arrays from record batch
-        let cols = record_batch.columns();
-        let open_values = cols[0].as_any().downcast_ref::<Int64Array>().unwrap();
-        let high_values = cols[1].as_any().downcast_ref::<Int64Array>().unwrap();
-        let low_values = cols[2].as_any().downcast_ref::<Int64Array>().unwrap();
-        let close_values = cols[3].as_any().downcast_ref::<Int64Array>().unwrap();
-        let volume_values = cols[4].as_any().downcast_ref::<UInt64Array>().unwrap();
-        let ts_event_values = cols[5].as_any().downcast_ref::<UInt64Array>().unwrap();
-        let ts_init_values = cols[6].as_any().downcast_ref::<UInt64Array>().unwrap();
-
-        // Construct iterator of values from field value arrays
-        let values = open_values
-            .into_iter()
-            .zip(high_values.iter())
-            .zip(low_values.iter())
-            .zip(close_values.iter())
-            .zip(volume_values.iter())
-            .zip(ts_event_values.iter())
-            .zip(ts_init_values.iter())
-            .map(
-                |((((((open, high), low), close), volume), ts_event), ts_init)| {
-                    Self {
-                        bar_type: bar_type.clone(),
-                        open: Price::from_raw(open.unwrap(), price_precision),
-                        high: Price::from_raw(high.unwrap(), price_precision),
-                        low: Price::from_raw(low.unwrap(), price_precision),
-                        close: Price::from_raw(close.unwrap(), price_precision),
-                        volume: Quantity::from_raw(volume.unwrap(), size_precision),
-                        ts_event: ts_event.unwrap(),
-                        ts_init: ts_init.unwrap(),
-                    }
-                    .into()
-                },
-            );
-
-        values.collect()
-    }
+use super::DecodeDataFromRecordBatch;
+use crate::arrow::{ArrowSchemaProvider, Data, DecodeFromRecordBatch, EncodeToRecordBatch};
 
+impl ArrowSchemaProvider for Bar {
     fn get_schema(metadata: std::collections::HashMap<String, String>) -> SchemaRef {
         let fields = vec![
             Field::new("open", DataType::Int64, false),
             Field::new("high", DataType::Int64, false),
             Field::new("low", DataType::Int64, false),
             Field::new("close", DataType::Int64, false),
             Field::new("volume", DataType::UInt64, false),
@@ -97,39 +56,128 @@
         .unwrap()
         .parse::<u8>()
         .unwrap();
 
     (bar_type, price_precision, size_precision)
 }
 
+impl EncodeToRecordBatch for Bar {
+    fn encode_batch(metadata: &HashMap<String, String>, data: &[Self]) -> RecordBatch {
+        // Create array builders
+        let mut open_builder = Int64Array::builder(data.len());
+        let mut high_builder = Int64Array::builder(data.len());
+        let mut low_builder = Int64Array::builder(data.len());
+        let mut close_builder = Int64Array::builder(data.len());
+        let mut volume_builder = UInt64Array::builder(data.len());
+        let mut ts_event_builder = UInt64Array::builder(data.len());
+        let mut ts_init_builder = UInt64Array::builder(data.len());
+
+        // Iterate over data
+        for bar in data {
+            open_builder.append_value(bar.open.raw);
+            high_builder.append_value(bar.high.raw);
+            low_builder.append_value(bar.low.raw);
+            close_builder.append_value(bar.close.raw);
+            volume_builder.append_value(bar.volume.raw);
+            ts_event_builder.append_value(bar.ts_event);
+            ts_init_builder.append_value(bar.ts_init);
+        }
+
+        // Build arrays
+        let open_array = open_builder.finish();
+        let high_array = high_builder.finish();
+        let low_array = low_builder.finish();
+        let close_array = close_builder.finish();
+        let volume_array = volume_builder.finish();
+        let ts_event_array = ts_event_builder.finish();
+        let ts_init_array = ts_init_builder.finish();
+
+        // Build record batch
+        RecordBatch::try_new(
+            Self::get_schema(metadata.clone()),
+            vec![
+                Arc::new(open_array),
+                Arc::new(high_array),
+                Arc::new(low_array),
+                Arc::new(close_array),
+                Arc::new(volume_array),
+                Arc::new(ts_event_array),
+                Arc::new(ts_init_array),
+            ],
+        )
+        .unwrap()
+    }
+}
+
+impl DecodeFromRecordBatch for Bar {
+    fn decode_batch(metadata: &HashMap<String, String>, record_batch: RecordBatch) -> Vec<Self> {
+        // Parse and validate metadata
+        let (bar_type, price_precision, size_precision) = parse_metadata(metadata);
+
+        // Extract field value arrays
+        let cols = record_batch.columns();
+        let open_values = cols[0].as_any().downcast_ref::<Int64Array>().unwrap();
+        let high_values = cols[1].as_any().downcast_ref::<Int64Array>().unwrap();
+        let low_values = cols[2].as_any().downcast_ref::<Int64Array>().unwrap();
+        let close_values = cols[3].as_any().downcast_ref::<Int64Array>().unwrap();
+        let volume_values = cols[4].as_any().downcast_ref::<UInt64Array>().unwrap();
+        let ts_event_values = cols[5].as_any().downcast_ref::<UInt64Array>().unwrap();
+        let ts_init_values = cols[6].as_any().downcast_ref::<UInt64Array>().unwrap();
+
+        // Construct iterator of values from arrays
+        let values = open_values
+            .into_iter()
+            .zip(high_values.iter())
+            .zip(low_values.iter())
+            .zip(close_values.iter())
+            .zip(volume_values.iter())
+            .zip(ts_event_values.iter())
+            .zip(ts_init_values.iter())
+            .map(
+                |((((((open, high), low), close), volume), ts_event), ts_init)| Self {
+                    bar_type,
+                    open: Price::from_raw(open.unwrap(), price_precision),
+                    high: Price::from_raw(high.unwrap(), price_precision),
+                    low: Price::from_raw(low.unwrap(), price_precision),
+                    close: Price::from_raw(close.unwrap(), price_precision),
+                    volume: Quantity::from_raw(volume.unwrap(), size_precision),
+                    ts_event: ts_event.unwrap(),
+                    ts_init: ts_init.unwrap(),
+                },
+            );
+
+        values.collect()
+    }
+}
+
+impl DecodeDataFromRecordBatch for Bar {
+    fn decode_data_batch(
+        metadata: &HashMap<String, String>,
+        record_batch: RecordBatch,
+    ) -> Vec<Data> {
+        let bars: Vec<Self> = Self::decode_batch(metadata, record_batch);
+        bars.into_iter().map(Data::from).collect()
+    }
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use std::{collections::HashMap, sync::Arc};
+    use std::sync::Arc;
 
     use datafusion::arrow::record_batch::RecordBatch;
 
     use super::*;
 
-    fn create_metadata() -> HashMap<String, String> {
-        let mut metadata = HashMap::new();
-        metadata.insert(
-            "bar_type".to_string(),
-            "AAPL.NASDAQ-1-MINUTE-LAST-INTERNAL".to_string(),
-        );
-        metadata.insert("price_precision".to_string(), "2".to_string());
-        metadata.insert("size_precision".to_string(), "0".to_string());
-        metadata
-    }
-
     #[test]
     fn test_get_schema() {
-        let metadata = create_metadata();
+        let bar_type = BarType::from_str("AAPL.NASDAQ-1-MINUTE-LAST-INTERNAL").unwrap();
+        let metadata = Bar::get_metadata(&bar_type, 2, 0);
         let schema = Bar::get_schema(metadata.clone());
         let expected_fields = vec![
             Field::new("open", DataType::Int64, false),
             Field::new("high", DataType::Int64, false),
             Field::new("low", DataType::Int64, false),
             Field::new("close", DataType::Int64, false),
             Field::new("volume", DataType::UInt64, false),
@@ -137,22 +185,85 @@
             Field::new("ts_init", DataType::UInt64, false),
         ];
         let expected_schema = Schema::new_with_metadata(expected_fields, metadata).into();
         assert_eq!(schema, expected_schema);
     }
 
     #[test]
+    fn test_encode_batch() {
+        let bar_type = BarType::from_str("AAPL.NASDAQ-1-MINUTE-LAST-INTERNAL").unwrap();
+        let metadata = Bar::get_metadata(&bar_type, 2, 0);
+
+        let bar1 = Bar::new(
+            bar_type,
+            Price::new(100.10, 2),
+            Price::new(102.00, 2),
+            Price::new(100.00, 2),
+            Price::new(101.00, 2),
+            Quantity::new(1100.0, 0),
+            1,
+            3,
+        );
+        let bar2 = Bar::new(
+            bar_type,
+            Price::new(100.00, 2),
+            Price::new(100.00, 2),
+            Price::new(100.00, 2),
+            Price::new(100.10, 2),
+            Quantity::new(1110.0, 0),
+            2,
+            4,
+        );
+
+        let data = vec![bar1, bar2];
+        let record_batch = Bar::encode_batch(&metadata, &data);
+
+        let columns = record_batch.columns();
+        let open_values = columns[0].as_any().downcast_ref::<Int64Array>().unwrap();
+        let high_values = columns[1].as_any().downcast_ref::<Int64Array>().unwrap();
+        let low_values = columns[2].as_any().downcast_ref::<Int64Array>().unwrap();
+        let close_values = columns[3].as_any().downcast_ref::<Int64Array>().unwrap();
+        let volume_values = columns[4].as_any().downcast_ref::<UInt64Array>().unwrap();
+        let ts_event_values = columns[5].as_any().downcast_ref::<UInt64Array>().unwrap();
+        let ts_init_values = columns[6].as_any().downcast_ref::<UInt64Array>().unwrap();
+
+        assert_eq!(columns.len(), 7);
+        assert_eq!(open_values.len(), 2);
+        assert_eq!(open_values.value(0), 100_100_000_000);
+        assert_eq!(open_values.value(1), 100_000_000_000);
+        assert_eq!(high_values.len(), 2);
+        assert_eq!(high_values.value(0), 102_000_000_000);
+        assert_eq!(high_values.value(1), 100_000_000_000);
+        assert_eq!(low_values.len(), 2);
+        assert_eq!(low_values.value(0), 100_000_000_000);
+        assert_eq!(low_values.value(1), 100_000_000_000);
+        assert_eq!(close_values.len(), 2);
+        assert_eq!(close_values.value(0), 101_000_000_000);
+        assert_eq!(close_values.value(1), 100_100_000_000);
+        assert_eq!(volume_values.len(), 2);
+        assert_eq!(volume_values.value(0), 1_100_000_000_000);
+        assert_eq!(volume_values.value(1), 1_110_000_000_000);
+        assert_eq!(ts_event_values.len(), 2);
+        assert_eq!(ts_event_values.value(0), 1);
+        assert_eq!(ts_event_values.value(1), 2);
+        assert_eq!(ts_init_values.len(), 2);
+        assert_eq!(ts_init_values.value(0), 3);
+        assert_eq!(ts_init_values.value(1), 4);
+    }
+
+    #[test]
     fn test_decode_batch() {
-        let metadata = create_metadata();
+        let bar_type = BarType::from_str("AAPL.NASDAQ-1-MINUTE-LAST-INTERNAL").unwrap();
+        let metadata = Bar::get_metadata(&bar_type, 2, 0);
 
-        let open = Int64Array::from(vec![10010, 10000]);
-        let high = Int64Array::from(vec![10200, 10000]);
-        let low = Int64Array::from(vec![10000, 10000]);
-        let close = Int64Array::from(vec![10100, 10010]);
-        let volume = UInt64Array::from(vec![110, 100]);
+        let open = Int64Array::from(vec![100_100_000_000, 10_000_000_000]);
+        let high = Int64Array::from(vec![102_000_000_000, 10_000_000_000]);
+        let low = Int64Array::from(vec![100_000_000_000, 10_000_000_000]);
+        let close = Int64Array::from(vec![101_000_000_000, 10_010_000_000]);
+        let volume = UInt64Array::from(vec![11_000_000_000, 10_000_000_000]);
         let ts_event = UInt64Array::from(vec![1, 2]);
         let ts_init = UInt64Array::from(vec![3, 4]);
 
         let record_batch = RecordBatch::try_new(
             Bar::get_schema(metadata.clone()),
             vec![
                 Arc::new(open),
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/mod.rs` & `nautilus_trader-1.176.0/nautilus_trader/core/data.pxd`

 * *Files 11% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
 
-mod bar;
-mod delta;
-mod quote;
-mod trade;
+
+cdef class Data:
+    pass
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/src/session.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/src/backend/session.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,32 +9,32 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::vec::IntoIter;
+use std::{collections::HashMap, vec::IntoIter};
 
 use compare::Compare;
 use datafusion::{error::Result, physical_plan::SendableRecordBatchStream, prelude::*};
 use futures::{executor::block_on, Stream, StreamExt};
 use nautilus_core::cvec::CVec;
 use nautilus_model::data::{
-    bar::Bar,
-    book::OrderBookDelta,
-    tick::{QuoteTick, TradeTick},
-    Data,
+    bar::Bar, delta::OrderBookDelta, quote::QuoteTick, trade::TradeTick, Data,
 };
 use pyo3::{prelude::*, types::PyCapsule};
 use pyo3_asyncio::tokio::get_runtime;
 
 use crate::{
+    arrow::{
+        DataStreamingError, DecodeDataFromRecordBatch, EncodeToRecordBatch, NautilusDataType,
+        WriteStream,
+    },
     kmerge_batch::{KMerge, PeekElementBatchStream},
-    parquet::{DecodeDataFromRecordBatch, ParquetType},
 };
 
 #[derive(Debug, Default)]
 pub struct TsInitComparator;
 
 impl<S> Compare<PeekElementBatchStream<S, Data>> for TsInitComparator
 where
@@ -46,36 +46,58 @@
         r: &PeekElementBatchStream<S, Data>,
     ) -> std::cmp::Ordering {
         // Max heap ordering must be reversed
         l.item.get_ts_init().cmp(&r.item.get_ts_init()).reverse()
     }
 }
 
+pub struct QueryResult<T = Data> {
+    data: Box<dyn Stream<Item = Vec<T>> + Unpin>,
+}
+
+impl Iterator for QueryResult {
+    type Item = Vec<Data>;
+
+    fn next(&mut self) -> Option<Self::Item> {
+        block_on(self.data.next())
+    }
+}
+
 /// Provides a DataFusion session and registers DataFusion queries.
 ///
 /// The session is used to register data sources and make queries on them. A
 /// query returns a Chunk of Arrow records. It is decoded and converted into
-/// a Vec of data by types that implement [`DecodeDataFromRecordBatch`].
+/// a Vec of data by types that implement [`DecodeFromRecordBatch`].
 #[pyclass]
 pub struct DataBackendSession {
     session_ctx: SessionContext,
-    batch_streams: Vec<Box<dyn Stream<Item = IntoIter<Data>> + Unpin>>,
-    chunk_size: usize,
+    batch_streams: Vec<Box<dyn Stream<Item = IntoIter<Data>> + Unpin + Send + 'static>>,
+    pub chunk_size: usize,
 }
 
 impl DataBackendSession {
     #[must_use]
     pub fn new(chunk_size: usize) -> Self {
         Self {
             session_ctx: SessionContext::default(),
             batch_streams: Vec::default(),
             chunk_size,
         }
     }
 
+    pub fn write_data<T: EncodeToRecordBatch>(
+        data: &[T],
+        metadata: &HashMap<String, String>,
+        stream: &mut dyn WriteStream,
+    ) -> Result<(), DataStreamingError> {
+        let record_batch = T::encode_batch(metadata, data);
+        stream.write(&record_batch)?;
+        Ok(())
+    }
+
     // Query a file for all it's records. the caller must specify `T` to indicate
     // the kind of data expected from this query.
     pub async fn add_file_default_query<T>(
         &mut self,
         table_name: &str,
         file_path: &str,
     ) -> Result<()>
@@ -136,58 +158,44 @@
     }
 
     fn add_batch_stream<T>(&mut self, stream: SendableRecordBatchStream)
     where
         T: DecodeDataFromRecordBatch + Into<Data>,
     {
         let transform = stream.map(|result| match result {
-            Ok(batch) => T::decode_batch(batch.schema().metadata(), batch).into_iter(),
+            Ok(batch) => T::decode_data_batch(batch.schema().metadata(), batch).into_iter(),
             Err(_err) => panic!("Error getting next batch from RecordBatchStream"),
         });
 
         self.batch_streams.push(Box::new(transform));
     }
 
-    // Consumes the registered queries and returns a [QueryResult].
+    // Consumes the registered queries and returns a [`QueryResult].
     // Passes the output of the query though the a KMerge which sorts the
     // queries in ascending order of `ts_init`.
     // QueryResult is an iterator that return Vec<Data>.
-    pub fn get_query_result(&mut self) -> QueryResult<Data> {
+    pub async fn get_query_result(&mut self) -> QueryResult<Data> {
         // TODO: No need to kmerge if there is only one batch stream
         let mut kmerge: KMerge<_, _, _> = KMerge::new(TsInitComparator);
 
-        Iterator::for_each(self.batch_streams.drain(..), |batch_stream| {
-            block_on(kmerge.push_stream(batch_stream));
-        });
+        kmerge.push_iter_stream(self.batch_streams.drain(..)).await;
 
         QueryResult {
             data: Box::new(kmerge.chunks(self.chunk_size)),
         }
     }
 }
 
-pub struct QueryResult<T = Data> {
-    data: Box<dyn Stream<Item = Vec<T>> + Unpin>,
-}
-
-impl Iterator for QueryResult {
-    type Item = Vec<Data>;
-
-    fn next(&mut self) -> Option<Self::Item> {
-        block_on(self.data.next())
-    }
-}
+// Note: Intended to be used on a single python thread
+unsafe impl Send for DataBackendSession {}
 
 ////////////////////////////////////////////////////////////////////////////////
-/// Python API
+// Python API
 ////////////////////////////////////////////////////////////////////////////////
 
-// Note: Intended to be used on a single python thread
-unsafe impl Send for DataBackendSession {}
-
 #[pymethods]
 impl DataBackendSession {
     #[new]
     #[pyo3(signature=(chunk_size=5000))]
     #[must_use]
     pub fn new_session(chunk_size: usize) -> Self {
         // Initialize runtime here
@@ -195,102 +203,100 @@
         Self::new(chunk_size)
     }
 
     pub fn add_file(
         mut slf: PyRefMut<'_, Self>,
         table_name: &str,
         file_path: &str,
-        parquet_type: ParquetType,
+        data_type: NautilusDataType,
     ) {
         let rt = get_runtime();
         let _guard = rt.enter();
 
-        match parquet_type {
-            ParquetType::OrderBookDelta => {
+        match data_type {
+            NautilusDataType::OrderBookDelta => {
                 match block_on(slf.add_file_default_query::<OrderBookDelta>(table_name, file_path))
                 {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
-            ParquetType::QuoteTick => {
+            NautilusDataType::QuoteTick => {
                 match block_on(slf.add_file_default_query::<QuoteTick>(table_name, file_path)) {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
-            ParquetType::TradeTick => {
+            NautilusDataType::TradeTick => {
                 match block_on(slf.add_file_default_query::<TradeTick>(table_name, file_path)) {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
-            ParquetType::Bar => {
+            NautilusDataType::Bar => {
                 match block_on(slf.add_file_default_query::<Bar>(table_name, file_path)) {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
         }
     }
 
     pub fn add_file_with_query(
         mut slf: PyRefMut<'_, Self>,
         table_name: &str,
         file_path: &str,
         sql_query: &str,
-        parquet_type: ParquetType,
+        data_type: NautilusDataType,
     ) {
         let rt = get_runtime();
         let _guard = rt.enter();
 
-        match parquet_type {
-            ParquetType::OrderBookDelta => {
+        match data_type {
+            NautilusDataType::OrderBookDelta => {
                 match block_on(
                     slf.add_file_with_custom_query::<OrderBookDelta>(
                         table_name, file_path, sql_query,
                     ),
                 ) {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
-            ParquetType::QuoteTick => {
+            NautilusDataType::QuoteTick => {
                 match block_on(
                     slf.add_file_with_custom_query::<QuoteTick>(table_name, file_path, sql_query),
                 ) {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
-            ParquetType::TradeTick => {
+            NautilusDataType::TradeTick => {
                 match block_on(
                     slf.add_file_with_custom_query::<TradeTick>(table_name, file_path, sql_query),
                 ) {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
-            ParquetType::Bar => {
+            NautilusDataType::Bar => {
                 match block_on(
                     slf.add_file_with_custom_query::<Bar>(table_name, file_path, sql_query),
                 ) {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
         }
     }
 
     #[must_use]
     pub fn to_query_result(mut slf: PyRefMut<'_, Self>) -> DataQueryResult {
         let rt = get_runtime();
-        let _guard = rt.enter();
-
-        let query_result = slf.get_query_result();
+        let query_result = rt.block_on(slf.get_query_result());
         DataQueryResult::new(query_result)
     }
 }
 
 #[pyclass]
 pub struct DataQueryResult {
     result: QueryResult<Data>,
@@ -314,24 +320,23 @@
         slf.result.next().map(|chunk| {
             let cvec = chunk.into();
             Python::with_gil(|py| PyCapsule::new::<CVec>(py, cvec, None).unwrap().into_py(py))
         })
     }
 }
 
-// Note: Intended to be used on a single python thread
-unsafe impl Send for DataQueryResult {}
-
 impl DataQueryResult {
-    fn new(result: QueryResult<Data>) -> Self {
+    #[must_use]
+    pub fn new(result: QueryResult<Data>) -> Self {
         Self {
             result,
             chunk: None,
         }
     }
+
     /// Chunks generated by iteration must be dropped after use, otherwise
     /// it will leak memory. Current chunk is held by the reader,
     /// drop if exists and reset the field.
     fn drop_chunk(&mut self) {
         if let Some(CVec { ptr, len, cap }) = self.chunk.take() {
             let data: Vec<Data> =
                 unsafe { Vec::from_raw_parts(ptr.cast::<nautilus_model::data::Data>(), len, cap) };
@@ -341,7 +346,10 @@
 }
 
 impl Drop for DataQueryResult {
     fn drop(&mut self) {
         self.drop_chunk();
     }
 }
+
+// Note: Intended to be used on a single python thread
+unsafe impl Send for DataQueryResult {}
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_catalog.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/tests/test_catalog.rs`

 * *Files 24% similar despite different names*

```diff
@@ -9,88 +9,116 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_model::data::{
-    tick::{QuoteTick, TradeTick},
-    Data,
+use nautilus_core::cvec::CVec;
+use nautilus_model::data::{delta::OrderBookDelta, quote::QuoteTick, trade::TradeTick, Data};
+use nautilus_persistence::{
+    arrow::NautilusDataType,
+    backend::session::{DataBackendSession, QueryResult},
 };
-use nautilus_persistence::session::{DataBackendSession, QueryResult};
+use pyo3::{types::PyCapsule, IntoPy, Py, PyAny, Python};
 
-// Note: "current_thread" configuration hangs up for some reason
-#[tokio::test(flavor = "multi_thread")]
+#[tokio::test]
 async fn test_quote_ticks() {
     let file_path = "../../tests/test_data/quote_tick_data.parquet";
-    let length = 9500;
-    let mut catalog = DataBackendSession::new(10000);
+    let length = 9_500;
+    let mut catalog = DataBackendSession::new(10_000);
     catalog
         .add_file_default_query::<QuoteTick>("quotes_0005", file_path)
         .await
         .unwrap();
-    let query_result: QueryResult = catalog.get_query_result();
+    let query_result: QueryResult = catalog.get_query_result().await;
     let ticks: Vec<Data> = query_result.flatten().collect();
 
-    // NOTE: is_sorted_by_key is unstable otherwise use
-    // ticks.is_sorted_by_key(|tick| tick.ts_init)
-    // https://github.com/rust-lang/rust/issues/53485
-    let is_ascending_by_init = |ticks: &Vec<Data>| {
-        for i in 1..ticks.len() {
-            // previous tick is more recent than current tick
-            // this is not ascending order
-            if ticks[i - 1].get_ts_init() > ticks[i].get_ts_init() {
-                return false;
-            }
-        }
-        true
-    };
-
     if let Data::Quote(q) = &ticks[0] {
         assert_eq!("EUR/USD.SIM", q.instrument_id.to_string())
     } else {
         assert!(false)
     }
 
     assert_eq!(ticks.len(), length);
     assert!(is_ascending_by_init(&ticks));
 }
 
-// Note: "current_thread" hangs up for some reason
-#[tokio::test(flavor = "multi_thread")]
+#[tokio::test]
 async fn test_data_ticks() {
-    let mut catalog = DataBackendSession::new(5000);
+    let mut catalog = DataBackendSession::new(5_000);
     catalog
         .add_file_default_query::<QuoteTick>(
             "quote_tick",
             "../../tests/test_data/quote_tick_data.parquet",
         )
         .await
         .unwrap();
     catalog
         .add_file_default_query::<TradeTick>(
             "quote_tick_2",
             "../../tests/test_data/trade_tick_data.parquet",
         )
         .await
         .unwrap();
-    let query_result: QueryResult = catalog.get_query_result();
+    let query_result: QueryResult = catalog.get_query_result().await;
     let ticks: Vec<Data> = query_result.flatten().collect();
 
-    // NOTE: is_sorted_by_key is unstable otherwise use
-    // ticks.is_sorted_by_key(|tick| tick.ts_init)
-    // https://github.com/rust-lang/rust/issues/53485
-    let is_ascending_by_init = |ticks: &Vec<Data>| {
-        for i in 1..ticks.len() {
-            // previous tick is more recent than current tick
-            // this is not ascending order
-            if ticks[i - 1].get_ts_init() > ticks[i].get_ts_init() {
-                return false;
-            }
-        }
-        true
-    };
-
     assert_eq!(ticks.len(), 9600);
     assert!(is_ascending_by_init(&ticks));
 }
+
+#[tokio::test]
+async fn test_order_book_delta() {
+    let file_path = "../../tests/test_data/order_book_deltas.parquet";
+    let mut catalog = DataBackendSession::new(1000);
+    catalog
+        .add_file_default_query::<OrderBookDelta>("order_book_delta", file_path)
+        .await
+        .unwrap();
+    let query_result: QueryResult = catalog.get_query_result().await;
+    let ticks: Vec<Data> = query_result.flatten().collect();
+
+    assert_eq!(ticks.len(), 1077);
+    assert!(is_ascending_by_init(&ticks));
+}
+
+#[test]
+fn test_order_book_delta_py() {
+    pyo3::prepare_freethreaded_python();
+
+    let file_path = "../../tests/test_data/order_book_deltas.parquet";
+    let catalog = DataBackendSession::new(2000);
+    Python::with_gil(|py| {
+        let pycatalog: Py<PyAny> = catalog.into_py(py);
+        pycatalog
+            .call_method1(
+                py,
+                "add_file",
+                (
+                    "order_book_deltas",
+                    file_path,
+                    NautilusDataType::OrderBookDelta,
+                ),
+            )
+            .unwrap();
+        let result = pycatalog.call_method0(py, "to_query_result").unwrap();
+        let chunk = result.call_method0(py, "__next__").unwrap();
+        let capsule: &PyCapsule = chunk.downcast(py).unwrap();
+        let cvec: &CVec = unsafe { &*(capsule.pointer() as *const CVec) };
+        assert_eq!(cvec.len, 1077);
+    });
+}
+
+// NOTE: is_sorted_by_key is unstable otherwise use
+// ticks.is_sorted_by_key(|tick| tick.ts_init)
+// https://github.com/rust-lang/rust/issues/53485
+fn is_ascending_by_init(ticks: &Vec<Data>) -> bool {
+    for i in 1..ticks.len() {
+        // previous tick is more recent than current tick
+        // this is not ascending order
+        if ticks[i - 1].get_ts_init() > ticks[i].get_ts_init() {
+            return false;
+        }
+    }
+    true
+}
```

### Comparing `nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_util.rs` & `nautilus_trader-1.176.0/nautilus_core/persistence/tests/test_util.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/pyo3/Cargo.toml` & `nautilus_trader-1.176.0/nautilus_core/pyo3/Cargo.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_core/pyo3/src/lib.rs` & `nautilus_trader-1.176.0/nautilus_core/pyo3/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 The top-level package contains all sub-packages needed for NautilusTrader.
 """
 
 import os
 
 import toml
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/accounting/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,18 +8,19 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `accounting` subpackage defines both different account types and account management machinery.
+The `accounting` subpackage defines both different account types and account management
+machinery.
 
 There is also an `ExchangeRateCalculator` for calculating the exchange rate between FX and/or Crypto
 pairs. The `AccountManager` is mainly used from the `Portfolio` to manage accounting operations.
 
 The `AccountFactory` supports customized account types for specific integrations. These custom
 account types can be registered with the factory and will then be instantiated when an `AccountState`
 event is received for that integration.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/betting.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pyx` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/betting.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/cash.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pyx` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/cash.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/margin.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pyx` & `nautilus_trader-1.176.0/nautilus_trader/accounting/accounts/margin.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/calculators.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pyx` & `nautilus_trader-1.176.0/nautilus_trader/accounting/calculators.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/error.py` & `nautilus_trader-1.176.0/nautilus_trader/accounting/error.py`

 * *Files 0% similar despite different names*

```diff
@@ -40,14 +40,15 @@
 
 
 class AccountMarginExceeded(AccountError):
     """
     Raised when the account margin for a currency is exceeded.
 
     In this scenario some form of liquidation event will occur.
+
     """
 
     def __init__(self, balance: Decimal, margin: Decimal, currency: Currency):
         super().__init__()
 
         self.balance = balance
         self.margin = margin
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/factory.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pyx` & `nautilus_trader-1.176.0/nautilus_trader/accounting/factory.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pxd` & `nautilus_trader-1.176.0/nautilus_trader/accounting/manager.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pyx` & `nautilus_trader-1.176.0/nautilus_trader/accounting/manager.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -278,33 +278,26 @@
         AccountState or ``None``
 
         """
         Condition.not_none(account, "account")
         Condition.not_none(instrument, "instrument")
         Condition.not_none(orders_open, "orders_open")
 
-        if not orders_open:
-            account.clear_margin_init(instrument.id)
-            return self._generate_account_state(
-                account=account,
-                ts_event=ts_event,
-            )
-
         cdef double total_margin_init = 0.0
         cdef double base_xrate = 0.0
 
         cdef Currency currency = instrument.get_settlement_currency()
         cdef:
             Order order
             double margin_init
         for order in orders_open:
             assert order.instrument_id == instrument.id, f"order not for instrument {instrument}"
-            assert order.is_open_c(), f"order not open {repr(order)}"
 
-            if not order.has_price_c() and not order.has_trigger_price_c():
+            if not order.is_open_c() or (not order.has_price_c() and not order.has_trigger_price_c()):
+                # Does not contribute to initial margin
                 continue
 
             # Calculate initial margin
             margin_init = account.calculate_margin_init(
                 instrument,
                 order.quantity,
                 order.price if order.has_price_c() else order.trigger_price,
@@ -331,15 +324,18 @@
                 # Apply base xrate
                 margin_init = round(margin_init * base_xrate, currency.get_precision())
 
             # Increment total initial margin
             total_margin_init += margin_init
 
         cdef Money margin_init_money = Money(total_margin_init, currency)
-        account.update_margin_init(instrument.id, margin_init_money)
+        if total_margin_init == 0.0:
+            account.clear_margin_init(instrument.id)
+        else:
+            account.update_margin_init(instrument.id, margin_init_money)
 
         self._log.info(f"{instrument.id} margin_init={margin_init_money.to_str()}")
 
         return self._generate_account_state(
             account=account,
             ts_event=ts_event,
         )
@@ -372,31 +368,27 @@
         AccountState or ``None``
 
         """
         Condition.not_none(account, "account")
         Condition.not_none(instrument, "instrument")
         Condition.not_none(positions_open, "positions_open")
 
-        if not positions_open:
-            account.clear_margin_maint(instrument.id)
-            return self._generate_account_state(
-                account=account,
-                ts_event=ts_event,
-            )
-
         cdef double total_margin_maint = 0.0
         cdef double base_xrate = 0.0
 
         cdef Currency currency = instrument.get_settlement_currency()
         cdef:
             Position position
             double margin_maint
         for position in positions_open:
             assert position.instrument_id == instrument.id
-            assert position.is_open_c()
+
+            if not position.is_open_c():
+                # Does not contribute to maintenance margin
+                continue
 
             # Calculate margin
             margin_maint = account.calculate_margin_maint(
                 instrument,
                 position.side,
                 position.quantity,
                 instrument.make_price(position.avg_px_open),  # TODO(cs): Temporary pending refactor
@@ -423,17 +415,20 @@
                 # Apply base xrate
                 margin_maint = round(margin_maint * base_xrate, currency.get_precision())
 
             # Increment total maintenance margin
             total_margin_maint += margin_maint
 
         cdef Money margin_maint_money = Money(total_margin_maint, currency)
-        account.update_margin_maint(instrument.id, margin_maint_money)
+        if total_margin_maint == 0.0:
+            account.clear_margin_maint(instrument.id)
+        else:
+            account.update_margin_maint(instrument.id, margin_maint_money)
 
-        # self._log.info(f"{instrument.id} margin_maint={margin_maint_money.to_str()}")
+        self._log.info(f"{instrument.id} margin_maint={margin_maint_money.to_str()}")
 
         return self._generate_account_state(
             account=account,
             ts_event=ts_event,
         )
 
     cdef void _update_balance_single_currency(
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,14 +8,16 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `adapters` subpackage provides integrations for data providers, brokerages, and exchanges.
+The `adapters` subpackage provides integrations for data providers, brokerages, and
+exchanges.
+
+Generally each integration will implement lower level HTTP REST and/or WebSocket clients
+for the exchange/venue API, which the rest of the components can then be built on top
+of.
 
-Generally each integration will implement lower level HTTP REST and/or WebSocket clients for the
-exchange/venue API, which the rest of the components can then be built on top of.
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/_template/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/core.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/_template/core.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/data.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/_template/data.py`

 * *Files 0% similar despite different names*

```diff
@@ -53,14 +53,15 @@
     | dispose                               | optional    |
     +---------------------------------------+-------------+
     | _subscribe                            | optional    |
     | _unsubscribe                          | optional    |
     +---------------------------------------+-------------+
     | _request                              | optional    |
     +---------------------------------------+-------------+
+
     """
 
     async def _connect(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def _disconnect(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
@@ -83,15 +84,16 @@
 
     async def _request(self, data_type: DataType, correlation_id: UUID4) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
 
 class TemplateLiveMarketDataClient(LiveMarketDataClient):
     """
-    An example of a ``LiveMarketDataClient`` highlighting the overridable abstract methods.
+    An example of a ``LiveMarketDataClient`` highlighting the overridable abstract
+    methods.
 
     A live market data client general handles market data feeds and requests.
 
     +----------------------------------------+-------------+
     | Method                                 | Requirement |
     +----------------------------------------+-------------+
     | _connect                               | required    |
@@ -125,14 +127,15 @@
     | _request                               | optional    |
     | _request_instrument                    | optional    |
     | _request_instruments                   | optional    |
     | _request_quote_ticks                   | optional    |
     | _request_trade_ticks                   | optional    |
     | _request_bars                          | optional    |
     +----------------------------------------+-------------+
+
     """
 
     async def _connect(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def _disconnect(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
@@ -155,24 +158,24 @@
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def _subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: Optional[int] = None,
-        kwargs: dict = None,
+        kwargs: Optional[dict] = None,
     ) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def _subscribe_order_book_snapshots(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: Optional[int] = None,
-        kwargs: dict = None,
+        kwargs: Optional[dict] = None,
     ) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def _subscribe_ticker(self, instrument_id: InstrumentId) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def _subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/_template/execution.py`

 * *Files 3% similar despite different names*

```diff
@@ -43,38 +43,39 @@
 # *** THESE PRAGMA: NO COVER COMMENTS MUST BE REMOVED IN ANY IMPLEMENTATION. ***
 
 
 class TemplateLiveExecutionClient(LiveExecutionClient):
     """
     An example of a ``LiveExecutionClient`` highlighting the method requirements.
 
-    +----------------------------------+-------------+
-    | Method                           | Requirement |
-    +----------------------------------+-------------+
-    | _connect                         | required    |
-    | _disconnect                      | required    |
-    | reset                            | optional    |
-    | dispose                          | optional    |
-    +------------------------------------------------+
-    | _submit_order                    | required    |
-    | _submit_order_list               | required    |
-    | _modify_order                    | required    |
-    | _cancel_order                    | required    |
-    | _cancel_all_orders               | required    |
-    | generate_order_status_report     | required    |
-    | generate_order_status_reports    | required    |
-    | generate_trade_reports           | required    |
-    | generate_position_status_reports | required    |
-    +------------------------------------------------+
+    +--------------------------------------------+-------------+
+    | Method                                     | Requirement |
+    +--------------------------------------------+-------------+
+    | _connect                                   | required    |
+    | _disconnect                                | required    |
+    | reset                                      | optional    |
+    | dispose                                    | optional    |
+    +--------------------------------------------+-------------+
+    | _submit_order                              | required    |
+    | _submit_order_list                         | required    |
+    | _modify_order                              | required    |
+    | _cancel_order                              | required    |
+    | _cancel_all_orders                         | required    |
+    | generate_order_status_report               | required    |
+    | generate_order_status_reports              | required    |
+    | generate_trade_reports                     | required    |
+    | generate_position_status_reports           | required    |
+    +--------------------------------------------+-------------+
+
     """
 
-    def _connect(self) -> None:
+    async def _connect(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    def _disconnect(self) -> None:
+    async def _disconnect(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     def reset(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     def dispose(self) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
@@ -87,33 +88,33 @@
         client_order_id: Optional[ClientOrderId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
     ) -> Optional[OrderStatusReport]:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_order_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
         open_only: bool = False,
     ) -> list[OrderStatusReport]:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_trade_reports(
         self,
-        instrument_id: InstrumentId = None,
-        venue_order_id: VenueOrderId = None,
+        instrument_id: Optional[InstrumentId] = None,
+        venue_order_id: Optional[VenueOrderId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[TradeReport]:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_position_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[PositionStatusReport]:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     # -- COMMAND HANDLERS -------------------------------------------------------------------------
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/providers.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/_template/providers.py`

 * *Files 5% similar despite different names*

```diff
@@ -28,16 +28,16 @@
 # is for all method implementations to be fully covered by tests.
 
 # *** THESE PRAGMA: NO COVER COMMENTS MUST BE REMOVED IN ANY IMPLEMENTATION. ***
 
 
 class TemplateInstrumentProvider(InstrumentProvider):
     """
-    An example template of an ``InstrumentProvider`` showing the minimal methods
-    which must be implemented for an integration to be complete.
+    An example template of an ``InstrumentProvider`` showing the minimal methods which
+    must be implemented for an integration to be complete.
     """
 
     async def load_all_async(self, filters: Optional[dict] = None) -> None:
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def load_ids_async(
         self,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,11 +8,10 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 Provides an API integration for the Betfair spots betting exchange.
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/core.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/client.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,307 +9,280 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import asyncio
-import datetime
-import pathlib
-import ssl
-from typing import Optional
-
-import msgspec
-from aiohttp import ClientResponse
-from aiohttp import ClientResponseError
+from typing import Literal, Optional
+
+from betfair_parser.endpoints import ENDPOINTS
+from betfair_parser.spec.accounts.operations import GetAccountDetails
+from betfair_parser.spec.accounts.operations import GetAccountFunds
+from betfair_parser.spec.accounts.type_definitions import AccountDetailsResponse
+from betfair_parser.spec.accounts.type_definitions import AccountFundsResponse
+from betfair_parser.spec.betting.enums import BetStatus
+from betfair_parser.spec.betting.enums import GroupBy
+from betfair_parser.spec.betting.enums import MarketProjection
+from betfair_parser.spec.betting.enums import MarketSort
+from betfair_parser.spec.betting.enums import OrderBy
+from betfair_parser.spec.betting.enums import OrderProjection
+from betfair_parser.spec.betting.enums import Side
+from betfair_parser.spec.betting.enums import SortDir
+from betfair_parser.spec.betting.listings import ListMarketCatalogue
+from betfair_parser.spec.betting.orders import CancelOrders
+from betfair_parser.spec.betting.orders import ListClearedOrders
+from betfair_parser.spec.betting.orders import ListCurrentOrders
+from betfair_parser.spec.betting.orders import PlaceOrders
+from betfair_parser.spec.betting.orders import ReplaceOrders
+from betfair_parser.spec.betting.orders import _CancelOrdersParams
+from betfair_parser.spec.betting.orders import _PlaceOrdersParams
+from betfair_parser.spec.betting.orders import _ReplaceOrdersParams
+from betfair_parser.spec.betting.type_definitions import CancelExecutionReport
+from betfair_parser.spec.betting.type_definitions import ClearedOrderSummary
+from betfair_parser.spec.betting.type_definitions import ClearedOrderSummaryReport
+from betfair_parser.spec.betting.type_definitions import CurrentOrderSummary
+from betfair_parser.spec.betting.type_definitions import CurrentOrderSummaryReport
+from betfair_parser.spec.betting.type_definitions import MarketCatalogue
+from betfair_parser.spec.betting.type_definitions import MarketFilter
+from betfair_parser.spec.betting.type_definitions import PlaceExecutionReport
+from betfair_parser.spec.betting.type_definitions import ReplaceExecutionReport
+from betfair_parser.spec.betting.type_definitions import RunnerId
+from betfair_parser.spec.common import BetId
+from betfair_parser.spec.common import CustomerOrderRef
+from betfair_parser.spec.common import CustomerStrategyRef
+from betfair_parser.spec.common import EventId
+from betfair_parser.spec.common import EventTypeId
+from betfair_parser.spec.common import MarketId
+from betfair_parser.spec.common import Request
+from betfair_parser.spec.common import TimeRange
+from betfair_parser.spec.identity import KeepAlive
+from betfair_parser.spec.identity import Login
+from betfair_parser.spec.identity import LoginResponse
+from betfair_parser.spec.identity import LoginStatus
+from betfair_parser.spec.navigation import Menu
 from betfair_parser.spec.navigation import Navigation
 
-from nautilus_trader.adapters.betfair.client.enums import MarketProjection
-from nautilus_trader.adapters.betfair.client.enums import MarketSort
-from nautilus_trader.adapters.betfair.client.exceptions import BetfairAPIError
-from nautilus_trader.adapters.betfair.client.exceptions import BetfairError
-from nautilus_trader.adapters.betfair.client.spec import ClearedOrder
-from nautilus_trader.adapters.betfair.client.spec import ClearedOrdersResponse
-from nautilus_trader.adapters.betfair.client.util import parse_params
 from nautilus_trader.common.logging import Logger
-from nautilus_trader.network.http import HttpClient
+from nautilus_trader.common.logging import LoggerAdapter
+from nautilus_trader.core.nautilus_pyo3.network import HttpClient
+from nautilus_trader.core.nautilus_pyo3.network import HttpResponse
+from nautilus_trader.core.rust.common import LogColor
 
 
-class BetfairClient(HttpClient):
+class BetfairHttpClient:
     """
     Provides a HTTP client for `Betfair`.
     """
 
-    IDENTITY_URL = "https://identitysso-cert.betfair.com/api/"
-    BASE_URL = "https://api.betfair.com/exchange/"
-    NAVIGATION_URL = BASE_URL + "betting/rest/v1/en/navigation/menu.json"
-    ACCOUNT_URL = BASE_URL + "account/json-rpc/v1"
-    BETTING_URL = BASE_URL + "betting/json-rpc/v1"
-    JSON_RPC_DEFAULTS = {"jsonrpc": "2.0", "id": 1}
-
     def __init__(
         self,
         username: str,
         password: str,
         app_key: str,
-        cert_dir: str,
-        loop: asyncio.AbstractEventLoop,
         logger: Logger,
-        ssl: Optional[ssl.SSLContext] = None,
     ):
-        super().__init__(
-            loop=loop,
-            logger=logger,
-            ssl=ssl,
-            ssl_context=ssl or self.ssl_context(cert_dir=cert_dir),
-            connector_kwargs={"enable_cleanup_closed": True, "force_close": True},
-        )
+        # Config
         self.username = username
         self.password = password
         self.app_key = app_key
-        self.session_token: Optional[str] = None
+
+        # Client
+        self._client = HttpClient()
+        self._headers: dict[str, str] = {}
+        self._log = LoggerAdapter(type(self).__name__, logger)
+        self.reset_headers()
+
+    async def _request(self, method: Literal["GET", "POST"], request: Request) -> HttpResponse:
+        url = ENDPOINTS.url_for_request(request)
+        headers = self._headers
+        body = request.body()
+        if isinstance(body, str):
+            body = body.encode()
+        response: HttpResponse = await self._client.request(
+            method,
+            url,
+            headers=headers,
+            body=body,
+        )
+        return response
+
+    async def _post(self, request: Request) -> Request.return_type:
+        response: HttpResponse = await self._request("POST", request)
+        return request.parse_response(response.body, raise_errors=True)
+
+    async def _get(self, request: Request) -> Request.return_type:
+        response: HttpResponse = await self._request("GET", request)
+        return request.parse_response(response.body, raise_errors=True)
 
     @property
-    def headers(self):
-        auth = {"X-Authentication": self.session_token} if self.session_token else {}
-        return {
-            "Accept-Encoding": "gzip, deflate",
-            "Connection": "keep-alive",
-            "content-type": "application/json",
-            "X-Application": self.app_key,
-            **auth,
-        }
+    def session_token(self) -> Optional[str]:
+        return self._headers.get("X-Authentication")
 
-    @staticmethod
-    def ssl_context(cert_dir):
-        files = list(pathlib.Path(cert_dir).glob("*"))
-        cert_file = next(p for p in files if p.suffix == ".crt")
-        key_file = next(p for p in files if p.suffix == ".key")
-        context = ssl.create_default_context()
-        context.load_cert_chain(certfile=cert_file, keyfile=key_file)
-        return context
-
-    # For testing purposes, can't mock HttpClient.request due to cython
-    async def request(self, method, url, **kwargs) -> ClientResponse:
-        return await super().request(method=method, url=url, **kwargs)
+    def update_headers(self, login_resp: LoginResponse):
+        self._headers.update(
+            {
+                "X-Authentication": login_resp.token,
+                "X-Application": login_resp.product,
+            },
+        )
 
-    async def rpc_post(
-        self,
-        url,
-        method,
-        params: Optional[dict] = None,
-        data: Optional[dict] = None,
-    ) -> dict:
-        data = {**self.JSON_RPC_DEFAULTS, "method": method, **(data or {}), "params": params or {}}
-        try:
-            resp = await self.request(method="POST", url=url, headers=self.headers, json=data)
-            data = msgspec.json.decode(resp.data)
-            if "error" in data:
-                self._log.error(str(data))
-                raise BetfairAPIError(code=data["error"]["code"], message=data["error"]["message"])
-            if isinstance(data, dict):
-                return data["result"]
-            else:
-                raise TypeError("Unexpected type:" + str(resp))
-        except BetfairError as e:
-            self._log.error(str(e))
-            raise e
-        except ClientResponseError as e:
-            self._log.error(f"Err on {method} status={e.status}, message={e!s}")
-            raise e
+    def reset_headers(self):
+        self._headers = {
+            "Accept": "application/json",
+            "Content-Type": "application/x-www-form-urlencoded",
+            "X-Application": self.app_key,
+        }
 
     async def connect(self):
-        await super().connect()
-        await self.login()
+        if self.session_token is not None:
+            self._log.warning("Session token exists (already connected), skipping.")
+            return
+
+        self._log.info("Connecting (Betfair login)")
+        request = Login.with_params(username=self.username, password=self.password)
+        resp: LoginResponse = await self._post(request)
+        assert resp.status == LoginStatus.SUCCESS
+        self._log.info("Login success.", color=LogColor.GREEN)
+        self.update_headers(login_resp=resp)
 
     async def disconnect(self):
         self._log.info("Disconnecting..")
-        self.session_token = None
-        await super().disconnect()
+        self.reset_headers()
         self._log.info("Disconnected.")
 
-    async def login(self):
-        self._log.debug("BetfairClient login")
-        if self.session_token is not None:
-            self._log.warning("Already logged in, returning")
-            return
-        url = self.IDENTITY_URL + "certlogin"
-        data = {"username": self.username, "password": self.password}
-        headers = {k: v for k, v in self.headers.items() if k.lower() != "content-type"}
-        headers["Content-Type"] = "application/x-www-form-urlencoded"
-        resp = await self.post(url=url, data=data, headers=headers)
-        data = msgspec.json.decode(resp.data)
-        if data["loginStatus"] == "SUCCESS":
-            self.session_token = data["sessionToken"]
-        else:
-            raise BetfairError(f"Login failed: {resp.data}")
+    async def keep_alive(self):
+        """
+        Renew authentication.
+        """
+        resp: KeepAlive.return_type = await self._post(KeepAlive())
+        if resp.status == "SUCCESS":
+            self.update_headers(resp)
 
     async def list_navigation(self) -> Navigation:
         """
         List the tree (navigation) of all betfair markets.
         """
-        resp = await self.get(url=self.NAVIGATION_URL, headers=self.headers)
-        return msgspec.json.decode(resp.data, type=Navigation)
+        navigation: Navigation = await self._get(request=Menu())
+        return navigation
 
     async def list_market_catalogue(
         self,
-        filter_: dict,
-        market_projection: list[MarketProjection] = None,
-        sort: str = None,
+        filter_: MarketFilter,
+        market_projection: Optional[list[MarketProjection]] = None,
+        sort: Optional[MarketSort] = None,
         max_results: int = 1000,
-        locale: str = None,
-    ):
+        locale: Optional[str] = None,
+    ) -> list[MarketCatalogue]:
         """
         Return specific data about markets.
         """
         assert 0 < max_results <= 1000
-
-        params = parse_params(**locals())
-
-        if "marketProjection" in params:
-            assert all(isinstance(m, MarketProjection) for m in params["marketProjection"])
-            params["marketProjection"] = [m.value for m in params["marketProjection"]]
-        if "sort" in params:
-            assert isinstance(sort, MarketSort)
-        resp = await self.rpc_post(
-            url=self.BETTING_URL,
-            method="SportsAPING/v1.0/listMarketCatalogue",
-            params=params,
+        resp: ListMarketCatalogue.return_type = await self._post(
+            request=ListMarketCatalogue.with_params(
+                filter=filter_,
+                market_projection=market_projection,
+                sort=sort,
+                max_results=max_results,
+                locale=locale,
+            ),
         )
         return resp
 
-    async def get_account_details(self):
-        resp = await self.rpc_post(
-            url=self.ACCOUNT_URL,
-            method="AccountAPING/v1.0/getAccountDetails",
-        )
-        return resp
+    async def get_account_details(self) -> AccountDetailsResponse:
+        return await self._post(request=GetAccountDetails.with_params())
 
-    async def get_account_funds(self, wallet: Optional[str] = None):
-        params = parse_params(**locals())
-        resp = await self.rpc_post(
-            url=self.ACCOUNT_URL,
-            method="AccountAPING/v1.0/getAccountFunds",
-            params=params,
-        )
-        return resp
+    async def get_account_funds(self, wallet: Optional[str] = None) -> AccountFundsResponse:
+        return await self._post(request=GetAccountFunds.with_params(wallet=wallet))
 
-    async def place_orders(
-        self,
-        market_id: str,
-        instructions: list,
-        customer_ref: str = None,
-        market_version: Optional[dict] = None,
-        customer_strategy_ref: str = None,
-    ):
-        """
-        Place a new order.
-        """
-        params = parse_params(**locals())
-        resp = await self.rpc_post(
-            url=self.BETTING_URL,
-            method="SportsAPING/v1.0/placeOrders",
-            params=params,
-        )
-        return resp
+    async def place_orders(self, params: _PlaceOrdersParams) -> PlaceExecutionReport:
+        return await self._post(PlaceOrders(params=params))
 
-    async def replace_orders(
-        self,
-        market_id: str = None,
-        instructions: list = None,
-        customer_ref: str = None,
-        market_version: Optional[dict] = None,
-    ):
-        params = parse_params(**locals())
-        resp = await self.rpc_post(
-            url=self.BETTING_URL,
-            method="SportsAPING/v1.0/replaceOrders",
-            params=params,
-        )
-        return resp
+    async def replace_orders(self, params: _ReplaceOrdersParams) -> ReplaceExecutionReport:
+        return await self._post(ReplaceOrders(params=params))
 
-    async def cancel_orders(
-        self,
-        market_id: str = None,
-        instructions: list = None,
-        customer_ref: str = None,
-    ):
-        params = parse_params(**locals())
-        resp = await self.rpc_post(
-            url=self.BETTING_URL,
-            method="SportsAPING/v1.0/cancelOrders",
-            params=params,
-        )
-        return resp
+    async def cancel_orders(self, params: _CancelOrdersParams) -> CancelExecutionReport:
+        return await self._post(CancelOrders(params=params))
 
     async def list_current_orders(
         self,
-        bet_ids: list = None,
-        market_ids: list = None,
-        order_projection: str = None,
-        customer_order_refs: list = None,
-        customer_strategy_refs: list = None,
-        date_from: datetime.datetime = None,
-        date_to: datetime.datetime = None,
-        order_by: str = "BY_PLACE_TIME",
-        sort_dir: str = None,
-        from_record: int = None,
-        record_count: int = None,
-        include_item_description: bool = None,
-    ) -> list[dict]:
-        params = parse_params(**locals())
-        current_orders = []
+        bet_ids: Optional[set[BetId]] = None,
+        market_ids: Optional[set[str]] = None,
+        order_projection: Optional[OrderProjection] = None,
+        customer_order_refs: Optional[set[CustomerOrderRef]] = None,
+        customer_strategy_refs: Optional[set[CustomerStrategyRef]] = None,
+        date_range: Optional[TimeRange] = None,
+        order_by: Optional[OrderBy] = None,
+        sort_dir: Optional[SortDir] = None,
+        from_record: Optional[int] = None,
+        record_count: Optional[int] = None,
+        include_item_description: Optional[bool] = None,
+    ) -> list[CurrentOrderSummary]:
+        current_orders: list[CurrentOrderSummary] = []
         more_available = True
         index = from_record or 0
         while more_available:
-            params["fromRecord"] = index
-            resp: dict = await self.rpc_post(
-                url=self.BETTING_URL,
-                method="SportsAPING/v1.0/listCurrentOrders",
-                params=params,
+            from_record = index
+            request = ListCurrentOrders.with_params(
+                bet_ids=bet_ids,
+                market_ids=market_ids,
+                order_projection=order_projection,
+                customer_order_refs=customer_order_refs,
+                customer_strategy_refs=customer_strategy_refs,
+                date_range=date_range,
+                order_by=order_by,
+                sort_dir=sort_dir,
+                from_record=from_record,
+                record_count=record_count,
+                include_item_description=include_item_description,
             )
-            order_chunk = resp["currentOrders"]
-            current_orders.extend(order_chunk)
-            more_available = resp["moreAvailable"]
-            index += len(order_chunk)
+            resp: CurrentOrderSummaryReport = await self._post(request=request)
+            current_orders.extend(resp.current_orders)
+            more_available = resp.more_available
+            index = len(current_orders)
         return current_orders
 
     async def list_cleared_orders(
         self,
-        bet_status: str = "SETTLED",
-        event_type_ids: list = None,
-        event_ids: list = None,
-        market_ids: list = None,
-        runner_ids: list = None,
-        bet_ids: list = None,
-        customer_order_refs: list = None,
-        customer_strategy_refs: list = None,
-        side: str = None,
-        settled_date_from: datetime.datetime = None,
-        settled_date_to: datetime.datetime = None,
-        group_by: str = None,
-        include_item_description: bool = None,
-        locale: str = None,
-        from_record: int = None,
-        record_count: int = None,
-    ) -> list[ClearedOrder]:
-        params = parse_params(**locals())
-        cleared_orders = []
+        bet_status: BetStatus,
+        event_type_ids: Optional[set[EventTypeId]] = None,
+        event_ids: Optional[set[EventId]] = None,
+        market_ids: Optional[set[MarketId]] = None,
+        runner_ids: Optional[set[RunnerId]] = None,
+        bet_ids: Optional[set[BetId]] = None,
+        customer_order_refs: Optional[set[CustomerOrderRef]] = None,
+        customer_strategy_refs: Optional[set[CustomerStrategyRef]] = None,
+        side: Optional[Side] = None,
+        settled_date_range: Optional[TimeRange] = None,
+        group_by: Optional[GroupBy] = None,
+        include_item_description: Optional[bool] = None,
+        locale: Optional[str] = None,
+        from_record: Optional[int] = None,
+        record_count: Optional[int] = None,
+    ) -> list[ClearedOrderSummary]:
+        cleared_orders: list[ClearedOrderSummary] = []
         more_available = True
         index = from_record or 0
         while more_available:
-            params["fromRecord"] = index
-            if settled_date_from or settled_date_to:
-                params["settledDateRange"] = {"from": settled_date_from, "to": settled_date_to}
-            data = await self.rpc_post(
-                url=self.BETTING_URL,
-                method="SportsAPING/v1.0/listClearedOrders",
-                params=params,
+            from_record = index
+            request = ListClearedOrders.with_params(
+                bet_status=bet_status,
+                event_type_ids=event_type_ids,
+                event_ids=event_ids,
+                market_ids=market_ids,
+                runner_ids=runner_ids,
+                bet_ids=bet_ids,
+                customer_order_refs=customer_order_refs,
+                customer_strategy_refs=customer_strategy_refs,
+                side=side,
+                settled_date_range=settled_date_range,
+                group_by=group_by,
+                include_item_description=include_item_description,
+                locale=locale,
+                from_record=from_record,
+                record_count=record_count,
             )
-            raw = msgspec.json.encode(data)
-            response: ClearedOrdersResponse = msgspec.json.decode(raw, type=ClearedOrdersResponse)
-            order_chunk = response.clearedOrders
-            cleared_orders.extend(order_chunk)
-            more_available = response.moreAvailable
-            index += len(order_chunk)
+            resp: ClearedOrderSummaryReport = await self._post(request=request)
+            cleared_orders.extend(resp.cleared_orders)
+            more_available = resp.more_available
+            index = len(cleared_orders)
         return cleared_orders
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/enums.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/winner_avg.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,69 +9,31 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from enum import Enum
+from typing import Any, Optional
 
+import pandas as pd
 
-class MarketProjection(Enum):
-    """
-    Represents a `Betfair` market projection type.
-    """
-
-    COMPETITION = "COMPETITION"
-    EVENT = "EVENT"
-    EVENT_TYPE = "EVENT_TYPE"
-    MARKET_START_TIME = "MARKET_START_TIME"
-    MARKET_DESCRIPTION = "MARKET_DESCRIPTION"
-    RUNNER_DESCRIPTION = "RUNNER_DESCRIPTION"
-    RUNNER_METADATA = "RUNNER_METADATA"
+from nautilus_trader.analysis.statistic import PortfolioStatistic
 
 
-class MarketSort(Enum):
+class AvgWinner(PortfolioStatistic):
     """
-    Represents a `Betfair` market sort type.
+    Calculates the average winner from a series of PnLs.
     """
 
-    MINIMUM_TRADED = "MINIMUM_TRADED"
-    MAXIMUM_TRADED = "MAXIMUM_TRADED"
-    MINIMUM_AVAILABLE = "MINIMUM_AVAILABLE"
-    MAXIMUM_AVAILABLE = "MAXIMUM_AVAILABLE"
-    FIRST_TO_START = "FIRST_TO_START"
-    LAST_TO_START = "LAST_TO_START"
-
-
-class MarketBettingType(Enum):
-    """
-    Represents a `Betfair` market betting type.
-    """
-
-    ODDS = "ODDS"
-    LINE = "LINE"
-    RANGE = "RANGE"
-    ASIAN_HANDICAP_DOUBLE_LINE = "ASIAN_HANDICAP_DOUBLE_LINE"
-    ASIAN_HANDICAP_SINGLE_LINE = "ASIAN_HANDICAP_SINGLE_LINE"
-    FIXED_ODDS = "FIXED_ODDS"
-
-
-class OrderStatus(Enum):
-    """
-    Represents a `Betfair` order status.
-    """
-
-    PENDING = "PENDING"
-    EXECUTION_COMPLETE = "EXECUTION_COMPLETE"
-    EXECUTABLE = "EXECUTABLE"
-    EXPIRED = "EXPIRED"
-
-
-class OrderProjection(Enum):
-    """
-    Represents a `Betfair` order projection.
-    """
+    def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
+        # Preconditions
+        if realized_pnls is None or realized_pnls.empty:
+            return 0.0
 
-    ALL = "ALL"
-    EXECUTABLE = "EXECUTABLE"
-    EXECUTION_COMPLETE = "EXECUTION_COMPLETE"
+        # Calculate statistic
+        pnls = realized_pnls.to_numpy()
+        winners = pnls[pnls > 0.0]
+        if len(winners) == 0:
+            return 0.0
+        else:
+            return winners.mean()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/spec.py` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/moving_average.pyx`

 * *Files 27% similar despite different names*

```diff
@@ -10,85 +10,89 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from enum import Enum
-from typing import Optional
+from enum import unique
 
-import msgspec
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.indicators.base.indicator cimport Indicator
+from nautilus_trader.model.enums_c cimport PriceType
+
+
+@unique
+class MovingAverageType(Enum):
+    """
+    Represents the type of moving average.
+    """
+    SIMPLE = 0
+    EXPONENTIAL = 1
+    WEIGHTED = 2
+    HULL = 3
+    ADAPTIVE = 4
+    WILDER = 5
+    DOUBLE_EXPONENTIAL = 6
+    VARIABLE_INDEX_DYNAMIC = 7
+
+
+cdef class MovingAverage(Indicator):
+    """
+    The base class for all moving average type indicators.
+
+    Parameters
+    ----------
+    period : int
+        The rolling window period for the indicator (> 0).
+    params : list
+        The initialization parameters for the indicator.
+    price_type : PriceType, optional
+        The specified price type for extracting values from quote ticks.
+
+    Warnings
+    --------
+    This class should not be used directly, but through a concrete subclass.
+    """
+
+    def __init__(
+        self,
+        int period,
+        list params not None,
+        PriceType price_type,
+    ):
+        Condition.positive_int(period, "period")
+        super().__init__(params)
+
+        self.period = period
+        self.price_type = price_type
+        self.value = 0
+        self.count = 0
+
+    cpdef void update_raw(self, double value):
+        """
+        Update the indicator with the given raw value.
+
+        Parameters
+        ----------
+        value : double
+            The update value.
+
+        """
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
+    cpdef void _increment_count(self):
+        self.count += 1
+
+        # Initialization logic
+        if not self.initialized:
+            self._set_has_inputs(True)
+            if self.count >= self.period:
+                self._set_initialized(True)
+
+    cpdef void _reset(self):
+        self._reset_ma()
+        self.count = 0
+        self.value = 0
 
-
-class BetfairSide(Enum):
-    """BetfairSide"""
-
-    BACK = "BACK"
-    LAY = "LAY"
-
-
-class ExecutionStatus(Enum):
-    """ExecutionStatus"""
-
-    PENDING = "PENDING"
-    EXECUTABLE = "EXECUTABLE"
-    EXECUTION_COMPLETE = "EXECUTION_COMPLETE"
-    EXPIRED = "EXPIRED"
-
-
-class PersistenceType(Enum):
-    """PersistenceType"""
-
-    LAPSE = "LAPSE"
-    PERSIST = "PERSIST"
-    MARKET_ON_CLOSE = "MARKET_ON_CLOSE"
-
-
-class OrderType(Enum):
-    """OrderType"""
-
-    LIMIT = "LIMIT"
-    LIMIT_ON_CLOSE = "LIMIT_ON_CLOSE"
-    MARKET_ON_CLOSE = "MARKET_ON_CLOSE"
-    # Deprecated
-    MARKET_AT_THE_CLOSE = "MARKET_AT_THE_CLOSE"
-    LIMIT_AT_THE_CLOSE = "LIMIT_AT_THE_CLOSE"
-
-
-class BetOutcome(Enum):
-    """BetOutcome"""
-
-    WON = "WON"
-    LOST = "LOST"
-
-
-class ClearedOrder(msgspec.Struct):
-    """ClearedOrder"""
-
-    eventTypeId: str
-    eventId: str
-    marketId: str
-    selectionId: int
-    handicap: float
-    betId: str
-    placedDate: str
-    persistenceType: PersistenceType
-    orderType: OrderType
-    side: BetfairSide
-    betOutcome: BetOutcome
-    priceRequested: float
-    settledDate: str
-    lastMatchedDate: str
-    betCount: int
-    priceMatched: float
-    priceReduced: bool
-    sizeSettled: float
-    profit: float
-    customerOrderRef: Optional[str] = None
-    customerStrategyRef: Optional[str] = None
-
-
-class ClearedOrdersResponse(msgspec.Struct):
-    """ClearedOrdersResponse"""
-
-    clearedOrders: list[ClearedOrder]
-    moreAvailable: bool
+    cpdef void _reset_ma(self):
+        pass  # Optionally override if additional values to reset
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/common.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/common.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,62 +9,72 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from betfair_parser.spec.betting.enums import PersistenceType
+from betfair_parser.spec.betting.enums import Side
+from betfair_parser.spec.betting.enums import TimeInForce as BetfairTimeInForce
+from betfair_parser.spec.common import OrderType
+
+from nautilus_trader.core.rust.model import OrderType as NautilusOrderType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
-from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.tick_scheme import register_tick_scheme
 from nautilus_trader.model.tick_scheme.implementations.tiered import TieredTickScheme
 
 
-BETFAIR_VENUE = Venue("BETFAIR")
-BETFAIR_PRICE_PRECISION = 2
-BETFAIR_QUANTITY_PRECISION = 4
-
 # ------------------------------- MAPPINGS ------------------------------- #
-
 # Mappings between Nautilus and betfair - prefixes:
 #     N2B = {NAUTILUS: BETFAIR}
 #     B2N = {BETFAIR: NAUTILUS}
 
-
 N2B_SIDE = {
-    OrderSide.BUY: "BACK",
-    OrderSide.SELL: "LAY",
+    OrderSide.BUY: Side.BACK,
+    OrderSide.SELL: Side.LAY,
 }
 
 N2B_TIME_IN_FORCE = {
-    TimeInForce.FOK: "FILL_OR_KILL",
+    TimeInForce.FOK: BetfairTimeInForce.FILL_OR_KILL,
 }
 
-B2N_MARKET_STREAM_SIDE = {
+N2B_PERSISTENCE = {
+    TimeInForce.GTC: PersistenceType.PERSIST,
+    TimeInForce.DAY: PersistenceType.MARKET_ON_CLOSE,
+}
+
+B2N_MARKET_SIDE = {
     "atb": OrderSide.SELL,  # Available to Back / Sell order
     "batb": OrderSide.SELL,  # Best available to Back / Sell order
     "bdatb": OrderSide.SELL,  # Best display to Back / Sell order
     "atl": OrderSide.BUY,  # Available to Lay / Buy order
     "batl": OrderSide.BUY,  # Best available to Lay / Buy order
     "bdatl": OrderSide.BUY,  # Best display available to Lay / Buy order
     "spb": OrderSide.SELL,  # Starting Price Back
     "spl": OrderSide.BUY,  # Starting Price LAY
 }
 
-B2N_ORDER_STREAM_SIDE = {
+B2N_ORDER_SIDE = {
+    Side.BACK: OrderSide.BUY,
+    Side.LAY: OrderSide.SELL,
     "B": OrderSide.BUY,
-    "L": OrderSide.SELL,
-    "BACK": OrderSide.BUY,
-    "LAY": OrderSide.SELL,
+    "L": OrderSide.BUY,
 }
 
 B2N_TIME_IN_FORCE = {
-    "LAPSE": TimeInForce.DAY,
-    "PERSIST": TimeInForce.GTC,
+    PersistenceType.LAPSE: TimeInForce.DAY,
+    PersistenceType.PERSIST: TimeInForce.GTC,
+}
+
+B2N_ORDER_TYPE = {
+    OrderType.LIMIT: NautilusOrderType.LIMIT,
+    OrderType.LIMIT_ON_CLOSE: NautilusOrderType.LIMIT,
+    OrderType.MARKET_ON_CLOSE: NautilusOrderType.MARKET,
 }
 
 BETFAIR_PRICE_TIERS = [
     (1.01, 2, 0.01),
     (2, 3, 0.02),
     (3, 4, 0.05),
     (4, 6, 0.1),
@@ -72,12 +82,12 @@
     (10, 20, 0.5),
     (20, 30, 1),
     (30, 50, 2),
     (50, 100, 5),
     (100, 1010, 10),
 ]
 
-BETFAIR_TICK_SCHEME = TieredTickScheme(name="BETFAIR", tiers=BETFAIR_PRICE_TIERS)
+BETFAIR_TICK_SCHEME = TieredTickScheme("BETFAIR", BETFAIR_PRICE_TIERS)
 BETFAIR_FLOAT_TO_PRICE = {price.as_double(): price for price in BETFAIR_TICK_SCHEME.ticks}
 MAX_BET_PRICE = max(BETFAIR_TICK_SCHEME.ticks)
 MIN_BET_PRICE = min(BETFAIR_TICK_SCHEME.ticks)
 register_tick_scheme(BETFAIR_TICK_SCHEME)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/config.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/config.py`

 * *Files 0% similar despite different names*

```diff
@@ -28,15 +28,16 @@
     username : str, optional
         The Betfair account username.
     password : str, optional
         The Betfair account password.
     app_key : str, optional
         The betfair application key.
     cert_dir : str, optional
-        The local directory that contains the betfair certificates
+        The local directory that contains the betfair certificates.
+
     """
 
     username: Optional[str] = None
     password: Optional[str] = None
     app_key: Optional[str] = None
     cert_dir: Optional[str] = None
     market_filter: Optional[tuple] = None
@@ -51,15 +52,16 @@
     username : str, optional
         The Betfair account username.
     password : str, optional
         The Betfair account password.
     app_key : str, optional
         The betfair application key.
     cert_dir : str, optional
-        The local directory that contains the betfair certificates
+        The local directory that contains the betfair certificates.
+
     """
 
     base_currency: str
     username: Optional[str] = None
     password: Optional[str] = None
     app_key: Optional[str] = None
     cert_dir: Optional[str] = None
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/constants.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/constants.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,44 +9,31 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import os
-from enum import Enum
-
 from betfair_parser.spec.streaming.mcm import MarketStatus as BetfairMarketStatus
 
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.enums import MarketStatus
+from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.objects import Price
 
 
+BETFAIR_VENUE = Venue("BETFAIR")
 BETFAIR_PRICE_PRECISION = 6
 BETFAIR_QUANTITY_PRECISION = 6
 BETFAIR_BOOK_TYPE = BookType.L2_MBP
 
 CLOSE_PRICE_WINNER = Price(1.0, precision=BETFAIR_PRICE_PRECISION)
 CLOSE_PRICE_LOSER = Price(0.0, precision=BETFAIR_PRICE_PRECISION)
 
-
 MARKET_STATUS_MAPPING: dict[tuple[BetfairMarketStatus, bool], MarketStatus] = {
     (BetfairMarketStatus.OPEN, False): MarketStatus.PRE_OPEN,
     (BetfairMarketStatus.OPEN, True): MarketStatus.OPEN,
     (BetfairMarketStatus.SUSPENDED, False): MarketStatus.PAUSE,
     (BetfairMarketStatus.SUSPENDED, True): MarketStatus.PAUSE,
     (BetfairMarketStatus.CLOSED, False): MarketStatus.CLOSED,
     (BetfairMarketStatus.CLOSED, True): MarketStatus.CLOSED,
 }
-
-# Betfair allows subscribing to
-STRICT_MARKET_DATA_HANDLING = os.environ.get("BETFAIR_STRICT_MARKET_DATA_HANDLING", "1")
-
-
-class MarketDataKind(Enum):
-    """MarketDataKind"""
-
-    ALL = "ALL"
-    BEST = "BEST"
-    DISPLAY = "DISPLAY"
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,37 +13,37 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
 from typing import Optional
 
 import msgspec
-from betfair_parser.spec.streaming import STREAM_DECODER
+from betfair_parser.spec.streaming import stream_decode
 from betfair_parser.spec.streaming.mcm import MCM
 from betfair_parser.spec.streaming.status import Connection
 from betfair_parser.spec.streaming.status import Status
 
-from nautilus_trader.adapters.betfair.client.core import BetfairClient
-from nautilus_trader.adapters.betfair.common import BETFAIR_VENUE
+from nautilus_trader.adapters.betfair.client import BetfairHttpClient
+from nautilus_trader.adapters.betfair.constants import BETFAIR_VENUE
 from nautilus_trader.adapters.betfair.data_types import BetfairStartingPrice
 from nautilus_trader.adapters.betfair.data_types import BSPOrderBookDeltas
 from nautilus_trader.adapters.betfair.data_types import SubscriptionStatus
 from nautilus_trader.adapters.betfair.parsing.core import BetfairParser
 from nautilus_trader.adapters.betfair.providers import BetfairInstrumentProvider
 from nautilus_trader.adapters.betfair.sockets import BetfairMarketStreamClient
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.live.data_client import LiveMarketDataClient
-from nautilus_trader.model.data import DataType
-from nautilus_trader.model.data import GenericData
+from nautilus_trader.model.data.base import DataType
+from nautilus_trader.model.data.base import GenericData
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments.betting import BettingInstrument
 from nautilus_trader.msgbus.bus import MessageBus
 
 
@@ -67,20 +67,21 @@
         The logger for the client.
     market_filter : dict
         The market filter.
     instrument_provider : BetfairInstrumentProvider, optional
         The instrument provider.
     strict_handling : bool
         If strict handling mode is enabled.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: BetfairClient,
+        client: BetfairHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         market_filter: dict,
         instrument_provider: Optional[BetfairInstrumentProvider] = None,
         strict_handling: bool = False,
@@ -94,17 +95,17 @@
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
         )
 
         self._instrument_provider: BetfairInstrumentProvider = instrument_provider
-        self._client: BetfairClient = client
+        self._client: BetfairHttpClient = client
         self._stream = BetfairMarketStreamClient(
-            client=self._client,
+            http_client=self._client,
             logger=logger,
             message_handler=self.on_market_update,
         )
         self.parser = BetfairParser()
         self.subscription_status = SubscriptionStatus.UNSUBSCRIBED
 
         # Subscriptions
@@ -113,15 +114,15 @@
         self._subscribed_market_ids: set[InstrumentId] = set()
 
     @property
     def instrument_provider(self) -> BetfairInstrumentProvider:
         return self._instrument_provider
 
     async def _connect(self):
-        self._log.info("Connecting to BetfairClient...")
+        self._log.info("Connecting to BetfairHttpClient...")
         await self._client.connect()
         self._log.info("BetfairClient login successful.", LogColor.GREEN)
 
         # Connect market data socket
         await self._stream.connect()
 
         # Pass any preloaded instruments into the engine
@@ -138,16 +139,16 @@
 
         # Schedule a heartbeat in 10s to give us a little more time to load instruments
         self._log.debug("scheduling heartbeat")
         self.create_task(self._post_connect_heartbeat())
 
     async def _post_connect_heartbeat(self):
         for _ in range(3):
-            await asyncio.sleep(5)
             await self._stream.send(msgspec.json.encode({"op": "heartbeat"}))
+            await asyncio.sleep(5)
 
     async def _disconnect(self):
         # Close socket
         self._log.info("Closing streaming socket...")
         await self._stream.disconnect()
 
         # Ensure client closed
@@ -241,15 +242,15 @@
     async def _unsubscribe_order_book_deltas(self, instrument_id: InstrumentId):
         # TODO - this could be done by removing the market from self.__subscribed_market_ids and resending the
         #  subscription message - when we have a use case
         self._log.warning("Betfair does not support unsubscribing from instruments")
 
     # -- STREAMS ----------------------------------------------------------------------------------
     def on_market_update(self, raw: bytes):
-        update = STREAM_DECODER.decode(raw)
+        update = stream_decode(raw)
         if isinstance(update, MCM):
             self._on_market_update(mcm=update)
         elif isinstance(update, Connection):
             pass
         elif isinstance(update, Status):
             self._handle_status_message(update=update)
         else:
@@ -290,14 +291,14 @@
         for mc in update.mc:
             if mc.con:
                 self._log.warning(
                     "Conflated stream - consuming data too slow (data received is delayed)",
                 )
 
     def _handle_status_message(self, update: Status):
-        if update.statusCode == "FAILURE" and update.connectionClosed:
+        if update.status_code == "FAILURE" and update.connection_closed:
             self._log.warning(str(update))
-            if update.errorCode == "MAX_CONNECTION_LIMIT_EXCEEDED":
+            if update.error_code == "MAX_CONNECTION_LIMIT_EXCEEDED":
                 raise RuntimeError("No more connections available")
             else:
                 self._log.info("Attempting reconnect")
                 self.create_task(self._stream.reconnect())
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data_types.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/data_types.py`

 * *Files 6% similar despite different names*

```diff
@@ -18,18 +18,18 @@
 from typing import Optional
 
 import pyarrow as pa
 
 # fmt: off
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
-from nautilus_trader.model.data import BookOrder
-from nautilus_trader.model.data import OrderBookDelta
-from nautilus_trader.model.data import OrderBookDeltas
-from nautilus_trader.model.data import Ticker
+from nautilus_trader.model.data.book import BookOrder
+from nautilus_trader.model.data.book import OrderBookDelta
+from nautilus_trader.model.data.book import OrderBookDeltas
+from nautilus_trader.model.data.ticker import Ticker
 from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.enums import book_action_from_str
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.serialization.arrow.implementations.order_book import deserialize as deserialize_orderbook
 from nautilus_trader.serialization.arrow.implementations.order_book import serialize as serialize_orderbook
 from nautilus_trader.serialization.arrow.schema import NAUTILUS_PARQUET_SCHEMA
 from nautilus_trader.serialization.arrow.serializer import register_parquet
@@ -60,30 +60,28 @@
     Represents a `Betfair` BSP order book delta.
     """
 
     @staticmethod
     def from_dict(values) -> "BSPOrderBookDelta":
         PyCondition.not_none(values, "values")
         action: BookAction = book_action_from_str(values["action"])
-        order: BookOrder = (
-            BookOrder.from_dict(
-                {
-                    "price": values["price"],
-                    "size": values["size"],
-                    "side": values["side"],
-                    "order_id": values["order_id"],
-                },
-            )
-            if values["action"] != "CLEAR"
-            else None
-        )
+        if action != BookAction.CLEAR:
+            book_dict = {
+                "price": str(values["price"]),
+                "size": str(values["size"]),
+                "side": values["side"],
+                "order_id": values["order_id"],
+            }
+            book_order = BookOrder.from_dict(book_dict)
+        else:
+            book_order = None
         return BSPOrderBookDelta(
             instrument_id=InstrumentId.from_str(values["instrument_id"]),
             action=action,
-            order=order,
+            order=book_order,
             ts_event=values["ts_event"],
             ts_init=values["ts_init"],
         )
 
     @staticmethod
     def to_dict(obj) -> dict:
         values = OrderBookDelta.to_dict(obj)
@@ -162,20 +160,30 @@
     """
 
     def __init__(
         self,
         instrument_id: InstrumentId,
         ts_event: int,
         ts_init: int,
-        bsp: float = None,
+        bsp: Optional[float] = None,
     ):
-        super().__init__(ts_event=ts_event, ts_init=ts_init)
+        super().__init__()
+        self._ts_event = ts_event
+        self._ts_init = ts_init
         self.instrument_id: InstrumentId = instrument_id
         self.bsp = bsp
 
+    @property
+    def ts_init(self) -> int:
+        return self._ts_init
+
+    @property
+    def ts_event(self) -> int:
+        return self._ts_event
+
     @classmethod
     def schema(cls):
         return pa.schema(
             {
                 "instrument_id": pa.dictionary(pa.int8(), pa.string()),
                 "ts_event": pa.uint64(),
                 "ts_init": pa.uint64(),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/execution.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,34 +16,40 @@
 import asyncio
 import hashlib
 from collections import defaultdict
 from typing import Optional
 
 import msgspec
 import pandas as pd
-from betfair_parser.spec.streaming import STREAM_DECODER
+from betfair_parser.exceptions import BetfairError
+from betfair_parser.spec.accounts.type_definitions import AccountDetailsResponse
+from betfair_parser.spec.betting.enums import ExecutionReportStatus
+from betfair_parser.spec.betting.enums import InstructionReportStatus
+from betfair_parser.spec.betting.orders import PlaceOrders
+from betfair_parser.spec.betting.type_definitions import CurrentOrderSummary
+from betfair_parser.spec.betting.type_definitions import PlaceExecutionReport
+from betfair_parser.spec.streaming import stream_decode
 from betfair_parser.spec.streaming.ocm import OCM
 from betfair_parser.spec.streaming.ocm import UnmatchedOrder
 from betfair_parser.spec.streaming.status import Connection
 from betfair_parser.spec.streaming.status import Status
 
 from nautilus_trader.accounting.factory import AccountFactory
-from nautilus_trader.adapters.betfair.client.core import BetfairClient
-from nautilus_trader.adapters.betfair.client.exceptions import BetfairAPIError
-from nautilus_trader.adapters.betfair.common import B2N_ORDER_STREAM_SIDE
-from nautilus_trader.adapters.betfair.common import BETFAIR_VENUE
+from nautilus_trader.adapters.betfair.client import BetfairHttpClient
+from nautilus_trader.adapters.betfair.common import B2N_ORDER_SIDE
+from nautilus_trader.adapters.betfair.constants import BETFAIR_VENUE
 from nautilus_trader.adapters.betfair.orderbook import betfair_float_to_price
 from nautilus_trader.adapters.betfair.orderbook import betfair_float_to_quantity
 from nautilus_trader.adapters.betfair.parsing.common import betfair_instrument_id
 from nautilus_trader.adapters.betfair.parsing.requests import bet_to_order_status_report
 from nautilus_trader.adapters.betfair.parsing.requests import betfair_account_to_account_state
 from nautilus_trader.adapters.betfair.parsing.requests import order_cancel_all_to_betfair
-from nautilus_trader.adapters.betfair.parsing.requests import order_cancel_to_betfair
-from nautilus_trader.adapters.betfair.parsing.requests import order_submit_to_betfair
-from nautilus_trader.adapters.betfair.parsing.requests import order_update_to_betfair
+from nautilus_trader.adapters.betfair.parsing.requests import order_cancel_to_cancel_order_params
+from nautilus_trader.adapters.betfair.parsing.requests import order_submit_to_place_order_params
+from nautilus_trader.adapters.betfair.parsing.requests import order_update_to_replace_order_params
 from nautilus_trader.adapters.betfair.parsing.requests import parse_handicap
 from nautilus_trader.adapters.betfair.providers import BetfairInstrumentProvider
 from nautilus_trader.adapters.betfair.sockets import BetfairOrderStreamClient
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
@@ -62,16 +68,16 @@
 from nautilus_trader.live.execution_client import LiveExecutionClient
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OmsType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import OrderType
-from nautilus_trader.model.events import AccountState
-from nautilus_trader.model.events import OrderFilled
+from nautilus_trader.model.events.account import AccountState
+from nautilus_trader.model.events.order import OrderFilled
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
 from nautilus_trader.model.objects import Money
@@ -83,15 +89,15 @@
     """
     Provides an execution client for Betfair.
 
     Parameters
     ----------
     loop : asyncio.AbstractEventLoop
         The event loop for the client.
-    client : BetfairClient
+    client : BetfairHttpClient
         The Betfair HttpClient.
     base_currency : Currency
         The account base currency for the client.
     msgbus : MessageBus
         The message bus for the client.
     cache : Cache
         The cache for the client.
@@ -99,20 +105,21 @@
         The clock for the client.
     logger : Logger
         The logger for the client.
     market_filter : dict
         The market filter.
     instrument_provider : BetfairInstrumentProvider
         The instrument provider.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: BetfairClient,
+        client: BetfairHttpClient,
         base_currency: Currency,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         market_filter: dict,
         instrument_provider: BetfairInstrumentProvider,
@@ -129,17 +136,17 @@
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
         )
 
         self._instrument_provider: BetfairInstrumentProvider = instrument_provider
-        self._client: BetfairClient = client
+        self._client: BetfairHttpClient = client
         self.stream = BetfairOrderStreamClient(
-            client=self._client,
+            http_client=self._client,
             logger=logger,
             message_handler=self.handle_order_stream_update,
         )
 
         self.venue_order_id_to_client_order_id: dict[VenueOrderId, ClientOrderId] = {}
         self.pending_update_order_client_ids: set[tuple[ClientOrderId, VenueOrderId]] = set()
         self.published_executions: dict[ClientOrderId, list[TradeId]] = defaultdict(list)
@@ -150,17 +157,17 @@
     @property
     def instrument_provider(self) -> BetfairInstrumentProvider:
         return self._instrument_provider
 
     # -- CONNECTION HANDLERS ----------------------------------------------------------------------
 
     async def _connect(self) -> None:
-        self._log.info("Connecting to BetfairClient...")
+        self._log.info("Connecting to BetfairHttpClient...")
         await self._client.connect()
-        self._log.info("BetfairClient login successful.", LogColor.GREEN)
+        self._log.info("BetfairHttpClient login successful.", LogColor.GREEN)
 
         aws = [
             self.stream.connect(),
             self.connection_account_state(),
             self.check_account_currency(),
         ]
         await asyncio.gather(*aws)
@@ -168,27 +175,30 @@
 
     async def _disconnect(self) -> None:
         # Close socket
         self._log.info("Closing streaming socket...")
         await self.stream.disconnect()
 
         # Ensure client closed
-        self._log.info("Closing BetfairClient...")
+        self._log.info("Closing BetfairHttpClient...")
         await self._client.disconnect()
 
+    # TODO - remove when we get socket reconnect in rust.
     async def watch_stream(self) -> None:
-        """Ensure socket stream is connected"""
-        while not self.stream.is_stopping:
+        """
+        Ensure socket stream is connected.
+        """
+        while True:
             if not self.stream.is_connected:
                 await self.stream.connect()
             await asyncio.sleep(1)
 
     # -- ERROR HANDLING ---------------------------------------------------------------------------
-    async def on_api_exception(self, error: BetfairAPIError) -> None:
-        if error.kind == "INVALID_SESSION_INFORMATION":
+    async def on_api_exception(self, error: BetfairError) -> None:
+        if "INVALID_SESSION_INFORMATION" in error.message:
             # Session is invalid, need to reconnect
             self._log.warning("Invalid session error, reconnecting..")
             await self._client.disconnect()
             await self._connect()
             self._log.info("Reconnected.")
 
     # -- ACCOUNT HANDLERS -------------------------------------------------------------------------
@@ -213,30 +223,30 @@
     async def generate_order_status_report(
         self,
         instrument_id: InstrumentId,
         client_order_id: Optional[ClientOrderId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
     ) -> Optional[OrderStatusReport]:
         assert venue_order_id is not None
-        orders = await self._client.list_current_orders(
-            bet_ids=[venue_order_id],
+        orders: list[CurrentOrderSummary] = await self._client.list_current_orders(
+            bet_ids={venue_order_id},
         )
 
         if not orders:
             self._log.warning(f"Could not find order for venue_order_id={venue_order_id}")
             return None
         # We have a response, check list length and grab first entry
         assert len(orders) == 1
-        order = orders[0]
+        order: CurrentOrderSummary = orders[0]
         instrument = self._instrument_provider.get_betting_instrument(
-            market_id=str(order["marketId"]),
-            selection_id=str(order["selectionId"]),
-            handicap=parse_handicap(order["handicap"]),
+            market_id=str(order.market_id),
+            selection_id=str(order.selection_id),
+            handicap=parse_handicap(order.handicap),
         )
-        venue_order_id = VenueOrderId(order["betId"])
+        venue_order_id = VenueOrderId(str(order.bet_id))
 
         report: OrderStatusReport = bet_to_order_status_report(
             order=order,
             account_id=self.account_id,
             instrument_id=instrument.id,
             venue_order_id=venue_order_id,
             client_order_id=self._cache.client_order_id(venue_order_id),
@@ -245,103 +255,106 @@
         )
 
         self._log.debug(f"Received {report}.")
         return report
 
     async def generate_order_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
         open_only: bool = False,
     ) -> list[OrderStatusReport]:
         self._log.warning("Cannot generate `OrderStatusReports`: not yet implemented.")
 
         return []
 
     async def generate_trade_reports(
         self,
-        instrument_id: InstrumentId = None,
-        venue_order_id: VenueOrderId = None,
+        instrument_id: Optional[InstrumentId] = None,
+        venue_order_id: Optional[VenueOrderId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[TradeReport]:
         self._log.warning("Cannot generate `TradeReports`: not yet implemented.")
 
         return []
 
     async def generate_position_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[PositionStatusReport]:
         self._log.warning("Cannot generate `PositionStatusReports`: not yet implemented.")
 
         return []
 
     # -- COMMAND HANDLERS -------------------------------------------------------------------------
 
     async def _submit_order(self, command: SubmitOrder) -> None:
         self._log.debug(f"Received submit_order {command}")
 
         self.generate_order_submitted(
-            instrument_id=command.instrument_id,
-            strategy_id=command.strategy_id,
-            client_order_id=command.order.client_order_id,
-            ts_event=self._clock.timestamp_ns(),
+            command.strategy_id,
+            command.instrument_id,
+            command.order.client_order_id,
+            self._clock.timestamp_ns(),
         )
         self._log.debug("Generated _generate_order_submitted")
 
         instrument = self._cache.instrument(command.instrument_id)
         PyCondition.not_none(instrument, "instrument")
         client_order_id = command.order.client_order_id
 
-        place_order = order_submit_to_betfair(command=command, instrument=instrument)
+        place_order_params: PlaceOrders.params = order_submit_to_place_order_params(
+            command=command,
+            instrument=instrument,
+        )
         try:
-            result = await self._client.place_orders(**place_order)
+            result: PlaceExecutionReport = await self._client.place_orders(place_order_params)
         except Exception as e:
-            if isinstance(e, BetfairAPIError):
+            if isinstance(e, BetfairError):
                 await self.on_api_exception(error=e)
             self._log.warning(f"Submit failed: {e}")
             self.generate_order_rejected(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=client_order_id,
-                reason="client error",
-                ts_event=self._clock.timestamp_ns(),
+                command.strategy_id,
+                command.instrument_id,
+                client_order_id,
+                "client error",
+                self._clock.timestamp_ns(),
             )
             return
 
         self._log.debug(f"result={result}")
-        for report in result["instructionReports"]:
-            if result["status"] == "FAILURE":
-                reason = f"{result['errorCode']}: {report['errorCode']}"
+        for report in result.instruction_reports:
+            if result.status == ExecutionReportStatus.FAILURE:
+                reason = f"{result.error_code.name} ({result.error_code.__doc__})"
                 self._log.warning(f"Submit failed - {reason}")
                 self.generate_order_rejected(
-                    strategy_id=command.strategy_id,
-                    instrument_id=command.instrument_id,
-                    client_order_id=client_order_id,
-                    reason=reason,
-                    ts_event=self._clock.timestamp_ns(),
+                    command.strategy_id,
+                    command.instrument_id,
+                    client_order_id,
+                    reason,
+                    self._clock.timestamp_ns(),
                 )
                 self._log.debug("Generated _generate_order_rejected")
                 return
             else:
-                venue_order_id = VenueOrderId(str(report["betId"]))
+                venue_order_id = VenueOrderId(str(report.bet_id))
                 self._log.debug(
                     f"Matching venue_order_id: {venue_order_id} to client_order_id: {client_order_id}",
                 )
                 self.venue_order_id_to_client_order_id[venue_order_id] = client_order_id
                 self.generate_order_accepted(
-                    strategy_id=command.strategy_id,
-                    instrument_id=command.instrument_id,
-                    client_order_id=client_order_id,
-                    venue_order_id=venue_order_id,
-                    ts_event=self._clock.timestamp_ns(),
+                    command.strategy_id,
+                    command.instrument_id,
+                    client_order_id,
+                    venue_order_id,
+                    self._clock.timestamp_ns(),
                 )
                 self._log.debug("Generated _generate_order_accepted")
 
     async def _modify_order(self, command: ModifyOrder) -> None:
         self._log.debug(f"Received modify_order {command}")
         client_order_id: ClientOrderId = command.client_order_id
         instrument = self._cache.instrument(command.instrument_id)
@@ -349,157 +362,154 @@
         existing_order = self._cache.order(client_order_id)  # type: Order
 
         if existing_order is None:
             self._log.warning(
                 f"Attempting to update order that does not exist in the cache: {command}",
             )
             self.generate_order_modify_rejected(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=client_order_id,
-                venue_order_id=command.venue_order_id,
-                reason="ORDER NOT IN CACHE",
-                ts_event=self._clock.timestamp_ns(),
+                command.strategy_id,
+                command.instrument_id,
+                client_order_id,
+                command.venue_order_id,
+                "ORDER NOT IN CACHE",
+                self._clock.timestamp_ns(),
             )
             return
         if existing_order.venue_order_id is None:
             self._log.warning(f"Order found does not have `id` set: {existing_order}")
             PyCondition.not_none(command.strategy_id, "command.strategy_id")
             PyCondition.not_none(command.instrument_id, "command.instrument_id")
             PyCondition.not_none(client_order_id, "client_order_id")
             self.generate_order_modify_rejected(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=client_order_id,
-                venue_order_id=None,
-                reason="ORDER MISSING VENUE_ORDER_ID",
-                ts_event=self._clock.timestamp_ns(),
+                command.strategy_id,
+                command.instrument_id,
+                client_order_id,
+                None,
+                "ORDER MISSING VENUE_ORDER_ID",
+                self._clock.timestamp_ns(),
             )
             return
 
         # Send order to client
-        kw = order_update_to_betfair(
+        replace_order_params = order_update_to_replace_order_params(
             command=command,
             venue_order_id=existing_order.venue_order_id,
-            side=existing_order.side,
             instrument=instrument,
         )
         self.pending_update_order_client_ids.add(
             (command.client_order_id, existing_order.venue_order_id),
         )
         try:
-            result = await self._client.replace_orders(**kw)
+            result = await self._client.replace_orders(replace_order_params)
         except Exception as e:
-            if isinstance(e, BetfairAPIError):
+            if isinstance(e, BetfairError):
                 await self.on_api_exception(error=e)
             self._log.warning(f"Modify failed: {e}")
             self.generate_order_modify_rejected(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=command.client_order_id,
-                venue_order_id=existing_order.venue_order_id,
-                reason="client error",
-                ts_event=self._clock.timestamp_ns(),
+                command.strategy_id,
+                command.instrument_id,
+                command.client_order_id,
+                existing_order.venue_order_id,
+                "client error",
+                self._clock.timestamp_ns(),
             )
             return
 
         self._log.debug(f"result={result}")
 
-        for report in result["instructionReports"]:
-            if report["status"] == "FAILURE":
-                reason = f"{result['errorCode']}: {report['errorCode']}"
+        for report in result.instruction_reports:
+            if report.status == ExecutionReportStatus.FAILURE:
+                reason = f"{result.error_code.name} ({result.error_code.__doc__})"
                 self._log.warning(f"replace failed - {reason}")
                 self.generate_order_rejected(
-                    strategy_id=command.strategy_id,
-                    instrument_id=command.instrument_id,
-                    client_order_id=command.client_order_id,
-                    reason=reason,
-                    ts_event=self._clock.timestamp_ns(),
+                    command.strategy_id,
+                    command.instrument_id,
+                    command.client_order_id,
+                    reason,
+                    self._clock.timestamp_ns(),
                 )
                 return
 
             # Check the venue_order_id that has been deleted currently exists on our order
-            deleted_bet_id = report["cancelInstructionReport"]["instruction"]["betId"]
+            deleted_bet_id = report.cancel_instruction_report.instruction.bet_id
             self._log.debug(f"{existing_order}, {deleted_bet_id}")
-            assert existing_order.venue_order_id == VenueOrderId(
-                deleted_bet_id,
-            ), f"{deleted_bet_id} != {existing_order.venue_order_id}"
+            err = f"{deleted_bet_id} != {existing_order.venue_order_id}"
+            assert existing_order.venue_order_id == VenueOrderId(str(deleted_bet_id)), err
 
-            update_instruction = report["placeInstructionReport"]
-            venue_order_id = VenueOrderId(update_instruction["betId"])
+            place_instruction = report.place_instruction_report
+            venue_order_id = VenueOrderId(str(place_instruction.bet_id))
             self.venue_order_id_to_client_order_id[venue_order_id] = client_order_id
             self.generate_order_updated(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=client_order_id,
-                venue_order_id=VenueOrderId(update_instruction["betId"]),
-                quantity=betfair_float_to_quantity(
-                    update_instruction["instruction"]["limitOrder"]["size"],
-                ),
-                price=betfair_float_to_price(
-                    update_instruction["instruction"]["limitOrder"]["price"],
-                ),
-                trigger_price=None,  # Not applicable for Betfair
-                ts_event=self._clock.timestamp_ns(),
-                venue_order_id_modified=True,
+                command.strategy_id,
+                command.instrument_id,
+                client_order_id,
+                venue_order_id,
+                betfair_float_to_quantity(place_instruction.instruction.limit_order.size),
+                betfair_float_to_price(place_instruction.instruction.limit_order.price),
+                None,  # Not applicable for Betfair
+                self._clock.timestamp_ns(),
+                True,
             )
 
     async def _cancel_order(self, command: CancelOrder) -> None:
         self._log.debug(f"Received cancel order: {command}")
         instrument = self._cache.instrument(command.instrument_id)
         PyCondition.not_none(instrument, "instrument")
 
         # Format
-        cancel_order = order_cancel_to_betfair(command=command, instrument=instrument)
-        self._log.debug(f"cancel_order {cancel_order}")
+        cancel_order_params = order_cancel_to_cancel_order_params(
+            command=command,
+            instrument=instrument,
+        )
+        self._log.debug(f"cancel_order {cancel_order_params}")
 
         # Send to client
         try:
-            result = await self._client.cancel_orders(**cancel_order)
+            result = await self._client.cancel_orders(cancel_order_params)
         except Exception as e:
-            if isinstance(e, BetfairAPIError):
+            if isinstance(e, BetfairError):
                 await self.on_api_exception(error=e)
             self._log.warning(f"Cancel failed: {e}")
             self.generate_order_cancel_rejected(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=command.client_order_id,
-                venue_order_id=command.venue_order_id,
-                reason="client error",
-                ts_event=self._clock.timestamp_ns(),
+                command.strategy_id,
+                command.instrument_id,
+                command.client_order_id,
+                command.venue_order_id,
+                "client error",
+                self._clock.timestamp_ns(),
             )
             return
         self._log.debug(f"result={result}")
 
         # Parse response
-        for report in result["instructionReports"]:
-            venue_order_id = VenueOrderId(report["instruction"]["betId"])
-            if report["status"] == "FAILURE":
-                reason = f"{result.get('errorCode', 'Error')}: {report['errorCode']}"
+        for report in result.instruction_reports:
+            venue_order_id = VenueOrderId(str(report.instruction.bet_id))
+            if report.status == InstructionReportStatus.FAILURE:
+                reason = f"{report.error_code.name}: {report.error_code.__doc__}"
                 self._log.warning(f"cancel failed - {reason}")
                 self.generate_order_cancel_rejected(
-                    strategy_id=command.strategy_id,
-                    instrument_id=command.instrument_id,
-                    client_order_id=command.client_order_id,
-                    venue_order_id=venue_order_id,
-                    reason=reason,
-                    ts_event=self._clock.timestamp_ns(),
+                    command.strategy_id,
+                    command.instrument_id,
+                    command.client_order_id,
+                    venue_order_id,
+                    reason,
+                    self._clock.timestamp_ns(),
                 )
                 return
 
             self._log.debug(
                 f"Matching venue_order_id: {venue_order_id} to client_order_id: {command.client_order_id}",
             )
             self.venue_order_id_to_client_order_id[venue_order_id] = command.client_order_id
             self.generate_order_canceled(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=command.client_order_id,
-                venue_order_id=venue_order_id,
-                ts_event=self._clock.timestamp_ns(),
+                command.strategy_id,
+                command.instrument_id,
+                command.client_order_id,
+                venue_order_id,
+                self._clock.timestamp_ns(),
             )
             self._log.debug("Sent order cancel")
 
     # TODO(cs): Currently not in use as old behavior restored to cancel orders individually
     async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
         open_orders = self._cache.orders_open(
             instrument_id=command.instrument_id,
@@ -539,15 +549,15 @@
         cancel_orders = order_cancel_all_to_betfair(instrument=instrument)
         self._log.debug(f"cancel_orders {cancel_orders}")
 
         # Send to client
         try:
             result = await self._client.cancel_orders(**cancel_orders)
         except Exception as e:
-            if isinstance(e, BetfairAPIError):
+            if isinstance(e, BetfairError):
                 await self.on_api_exception(error=e)
             self._log.error(f"Cancel failed: {e}")
             # TODO(cs): Will probably just need to recover the client order ID
             #  and order ID from the trade report?
             # self.generate_order_cancel_rejected(
             #     strategy_id=command.strategy_id,
             #     instrument_id=command.instrument_id,
@@ -557,17 +567,17 @@
             #     ts_event=self._clock.timestamp_ns(),
             # )
             return
         self._log.debug(f"result={result}")
 
         # Parse response
         for report in result["instructionReports"]:
-            venue_order_id = VenueOrderId(report["instruction"]["betId"])
+            venue_order_id = VenueOrderId(report.instruction.bet_id)
             if report["status"] == "FAILURE":
-                reason = f"{result.get('errorCode', 'Error')}: {report['errorCode']}"
+                reason = f"{result.error_code.name} ({result.error_code.__doc__})"
                 self._log.error(f"cancel failed - {reason}")
                 # TODO(cs): Will probably just need to recover the client order ID
                 #  and order ID from the trade report?
                 # self.generate_order_cancel_rejected(
                 #     strategy_id=command.strategy_id,
                 #     instrument_id=command.instrument_id,
                 #     client_order_id=command.client_order_id,
@@ -578,19 +588,19 @@
                 # return
 
             self._log.debug(
                 f"Matching venue_order_id: {venue_order_id} to client_order_id: {command.client_order_id}",
             )
             self.venue_order_id_to_client_order_id[venue_order_id] = command.client_order_id
             self.generate_order_canceled(
-                strategy_id=command.strategy_id,
-                instrument_id=command.instrument_id,
-                client_order_id=command.client_order_id,
-                venue_order_id=venue_order_id,
-                ts_event=self._clock.timestamp_ns(),
+                command.strategy_id,
+                command.instrument_id,
+                command.client_order_id,
+                venue_order_id,
+                self._clock.timestamp_ns(),
             )
             self._log.debug("Sent order cancel")
 
     # cpdef void bulk_submit_order(self, list commands):
     # betfair allows up to 200 inserts per request
     #     raise NotImplementedError
 
@@ -602,34 +612,37 @@
     # betfair allows up to 60 cancels per request
     #     raise NotImplementedError
 
     # -- ACCOUNT ----------------------------------------------------------------------------------
 
     async def check_account_currency(self) -> None:
         """
-        Check account currency against BetfairClient
+        Check account currency against BetfairHttpClient.
         """
         self._log.debug("Checking account currency")
         PyCondition.not_none(self.base_currency, "self.base_currency")
-        details = await self._client.get_account_details()
-        currency_code = details["currencyCode"]
+        details: AccountDetailsResponse = await self._client.get_account_details()
+        currency_code = details.currency_code
         self._log.debug(f"Account {currency_code=}, {self.base_currency.code=}")
         assert currency_code == self.base_currency.code
         self._log.debug("Base currency matches client details")
 
     # -- DEBUGGING --------------------------------------------------------------------------------
 
-    def client(self) -> BetfairClient:
+    def client(self) -> BetfairHttpClient:
         return self._client
 
     # -- ORDER STREAM API -------------------------------------------------------------------------
 
     def handle_order_stream_update(self, raw: bytes) -> None:
-        """Handle an update from the order stream socket"""
-        update = STREAM_DECODER.decode(raw)
+        """
+        Handle an update from the order stream socket.
+        """
+        update = stream_decode(raw)
+
         if isinstance(update, OCM):
             self.create_task(self._handle_order_stream_update(update))
         elif isinstance(update, Connection):
             pass
         elif isinstance(update, Status):
             self._handle_status_message(update=update)
         else:
@@ -687,15 +700,16 @@
                                 matched = True
                     if not matched:
                         self._log.error(f"UNKNOWN FILL: {instrument_id=} {matched_order}")
                         raise RuntimeError(f"UNKNOWN FILL: {instrument_id=} {matched_order}")
 
     async def _check_order_update(self, unmatched_order: UnmatchedOrder) -> None:
         """
-        Ensure we have a client_order_id, instrument and order for this venue order update
+        Ensure we have a client_order_id, instrument and order for this venue order
+        update.
         """
         venue_order_id = VenueOrderId(str(unmatched_order.id))
         client_order_id = await self.wait_for_order(
             venue_order_id=venue_order_id,
             timeout_seconds=10.0,
         )
         if client_order_id is None:
@@ -705,15 +719,15 @@
         order = self._cache.order(client_order_id)
         PyCondition.not_none(order, "order")
         instrument = self._cache.instrument(order.instrument_id)
         PyCondition.not_none(instrument, "instrument")
 
     def _handle_stream_executable_order_update(self, unmatched_order: UnmatchedOrder) -> None:
         """
-        Handle update containing "E" (executable) order update
+        Handle update containing "E" (executable) order update.
         """
         venue_order_id = VenueOrderId(unmatched_order.id)
         client_order_id = self.venue_order_id_to_client_order_id[venue_order_id]
         order = self._cache.order(client_order_id)
         instrument = self._cache.instrument(order.instrument_id)
 
         # Check if this is the first time seeing this order (backtest or replay)
@@ -744,15 +758,15 @@
                 self.generate_order_filled(
                     strategy_id=order.strategy_id,
                     instrument_id=order.instrument_id,
                     client_order_id=client_order_id,
                     venue_order_id=venue_order_id,
                     venue_position_id=None,  # Can be None
                     trade_id=trade_id,
-                    order_side=B2N_ORDER_STREAM_SIDE[unmatched_order.side],
+                    order_side=B2N_ORDER_SIDE[unmatched_order.side],
                     order_type=OrderType.LIMIT,
                     last_qty=betfair_float_to_quantity(fill_qty),
                     last_px=betfair_float_to_price(fill_price),
                     quote_currency=instrument.quote_currency,
                     commission=Money(0, self.base_currency),
                     liquidity_side=LiquiditySide.NO_LIQUIDITY_SIDE,
                     ts_event=millis_to_nanos(unmatched_order.md),
@@ -788,15 +802,15 @@
                 return price
 
     def _handle_stream_execution_complete_order_update(
         self,
         unmatched_order: UnmatchedOrder,
     ) -> None:
         """
-        Handle "EC" (execution complete) order updates
+        Handle "EC" (execution complete) order updates.
         """
         venue_order_id = VenueOrderId(str(unmatched_order.id))
         client_order_id = self._cache.client_order_id(venue_order_id=venue_order_id)
         order = self._cache.order(client_order_id=client_order_id)
         instrument = self._cache.instrument(order.instrument_id)
         assert instrument
 
@@ -813,15 +827,15 @@
                 self.generate_order_filled(
                     strategy_id=order.strategy_id,
                     instrument_id=instrument.id,
                     client_order_id=client_order_id,
                     venue_order_id=venue_order_id,
                     venue_position_id=None,  # Can be None
                     trade_id=trade_id,
-                    order_side=B2N_ORDER_STREAM_SIDE[unmatched_order.side],
+                    order_side=B2N_ORDER_SIDE[unmatched_order.side],
                     order_type=OrderType.LIMIT,
                     last_qty=betfair_float_to_quantity(fill_qty),
                     last_px=betfair_float_to_price(fill_price),
                     quote_currency=instrument.quote_currency,
                     # avg_px=order['avp'],
                     commission=Money(0, self.base_currency),
                     liquidity_side=LiquiditySide.TAKER,  # TODO - Fix this?
@@ -864,19 +878,20 @@
 
     async def wait_for_order(
         self,
         venue_order_id: VenueOrderId,
         timeout_seconds=10.0,
     ) -> Optional[ClientOrderId]:
         """
-        We may get an order update from the socket before our submit_order
-        response has come back (with our betId).
+        We may get an order update from the socket before our submit_order response has
+        come back (with our bet_id).
 
-        As a precaution, wait up to `timeout_seconds` for the betId to be added
+        As a precaution, wait up to `timeout_seconds` for the bet_id to be added
         to `self.order_id_to_client_order_id`.
+
         """
         assert isinstance(venue_order_id, VenueOrderId)
         start = self._clock.timestamp_ns()
         now = start
         while (now - start) < secs_to_nanos(timeout_seconds):
             # self._log.debug(
             #     f"checking venue_order_id={venue_order_id} in {self.venue_order_id_to_client_order_id}"
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/factories.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/factories.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
 import os
 from functools import lru_cache
 from typing import Optional
 
-from nautilus_trader.adapters.betfair.client.core import BetfairClient
+from nautilus_trader.adapters.betfair.client import BetfairHttpClient
 from nautilus_trader.adapters.betfair.config import BetfairDataClientConfig
 from nautilus_trader.adapters.betfair.config import BetfairExecClientConfig
 from nautilus_trader.adapters.betfair.data import BetfairDataClient
 from nautilus_trader.adapters.betfair.execution import BetfairExecutionClient
 from nautilus_trader.adapters.betfair.providers import BetfairInstrumentProvider
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
@@ -30,27 +30,26 @@
 from nautilus_trader.common.logging import LoggerAdapter
 from nautilus_trader.live.factories import LiveDataClientFactory
 from nautilus_trader.live.factories import LiveExecClientFactory
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.msgbus.bus import MessageBus
 
 
-CLIENTS: dict[str, BetfairClient] = {}
+CLIENTS: dict[str, BetfairHttpClient] = {}
 INSTRUMENT_PROVIDER = None
 
 
 @lru_cache(1)
 def get_cached_betfair_client(
     loop: asyncio.AbstractEventLoop,
     logger: Logger,
     username: Optional[str] = None,
     password: Optional[str] = None,
     app_key: Optional[str] = None,
-    cert_dir: Optional[str] = None,
-) -> BetfairClient:
+) -> BetfairHttpClient:
     """
     Cache and return a Betfair HTTP client with the given credentials.
 
     If a cached client with matching credentials already exists, then that
     cached client will be returned.
 
     Parameters
@@ -64,50 +63,44 @@
         If None then will source from the `BETFAIR_USERNAME` env var.
     password : str, optional
         The API password for the client.
         If None then will source from the `BETFAIR_PASSWORD` env var.
     app_key : str, optional
         The API application key for the client.
         If None then will source from the `BETFAIR_APP_KEY` env var.
-    cert_dir : str, optional
-        The API SSL certificate directory for the client.
-        If None then will source from the `BETFAIR_CERT_DIR` env var.
 
     Returns
     -------
-    BetfairClient
+    BetfairHttpClient
 
     """
     global CLIENTS
 
     username = username or os.environ["BETFAIR_USERNAME"]
     password = password or os.environ["BETFAIR_PASSWORD"]
     app_key = app_key or os.environ["BETFAIR_APP_KEY"]
-    cert_dir = cert_dir or os.environ["BETFAIR_CERT_DIR"]
 
-    key: str = "|".join((username, password, app_key, cert_dir))
+    key: str = "|".join((username, password, app_key))
     if key not in CLIENTS:
         LoggerAdapter("BetfairFactory", logger).warning(
-            "Creating new instance of BetfairClient",
+            "Creating new instance of BetfairHttpClient",
         )
-        client = BetfairClient(
+        client = BetfairHttpClient(
             username=username,
             password=password,
             app_key=app_key,
-            cert_dir=cert_dir,
-            loop=loop,
             logger=logger,
         )
         CLIENTS[key] = client
     return CLIENTS[key]
 
 
 @lru_cache(1)
 def get_cached_betfair_instrument_provider(
-    client: BetfairClient,
+    client: BetfairHttpClient,
     logger: Logger,
     market_filter: tuple,
 ) -> BetfairInstrumentProvider:
     """
     Cache and return a BetfairInstrumentProvider.
 
     If a cached provider already exists, then that cached provider will be returned.
@@ -119,15 +112,15 @@
     logger : Logger
         The logger for the instrument provider.
     market_filter : tuple
         The market filter to load into the instrument provider.
 
     Returns
     -------
-    BinanceInstrumentProvider
+    BetfairInstrumentProvider
 
     """
     global INSTRUMENT_PROVIDER
     if INSTRUMENT_PROVIDER is None:
         LoggerAdapter("BetfairFactory", logger).warning(
             "Creating new instance of BetfairInstrumentProvider",
         )
@@ -182,17 +175,16 @@
         market_filter: tuple = config.market_filter or ()
 
         # Create client
         client = get_cached_betfair_client(
             username=config.username,
             password=config.password,
             app_key=config.app_key,
-            cert_dir=config.cert_dir,
-            loop=loop,
             logger=logger,
+            loop=loop,
         )
         provider = get_cached_betfair_instrument_provider(
             client=client,
             logger=logger,
             market_filter=market_filter,
         )
 
@@ -248,19 +240,18 @@
         -------
         BetfairExecutionClient
 
         """
         market_filter: tuple = config.market_filter or ()
 
         client = get_cached_betfair_client(
+            loop=loop,
             username=config.username,
             password=config.password,
             app_key=config.app_key,
-            cert_dir=config.cert_dir,
-            loop=loop,
             logger=logger,
         )
         provider = get_cached_betfair_instrument_provider(
             client=client,
             logger=logger,
             market_filter=market_filter,
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/historic.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/historic.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from typing import Optional
 
 import msgspec
 from betfair_parser.spec.streaming import MCM
-from betfair_parser.spec.streaming import STREAM_DECODER
+from betfair_parser.spec.streaming import stream_decode
 
 from nautilus_trader.adapters.betfair.parsing.core import BetfairParser
 from nautilus_trader.adapters.betfair.providers import BetfairInstrumentProvider
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.persistence.external.readers import LinePreprocessor
 from nautilus_trader.persistence.external.readers import TextReader
 
@@ -31,18 +31,18 @@
 
     if instrument_provider is None:
         return
 
     mcm = msgspec.json.decode(line, type=MCM)
     # Find instruments in data
     for mc in mcm.mc:
-        if mc.marketDefinition:
-            market_def = msgspec.structs.replace(mc.marketDefinition, marketId=mc.id)
-            mc = msgspec.structs.replace(mc, marketDefinition=market_def)
-            instruments = make_instruments(mc.marketDefinition, currency="GBP")
+        if mc.market_definition:
+            market_def = msgspec.structs.replace(mc.market_definition, market_id=mc.id)
+            mc = msgspec.structs.replace(mc, market_definition=market_def)
+            instruments = make_instruments(mc.market_definition, currency="GBP")
             instrument_provider.add_bulk(instruments)
 
     # By this point we should always have some instruments loaded from historical data
     if not instrument_provider.list_all():
         # TODO - Need to add historical search
         raise Exception("No instruments found")
 
@@ -51,15 +51,15 @@
     instrument_provider: Optional[InstrumentProvider] = None,
     line_preprocessor: Optional[LinePreprocessor] = None,
 ) -> TextReader:
     instrument_provider = instrument_provider or BetfairInstrumentProvider.from_instruments([])
     parser = BetfairParser()
 
     def parse_line(line):
-        yield from parser.parse(STREAM_DECODER.decode(line))
+        yield from parser.parse(stream_decode(line))
 
     return TextReader(
         # Use the standard `on_market_update` betfair parser that the adapter uses
         line_preprocessor=line_preprocessor,
         line_parser=parse_line,
         instrument_provider_update=historical_instrument_provider_loader,
         instrument_provider=instrument_provider,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pxd` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/orderbook.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pyx` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/orderbook.pyx`

 * *Files 10% similar despite different names*

```diff
@@ -10,28 +10,29 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.adapters.betfair.common import BETFAIR_FLOAT_TO_PRICE
-from nautilus_trader.adapters.betfair.common import BETFAIR_PRICE_PRECISION
-from nautilus_trader.adapters.betfair.common import BETFAIR_QUANTITY_PRECISION
 from nautilus_trader.adapters.betfair.constants import BETFAIR_PRICE_PRECISION
 from nautilus_trader.adapters.betfair.constants import BETFAIR_QUANTITY_PRECISION
-from nautilus_trader.model.enums import BookType
-from nautilus_trader.model.orderbook.book import OrderBook
+from nautilus_trader.core.rust.model import BookType
 
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
 cpdef inline OrderBook create_betfair_order_book(InstrumentId instrument_id):
-    return OrderBook(instrument_id, BookType.L2_MBP)
+    return OrderBook(
+        instrument_id,
+        BookType.L2_MBP,
+    )
+
 
 
 cpdef Price betfair_float_to_price(double value):
     try:
         return BETFAIR_FLOAT_TO_PRICE[value]
     except KeyError:
         return Price(value, BETFAIR_PRICE_PRECISION)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/common.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/common.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,18 +8,19 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
+
 from functools import lru_cache
 from typing import Optional
 
-from nautilus_trader.adapters.betfair.common import BETFAIR_VENUE
+from nautilus_trader.adapters.betfair.constants import BETFAIR_VENUE
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Symbol
 
 
 def hash_market_trade(timestamp: int, price: float, volume: float):
     return f"{str(timestamp)[:-6]}{price}{volume!s}"
@@ -27,18 +28,19 @@
 
 def make_symbol(
     market_id: str,
     selection_id: str,
     selection_handicap: Optional[str],
 ) -> Symbol:
     """
-    Make symbol
+    Make symbol.
 
     >>> make_symbol(market_id="1.201070830", selection_id="123456", selection_handicap=None)
     Symbol('1.201070830|123456|None')
+
     """
 
     def _clean(s):
         return str(s).replace(" ", "").replace(":", "")
 
     value: str = "|".join(
         [_clean(k) for k in (market_id, selection_id, selection_handicap)],
@@ -50,15 +52,15 @@
 @lru_cache
 def betfair_instrument_id(
     market_id: str,
     selection_id: str,
     selection_handicap: Optional[str],
 ) -> InstrumentId:
     """
-    Create an instrument ID from betfair fields
+    Create an instrument ID from betfair fields.
 
     >>> betfair_instrument_id(market_id="1.201070830", selection_id="123456", selection_handicap=None)
     InstrumentId('1.201070830|123456|None.BETFAIR')
 
     """
     PyCondition.not_empty(market_id, "market_id")
     symbol = make_symbol(market_id, selection_id, selection_handicap)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/core.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/core.py`

 * *Files 4% similar despite different names*

```diff
@@ -23,15 +23,17 @@
 
 from nautilus_trader.adapters.betfair.parsing.streaming import PARSE_TYPES
 from nautilus_trader.adapters.betfair.parsing.streaming import market_change_to_updates
 from nautilus_trader.core.datetime import millis_to_nanos
 
 
 class BetfairParser:
-    """Stateful parser that keeps market definition"""
+    """
+    Stateful parser that keeps market definition.
+    """
 
     def __init__(self) -> None:
         self.market_definitions: dict[str, MarketDefinition] = {}
 
     def parse(self, mcm: MCM, ts_init: Optional[int] = None) -> list[PARSE_TYPES]:
         if isinstance(mcm, (Status, Connection, OCM)):
             return []
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/requests.py` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/market.pyx`

 * *Files 24% similar despite different names*

```diff
@@ -9,312 +9,324 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import datetime
-from functools import lru_cache
-from typing import Optional, Union
-
-import pandas as pd
-
-from nautilus_trader.adapters.betfair.common import B2N_ORDER_STREAM_SIDE
-from nautilus_trader.adapters.betfair.common import B2N_TIME_IN_FORCE
-from nautilus_trader.adapters.betfair.common import BETFAIR_FLOAT_TO_PRICE
-from nautilus_trader.adapters.betfair.common import BETFAIR_QUANTITY_PRECISION
-from nautilus_trader.adapters.betfair.common import BETFAIR_VENUE
-from nautilus_trader.adapters.betfair.common import MAX_BET_PRICE
-from nautilus_trader.adapters.betfair.common import MIN_BET_PRICE
-from nautilus_trader.adapters.betfair.common import N2B_SIDE
-from nautilus_trader.adapters.betfair.common import N2B_TIME_IN_FORCE
-from nautilus_trader.core.datetime import dt_to_unix_nanos
-from nautilus_trader.execution.messages import CancelOrder
-from nautilus_trader.execution.messages import ModifyOrder
-from nautilus_trader.execution.messages import SubmitOrder
-from nautilus_trader.execution.reports import OrderStatusReport
-from nautilus_trader.execution.reports import TradeReport
-from nautilus_trader.model.currency import Currency
-from nautilus_trader.model.enums import AccountType
-from nautilus_trader.model.enums import ContingencyType
-from nautilus_trader.model.enums import LiquiditySide
-from nautilus_trader.model.enums import OrderSide
-from nautilus_trader.model.enums import OrderStatus
-from nautilus_trader.model.enums import TimeInForce
-from nautilus_trader.model.enums import order_type_from_str
-from nautilus_trader.model.events import AccountState
-from nautilus_trader.model.identifiers import AccountId
-from nautilus_trader.model.identifiers import ClientOrderId
-from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import StrategyId
-from nautilus_trader.model.identifiers import Symbol
-from nautilus_trader.model.identifiers import TradeId
-from nautilus_trader.model.identifiers import VenueOrderId
-from nautilus_trader.model.instruments.betting import BettingInstrument
-from nautilus_trader.model.objects import AccountBalance
-from nautilus_trader.model.objects import Money
-from nautilus_trader.model.objects import Price
-from nautilus_trader.model.objects import Quantity
-from nautilus_trader.model.orders import LimitOrder
-from nautilus_trader.model.orders import MarketOrder
-
-
-def make_custom_order_ref(client_order_id: ClientOrderId, strategy_id: StrategyId) -> str:
-    return client_order_id.value.rsplit("-" + strategy_id.get_tag(), maxsplit=1)[0]
-
-
-def _make_limit_order(order: LimitOrder):
-    price = order.price.as_double()
-    size = order.quantity.as_double()
+import msgspec
 
-    if order.time_in_force == TimeInForce.AT_THE_OPEN:
-        return {
-            "orderType": "LIMIT_ON_CLOSE",
-            "limitOnCloseOrder": {"price": price, "liability": size},
-        }
-    elif order.time_in_force in (TimeInForce.GTC, TimeInForce.IOC, TimeInForce.FOK):
-        parsed = {
-            "orderType": "LIMIT",
-            "limitOrder": {"price": price, "size": size, "persistenceType": "PERSIST"},
-        }
-        if order.time_in_force in N2B_TIME_IN_FORCE:
-            parsed["limitOrder"]["timeInForce"] = N2B_TIME_IN_FORCE[order.time_in_force]  # type: ignore
-            parsed["limitOrder"]["persistenceType"] = "LAPSE"  # type: ignore
-        return parsed
-    else:
-        raise ValueError("Betfair only supports time_in_force of `GTC` or `AT_THE_OPEN`")
+from libc.stdint cimport uint64_t
 
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.uuid cimport UUID4
+from nautilus_trader.model.enums_c cimport ContingencyType
+from nautilus_trader.model.enums_c cimport OrderSide
+from nautilus_trader.model.enums_c cimport OrderType
+from nautilus_trader.model.enums_c cimport TimeInForce
+from nautilus_trader.model.enums_c cimport TriggerType
+from nautilus_trader.model.enums_c cimport contingency_type_to_str
+from nautilus_trader.model.enums_c cimport liquidity_side_to_str
+from nautilus_trader.model.enums_c cimport order_side_to_str
+from nautilus_trader.model.enums_c cimport order_type_to_str
+from nautilus_trader.model.enums_c cimport time_in_force_to_str
+from nautilus_trader.model.events.order cimport OrderInitialized
+from nautilus_trader.model.events.order cimport OrderUpdated
+from nautilus_trader.model.identifiers cimport ClientOrderId
+from nautilus_trader.model.identifiers cimport ExecAlgorithmId
+from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.identifiers cimport OrderListId
+from nautilus_trader.model.identifiers cimport StrategyId
+from nautilus_trader.model.identifiers cimport TraderId
+from nautilus_trader.model.objects cimport Quantity
+from nautilus_trader.model.orders.base cimport Order
 
-def _make_market_order(order: MarketOrder):
-    if order.time_in_force == TimeInForce.AT_THE_OPEN:
+
+cdef class MarketOrder(Order):
+    """
+    Represents a `Market` order.
+
+    A Market order is an order to BUY (or SELL) at the market bid or offer price.
+    A market order may increase the likelihood of a fill and the speed of
+    execution, but unlike the Limit order - a Market order provides no price
+    protection and may fill at a price far lower/higher than the top of book
+    bid/ask.
+
+    - A `Market-On-Open (MOO)` order can be represented using a time in force of ``AT_THE_OPEN``.
+    - A `Market-On-Close (MOC)` order can be represented using a time in force of ``AT_THE_CLOSE``.
+
+    Parameters
+    ----------
+    trader_id : TraderId
+        The trader ID associated with the order.
+    strategy_id : StrategyId
+        The strategy ID associated with the order.
+    instrument_id : InstrumentId
+        The order instrument ID.
+    client_order_id : ClientOrderId
+        The client order ID.
+    order_side : OrderSide {``BUY``, ``SELL``}
+        The order side.
+    quantity : Quantity
+        The order quantity (> 0).
+    init_id : UUID4
+        The order initialization event ID.
+    ts_init : uint64_t
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
+        The order time in force.
+    reduce_only : bool, default False
+        If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
+    contingency_type : ContingencyType, default ``NO_CONTINGENCY``
+        The order contingency type.
+    order_list_id : OrderListId, optional
+        The order list ID associated with the order.
+    linked_order_ids : list[ClientOrderId], optional
+        The order linked client order ID(s).
+    parent_order_id : ClientOrderId, optional
+        The order parent client order ID.
+    exec_algorithm_id : ExecAlgorithmId, optional
+        The execution algorithm ID for the order.
+    exec_algorithm_params : dict[str, Any], optional
+        The execution algorithm parameters for the order.
+    exec_spawn_id : ClientOrderId, optional
+        The execution algorithm spawning primary client order ID.
+    tags : str, optional
+        The custom user tags for the order. These are optional and can
+        contain any arbitrary delimiter if required.
+
+    Raises
+    ------
+    ValueError
+        If `order_side` is ``NO_ORDER_SIDE``.
+    ValueError
+        If `quantity` is not positive (> 0).
+    ValueError
+        If `time_in_force` is ``GTD``.
+
+    References
+    ----------
+    https://www.interactivebrokers.com/en/trading/orders/market.php
+    """
+
+    def __init__(
+        self,
+        TraderId trader_id not None,
+        StrategyId strategy_id not None,
+        InstrumentId instrument_id not None,
+        ClientOrderId client_order_id not None,
+        OrderSide order_side,
+        Quantity quantity not None,
+        UUID4 init_id not None,
+        uint64_t ts_init,
+        TimeInForce time_in_force = TimeInForce.GTC,
+        bint reduce_only = False,
+        bint quote_quantity = False,
+        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
+        OrderListId order_list_id = None,
+        list linked_order_ids = None,
+        ClientOrderId parent_order_id = None,
+        ExecAlgorithmId exec_algorithm_id = None,
+        dict exec_algorithm_params = None,
+        ClientOrderId exec_spawn_id = None,
+        str tags = None,
+    ):
+        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
+        Condition.not_equal(time_in_force, TimeInForce.GTD, "time_in_force", "GTD")
+
+        # Create initialization event
+        cdef OrderInitialized init = OrderInitialized(
+            trader_id=trader_id,
+            strategy_id=strategy_id,
+            instrument_id=instrument_id,
+            client_order_id=client_order_id,
+            order_side=order_side,
+            order_type=OrderType.MARKET,
+            quantity=quantity,
+            time_in_force=time_in_force,
+            post_only=False,
+            reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
+            options={},
+            emulation_trigger=TriggerType.NO_TRIGGER,
+            trigger_instrument_id=None,
+            contingency_type=contingency_type,
+            order_list_id=order_list_id,
+            linked_order_ids=linked_order_ids,
+            parent_order_id=parent_order_id,
+            exec_algorithm_id=exec_algorithm_id,
+            exec_algorithm_params=exec_algorithm_params,
+            exec_spawn_id=exec_spawn_id,
+            tags=tags,
+            event_id=init_id,
+            ts_init=ts_init,
+        )
+        super().__init__(init=init)
+
+    cdef void _updated(self, OrderUpdated event):
+        if event.quantity is not None:
+            self.quantity = event.quantity
+            self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
+
+    cdef bint has_price_c(self):
+        return False
+
+    cdef bint has_trigger_price_c(self):
+        return False
+
+    cpdef str info(self):
+        """
+        Return a summary description of the order.
+
+        Returns
+        -------
+        str
+
+        """
+        return (
+            f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
+            f"{order_type_to_str(self.order_type)} "
+            f"{time_in_force_to_str(self.time_in_force)}"
+        )
+
+    cpdef dict to_dict(self):
+        """
+        Return a dictionary representation of this object.
+
+        Returns
+        -------
+        dict[str, object]
+
+        """
+        cdef ClientOrderId o
         return {
-            "orderType": "MARKET_ON_CLOSE",
-            "marketOnCloseOrder": {
-                "liability": str(order.quantity.as_double()),
-            },
+            "trader_id": self.trader_id.to_str(),
+            "strategy_id": self.strategy_id.to_str(),
+            "instrument_id": self.instrument_id.to_str(),
+            "client_order_id": self.client_order_id.to_str(),
+            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
+            "position_id": self.position_id.to_str() if self.position_id is not None else None,
+            "account_id": self.account_id.to_str() if self.account_id is not None else None,
+            "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
+            "type": order_type_to_str(self.order_type),
+            "side": order_side_to_str(self.side),
+            "quantity": str(self.quantity),
+            "time_in_force": time_in_force_to_str(self.time_in_force),
+            "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
+            "filled_qty": str(self.filled_qty),
+            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
+            "status": self._fsm.state_string_c(),
+            "contingency_type": contingency_type_to_str(self.contingency_type),
+            "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
+            "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
+            "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
+            "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
+            "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
+            "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
+            "tags": self.tags,
+            "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
-    elif order.time_in_force == TimeInForce.GTC:
-        # Betfair doesn't really support market orders, return a limit order with min/max price
-        limit_order = LimitOrder(
+
+    @staticmethod
+    cdef MarketOrder create(OrderInitialized init):
+        """
+        Return a `market` order from the given initialized event.
+
+        Parameters
+        ----------
+        init : OrderInitialized
+            The event to initialize with.
+
+        Returns
+        -------
+        MarketOrder
+
+        Raises
+        ------
+        ValueError
+            If `init.order_type` is not equal to ``MARKET``.
+
+        """
+        Condition.not_none(init, "init")
+        Condition.equal(init.order_type, OrderType.MARKET, "init.order_type", "OrderType")
+
+        return MarketOrder(
+            trader_id=init.trader_id,
+            strategy_id=init.strategy_id,
+            instrument_id=init.instrument_id,
+            client_order_id=init.client_order_id,
+            order_side=init.side,
+            quantity=init.quantity,
+            time_in_force=init.time_in_force,
+            reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
+            init_id=init.id,
+            ts_init=init.ts_init,
+            contingency_type=init.contingency_type,
+            order_list_id=init.order_list_id,
+            linked_order_ids=init.linked_order_ids,
+            parent_order_id=init.parent_order_id,
+            exec_algorithm_id=init.exec_algorithm_id,
+            exec_algorithm_params=init.exec_algorithm_params,
+            exec_spawn_id=init.exec_spawn_id,
+            tags=init.tags,
+        )
+
+    @staticmethod
+    cdef MarketOrder transform(Order order, uint64_t ts_init):
+        """
+        Transform the given order to a `market` order.
+
+        All existing events will be prepended to the orders internal events
+        prior to the new `OrderInitialized` event.
+
+        Parameters
+        ----------
+        order : Order
+            The order to transform from.
+        ts_init : uint64_t
+            The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        MarketOrder
+
+        """
+        Condition.not_none(order, "order")
+
+        cdef list original_events = order.events_c()
+        cdef MarketOrder transformed = MarketOrder(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             order_side=order.side,
             quantity=order.quantity,
-            price=MIN_BET_PRICE if order.side == OrderSide.BUY else MAX_BET_PRICE,
-            time_in_force=TimeInForce.FOK,
-            init_id=order.init_id,
-            ts_init=order.ts_init,
+            time_in_force=order.time_in_force if order.time_in_force != TimeInForce.GTD else TimeInForce.GTC,
+            reduce_only=order.is_reduce_only,
+            quote_quantity=order.is_quote_quantity,
+            init_id=UUID4(),
+            ts_init=ts_init,
+            contingency_type=order.contingency_type,
+            order_list_id=order.order_list_id,
+            linked_order_ids=order.linked_order_ids,
+            parent_order_id=order.parent_order_id,
+            exec_algorithm_id=order.exec_algorithm_id,
+            exec_algorithm_params=order.exec_algorithm_params,
+            exec_spawn_id=order.exec_spawn_id,
+            tags=order.tags,
         )
-        limit_order = _make_limit_order(order=limit_order)
-        # We transform the size of a limit order inside `_make_limit_order` but for a market order we want to just use
-        # the size as is.
-        limit_order["limitOrder"]["size"] = order.quantity.as_double()
-        return limit_order
-    else:
-        raise ValueError("Betfair only supports time_in_force of `GTC` or `AT_THE_OPEN`")
-
-
-def make_order(order: Union[LimitOrder, MarketOrder]):
-    if isinstance(order, LimitOrder):
-        return _make_limit_order(order=order)
-    elif isinstance(order, MarketOrder):
-        return _make_market_order(order=order)
-    else:
-        raise TypeError(f"Unknown order type: {type(order)}")
 
+        Order._hydrate_initial_events(original=order, transformed=transformed)
 
-def order_submit_to_betfair(command: SubmitOrder, instrument: BettingInstrument) -> dict:
-    """
-    Convert a SubmitOrder command into the data required by BetfairClient.
-    """
-    order = make_order(command.order)
+        return transformed
 
-    place_order = {
-        "market_id": instrument.market_id,
-        # Used to de-dupe orders on betfair server side
-        "customer_ref": command.id.value.replace("-", ""),
-        "customer_strategy_ref": command.strategy_id.value[:15],
-        "instructions": [
-            {
-                **order,
-                "selectionId": instrument.selection_id,
-                "side": N2B_SIDE[command.order.side],
-                "handicap": instrument.selection_handicap,
-                # Remove the strategy name from customer_order_ref; it has a limited size and don't control what
-                # length the strategy might be or what characters users might append
-                "customerOrderRef": make_custom_order_ref(
-                    client_order_id=command.order.client_order_id,
-                    strategy_id=command.strategy_id,
-                ),
-            },
-        ],
-    }
-    return place_order
-
-
-def order_update_to_betfair(
-    command: ModifyOrder,
-    venue_order_id: VenueOrderId,
-    side: OrderSide,
-    instrument: BettingInstrument,
-):
-    """
-    Convert an ModifyOrder command into the data required by BetfairClient.
-    """
-    return {
-        "market_id": instrument.market_id,
-        "customer_ref": command.id.value.replace("-", ""),
-        "instructions": [
-            {
-                "betId": venue_order_id.value,
-                "newPrice": command.price.as_double(),
-            },
-        ],
-    }
-
-
-def order_cancel_to_betfair(command: CancelOrder, instrument: BettingInstrument):
-    """
-    Convert a CancelOrder command into the data required by BetfairClient.
-    """
-    return {
-        "market_id": instrument.market_id,
-        "customer_ref": command.id.value.replace("-", ""),
-        "instructions": [{"betId": command.venue_order_id.value}],
-    }
-
-
-def order_cancel_all_to_betfair(instrument: BettingInstrument):
-    """
-    Convert a CancelAllOrders command into the data required by BetfairClient.
-    """
-    return {
-        "market_id": instrument.market_id,
-    }
-
-
-def betfair_account_to_account_state(
-    account_detail,
-    account_funds,
-    event_id,
-    ts_event,
-    ts_init,
-    account_id="001",
-) -> AccountState:
-    currency = Currency.from_str(account_detail["currencyCode"])
-    balance = float(account_funds["availableToBetBalance"])
-    locked = -float(account_funds["exposure"]) if account_funds["exposure"] else 0.0
-    free = balance - locked
-    return AccountState(
-        account_id=AccountId(f"{BETFAIR_VENUE.value}-{account_id}"),
-        account_type=AccountType.BETTING,
-        base_currency=currency,
-        reported=False,
-        balances=[
-            AccountBalance(
-                total=Money(balance, currency),
-                locked=Money(locked, currency),
-                free=Money(free, currency),
-            ),
-        ],
-        margins=[],
-        info={"funds": account_funds, "detail": account_detail},
-        event_id=event_id,
-        ts_event=ts_event,
-        ts_init=ts_init,
-    )
-
-
-async def generate_trades_list(
-    self,
-    venue_order_id: VenueOrderId,
-    symbol: Symbol,
-    since: datetime = None,  # type: ignore
-) -> list[TradeReport]:
-    filled = self.client().betting.list_cleared_orders(
-        bet_ids=[venue_order_id],
-    )
-    if not filled["clearedOrders"]:
-        self._log.warn(f"Found no existing order for {venue_order_id}")
-        return []
-    fill = filled["clearedOrders"][0]
-    ts_event = pd.Timestamp(fill["lastMatchedDate"]).value
-    return [
-        TradeReport(
-            client_order_id=self.venue_order_id_to_client_order_id[venue_order_id],
-            venue_order_id=VenueOrderId(fill["betId"]),
-            venue_position_id=None,  # Can be None
-            trade_id=TradeId(fill["lastMatchedDate"]),
-            last_qty=Quantity.from_str(str(fill["sizeSettled"])),  # TODO: Incorrect precision?
-            last_px=Price.from_str(str(fill["priceMatched"])),  # TODO: Incorrect precision?
-            commission=None,  # Can be None
-            liquidity_side=LiquiditySide.NO_LIQUIDITY_SIDE,
-            ts_event=ts_event,
-            ts_init=ts_event,
-        ),
-    ]
-
-
-@lru_cache(None)
-def parse_handicap(x) -> Optional[str]:
-    """
-    Ensure consistent parsing of the various handicap sources we get.
-    """
-    if x in (None, ""):
-        return "0.0"
-    if isinstance(x, (int, str)):
-        return str(float(x))
-    elif isinstance(x, float):
-        return str(x)
-    else:
-        raise TypeError(f"Unexpected type ({type(x)}) for handicap: {x}")
-
-
-def bet_to_order_status_report(
-    order,
-    account_id: AccountId,
-    instrument_id: InstrumentId,
-    venue_order_id: VenueOrderId,
-    client_order_id: ClientOrderId,
-    ts_init,
-    report_id,
-) -> OrderStatusReport:
-    return OrderStatusReport(
-        account_id=account_id,
-        instrument_id=instrument_id,
-        venue_order_id=venue_order_id,
-        client_order_id=client_order_id,
-        order_side=B2N_ORDER_STREAM_SIDE[order["side"]],
-        order_type=order_type_from_str(order["orderType"]),
-        contingency_type=ContingencyType.NO_CONTINGENCY,
-        time_in_force=B2N_TIME_IN_FORCE[order["persistenceType"]],
-        order_status=determine_order_status(order),
-        price=BETFAIR_FLOAT_TO_PRICE[order["priceSize"]["price"]],
-        quantity=Quantity(order["priceSize"]["size"], BETFAIR_QUANTITY_PRECISION),
-        filled_qty=Quantity(order["sizeMatched"], BETFAIR_QUANTITY_PRECISION),
-        report_id=report_id,
-        ts_accepted=dt_to_unix_nanos(pd.Timestamp(order["placedDate"])),
-        ts_triggered=0,
-        ts_last=dt_to_unix_nanos(pd.Timestamp(order["matchedDate"]))
-        if "matchedDate" in order
-        else 0,
-        ts_init=ts_init,
-    )
-
-
-def determine_order_status(order: dict) -> OrderStatus:
-    order_size = order["priceSize"]["size"]
-    if order["status"] == "EXECUTION_COMPLETE":
-        if order_size == order["sizeMatched"]:
-            return OrderStatus.FILLED
-        elif order["sizeCancelled"] > 0.0:
-            return OrderStatus.CANCELED
-        else:
-            return OrderStatus.PARTIALLY_FILLED
-    elif order["status"] == "EXECUTABLE":
-        if order["sizeMatched"] == 0.0:
-            return OrderStatus.ACCEPTED
-        elif order["sizeMatched"] > 0.0:
-            return OrderStatus.PARTIALLY_FILLED
+    @staticmethod
+    def transform_py(Order order, uint64_t ts_init) -> MarketOrder:
+        return MarketOrder.transform(order, ts_init)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/streaming.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/parsing/streaming.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,78 +9,75 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import datetime
 from collections import defaultdict
+from datetime import datetime
 from typing import Literal, Optional, Union
 
 import pandas as pd
+from betfair_parser.spec.betting.type_definitions import ClearedOrderSummary
 from betfair_parser.spec.streaming.mcm import MarketChange
 from betfair_parser.spec.streaming.mcm import MarketDefinition
 from betfair_parser.spec.streaming.mcm import Runner
 from betfair_parser.spec.streaming.mcm import RunnerChange
 from betfair_parser.spec.streaming.mcm import RunnerStatus
+from betfair_parser.spec.streaming.mcm import _PriceVolume
 
-from nautilus_trader.adapters.betfair.client.spec import ClearedOrder
-from nautilus_trader.adapters.betfair.common import B2N_MARKET_STREAM_SIDE
-from nautilus_trader.adapters.betfair.constants import BETFAIR_PRICE_PRECISION
-from nautilus_trader.adapters.betfair.constants import BETFAIR_QUANTITY_PRECISION
+from nautilus_trader.adapters.betfair.common import B2N_MARKET_SIDE
 from nautilus_trader.adapters.betfair.constants import CLOSE_PRICE_LOSER
 from nautilus_trader.adapters.betfair.constants import CLOSE_PRICE_WINNER
 from nautilus_trader.adapters.betfair.constants import MARKET_STATUS_MAPPING
-from nautilus_trader.adapters.betfair.constants import STRICT_MARKET_DATA_HANDLING
-from nautilus_trader.adapters.betfair.constants import MarketDataKind
 from nautilus_trader.adapters.betfair.data_types import BetfairStartingPrice
 from nautilus_trader.adapters.betfair.data_types import BetfairTicker
 from nautilus_trader.adapters.betfair.data_types import BSPOrderBookDelta
 from nautilus_trader.adapters.betfair.data_types import BSPOrderBookDeltas
 from nautilus_trader.adapters.betfair.orderbook import betfair_float_to_price
 from nautilus_trader.adapters.betfair.orderbook import betfair_float_to_quantity
 from nautilus_trader.adapters.betfair.parsing.common import betfair_instrument_id
 from nautilus_trader.adapters.betfair.parsing.common import hash_market_trade
 from nautilus_trader.adapters.betfair.parsing.requests import parse_handicap
+from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.execution.reports import TradeReport
-from nautilus_trader.model.data import BookOrder
-from nautilus_trader.model.data import InstrumentClose
-from nautilus_trader.model.data import InstrumentStatusUpdate
-from nautilus_trader.model.data import OrderBookDelta
-from nautilus_trader.model.data import OrderBookDeltas
-from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.data.book import BookOrder
+from nautilus_trader.model.data.book import OrderBookDelta
+from nautilus_trader.model.data.book import OrderBookDeltas
+from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data.venue import InstrumentClose
+from nautilus_trader.model.data.venue import InstrumentStatusUpdate
 from nautilus_trader.model.enums import AggressorSide
 from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.enums import InstrumentCloseType
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import MarketStatus
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Symbol
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
 from nautilus_trader.model.objects import Price
-from nautilus_trader.model.objects import Quantity
 
 
 PARSE_TYPES = Union[
     InstrumentStatusUpdate,
     InstrumentClose,
     OrderBookDeltas,
     TradeTick,
     BetfairTicker,
     BSPOrderBookDelta,
     BSPOrderBookDeltas,
     BetfairStartingPrice,
 ]
 
 
-def market_change_to_updates(  # noqa: too complex
+def market_change_to_updates(  # noqa: C901
     mc: MarketChange,
     ts_event: int,
     ts_init: int,
 ) -> list[PARSE_TYPES]:
     updates: list[PARSE_TYPES] = []
 
     # Handle instrument status and close updates first
@@ -179,15 +176,15 @@
             try:
                 status = MARKET_STATUS_MAPPING[key]
             except KeyError:
                 raise ValueError(
                     f"{runner.status=} {market_definition.status=} {market_definition.in_play=}",
                 )
         status = InstrumentStatusUpdate(
-            instrument_id=instrument_id,
+            instrument_id,
             status=status,
             ts_event=ts_event,
             ts_init=ts_init,
         )
         updates.append(status)
     return updates
 
@@ -208,31 +205,31 @@
 
 def runner_to_instrument_close(
     runner: Runner,
     market_id: str,
     ts_event: int,
     ts_init: int,
 ) -> Optional[InstrumentClose]:
-    instrument_id = betfair_instrument_id(
+    instrument_id: InstrumentId = betfair_instrument_id(
         market_id=market_id,
         selection_id=str(runner.runner_id),
         selection_handicap=parse_handicap(runner.handicap),
     )
 
     if runner.status in (RunnerStatus.LOSER, RunnerStatus.REMOVED):
         return InstrumentClose(
-            instrument_id=instrument_id,
+            instrument_id,
             close_price=CLOSE_PRICE_LOSER,
             close_type=InstrumentCloseType.CONTRACT_EXPIRED,
             ts_event=ts_event,
             ts_init=ts_init,
         )
     elif runner.status in (RunnerStatus.WINNER, RunnerStatus.PLACED):
         return InstrumentClose(
-            instrument_id=instrument_id,
+            instrument_id,
             close_price=CLOSE_PRICE_WINNER,
             close_type=InstrumentCloseType.CONTRACT_EXPIRED,
             ts_event=ts_event,
             ts_init=ts_init,
         )
     elif runner.status == RunnerStatus.ACTIVE:
         return None
@@ -272,319 +269,156 @@
             ts_event=ts_event,
             ts_init=ts_init,
         )
     else:
         return None
 
 
-def runner_change_to_market_data_kind(rc: RunnerChange) -> MarketDataKind:
-    if rc.atb or rc.atl:
-        if STRICT_MARKET_DATA_HANDLING:
-            assert not any((rc.batb, rc.batl, rc.bdatb, rc.bdatl)), "Mixed market data kinds"
-        return MarketDataKind.ALL
-    elif rc.batl or rc.batb:
-        if STRICT_MARKET_DATA_HANDLING:
-            assert not any((rc.atb, rc.atl, rc.bdatb, rc.bdatl)), "Mixed market data kinds"
-        return MarketDataKind.BEST
-    elif rc.bdatb or rc.bdatl:
-        if STRICT_MARKET_DATA_HANDLING:
-            assert not any((rc.atb, rc.atl, rc.batb, rc.batl)), "Mixed market data kinds"
-        return MarketDataKind.DISPLAY
-    else:
-        raise ValueError("rc contains no valid market data")
+def _price_volume_to_book_order(pv: _PriceVolume, side: OrderSide, order_id: int) -> BookOrder:
+    return BookOrder(
+        side,
+        betfair_float_to_price(pv.price),
+        betfair_float_to_quantity(pv.volume),
+        order_id,
+    )
+
+
+def price_to_order_id(price: Price) -> int:
+    return int(price.as_double() * 10**price.precision)
 
 
 def runner_change_to_order_book_snapshot(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
-) -> Optional[OrderBookDeltas]:
-    try:
-        market_data_kind = runner_change_to_market_data_kind(rc)
-    except ValueError:
-        return None
-    if market_data_kind == MarketDataKind.ALL:
-        return runner_change_all_depth_to_order_book_snapshot(rc, instrument_id, ts_event, ts_init)
-    elif market_data_kind == MarketDataKind.BEST:
-        return runner_change_best_depth_to_order_book_snapshot(rc, instrument_id, ts_event, ts_init)
-    elif market_data_kind == MarketDataKind.DISPLAY:
-        return runner_change_display_depth_to_order_book_snapshot(
-            rc,
+) -> OrderBookDeltas:
+    """
+    Convert a RunnerChange to a OrderBookDeltas snapshot.
+    """
+    # Check for incorrect data types
+    assert not (
+        rc.bdatb or rc.bdatl
+    ), "Incorrect orderbook data found (best display), should only be `atb` and `atl`"
+    assert not (
+        rc.batb or rc.batl
+    ), "Incorrect orderbook data found (best) should only be `atb` and `atl`"
+
+    deltas: list[OrderBookDelta] = [
+        OrderBookDelta(
             instrument_id,
+            BookAction.CLEAR,
+            None,
             ts_event,
             ts_init,
-        )
-    else:
-        raise ValueError("Unknown market data kind")
-
-
-def runner_change_all_depth_to_order_book_snapshot(
-    rc: RunnerChange,
-    instrument_id: InstrumentId,
-    ts_event: int,
-    ts_init: int,
-) -> Optional[OrderBookDeltas]:
-    # ATL = Available To Lay = Back orders
-    if rc.atl:
-        asks: list = [
-            (betfair_float_to_price(order.price), order.volume) for order in rc.atl if order.price
-        ]
-    else:
-        asks = []
-
-    # Asks are available to back (atb)
-    if rc.atb:
-        bids: list = [
-            (betfair_float_to_price(order.price), order.volume) for order in rc.atb if order.price
-        ]
-    else:
-        bids = []
-
-    deltas = bids + asks
-    deltas.insert(0, OrderBookDelta.clear(instrument_id, ts_event, ts_init))
-    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
-
-
-def runner_change_best_depth_to_order_book_snapshot(
-    rc: RunnerChange,
-    instrument_id: InstrumentId,
-    ts_event: int,
-    ts_init: int,
-) -> Optional[OrderBookDeltas]:
-    # Bids are best available to lay (batl)
-    if rc.batl:
-        asks: list = [
-            (betfair_float_to_price(order.price), order.volume) for order in rc.batl if order.price
-        ]
-    else:
-        asks = []
-
-    # Asks are best available to back (batb)
-    if rc.batb:
-        bids: list = [
-            (betfair_float_to_price(order.price), order.volume) for order in rc.batb if order.price
-        ]
-    else:
-        bids = []
-    deltas = bids + asks
-    deltas.insert(0, OrderBookDelta.clear(instrument_id, ts_event, ts_init))
-    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
-
-
-def runner_change_display_depth_to_order_book_snapshot(
-    rc: RunnerChange,
-    instrument_id: InstrumentId,
-    ts_event: int,
-    ts_init: int,
-) -> Optional[OrderBookDeltas]:
-    # Bids are best display available to lay (bdatl)
-    asks = (
-        [(betfair_float_to_price(order.price), order.volume) for order in rc.bdatl if order.price]
-        if rc.bdatl
-        else []
-    )
-    # Asks are best display available to back (bdatb)
-    if rc.bdatb:
-        bids: list = [
-            (betfair_float_to_price(order.price), order.volume) for order in rc.bdatb if order.price
-        ]
-    else:
-        bids = []
-    return OrderBookDeltas(
-        instrument_id=instrument_id,
-        deltas=bids + asks,
-    )
-
+        ),
+    ]
 
-def runner_change_to_order_book_deltas(
-    rc: RunnerChange,
-    instrument_id: InstrumentId,
-    ts_event: int,
-    ts_init: int,
-) -> Optional[OrderBookDeltas]:
-    try:
-        market_data_kind = runner_change_to_market_data_kind(rc)
-    except ValueError:
-        return None
-    if market_data_kind == MarketDataKind.ALL:
-        return runner_change_all_depth_to_order_book_deltas(rc, instrument_id, ts_event, ts_init)
-    elif market_data_kind == MarketDataKind.BEST:
-        return runner_change_best_depth_to_deltas(rc, instrument_id, ts_event, ts_init)
-    elif market_data_kind == MarketDataKind.DISPLAY:
-        return runner_change_display_depth_to_deltas(
-            rc,
+    # Bids are available to back (atb)
+    for bid in rc.atb:
+        bid_price = betfair_float_to_price(bid.price)
+        bid_volume = betfair_float_to_quantity(bid.volume)
+        bid_order_id = price_to_order_id(bid_price)
+        delta = OrderBookDelta(
             instrument_id,
+            BookAction.UPDATE if bid.volume > 0.0 else BookAction.DELETE,
+            BookOrder(OrderSide.BUY, bid_price, bid_volume, bid_order_id),
             ts_event,
             ts_init,
         )
-    else:
-        raise ValueError("Unknown market data kind")
+        deltas.append(delta)
 
-
-def runner_change_all_depth_to_order_book_deltas(
-    rc: RunnerChange,
-    instrument_id: InstrumentId,
-    ts_event: int,
-    ts_init: int,
-) -> Optional[OrderBookDeltas]:
-    deltas: list[OrderBookDelta] = []
-
-    # Bids are available to lay (atl)
-    if rc.atl:
-        deltas.extend(
-            [
-                OrderBookDelta(
-                    instrument_id,
-                    BookAction.UPDATE if back.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(
-                        OrderSide.SELL,
-                        Price(back.price, BETFAIR_PRICE_PRECISION),
-                        Quantity(back.volume, BETFAIR_QUANTITY_PRECISION),
-                        ts_init,
-                    ),
-                    ts_event,
-                    ts_init,
-                )
-                for back in rc.atl
-            ],
+    # Asks are available to back (atl)
+    for ask in rc.atl:
+        ask_price = betfair_float_to_price(ask.price)
+        ask_volume = betfair_float_to_quantity(ask.volume)
+        ask_order_id = price_to_order_id(ask_price)
+        delta = OrderBookDelta(
+            instrument_id,
+            BookAction.UPDATE if ask.volume > 0.0 else BookAction.DELETE,
+            BookOrder(OrderSide.SELL, ask_price, ask_volume, ask_order_id),
+            ts_event,
+            ts_init,
         )
+        deltas.append(delta)
 
-    # Asks are available to back (atb)
-    if rc.atb:
-        deltas.extend(
-            [
-                OrderBookDelta(
-                    instrument_id,
-                    BookAction.UPDATE if lay.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(
-                        OrderSide.BUY,
-                        Price(lay.price, BETFAIR_PRICE_PRECISION),
-                        Quantity(lay.volume, BETFAIR_QUANTITY_PRECISION),
-                        ts_init,
-                    ),
-                    ts_event,
-                    ts_init,
-                )
-                for lay in rc.atb
-            ],
-        )
-    if not deltas:
-        return None
-    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
+    return OrderBookDeltas(instrument_id, deltas)
 
 
-def runner_change_best_depth_to_deltas(
+def runner_change_to_order_book_deltas(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
 ) -> Optional[OrderBookDeltas]:
-    deltas: list[OrderBookDelta] = []
-
-    # Bids are best available to lay (batl)
-    if rc.batl:
-        deltas.extend(
-            [
-                OrderBookDelta(
-                    instrument_id,
-                    BookAction.UPDATE if back.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(back.price, back.volume, OrderSide.SELL),
-                    ts_event,
-                    ts_init,
-                )
-                for back in rc.batl
-            ],
-        )
-
-    # Asks are best available to back (batb)
-    if rc.batb:
-        deltas.extend(
-            [
-                OrderBookDelta(
-                    instrument_id,
-                    BookAction.UPDATE if lay.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(lay.price, lay.volume, OrderSide.BUY),
-                    ts_event,
-                    ts_init,
-                )
-                for lay in rc.batb
-            ],
-        )
-    if not deltas:
-        return None
-    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
+    """
+    Convert a RunnerChange to a list of OrderBookDeltas.
+    """
+    assert not (
+        rc.bdatb or rc.bdatl
+    ), "Incorrect orderbook data found (best display), should only be `atb` and `atl`"
+    assert not (
+        rc.batb or rc.batl
+    ), "Incorrect orderbook data found (best) should only be `atb` and `atl`"
 
-
-def runner_change_display_depth_to_deltas(
-    rc: RunnerChange,
-    instrument_id: InstrumentId,
-    ts_event: int,
-    ts_init: int,
-) -> Optional[OrderBookDeltas]:
     deltas: list[OrderBookDelta] = []
 
-    # Bids are best display available to lay (bdatl)
-    if rc.bdatl:
-        deltas.extend(
-            [
-                OrderBookDelta(
-                    instrument_id,
-                    BookAction.UPDATE if back.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(back.price, back.volume, OrderSide.SELL),
-                    ts_event,
-                    ts_init,
-                )
-                for back in rc.bdatl
-            ],
+    # Bids are available to back (atb)
+    for bid in rc.atb:
+        bid_price = betfair_float_to_price(bid.price)
+        bid_volume = betfair_float_to_quantity(bid.volume)
+        bid_order_id = price_to_order_id(bid_price)
+        delta = OrderBookDelta(
+            instrument_id,
+            BookAction.UPDATE if bid.volume > 0.0 else BookAction.DELETE,
+            BookOrder(OrderSide.BUY, bid_price, bid_volume, bid_order_id),
+            ts_event,
+            ts_init,
         )
+        deltas.append(delta)
 
-    # Asks are best display available to back (bdatb)
-    if rc.bdatb:
-        deltas.extend(
-            [
-                OrderBookDelta(
-                    instrument_id,
-                    BookAction.UPDATE if lay.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(lay.price, lay.volume, OrderSide.BUY),
-                    ts_event,
-                    ts_init,
-                )
-                for lay in rc.bdatb
-            ],
+    # Asks are available to back (atl)
+    for ask in rc.atl:
+        ask_price = betfair_float_to_price(ask.price)
+        ask_volume = betfair_float_to_quantity(ask.volume)
+        ask_order_id = price_to_order_id(ask_price)
+        delta = OrderBookDelta(
+            instrument_id,
+            BookAction.UPDATE if ask.volume > 0.0 else BookAction.DELETE,
+            BookOrder(OrderSide.SELL, ask_price, ask_volume, ask_order_id),
+            ts_event,
+            ts_init,
         )
+        deltas.append(delta)
+
     if not deltas:
         return None
-    return OrderBookDeltas(
-        instrument_id=instrument_id,
-        deltas=deltas,
-        ts_event=ts_event,
-        ts_init=ts_init,
-    )
+
+    return OrderBookDeltas(instrument_id, deltas)
 
 
 def runner_change_to_trade_ticks(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
 ) -> list[TradeTick]:
     trade_ticks: list[TradeTick] = []
     for trd in rc.trd:
         if trd.volume == 0:
             continue
         trade_id = hash_market_trade(timestamp=ts_event, price=trd.price, volume=trd.volume)
         tick = TradeTick(
-            instrument_id=instrument_id,
-            price=betfair_float_to_price(trd.price),
-            size=betfair_float_to_quantity(trd.volume),
-            aggressor_side=AggressorSide.NO_AGGRESSOR,
-            trade_id=TradeId(trade_id),
-            ts_event=ts_event,
-            ts_init=ts_init,
+            instrument_id,
+            betfair_float_to_price(trd.price),
+            betfair_float_to_quantity(trd.volume),
+            AggressorSide.NO_AGGRESSOR,
+            TradeId(trade_id),
+            ts_event,
+            ts_init,
         )
         trade_ticks.append(tick)
     return trade_ticks
 
 
 def runner_change_to_betfair_ticker(
     runner: RunnerChange,
@@ -621,24 +455,27 @@
     bsp_instrument_id: InstrumentId,
     side: Literal["spb", "spl"],
     price: float,
     volume: float,
     ts_event: int,
     ts_init: int,
 ) -> BSPOrderBookDelta:
+    price = betfair_float_to_price(price)
+    order_id = price_to_order_id(price)
     return BSPOrderBookDelta(
-        instrument_id=bsp_instrument_id,
-        action=BookAction.DELETE if volume == 0 else BookAction.UPDATE,
-        order=BookOrder(
-            price=betfair_float_to_price(price),
+        bsp_instrument_id,
+        BookAction.DELETE if volume == 0 else BookAction.UPDATE,
+        BookOrder(
+            price=price,
             size=betfair_float_to_quantity(volume),
-            side=B2N_MARKET_STREAM_SIDE[side],
+            side=B2N_MARKET_SIDE[side],
+            order_id=order_id,
         ),
-        ts_event=ts_event,
-        ts_init=ts_init,
+        ts_event,
+        ts_init,
     )
 
 
 def runner_change_to_bsp_order_book_deltas(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
@@ -667,20 +504,15 @@
                 spl.price,
                 spl.volume,
                 ts_event,
                 ts_init,
             ),
         )
 
-    return BSPOrderBookDeltas(
-        instrument_id=bsp_instrument_id,
-        deltas=deltas,
-        ts_event=ts_event,
-        ts_init=ts_init,
-    )
+    return BSPOrderBookDeltas(bsp_instrument_id, deltas)
 
 
 def _merge_order_book_deltas(all_deltas: list[OrderBookDeltas]):
     cls = type(all_deltas[0])
     per_instrument_deltas = defaultdict(list)
 
     for deltas in all_deltas:
@@ -694,37 +526,41 @@
     ]
 
 
 async def generate_trades_list(
     self,
     venue_order_id: VenueOrderId,
     symbol: Symbol,
-    since: datetime = None,  # type: ignore
+    since: Optional[datetime] = None,
 ) -> list[TradeReport]:
-    filled: list[ClearedOrder] = self.client().betting.list_cleared_orders(bet_ids=[venue_order_id])
+    filled: list[ClearedOrderSummary] = self.client().betting.list_cleared_orders(
+        bet_ids=[venue_order_id],
+    )
     if not filled:
         self._log.warn(f"Found no existing order for {venue_order_id}")
         return []
     fill = filled[0]
     ts_event = pd.Timestamp(fill.lastMatchedDate).value
     return [
         TradeReport(
             account_id=AccountId("BETFAIR"),
             instrument_id=betfair_instrument_id(
                 fill.marketId,
                 str(fill.selectionId),
                 str(fill.handicap),
             ),
+            order_side=OrderSide.NO_ORDER_SIDE,  # TODO: Needs this
             venue_order_id=VenueOrderId(fill.betId),
             venue_position_id=None,  # Can be None
             trade_id=TradeId(fill.lastMatchedDate),
             last_qty=betfair_float_to_quantity(fill.sizeSettled),
             last_px=betfair_float_to_price(fill.priceMatched),
             commission=None,  # Can be None
             liquidity_side=LiquiditySide.NO_LIQUIDITY_SIDE,
+            report_id=UUID4(),
             ts_event=ts_event,
             ts_init=ts_event,
         ),
     ]
 
 
 def make_bsp_instrument_id(instrument_id: InstrumentId) -> InstrumentId:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/providers.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/providers.py`

 * *Files 5% similar despite different names*

```diff
@@ -14,25 +14,27 @@
 # -------------------------------------------------------------------------------------------------
 
 import time
 from typing import Optional, Union
 
 import msgspec.json
 import pandas as pd
+from betfair_parser.spec.betting.enums import MarketProjection
 from betfair_parser.spec.betting.type_definitions import MarketCatalogue
+from betfair_parser.spec.betting.type_definitions import MarketFilter
 from betfair_parser.spec.common import decode as bf_decode
 from betfair_parser.spec.common import encode as bf_encode
 from betfair_parser.spec.navigation import FlattenedMarket
 from betfair_parser.spec.navigation import Navigation
-from betfair_parser.spec.navigation import navigation_to_flatten_markets
+from betfair_parser.spec.navigation import flatten_nav_tree
 from betfair_parser.spec.streaming.mcm import MarketDefinition
 
-from nautilus_trader.adapters.betfair.client.core import BetfairClient
-from nautilus_trader.adapters.betfair.client.enums import MarketProjection
-from nautilus_trader.adapters.betfair.common import BETFAIR_VENUE
+from nautilus_trader.adapters.betfair.client import BetfairHttpClient
+from nautilus_trader.adapters.betfair.common import BETFAIR_TICK_SCHEME
+from nautilus_trader.adapters.betfair.constants import BETFAIR_VENUE
 from nautilus_trader.adapters.betfair.parsing.common import chunk
 from nautilus_trader.adapters.betfair.parsing.requests import parse_handicap
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.config import InstrumentProviderConfig
 from nautilus_trader.model.identifiers import InstrumentId
@@ -48,19 +50,20 @@
     ----------
     client : BetfairClient, optional
         The client for the provider.
     logger : Logger
         The logger for the provider.
     config : InstrumentProviderConfig, optional
         The configuration for the provider.
+
     """
 
     def __init__(
         self,
-        client: Optional[BetfairClient],
+        client: Optional[BetfairHttpClient],
         logger: Logger,
         filters: Optional[dict] = None,
         config: Optional[InstrumentProviderConfig] = None,
     ):
         if config is None:
             config = InstrumentProviderConfig(
                 load_all=True,
@@ -123,19 +126,29 @@
         ]
         for instrument in instruments:
             self.add(instrument=instrument)
 
         self._log.info(f"{len(instruments)} Instruments created")
 
     def load_markets(self, market_filter: Optional[dict] = None):
-        """Search for betfair markets. Useful for debugging / interactive use"""
+        """
+        Search for betfair markets.
+
+        Useful for debugging / interactive use
+
+        """
         return load_markets(client=self._client, market_filter=market_filter)
 
     def search_instruments(self, instrument_filter: Optional[dict] = None):
-        """Search for instruments within the cache. Useful for debugging / interactive use"""
+        """
+        Search for instruments within the cache.
+
+        Useful for debugging / interactive use
+
+        """
         instruments = self.list_all()
         if instrument_filter:
             instruments = [
                 ins
                 for ins in instruments
                 if all(getattr(ins, k) == v for k, v in instrument_filter.items())
             ]
@@ -143,15 +156,17 @@
 
     def get_betting_instrument(
         self,
         market_id: str,
         selection_id: str,
         handicap: str,
     ) -> BettingInstrument:
-        """Return a betting instrument with performance friendly lookup."""
+        """
+        Return a betting instrument with performance friendly lookup.
+        """
         key = (market_id, selection_id, handicap)
         if key not in self._cache:
             instrument_filter = {
                 "market_id": market_id,
                 "selection_id": selection_id,
                 "selection_handicap": parse_handicap(handicap),
             }
@@ -166,15 +181,15 @@
             # assert count == 1, f"Wrong number of instruments: {len(instruments)} for filter: {instrument_filter}"
             self._cache[key] = instruments[0]
         return self._cache[key]
 
     async def get_account_currency(self) -> str:
         if self._account_currency is None:
             detail = await self._client.get_account_details()
-            self._account_currency = detail["currencyCode"]
+            self._account_currency = detail.currency_code
         return self._account_currency
 
 
 def _parse_date(s, tz):
     # pd.Timestamp is ~5x faster than datetime.datetime.isoformat here.
     return pd.Timestamp(s, tz=tz)
 
@@ -196,18 +211,19 @@
             event_country_code=market_catalog.event.country_code or "",
             event_open_date=pd.Timestamp(market_catalog.event.open_date),
             betting_type=market_catalog.description.betting_type.name,
             market_id=market_catalog.market_id,
             market_name=market_catalog.market_name,
             market_start_time=pd.Timestamp(market_catalog.market_start_time),
             market_type=market_catalog.description.market_type,
-            selection_id=str(runner.runner_id),
+            selection_id=str(runner.selection_id),
             selection_name=runner.runner_name,
             selection_handicap=parse_handicap(runner.handicap),
             currency=currency,
+            tick_scheme_name=BETFAIR_TICK_SCHEME.name,
             ts_event=time.time_ns(),
             ts_init=time.time_ns(),
             info=msgspec.json.decode(bf_encode(market_catalog).decode()),
         )
         instruments.append(instrument)
     return instruments
 
@@ -234,14 +250,15 @@
             market_start_time=pd.Timestamp(market_definition.market_time)
             if market_definition.market_time
             else pd.Timestamp(0, tz="UTC"),
             market_type=market_definition.market_type,
             selection_id=str(runner.selection_id or runner.id),
             selection_name=runner.name or "",
             selection_handicap=parse_handicap(runner.hc),
+            tick_scheme_name=BETFAIR_TICK_SCHEME.name,
             currency=currency,
             ts_event=time.time_ns(),
             ts_init=time.time_ns(),
             info=msgspec.json.decode(msgspec.json.encode(market_definition)),
         )
         instruments.append(instrument)
     return instruments
@@ -271,57 +288,57 @@
     "market_marketType",
     "market_marketStartTime",
     "market_numberOfWinners",
 )
 
 
 async def load_markets(
-    client: BetfairClient,
+    client: BetfairHttpClient,
     market_filter: Optional[dict] = None,
 ) -> list[FlattenedMarket]:
     if isinstance(market_filter, dict):
         # This code gets called from search instruments which may pass selection_id/handicap which don't exist here,
         # only the market_id is relevant, so we just drop these two fields
         market_filter = {
             k: v
             for k, v in market_filter.items()
             if k not in ("selection_id", "selection_handicap")
         }
     assert all(k in VALID_MARKET_FILTER_KEYS for k in (market_filter or []))
     navigation: Navigation = await client.list_navigation()
-    markets = navigation_to_flatten_markets(navigation, **market_filter)
+    markets = flatten_nav_tree(navigation, **market_filter)
     return markets
 
 
 def parse_market_catalog(catalog: list[dict]) -> list[MarketCatalogue]:
     raw = msgspec.json.encode(catalog)
     return bf_decode(raw, type=list[MarketCatalogue])
 
 
 async def load_markets_metadata(
-    client: BetfairClient,
+    client: BetfairHttpClient,
     markets: list[FlattenedMarket],
 ) -> list[MarketCatalogue]:
-    all_results = []
+    all_results: list[MarketCatalogue] = []
     for market_id_chunk in chunk(list({m.market_id for m in markets}), 50):
         results = await client.list_market_catalogue(
             market_projection=[
                 MarketProjection.EVENT_TYPE,
                 MarketProjection.EVENT,
                 MarketProjection.COMPETITION,
                 MarketProjection.MARKET_DESCRIPTION,
                 MarketProjection.RUNNER_METADATA,
                 MarketProjection.RUNNER_DESCRIPTION,
                 MarketProjection.MARKET_START_TIME,
             ],
-            filter_={"marketIds": market_id_chunk},
+            filter_=MarketFilter(market_ids=market_id_chunk),
             max_results=len(market_id_chunk),
         )
         all_results.extend(results)
-    return parse_market_catalog(all_results)
+    return all_results
 
 
 def get_market_book(client, market_ids):
     resp = client.betting.list_market_book(
         market_ids=market_ids,
         price_projection={"priceData": ["EX_TRADED"]},
     )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/sockets.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/betfair/sockets.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,97 +9,137 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import asyncio
+import itertools
 from typing import Callable, Optional
 
 import msgspec
 
-from nautilus_trader.adapters.betfair.client.core import BetfairClient
+from nautilus_trader.adapters.betfair.client import BetfairHttpClient
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.logging import LoggerAdapter
-from nautilus_trader.network.socket import SocketClient
+from nautilus_trader.core.nautilus_pyo3.network import SocketClient
 
 
 HOST = "stream-api.betfair.com"
 # HOST = "stream-api-integration.betfair.com"
 PORT = 443
 CRLF = b"\r\n"
 ENCODING = "utf-8"
-_UNIQUE_ID = 0
+UNIQUE_ID = itertools.count()
 
 
-class BetfairStreamClient(SocketClient):
+class BetfairStreamClient:
     """
     Provides a streaming client for `Betfair`.
     """
 
     def __init__(
         self,
-        client: BetfairClient,
+        http_client: BetfairHttpClient,
         logger_adapter: LoggerAdapter,
-        message_handler,
-        loop: Optional[asyncio.AbstractEventLoop] = None,
-        host: Optional[str] = None,
+        message_handler: Callable[[bytes], None],
+        host: Optional[str] = HOST,
         port: Optional[int] = None,
         crlf: Optional[bytes] = None,
         encoding: Optional[str] = None,
-    ):
-        super().__init__(
-            loop=loop or asyncio.get_event_loop(),
-            logger=logger_adapter.get_logger(),
-            host=host or HOST,
-            port=port or PORT,
-            handler=message_handler,
-            crlf=crlf or CRLF,
-            encoding=encoding or ENCODING,
-        )
-        self.client = client
-        self.unique_id = self.new_unique_id()
+    ) -> None:
+        self._http_client = http_client
+        self._log = logger_adapter
+        self.handler = message_handler
+        self.host = host or HOST
+        self.port = port or PORT
+        self.crlf = crlf or CRLF
+        self.encoding = encoding or ENCODING
+        self._client: Optional[SocketClient] = None
+        self.unique_id = next(UNIQUE_ID)
+        self.is_connected: bool = False
 
     async def connect(self):
-        if not self.client.session_token:
-            await self.client.connect()
-        return await super().connect()
-
-    def new_unique_id(self) -> int:
-        global _UNIQUE_ID
-        _UNIQUE_ID += 1
-        return _UNIQUE_ID
+        if not self._http_client.session_token:
+            await self._http_client.connect()
+
+        if self.is_connected:
+            self._log.info("Socket already connected.")
+            return
+
+        self._log.info("Connecting betfair socket client..")
+        self._client = await SocketClient.connect(
+            url=f"{self.host}:{self.port}",
+            handler=self.handler,
+            ssl=True,
+            suffix=self.crlf,
+        )
+
+        self._log.debug("Running post connect")
+        await self.post_connection()
+
+        self.is_connected = True
+        self._log.info("Connected.")
+
+    async def post_connection(self):
+        """
+        Actions to be performed post connection.
+        """
+
+    async def disconnect(self):
+        self._log.info("Disconnecting .. ")
+        self._client.close()
+        await self.post_disconnection()
+        self.is_connected = False
+        self._log.info("Disconnected.")
+
+    async def post_disconnection(self) -> None:
+        """
+        Actions to be performed post disconnection.
+        """
+        # Override to implement additional disconnection related behaviour
+        # (canceling ping tasks etc.).
+
+    async def reconnect(self):
+        self._log.info("Triggering reconnect..")
+        await self.disconnect()
+        await self.connect()
+        self._log.info("Reconnected.")
+
+    async def send(self, message: bytes):
+        self._log.debug(f"[SEND] {message.decode()}")
+        await self._client.send(message)
+        self._log.debug("[SENT]")
 
     def auth_message(self):
         return {
             "op": "authentication",
             "id": self.unique_id,
-            "appKey": self.client.app_key,
-            "session": self.client.session_token,
+            "appKey": self._http_client.app_key,
+            "session": self._http_client.session_token,
         }
 
 
 class BetfairOrderStreamClient(BetfairStreamClient):
     """
     Provides an order stream client for `Betfair`.
     """
 
     def __init__(
         self,
-        client: BetfairClient,
+        http_client: BetfairHttpClient,
         logger: Logger,
         message_handler,
         partition_matched_by_strategy_ref: bool = True,
         include_overall_position: Optional[str] = None,
         customer_strategy_refs: Optional[str] = None,
         **kwargs,
     ):
         super().__init__(
-            client=client,
+            http_client=http_client,
             logger_adapter=LoggerAdapter("BetfairOrderStreamClient", logger),
             message_handler=message_handler,
             **kwargs,
         )
         self.order_filter = {
             "includeOverallPosition": include_overall_position,
             "customerStrategyRefs": customer_strategy_refs,
@@ -119,39 +159,44 @@
 
 
 class BetfairMarketStreamClient(BetfairStreamClient):
     """
     Provides a `Betfair` market stream client.
     """
 
-    def __init__(self, client: BetfairClient, logger: Logger, message_handler: Callable, **kwargs):
-        self.subscription_message = None
+    def __init__(
+        self,
+        http_client: BetfairHttpClient,
+        logger: Logger,
+        message_handler: Callable,
+        **kwargs,
+    ):
         super().__init__(
-            client=client,
+            http_client=http_client,
             logger_adapter=LoggerAdapter("BetfairMarketStreamClient", logger),
             message_handler=message_handler,
             **kwargs,
         )
 
     # TODO - Add support for initial_clk/clk reconnection
     async def send_subscription_message(
         self,
-        market_ids: list = None,
-        betting_types: list = None,
-        event_type_ids: list = None,
-        event_ids: list = None,
-        turn_in_play_enabled: bool = None,
-        market_types: list = None,
-        venues: list = None,
-        country_codes: list = None,
-        race_types: list = None,
-        initial_clk: str = None,
-        clk: str = None,
-        conflate_ms: int = None,
-        heartbeat_ms: int = None,
+        market_ids: Optional[list] = None,
+        betting_types: Optional[list] = None,
+        event_type_ids: Optional[list] = None,
+        event_ids: Optional[list] = None,
+        turn_in_play_enabled: Optional[bool] = None,
+        market_types: Optional[list] = None,
+        venues: Optional[list] = None,
+        country_codes: Optional[list] = None,
+        race_types: Optional[list] = None,
+        initial_clk: Optional[str] = None,
+        clk: Optional[str] = None,
+        conflate_ms: Optional[int] = None,
+        heartbeat_ms: Optional[int] = None,
         segmentation_enabled: bool = True,
         subscribe_book_updates=True,
         subscribe_trade_updates=True,
         subscribe_market_definitions=True,
         subscribe_bsp_updates=True,
         subscribe_bsp_projected=True,
     ):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,11 +8,10 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 Provides an API integration for the Binance Crypto exchange.
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/constants.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/constants.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/data.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/data.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,14 +28,15 @@
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceDataMsgWrapper
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceOrderBookMsg
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceQuoteMsg
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTickerMsg
 from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.common.types import BinanceBar
 from nautilus_trader.adapters.binance.common.types import BinanceTicker
+from nautilus_trader.adapters.binance.config import BinanceDataClientConfig
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.market import BinanceMarketHttpAPI
 from nautilus_trader.adapters.binance.websocket.client import BinanceWebSocketClient
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
@@ -83,21 +84,21 @@
         The logger for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
     account_type : BinanceAccountType
         The account type for the client.
     base_url_ws : str
         The base URL for the WebSocket client.
-    use_agg_trade_ticks : bool, default False
-        Whether to use aggregated trade tick endpoints instead of raw trade ticks.
-        TradeId of ticks will be the Aggregate tradeId returned by Binance.
+    config : BinanceDataClientConfig
+        The configuration for the client.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         market: BinanceMarketHttpAPI,
@@ -105,35 +106,36 @@
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InstrumentProvider,
         account_type: BinanceAccountType,
         base_url_ws: str,
-        use_agg_trade_ticks: bool = False,
+        config: BinanceDataClientConfig,
     ) -> None:
         super().__init__(
             loop=loop,
             client_id=ClientId(BINANCE_VENUE.value),
             venue=BINANCE_VENUE,
             instrument_provider=instrument_provider,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
         )
 
         self._binance_account_type = account_type
-        self._use_agg_trade_ticks = use_agg_trade_ticks
+        self._use_agg_trade_ticks = config.use_agg_trade_ticks
         self._log.info(f"Account type: {self._binance_account_type.value}.", LogColor.BLUE)
+        self._log.info(f"{config.use_agg_trade_ticks=}", LogColor.BLUE)
 
         self._update_instrument_interval: int = 60 * 60  # Once per hour (hardcode)
         self._update_instruments_task: Optional[asyncio.Task] = None
 
-        self._connect_websockets_interval: int = 4  # Retry websocket connection every 4 seconds
+        self._connect_websockets_delay: float = 0.0  # Delay for bulk subscriptions to come in
         self._connect_websockets_task: Optional[asyncio.Task] = None
 
         # HTTP API
         self._http_client = client
         self._http_market = market
 
         # Enum parser
@@ -175,40 +177,20 @@
         self._decoder_order_book_msg = msgspec.json.Decoder(BinanceOrderBookMsg)
         self._decoder_quote_msg = msgspec.json.Decoder(BinanceQuoteMsg)
         self._decoder_ticker_msg = msgspec.json.Decoder(BinanceTickerMsg)
         self._decoder_candlestick_msg = msgspec.json.Decoder(BinanceCandlestickMsg)
         self._decoder_agg_trade_msg = msgspec.json.Decoder(BinanceAggregatedTradeMsg)
 
     async def _connect(self) -> None:
-        self._log.info("Initialising instruments...")
+        self._log.info("Initializing instruments...")
         await self._instrument_provider.initialize()
 
         self._send_all_instruments_to_data_engine()
         self._update_instruments_task = self.create_task(self._update_instruments())
 
-        # Connect WebSocket clients
-        self._connect_websockets_task = self.create_task(self._connect_websockets())
-
-    async def _connect_websockets(self) -> None:
-        try:
-            while True:
-                self._log.debug(
-                    f"Scheduled `connect_websockets` to run in "
-                    f"{self._connect_websockets_interval}s.",
-                )
-                await asyncio.sleep(self._connect_websockets_interval)
-
-                if self._ws_client.has_subscriptions:
-                    await self._ws_client.connect()
-                    break
-                else:
-                    self._log.info("Awaiting subscriptions...")
-        except asyncio.CancelledError:
-            self._log.debug("`connect_websockets` task was canceled.")
-
     async def _update_instruments(self) -> None:
         try:
             while True:
                 self._log.debug(
                     f"Scheduled `update_instruments` to run in "
                     f"{self._update_instrument_interval}s.",
                 )
@@ -221,28 +203,21 @@
     async def _disconnect(self) -> None:
         # Cancel update instruments task
         if self._update_instruments_task:
             self._log.debug("Canceling `update_instruments` task...")
             self._update_instruments_task.cancel()
             self._update_instruments_task = None
 
-        # Cancel WebSocket connect task
-        if self._connect_websockets_task:
-            self._log.debug("Canceling `connect_websockets` task...")
-            self._connect_websockets_task.cancel()
-            self._connect_websockets_task = None
-
-        if self._ws_client.is_connected:
-            await self._ws_client.disconnect()
+        await self._ws_client.disconnect()
 
     # -- SUBSCRIPTIONS ----------------------------------------------------------------------------
 
     async def _subscribe(self, data_type: DataType) -> None:
         # Replace method in child class, for exchange specific data types.
-        raise NotImplementedError("Cannot subscribe to {data_type.type} (not implemented).")
+        raise NotImplementedError(f"Cannot subscribe to {data_type.type} (not implemented).")
 
     async def _subscribe_instruments(self) -> None:
         pass  # Do nothing further
 
     async def _subscribe_instrument(self, instrument_id: InstrumentId) -> None:
         pass  # Do nothing further
 
@@ -321,49 +296,49 @@
             if depth not in (5, 10, 20):
                 self._log.error(
                     "Cannot subscribe to order book snapshots: "
                     f"invalid `depth`, was {depth}. "
                     "Valid depths are 5, 10 or 20.",
                 )
                 return
-            self._ws_client.subscribe_partial_book_depth(
+            await self._ws_client.subscribe_partial_book_depth(
                 symbol=instrument_id.symbol.value,
                 depth=depth,
                 speed=update_speed,
             )
 
             snapshot = await self._http_market.request_order_book_snapshot(
                 instrument_id=instrument_id,
                 limit=depth,
                 ts_init=self._clock.timestamp_ns(),
             )
             self._handle_data(snapshot)
         else:
-            self._ws_client.subscribe_diff_book_depth(
+            await self._ws_client.subscribe_diff_book_depth(
                 symbol=instrument_id.symbol.value,
                 speed=update_speed,
             )
 
         book_buffer = self._book_buffer.pop(instrument_id, [])
         for deltas in book_buffer:
             if snapshot and deltas.sequence <= snapshot.sequence:
                 continue
             self._handle_data(deltas)
 
     async def _subscribe_ticker(self, instrument_id: InstrumentId) -> None:
-        self._ws_client.subscribe_ticker(instrument_id.symbol.value)
+        await self._ws_client.subscribe_ticker(instrument_id.symbol.value)
 
     async def _subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
-        self._ws_client.subscribe_book_ticker(instrument_id.symbol.value)
+        await self._ws_client.subscribe_book_ticker(instrument_id.symbol.value)
 
     async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
         if self._use_agg_trade_ticks:
-            self._ws_client.subscribe_agg_trades(instrument_id.symbol.value)
+            await self._ws_client.subscribe_agg_trades(instrument_id.symbol.value)
         else:
-            self._ws_client.subscribe_trades(instrument_id.symbol.value)
+            await self._ws_client.subscribe_trades(instrument_id.symbol.value)
 
     async def _subscribe_bars(self, bar_type: BarType) -> None:
         PyCondition.true(bar_type.is_externally_aggregated(), "aggregation_source is not EXTERNAL")
 
         if not bar_type.spec.is_time_aggregated():
             self._log.error(
                 f"Cannot subscribe to {bar_type}: only time bars are aggregated by Binance.",
@@ -380,15 +355,15 @@
             interval = BinanceKlineInterval(f"{bar_type.spec.step}{resolution}")
         except ValueError:
             self._log.error(
                 f"Bar interval {bar_type.spec.step}{resolution} not supported by Binance.",
             )
             return
 
-        self._ws_client.subscribe_bars(
+        await self._ws_client.subscribe_bars(
             symbol=bar_type.instrument_id.symbol.value,
             interval=interval.value,
         )
         self._add_subscription_bars(bar_type)
 
     async def _unsubscribe(self, data_type: DataType) -> None:
         # Replace method in child class, for exchange specific data types.
@@ -563,15 +538,15 @@
         for currency in self._instrument_provider.currencies().values():
             self._cache.add_currency(currency)
 
     def _get_cached_instrument_id(self, symbol: str) -> InstrumentId:
         # Parse instrument ID
         binance_symbol = BinanceSymbol(symbol)
         assert binance_symbol
-        nautilus_symbol: str = binance_symbol.parse_binance_to_internal(
+        nautilus_symbol: str = binance_symbol.parse_as_nautilus(
             self._binance_account_type,
         )
         instrument_id: Optional[InstrumentId] = self._instrument_ids.get(nautilus_symbol)
         if not instrument_id:
             instrument_id = InstrumentId(Symbol(nautilus_symbol), BINANCE_VENUE)
             self._instrument_ids[nautilus_symbol] = instrument_id
         return instrument_id
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/execution.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,774 +10,835 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
-from typing import Optional
+import json
+from typing import Any, Optional
 
 import pandas as pd
-
-from nautilus_trader.adapters.binance.common.constants import BINANCE_VENUE
-from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
-from nautilus_trader.adapters.binance.common.enums import BinanceEnumParser
-from nautilus_trader.adapters.binance.common.enums import BinanceTimeInForce
-from nautilus_trader.adapters.binance.common.schemas.account import BinanceOrder
-from nautilus_trader.adapters.binance.common.schemas.account import BinanceUserTrade
-from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
-from nautilus_trader.adapters.binance.common.schemas.user import BinanceListenKey
-from nautilus_trader.adapters.binance.http.account import BinanceAccountHttpAPI
-from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
-from nautilus_trader.adapters.binance.http.error import BinanceError
-from nautilus_trader.adapters.binance.http.market import BinanceMarketHttpAPI
-from nautilus_trader.adapters.binance.http.user import BinanceUserDataHttpAPI
-from nautilus_trader.adapters.binance.websocket.client import BinanceWebSocketClient
+from ibapi.commission_report import CommissionReport
+from ibapi.common import UNSET_DECIMAL
+from ibapi.common import UNSET_DOUBLE
+from ibapi.execution import Execution
+from ibapi.order import Order as IBOrder
+from ibapi.order_state import OrderState as IBOrderState
+
+# fmt: off
+from nautilus_trader.adapters.interactive_brokers.client import InteractiveBrokersClient
+from nautilus_trader.adapters.interactive_brokers.client.common import IBPosition
+from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_action
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_fields
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_status
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_type
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_time_in_force
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_trigger_method
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import order_side_to_order_action
+from nautilus_trader.adapters.interactive_brokers.parsing.execution import timestring_to_timestamp
+from nautilus_trader.adapters.interactive_brokers.providers import InteractiveBrokersInstrumentProvider
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
-from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
-from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.core.datetime import secs_to_millis
+from nautilus_trader.core.rust.common import LogColor
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.execution.messages import CancelAllOrders
 from nautilus_trader.execution.messages import CancelOrder
 from nautilus_trader.execution.messages import ModifyOrder
 from nautilus_trader.execution.messages import SubmitOrder
 from nautilus_trader.execution.messages import SubmitOrderList
 from nautilus_trader.execution.reports import OrderStatusReport
 from nautilus_trader.execution.reports import PositionStatusReport
 from nautilus_trader.execution.reports import TradeReport
 from nautilus_trader.live.execution_client import LiveExecutionClient
+from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.enums import AccountType
+from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OmsType
 from nautilus_trader.model.enums import OrderSide
+from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.enums import OrderType
+from nautilus_trader.model.enums import PositionSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TrailingOffsetType
 from nautilus_trader.model.enums import TriggerType
-from nautilus_trader.model.enums import trailing_offset_type_to_str
-from nautilus_trader.model.enums import trigger_type_to_str
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import Symbol
+from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
+from nautilus_trader.model.objects import AccountBalance
+from nautilus_trader.model.objects import MarginBalance
+from nautilus_trader.model.objects import Money
 from nautilus_trader.model.objects import Price
-from nautilus_trader.model.orders import LimitOrder
-from nautilus_trader.model.orders import MarketOrder
-from nautilus_trader.model.orders import Order
-from nautilus_trader.model.orders import StopLimitOrder
-from nautilus_trader.model.orders import StopMarketOrder
-from nautilus_trader.model.orders import TrailingStopMarketOrder
-from nautilus_trader.model.position import Position
+from nautilus_trader.model.objects import Quantity
+from nautilus_trader.model.orders.base import Order
+from nautilus_trader.model.orders.limit_if_touched import LimitIfTouchedOrder
+from nautilus_trader.model.orders.market_if_touched import MarketIfTouchedOrder
+from nautilus_trader.model.orders.stop_limit import StopLimitOrder
+from nautilus_trader.model.orders.stop_market import StopMarketOrder
+from nautilus_trader.model.orders.trailing_stop_limit import TrailingStopLimitOrder
+from nautilus_trader.model.orders.trailing_stop_market import TrailingStopMarketOrder
 from nautilus_trader.msgbus.bus import MessageBus
 
 
-class BinanceCommonExecutionClient(LiveExecutionClient):
+# fmt: on
+
+ib_to_nautilus_trigger_method = dict(zip(map_trigger_method.values(), map_trigger_method.keys()))
+ib_to_nautilus_time_in_force = dict(zip(map_time_in_force.values(), map_time_in_force.keys()))
+ib_to_nautilus_order_side = dict(zip(map_order_action.values(), map_order_action.keys()))
+ib_to_nautilus_order_type = dict(zip(map_order_type.values(), map_order_type.keys()))
+
+
+class InteractiveBrokersExecutionClient(LiveExecutionClient):
     """
-    Execution client providing common functionality for the `Binance` exchanges.
+    Provides an execution client for Interactive Brokers TWS API.
 
     Parameters
     ----------
     loop : asyncio.AbstractEventLoop
         The event loop for the client.
-    client : BinanceHttpClient
-        The binance HTTP client.
-    account : BinanceAccountHttpAPI
-        The binance Account HTTP API.
-    market : BinanceMarketHttpAPI
-        The binance Market HTTP API.
-    user : BinanceUserHttpAPI
-        The binance User HTTP API.
-    enum_parser : BinanceEnumParser
-        The parser for Binance enums.
+    client : InteractiveBrokersClient
+        The nautilus InteractiveBrokersClient using ibapi.
+    account_id: AccountId
+        Account ID associated with this client.
     msgbus : MessageBus
         The message bus for the client.
     cache : Cache
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
-    instrument_provider : BinanceSpotInstrumentProvider
+    instrument_provider : InteractiveBrokersInstrumentProvider
         The instrument provider.
-    account_type : BinanceAccountType
-        The account type for the client.
-    base_url_ws : str
-        The base URL for the WebSocket client.
-    warn_gtd_to_gtc : bool, default True
-        If log warning for GTD time in force transformed to GTC.
-
-    Warnings
-    --------
-    This class should not be used directly, but through a concrete subclass.
+    ibg_client_id : int
+        Client ID used to connect TWS/Gateway.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: BinanceHttpClient,
-        account: BinanceAccountHttpAPI,
-        market: BinanceMarketHttpAPI,
-        user: BinanceUserDataHttpAPI,
-        enum_parser: BinanceEnumParser,
+        client: InteractiveBrokersClient,
+        account_id: AccountId,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        instrument_provider: InstrumentProvider,
-        account_type: BinanceAccountType,
-        base_url_ws: str,
-        warn_gtd_to_gtc: bool = True,
-    ) -> None:
+        instrument_provider: InteractiveBrokersInstrumentProvider,
+        ibg_client_id: int,
+    ):
         super().__init__(
             loop=loop,
-            client_id=ClientId(BINANCE_VENUE.value),
-            venue=BINANCE_VENUE,
-            oms_type=OmsType.HEDGING if account_type.is_futures else OmsType.NETTING,
+            # client_id=ClientId(f"{IB_VENUE.value}-{ibg_client_id:03d}"), # TODO: Fix account_id.get_id()
+            client_id=ClientId(f"{IB_VENUE.value}"),
+            venue=IB_VENUE,
+            oms_type=OmsType.NETTING,
             instrument_provider=instrument_provider,
-            account_type=AccountType.CASH if account_type.is_spot else AccountType.MARGIN,
-            base_currency=None,
+            account_type=AccountType.MARGIN,
+            base_currency=None,  # IB accounts are multi-currency
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
-        )
-
-        self._binance_account_type = account_type
-        self._warn_gtd_to_gtc = warn_gtd_to_gtc
-        self._log.info(f"Account type: {self._binance_account_type.value}.", LogColor.BLUE)
-
-        self._set_account_id(AccountId(f"{BINANCE_VENUE.value}-spot-master"))
-
-        # Enum parser
-        self._enum_parser = enum_parser
-
-        # Http API
-        self._http_client = client
-        self._http_account = account
-        self._http_market = market
-        self._http_user = user
-
-        # Listen keys
-        self._ping_listen_keys_interval: int = 60 * 5  # Once every 5 mins (hardcode)
-        self._ping_listen_keys_task: Optional[asyncio.Task] = None
-        self._listen_key: Optional[str] = None
-
-        # WebSocket API
-        self._ws_client = BinanceWebSocketClient(
-            clock=clock,
-            logger=logger,
-            handler=self._handle_user_ws_message,
-            base_url=base_url_ws,
-        )
-
-        # Hot caches
-        self._instrument_ids: dict[str, InstrumentId] = {}
-        self._generate_order_status_retries: dict[ClientOrderId, int] = {}
-        self._modifying_orders: dict[ClientOrderId, VenueOrderId] = {}
-
-        # Order submission method hashmap
-        self._submit_order_method = {
-            OrderType.MARKET: self._submit_market_order,
-            OrderType.LIMIT: self._submit_limit_order,
-            OrderType.STOP_LIMIT: self._submit_stop_limit_order,
-            OrderType.LIMIT_IF_TOUCHED: self._submit_stop_limit_order,
-            OrderType.STOP_MARKET: self._submit_stop_market_order,
-            OrderType.MARKET_IF_TOUCHED: self._submit_stop_market_order,
-            OrderType.TRAILING_STOP_MARKET: self._submit_trailing_stop_market_order,
+            config={
+                "name": f"{type(self).__name__}-{ibg_client_id:03d}",
+                "client_id": ibg_client_id,
+            },
+        )
+        self._client: InteractiveBrokersClient = client
+        self._set_account_id(account_id)
+        self._account_summary_tags = {
+            "NetLiquidation",
+            "FullAvailableFunds",
+            "FullInitMarginReq",
+            "FullMaintMarginReq",
         }
 
-        self._log.info(f"Base URL HTTP {self._http_client.base_url}.", LogColor.BLUE)
-        self._log.info(f"Base URL WebSocket {base_url_ws}.", LogColor.BLUE)
-
-    async def _connect(self) -> None:
-        try:
-            # Initialize instrument provider
-            await self._instrument_provider.initialize()
-            # Authenticate API key and update account(s)
-            await self._update_account_state()
-            # Get listen keys
-            response: BinanceListenKey = await self._http_user.create_listen_key()
-        except BinanceError as e:
-            self._log.exception(f"Error on connect: {e.message}", e)
-            return
-
-        # Check Binance-Nautilus clock sync
-        server_time: int = await self._http_market.request_server_time()
-        self._log.info(f"Binance server time {server_time} UNIX (ms).")
-
-        nautilus_time: int = self._clock.timestamp_ms()
-        self._log.info(f"Nautilus clock time {nautilus_time} UNIX (ms).")
-
-        # Setup websocket listen key
-        self._listen_key = response.listenKey
-        self._log.info(f"Listen key {self._listen_key}")
-        self._ping_listen_keys_task = self.create_task(self._ping_listen_keys())
-
-        # Connect WebSocket client
-        await self._ws_client.subscribe(key=self._listen_key)
-        await self._ws_client.connect()
-
-    async def _update_account_state(self) -> None:
-        # Replace method in child class
-        raise NotImplementedError
+        self._account_summary_loaded: asyncio.Event = asyncio.Event()
 
-    async def _ping_listen_keys(self) -> None:
-        try:
-            while True:
-                self._log.debug(
-                    f"Scheduled `ping_listen_keys` to run in "
-                    f"{self._ping_listen_keys_interval}s.",
-                )
-                await asyncio.sleep(self._ping_listen_keys_interval)
-                if self._listen_key:
-                    self._log.debug(f"Pinging WebSocket listen key {self._listen_key}...")
-                    await self._http_user.keepalive_listen_key(listen_key=self._listen_key)
-        except asyncio.CancelledError:
-            self._log.debug("`ping_listen_keys` task was canceled.")
-
-    async def _disconnect(self) -> None:
-        # Cancel tasks
-        if self._ping_listen_keys_task:
-            self._log.debug("Canceling `ping_listen_keys` task...")
-            self._ping_listen_keys_task.cancel()
-            self._ping_listen_keys_task = None
-
-        if self._ws_client.is_connected:
-            await self._ws_client.disconnect()
+        # Hot caches
+        self._account_summary: dict[str, dict[str, Any]] = {}
 
-    # -- EXECUTION REPORTS ------------------------------------------------------------------------
+    @property
+    def instrument_provider(self) -> InteractiveBrokersInstrumentProvider:
+        return self._instrument_provider  # type: ignore
+
+    async def _connect(self):
+        # Connect client
+        await self._client.is_running_async()
+        await self.instrument_provider.initialize()
+
+        # Validate if connected to expected TWS/Gateway using Account
+        if self.account_id.get_id() in self._client.accounts():
+            self._log.info(
+                f"Account `{self.account_id.get_id()}` found in the connected TWS/Gateway.",
+                LogColor.GREEN,
+            )
+        else:
+            self.fault()
+            raise ValueError(
+                f"Account `{self.account_id.get_id()}` not found in the connected TWS/Gateway. "
+                f"Available accounts are {self._client.accounts()}",
+            )
+
+        # Event hooks
+        account = self.account_id.get_id()
+        self._client.registered_nautilus_clients.add(self.id)
+        self._client.subscribe_event(f"accountSummary-{account}", self._on_account_summary)
+        self._client.subscribe_event(f"openOrder-{account}", self._on_open_order)
+        self._client.subscribe_event(f"orderStatus-{account}", self._on_order_status)
+        self._client.subscribe_event(f"execDetails-{account}", self._on_exec_details)
+
+        # Load account balance
+        self._client.subscribe_account_summary()
+        await self._account_summary_loaded.wait()
+
+        self._set_connected(True)
+
+    async def _disconnect(self):
+        self._client.registered_nautilus_clients.discard(self.id)
+        if self._client.is_running and self._client.registered_nautilus_clients == set():
+            self._client.stop()
+        self._set_connected(False)
 
     async def generate_order_status_report(
         self,
         instrument_id: InstrumentId,
         client_order_id: Optional[ClientOrderId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
     ) -> Optional[OrderStatusReport]:
-        PyCondition.false(
-            client_order_id is None and venue_order_id is None,
-            "both `client_order_id` and `venue_order_id` were `None`",
-        )
-
-        retries = self._generate_order_status_retries.get(client_order_id, 0)
-        if retries > 3:
-            self._log.error(
-                f"Reached maximum retries 3/3 for generating OrderStatusReport for "
-                f"{repr(client_order_id) if client_order_id else ''} "
-                f"{repr(venue_order_id) if venue_order_id else ''}...",
-            )
+        """
+        Generate an `OrderStatusReport` for the given order identifier parameter(s). If
+        the order is not found, or an error occurs, then logs and returns ``None``.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId
+            The instrument ID for the report.
+        client_order_id : ClientOrderId, optional
+            The client order ID for the report.
+        venue_order_id : VenueOrderId, optional
+            The venue order ID for the report.
+
+        Returns
+        -------
+        OrderStatusReport or ``None``
+
+        Raises
+        ------
+        ValueError
+            If both the `client_order_id` and `venue_order_id` are ``None``.
+
+        """
+        PyCondition.type_or_none(client_order_id, ClientOrderId, "client_order_id")
+        PyCondition.type_or_none(venue_order_id, VenueOrderId, "venue_order_id")
+        if not (client_order_id or venue_order_id):
+            self._log.debug("Both `client_order_id` and `venue_order_id` cannot be None.")
             return None
 
-        self._log.info(
-            f"Generating OrderStatusReport for "
-            f"{repr(client_order_id) if client_order_id else ''} "
-            f"{repr(venue_order_id) if venue_order_id else ''}...",
-        )
-
-        try:
-            if venue_order_id:
-                binance_order = await self._http_account.query_order(
-                    symbol=instrument_id.symbol.value,
-                    order_id=int(venue_order_id.value),
+        report = None
+        ib_orders = await self._client.get_open_orders(self.account_id.get_id())
+        for ib_order in ib_orders:
+            if (client_order_id and client_order_id.value == ib_order.orderRef) or (
+                venue_order_id
+                and venue_order_id.value
+                == str(
+                    ib_order.orderId,
                 )
-            else:
-                binance_order = await self._http_account.query_order(
-                    symbol=instrument_id.symbol.value,
-                    orig_client_order_id=client_order_id.value
-                    if client_order_id is not None
-                    else None,
-                )
-        except BinanceError as e:
-            self._log.error(
-                f"Cannot generate order status report for {client_order_id!r}: {e.message}. Retry {retries}/3",
-            )
-            retries += 1
-            self._generate_order_status_retries[client_order_id] = retries
-            if not client_order_id:
-                self._log.warning("Cannot retry without a client order ID.")
-            else:
-                order: Optional[Order] = self._cache.order(client_order_id)
-                if order is None:
-                    self._log.warning("Order not found in cache.")
-                    return None
-                elif order.is_closed:
-                    return None  # Nothing else to do
-
-                if retries >= 3:
-                    # Order will no longer be considered in-flight once this event is applied.
-                    # We could pop the value out of the hashmap here, but better to leave it in
-                    # so that there are no longer subsequent retries (we don't expect many of these).
-                    self.generate_order_rejected(
-                        strategy_id=order.strategy_id,
-                        instrument_id=instrument_id,
-                        client_order_id=client_order_id,
-                        reason=e.message,
-                        ts_event=self._clock.timestamp_ns(),
-                    )
-            return None  # Error now handled
+            ):
+                report = await self._parse_ib_order_to_order_status_report(ib_order)
+                break
+        if report is None:  # TODO: Further testing
+            self._log.warning(
+                f"Order {client_order_id=}, {venue_order_id} not found, Cancelling...",
+            )
+            self._on_order_status(
+                order_ref=client_order_id.value,
+                order_status="Cancelled",
+                reason="Not found in query",
+            )
+        return report
 
-        if not binance_order:
-            # Cannot proceed to generating report
-            return None
+    async def _parse_ib_order_to_order_status_report(self, ib_order: IBOrder):
+        self._log.debug(f"Trying OrderStatusReport for {ib_order}")
+        instrument = await self.instrument_provider.find_with_contract_id(
+            ib_order.contract.conId,
+        )
+
+        total_qty = (
+            Quantity.from_int(0)
+            if ib_order.totalQuantity == UNSET_DECIMAL
+            else Quantity.from_str(str(ib_order.totalQuantity))
+        )
+        filled_qty = (
+            Quantity.from_int(0)
+            if ib_order.filledQuantity == UNSET_DECIMAL
+            else Quantity.from_str(str(ib_order.filledQuantity))
+        )
+        if total_qty.as_double() > filled_qty.as_double() > 0:
+            order_status = OrderStatus.PARTIALLY_FILLED
+        else:
+            order_status = map_order_status[ib_order.order_state.status]
+        ts_init = self._clock.timestamp_ns()
+        price = (
+            None if ib_order.lmtPrice == UNSET_DOUBLE else Price.from_str(str(ib_order.lmtPrice))
+        )
+        expire_time = (
+            timestring_to_timestamp(ib_order.goodTillDate) if ib_order.tif == "GTD" else None
+        )
 
-        report: OrderStatusReport = binance_order.parse_to_order_status_report(
+        # TODO: Testing for advanced Open orders
+        order_status = OrderStatusReport(
             account_id=self.account_id,
-            instrument_id=self._get_cached_instrument_id(binance_order.symbol),
+            instrument_id=instrument.id,
+            venue_order_id=VenueOrderId(str(ib_order.orderId)),
+            order_side=ib_to_nautilus_order_side[ib_order.action],
+            order_type=ib_to_nautilus_order_type[ib_order.orderType],
+            time_in_force=ib_to_nautilus_time_in_force[ib_order.tif],
+            order_status=order_status,
+            quantity=total_qty,
+            filled_qty=filled_qty,
             report_id=UUID4(),
-            enum_parser=self._enum_parser,
-            ts_init=self._clock.timestamp_ns(),
+            ts_accepted=ts_init,
+            ts_last=ts_init,
+            ts_init=ts_init,
+            client_order_id=ClientOrderId(ib_order.orderRef),
+            # order_list_id=,
+            # contingency_type=,
+            expire_time=expire_time,
+            price=price,
+            trigger_price=Price.from_str(str(ib_order.auxPrice)),
+            trigger_type=TriggerType.BID_ASK,
+            # limit_offset=,
+            # trailing_offset=,
         )
-
-        self._log.debug(f"Received {report}.")
-        return report
-
-    def _get_cache_active_symbols(self) -> list[str]:
-        # Check cache for all active symbols
-        open_orders: list[Order] = self._cache.orders_open(venue=self.venue)
-        open_positions: list[Position] = self._cache.positions_open(venue=self.venue)
-        active_symbols: list[str] = []
-        for o in open_orders:
-            active_symbols.append(o.instrument_id.symbol.value)
-        for p in open_positions:
-            active_symbols.append(p.instrument_id.symbol.value)
-        return active_symbols
-
-    async def _get_binance_position_status_reports(
-        self,
-        symbol: Optional[str] = None,
-    ) -> list[str]:
-        # Implement in child class
-        raise NotImplementedError
-
-    async def _get_binance_active_position_symbols(
-        self,
-        symbol: Optional[str] = None,
-    ) -> list[str]:
-        # Implement in child class
-        raise NotImplementedError
+        self._log.debug(f"Received {order_status!r}")
+        return order_status
 
     async def generate_order_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
         open_only: bool = False,
     ) -> list[OrderStatusReport]:
-        self._log.info(f"Generating OrderStatusReports for {self.id}...")
+        """
+        Generate a list of `OrderStatusReport`s with optional query filters. The
+        returned list may be empty if no orders match the given parameters.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId, optional
+            The instrument ID query filter.
+        start : pd.Timestamp, optional
+            The start datetime query filter.
+        end : pd.Timestamp, optional
+            The end datetime query filter.
+        open_only : bool, default False
+            If the query is for open orders only.
+
+        Returns
+        -------
+        list[OrderStatusReport]
+
+        """
+        report = []
+        # Create the Filled OrderStatusReport from Open Positions
+        positions: list[IBPosition] = await self._client.get_positions(self.account_id.get_id())
+        ts_init = self._clock.timestamp_ns()
+        for position in positions:
+            self._log.debug(f"Trying OrderStatusReport for {position.contract.conId}")
+            if position.quantity > 0:
+                order_side = OrderSide.BUY
+            elif position.quantity < 0:
+                order_side = OrderSide.SELL
+            else:
+                order_side = OrderSide.NO_ORDER_SIDE
+                continue  # Skip, IB may continue to display closed positions
 
-        try:
-            # Check Binance for all order active symbols
-            symbol = instrument_id.symbol.value if instrument_id is not None else None
-            active_symbols = self._get_cache_active_symbols()
-            active_symbols.extend(await self._get_binance_active_position_symbols(symbol))
-            binance_open_orders = await self._http_account.query_open_orders(symbol)
-            for order in binance_open_orders:
-                active_symbols.append(order.symbol)
-            # Get all orders for those active symbols
-            binance_orders: list[BinanceOrder] = []
-            for symbol in active_symbols:
-                response = await self._http_account.query_all_orders(
-                    symbol=symbol,
-                    start_time=secs_to_millis(start.timestamp()) if start is not None else None,
-                    end_time=secs_to_millis(end.timestamp()) if end is not None else None,
-                )
-                binance_orders.extend(response)
-        except BinanceError as e:
-            self._log.exception(f"Cannot generate OrderStatusReport: {e.message}", e)
-            return []
-
-        reports: list[OrderStatusReport] = []
-        for order in binance_orders:
-            # Apply filter (always report open orders regardless of start, end filter)
-            # TODO(cs): Time filter is WIP
-            # timestamp = pd.to_datetime(data["time"], utc=True)
-            # if data["status"] not in ("NEW", "PARTIALLY_FILLED", "PENDING_CANCEL"):
-            #     if start is not None and timestamp < start:
-            #         continue
-            #     if end is not None and timestamp > end:
-            #         continue
-            report = order.parse_to_order_status_report(
+            instrument = await self.instrument_provider.find_with_contract_id(
+                position.contract.conId,
+            )
+            avg_px = instrument.make_price(
+                position.avg_cost / instrument.multiplier,
+            ).as_decimal()
+            quantity = Quantity.from_str(str(position.quantity.copy_abs()))
+            order_status = OrderStatusReport(
                 account_id=self.account_id,
-                instrument_id=self._get_cached_instrument_id(order.symbol),
+                instrument_id=instrument.id,
+                venue_order_id=VenueOrderId(instrument.id.value),
+                order_side=order_side,
+                order_type=OrderType.MARKET,
+                time_in_force=TimeInForce.FOK,
+                order_status=OrderStatus.FILLED,
+                quantity=quantity,
+                filled_qty=quantity,
+                avg_px=avg_px,
                 report_id=UUID4(),
-                enum_parser=self._enum_parser,
-                ts_init=self._clock.timestamp_ns(),
-            )
-            self._log.debug(f"Received {reports}.")
-            reports.append(report)
-
-        len_reports = len(reports)
-        plural = "" if len_reports == 1 else "s"
-        self._log.info(f"Generated {len(reports)} OrderStatusReport{plural}.")
-
-        return reports
+                ts_accepted=ts_init,
+                ts_last=ts_init,
+                ts_init=ts_init,
+                client_order_id=ClientOrderId(instrument.id.value),
+            )
+            self._log.debug(f"Received {order_status!r}")
+            report.append(order_status)
+
+        # Create the Open OrderStatusReport from Open Orders
+        ib_orders = await self._client.get_open_orders(self.account_id.get_id())
+        for ib_order in ib_orders:
+            order_status = await self._parse_ib_order_to_order_status_report(ib_order)
+            report.append(order_status)
+        return report
 
     async def generate_trade_reports(
         self,
-        instrument_id: InstrumentId = None,
-        venue_order_id: VenueOrderId = None,
+        instrument_id: Optional[InstrumentId] = None,
+        venue_order_id: Optional[VenueOrderId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[TradeReport]:
-        self._log.info(f"Generating TradeReports for {self.id}...")
-
-        try:
-            # Check Binance for all trades on active symbols
-            symbol = instrument_id.symbol.value if instrument_id is not None else None
-            active_symbols = self._get_cache_active_symbols()
-            active_symbols.extend(await self._get_binance_active_position_symbols(symbol))
-            binance_trades: list[BinanceUserTrade] = []
-            for symbol in active_symbols:
-                response = await self._http_account.query_user_trades(
-                    symbol=symbol,
-                    start_time=secs_to_millis(start.timestamp()) if start is not None else None,
-                    end_time=secs_to_millis(end.timestamp()) if end is not None else None,
-                )
-                binance_trades.extend(response)
-        except BinanceError as e:
-            self._log.exception(f"Cannot generate TradeReport: {e.message}", e)
-            return []
-
-        # Parse all Binance trades
-        reports: list[TradeReport] = []
-        for trade in binance_trades:
-            # Apply filter
-            # TODO(cs): Time filter is WIP
-            # timestamp = pd.to_datetime(data["time"], utc=True)
-            # if start is not None and timestamp < start:
-            #     continue
-            # if end is not None and timestamp > end:
-            #     continue
-            if trade.symbol is None:
-                self._log.warning(f"No symbol for trade {trade}.")
-                continue
-            report = trade.parse_to_trade_report(
-                account_id=self.account_id,
-                instrument_id=self._get_cached_instrument_id(trade.symbol),
-                report_id=UUID4(),
-                ts_init=self._clock.timestamp_ns(),
-            )
-            self._log.debug(f"Received {report}.")
-            reports.append(report)
-
-        # Confirm sorting in ascending order
-        reports = sorted(reports, key=lambda x: x.trade_id)
+        """
+        Generate a list of `TradeReport`s with optional query filters. The returned list
+        may be empty if no trades match the given parameters.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId, optional
+            The instrument ID query filter.
+        venue_order_id : VenueOrderId, optional
+            The venue order ID (assigned by the venue) query filter.
+        start : pd.Timestamp, optional
+            The start datetime query filter.
+        end : pd.Timestamp, optional
+            The end datetime query filter.
+
+        Returns
+        -------
+        list[TradeReport]
 
-        len_reports = len(reports)
-        plural = "" if len_reports == 1 else "s"
-        self._log.info(f"Generated {len(reports)} TradeReport{plural}.")
+        """
+        self._log.warning("Cannot generate `list[TradeReport]`: not yet implemented.")
 
-        return reports
+        return []  # TODO: Implement
 
     async def generate_position_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[PositionStatusReport]:
-        self._log.info(f"Generating PositionStatusReports for {self.id}...")
+        """
+        Generate a list of `PositionStatusReport`s with optional query filters. The
+        returned list may be empty if no positions match the given parameters.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId, optional
+            The instrument ID query filter.
+        start : pd.Timestamp, optional
+            The start datetime query filter.
+        end : pd.Timestamp, optional
+            The end datetime query filter.
+
+        Returns
+        -------
+        list[PositionStatusReport]
+
+        """
+        report = []
+        positions: list[IBPosition] = await self._client.get_positions(self.account_id.get_id())
+        for position in positions:
+            self._log.debug(f"Trying PositionStatusReport for {position.contract.conId}")
+            if position.quantity > 0:
+                side = PositionSide.LONG
+            elif position.quantity < 0:
+                side = PositionSide.SHORT
+            else:
+                continue  # Skip, IB may continue to display closed positions
 
-        try:
-            symbol = instrument_id.symbol.value if instrument_id is not None else None
-            reports = await self._get_binance_position_status_reports(symbol)
-        except BinanceError as e:
-            self._log.exception(f"Cannot generate PositionStatusReport: {e.message}", e)
-            return []
-
-        len_reports = len(reports)
-        plural = "" if len_reports == 1 else "s"
-        self._log.info(f"Generated {len(reports)} PositionStatusReport{plural}.")
+            instrument = await self.instrument_provider.find_with_contract_id(
+                position.contract.conId,
+            )
+            if not self._cache.instrument(instrument.id):
+                self._msgbus.send(endpoint="DataEngine.process", msg=instrument)
 
-        return reports
+            position_status = PositionStatusReport(
+                account_id=self.account_id,
+                instrument_id=instrument.id,
+                position_side=side,
+                quantity=Quantity.from_str(str(abs(position.quantity))),
+                report_id=UUID4(),
+                ts_last=self._clock.timestamp_ns(),
+                ts_init=self._clock.timestamp_ns(),
+            )
+            self._log.debug(f"Received {position_status!r}")
+            report.append(position_status)
 
-    # -- COMMAND HANDLERS -------------------------------------------------------------------------
+        return report
 
-    async def _submit_order(self, command: SubmitOrder) -> None:
-        order: Order = command.order
+    def _transform_order(self, order: Order) -> IBOrder:
+        ib_order = IBOrder()
+        for key, field, fn in map_order_fields:
+            if value := getattr(order, key, None):
+                setattr(ib_order, field, fn(value))
+
+        if isinstance(order, (TrailingStopLimitOrder, TrailingStopMarketOrder)):
+            ib_order.auxPrice = float(order.trailing_offset)
+            if order.trigger_price:
+                ib_order.trailStopPrice = order.trigger_price.as_double()
+                ib_order.triggerMethod = map_trigger_method[order.trigger_type]
+        elif (
+            isinstance(
+                order,
+                (MarketIfTouchedOrder, LimitIfTouchedOrder, StopLimitOrder, StopMarketOrder),
+            )
+        ) and order.trigger_price:
+            ib_order.auxPrice = order.trigger_price.as_double()
+
+        details = self.instrument_provider.contract_details[order.instrument_id.value]
+        ib_order.contract = details.contract
+        ib_order.account = self.account_id.get_id()
+        ib_order.clearingAccount = self.account_id.get_id()
 
-        if order.is_closed:
-            self._log.warning(f"Cannot submit already closed order {order}.")
-            return
+        if order.tags:
+            return self._attach_order_tags(ib_order, order)
+        else:
+            return ib_order
 
-        # Check validity
-        self._check_order_validity(order)
-        self._log.debug(f"Submitting {order}.")
-
-        # Generate event here to ensure correct ordering of events
-        self.generate_order_submitted(
-            strategy_id=order.strategy_id,
-            instrument_id=order.instrument_id,
-            client_order_id=order.client_order_id,
-            ts_event=self._clock.timestamp_ns(),
-        )
+    def _attach_order_tags(self, ib_order: IBOrder, order: Order) -> IBOrder:
         try:
-            await self._submit_order_method[order.order_type](order)
-        except BinanceError as e:
-            self.generate_order_rejected(
-                strategy_id=order.strategy_id,
-                instrument_id=order.instrument_id,
-                client_order_id=order.client_order_id,
-                reason=e.message,
-                ts_event=self._clock.timestamp_ns(),
+            tags: dict = json.loads(order.tags)
+            for tag in tags:
+                if tag == "conditions":
+                    for condition in tags[tag]:
+                        pass  # TODO:
+                else:
+                    setattr(ib_order, tag, tags[tag])
+            return ib_order
+        except (json.JSONDecodeError, TypeError):
+            self._log.warning(
+                f"{order.client_order_id} {order.tags=} ignored, must be valid IBOrderTags.value",
             )
-        except KeyError:
-            raise RuntimeError(f"unsupported order type, was {order.order_type}")
-
-    def _check_order_validity(self, order: Order) -> None:
-        # Implement in child class
-        raise NotImplementedError
-
-    async def _submit_market_order(self, order: MarketOrder) -> None:
-        await self._http_account.new_order(
-            symbol=order.instrument_id.symbol.value,
-            side=self._enum_parser.parse_internal_order_side(order.side),
-            order_type=self._enum_parser.parse_internal_order_type(order),
-            quantity=str(order.quantity),
-            new_client_order_id=order.client_order_id.value,
-            recv_window=str(5000),
-        )
-
-    async def _submit_limit_order(self, order: LimitOrder) -> None:
-        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
-        if (
-            order.time_in_force == TimeInForce.GTD
-            and time_in_force == BinanceTimeInForce.GTC
-            and self._warn_gtd_to_gtc
-        ):
-            self._log.warning("Converted GTD `time_in_force` to GTC.")
-        if order.is_post_only and self._binance_account_type.is_spot_or_margin:
-            time_in_force = None
-        elif order.is_post_only and self._binance_account_type.is_futures:
-            time_in_force = BinanceTimeInForce.GTX
-
-        await self._http_account.new_order(
-            symbol=order.instrument_id.symbol.value,
-            side=self._enum_parser.parse_internal_order_side(order.side),
-            order_type=self._enum_parser.parse_internal_order_type(order),
-            time_in_force=time_in_force,
-            quantity=str(order.quantity),
-            price=str(order.price),
-            iceberg_qty=str(order.display_qty) if order.display_qty is not None else None,
-            reduce_only=str(order.is_reduce_only) if order.is_reduce_only is True else None,
-            new_client_order_id=order.client_order_id.value,
-            recv_window=str(5000),
-        )
+            return ib_order
 
-    async def _submit_stop_limit_order(self, order: StopLimitOrder) -> None:
-        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
-
-        if self._binance_account_type.is_spot_or_margin:
-            working_type = None
-        elif order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
-            working_type = "CONTRACT_PRICE"
-        elif order.trigger_type == TriggerType.MARK_PRICE:
-            working_type = "MARK_PRICE"
-        else:
-            self._log.error(
-                f"Cannot submit order: invalid `order.trigger_type`, was "
-                f"{trigger_type_to_str(order.trigger_price)}. {order}",
+    async def _submit_order(self, command: SubmitOrder) -> None:
+        PyCondition.type(command, SubmitOrder, "command")
+        # Reject the non-compliant orders.
+        # These conditions are based on available info and can be relaxed if there is use case.
+        reject_reason = None
+        if getattr(command.order, "trailing_offset_type", None) not in [
+            TrailingOffsetType.PRICE,
+            None,
+        ]:
+            reject_reason = f"{command.order.trailing_offset_type!r} not implemented"
+        elif getattr(command.order, "is_post_only", None) is True:
+            reject_reason = (
+                "post_only=True, `Marketing making` not supported by InteractiveBrokers."
+            )
+        if reject_reason:
+            self._handle_order_event(
+                status=OrderStatus.REJECTED,
+                order=command.order,
+                reason=reject_reason,
             )
             return
 
-        await self._http_account.new_order(
-            symbol=order.instrument_id.symbol.value,
-            side=self._enum_parser.parse_internal_order_side(order.side),
-            order_type=self._enum_parser.parse_internal_order_type(order),
-            time_in_force=time_in_force,
-            quantity=str(order.quantity),
-            price=str(order.price),
-            stop_price=str(order.trigger_price),
-            working_type=working_type,
-            iceberg_qty=str(order.display_qty) if order.display_qty is not None else None,
-            reduce_only=str(order.is_reduce_only) if order.is_reduce_only is True else None,
-            new_client_order_id=order.client_order_id.value,
-            recv_window=str(5000),
-        )
+        ib_order: IBOrder = self._transform_order(command.order)
+        ib_order.orderId = self._client.next_order_id()
+        self._client.place_order(ib_order)
+        self._handle_order_event(status=OrderStatus.SUBMITTED, order=command.order)
 
     async def _submit_order_list(self, command: SubmitOrderList) -> None:
-        for order in command.order_list.orders:
-            self.generate_order_submitted(
-                strategy_id=order.strategy_id,
-                instrument_id=order.instrument_id,
-                client_order_id=order.client_order_id,
-                ts_event=self._clock.timestamp_ns(),
-            )
+        PyCondition.type(command, SubmitOrderList, "command")
 
-        for order in command.order_list.orders:
-            if order.linked_order_ids:  # TODO(cs): Implement
-                self._log.warning(f"Cannot yet handle OCO conditional orders, {order}.")
-            await self._submit_order(order)
-
-    async def _submit_stop_market_order(self, order: StopMarketOrder) -> None:
-        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
-
-        if self._binance_account_type.is_spot_or_margin:
-            working_type = None
-        elif order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
-            working_type = "CONTRACT_PRICE"
-        elif order.trigger_type == TriggerType.MARK_PRICE:
-            working_type = "MARK_PRICE"
-        else:
-            self._log.error(
-                f"Cannot submit order: invalid `order.trigger_type`, was "
-                f"{trigger_type_to_str(order.trigger_price)}. {order}",
-            )
-            return
-
-        await self._http_account.new_order(
-            symbol=order.instrument_id.symbol.value,
-            side=self._enum_parser.parse_internal_order_side(order.side),
-            order_type=self._enum_parser.parse_internal_order_type(order),
-            time_in_force=time_in_force,
-            quantity=str(order.quantity),
-            stop_price=str(order.trigger_price),
-            working_type=working_type,
-            reduce_only=str(order.is_reduce_only) if order.is_reduce_only is True else None,
-            new_client_order_id=order.client_order_id.value,
-            recv_window=str(5000),
-        )
+        order_id_map = {}
+        client_id_to_orders = {}
+        ib_orders = []
 
-    async def _submit_trailing_stop_market_order(self, order: TrailingStopMarketOrder) -> None:
-        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
+        # Translate orders
+        for order in command.order_list.orders:
+            order_id_map[order.client_order_id.value] = self._client.next_order_id()
+            client_id_to_orders[order.client_order_id.value] = order
 
-        if order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
-            working_type = "CONTRACT_PRICE"
-        elif order.trigger_type == TriggerType.MARK_PRICE:
-            working_type = "MARK_PRICE"
-        else:
-            self._log.error(
-                f"Cannot submit order: invalid `order.trigger_type`, was "
-                f"{trigger_type_to_str(order.trigger_price)}. {order}",
+            ib_order = self._transform_order(order)
+            ib_order.transmit = False
+            ib_order.orderId = order_id_map[order.client_order_id.value]
+            ib_orders.append(ib_order)
+
+        # Mark last order to transmit
+        ib_orders[-1].transmit = True
+
+        for ib_order in ib_orders:
+            # Map the Parent Order Ids
+            if parent_id := order_id_map.get(ib_order.parentId):
+                ib_order.parentId = parent_id
+            # Place orders
+            order_ref = ib_order.orderRef
+            self._client.place_order(ib_order)
+            self._handle_order_event(
+                status=OrderStatus.SUBMITTED,
+                order=client_id_to_orders[order_ref],
             )
-            return
 
-        if order.trailing_offset_type != TrailingOffsetType.BASIS_POINTS:
-            self._log.error(
-                f"Cannot submit order: invalid `order.trailing_offset_type`, was "
-                f"{trailing_offset_type_to_str(order.trailing_offset_type)} (use `BASIS_POINTS`). "
-                f"{order}",
-            )
+    async def _modify_order(self, command: ModifyOrder) -> None:
+        PyCondition.not_none(command, "command")
+        if not (command.quantity or command.price or command.trigger_price):
             return
 
-        # Ensure activation price
-        activation_price: Optional[Price] = order.trigger_price
-        if not activation_price:
-            quote = self._cache.quote_tick(order.instrument_id)
-            trade = self._cache.trade_tick(order.instrument_id)
-            if quote:
-                if order.side == OrderSide.BUY:
-                    activation_price = quote.ask
-                elif order.side == OrderSide.SELL:
-                    activation_price = quote.bid
-            elif trade:
-                activation_price = trade.price
+        nautilus_order: Order = self._cache.order(command.client_order_id)
+        self._log.info(f"Nautilus order status is {nautilus_order.status!r}", LogColor.GREEN)
+        ib_order: IBOrder = self._transform_order(nautilus_order)
+        ib_order.orderId = int(command.venue_order_id.value)
+        if ib_order.parentId:
+            parent_nautilus_order = self._cache.order(ClientOrderId(ib_order.parentId))
+            if parent_nautilus_order:
+                ib_order.parentId = int(parent_nautilus_order.venue_order_id.value)
             else:
-                self._log.error(
-                    "Cannot submit order: no trigger price specified for Binance activation price "
-                    f"and could not find quotes or trades for {order.instrument_id}",
-                )
-
-        await self._http_account.new_order(
-            symbol=order.instrument_id.symbol.value,
-            side=self._enum_parser.parse_internal_order_side(order.side),
-            order_type=self._enum_parser.parse_internal_order_type(order),
-            time_in_force=time_in_force,
-            quantity=str(order.quantity),
-            activation_price=str(activation_price),
-            callback_rate=str(order.trailing_offset / 100),
-            working_type=working_type,
-            reduce_only=str(order.is_reduce_only) if order.is_reduce_only is True else None,
-            new_client_order_id=order.client_order_id.value,
-            recv_window=str(5000),
-        )
-
-    def _get_cached_instrument_id(self, symbol: str) -> InstrumentId:
-        # Parse instrument ID
-        nautilus_symbol: str = BinanceSymbol(symbol).parse_binance_to_internal(
-            self._binance_account_type,
-        )
-        instrument_id: Optional[InstrumentId] = self._instrument_ids.get(nautilus_symbol)
-        if not instrument_id:
-            instrument_id = InstrumentId(Symbol(nautilus_symbol), BINANCE_VENUE)
-            self._instrument_ids[nautilus_symbol] = instrument_id
-        return instrument_id
-
-    async def _modify_order(self, command: ModifyOrder) -> None:
-        self._log.error("Cannot modify order: not supported by the venue.")
+                ib_order.parentId = 0
+        if command.quantity and command.quantity != ib_order.totalQuantity:
+            ib_order.totalQuantity = command.quantity.as_double()
+        if command.price and command.price.as_double() != getattr(ib_order, "lmtPrice", None):
+            ib_order.lmtPrice = command.price.as_double()
+        if command.trigger_price and command.trigger_price.as_double() != getattr(
+            ib_order,
+            "auxPrice",
+            None,
+        ):
+            ib_order.auxPrice = command.trigger_price.as_double()
+        self._log.info(f"Placing {ib_order!r}")
+        self._client.place_order(ib_order)
 
     async def _cancel_order(self, command: CancelOrder) -> None:
-        await self._cancel_order_single(
-            instrument_id=command.instrument_id,
-            client_order_id=command.client_order_id,
-            venue_order_id=command.venue_order_id,
-        )
+        PyCondition.not_none(command, "command")
 
-    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
-        open_orders_strategy = self._cache.orders_open(
-            instrument_id=command.instrument_id,
-            strategy_id=command.strategy_id,
-        )
-        for order in open_orders_strategy:
-            if order.is_pending_cancel:
-                continue  # Already pending cancel
+        venue_order_id = command.venue_order_id
+        if venue_order_id:
+            self._client.cancel_order(int(venue_order_id.value))
+        else:
+            self._log.error(f"VenueOrderId not found for {command.client_order_id}")
 
-        # Check total orders for instrument
-        open_orders_total_count = self._cache.orders_open_count(
+    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
+        for order in self._cache.orders_open(
             instrument_id=command.instrument_id,
-        )
+        ):
+            venue_order_id = order.venue_order_id
+            if venue_order_id:
+                self._client.cancel_order(int(venue_order_id.value))
+            else:
+                self._log.error(f"VenueOrderId not found for {order.client_order_id}")
 
+    def _on_account_summary(self, tag: str, value: str, currency: str):
+        if not self._account_summary.get(currency):
+            self._account_summary[currency] = {}
         try:
-            if open_orders_total_count == len(open_orders_strategy):
-                await self._http_account.cancel_all_open_orders(
-                    symbol=command.instrument_id.symbol.value,
+            self._account_summary[currency][tag] = float(value)
+        except ValueError:
+            self._account_summary[currency][tag] = value
+
+        for currency in self._account_summary:
+            if not currency:
+                continue
+            if self._account_summary_tags - set(self._account_summary[currency].keys()) == set():
+                self._log.info(f"{self._account_summary}", LogColor.GREEN)
+                free = self._account_summary[currency]["FullAvailableFunds"]
+                locked = self._account_summary[currency]["FullMaintMarginReq"]
+                # total = self._account_summary[currency]["NetLiquidation"]
+                total = 400000  # TODO: Bug; Cannot recalculate balance when no current balance
+                free = total - locked
+                account_balance = AccountBalance(
+                    total=Money(total, Currency.from_str(currency)),
+                    free=Money(free, Currency.from_str(currency)),
+                    locked=Money(locked, Currency.from_str(currency)),
                 )
-            else:
-                for order in open_orders_strategy:
-                    await self._cancel_order_single(
-                        instrument_id=order.instrument_id,
-                        client_order_id=order.client_order_id,
-                        venue_order_id=order.venue_order_id,
-                    )
-        except BinanceError as e:
-            if "Unknown order sent" in e.message:
-                self._log.info(
-                    "No open orders to cancel according to Binance.",
-                    LogColor.GREEN,
+
+                margin_balance = MarginBalance(
+                    initial=Money(
+                        self._account_summary[currency]["FullInitMarginReq"],
+                        currency=Currency.from_str(currency),
+                    ),
+                    maintenance=Money(
+                        self._account_summary[currency]["FullMaintMarginReq"],
+                        currency=Currency.from_str(currency),
+                    ),
+                )
+
+                self.generate_account_state(
+                    balances=[account_balance],
+                    margins=[margin_balance],
+                    reported=True,
+                    ts_event=self._clock.timestamp_ns(),
+                )
+
+                # Store all available fields to Cache (for now until permanent solution)
+                self._cache.add(
+                    f"accountSummary:{self.account_id.get_id()}",
+                    json.dumps(self._account_summary).encode("utf-8"),
                 )
-            else:
-                self._log.exception(f"Cannot cancel open orders: {e.message}", e)
 
-    async def _cancel_order_single(
+        self._account_summary_loaded.set()
+
+    def _handle_order_event(
         self,
-        instrument_id: InstrumentId,
-        client_order_id: ClientOrderId,
-        venue_order_id: Optional[VenueOrderId],
-    ) -> None:
-        try:
-            if venue_order_id is not None:
-                await self._http_account.cancel_order(
-                    symbol=instrument_id.symbol.value,
-                    order_id=int(venue_order_id.value),
+        status: OrderStatus,
+        order: Order,
+        order_id: Optional[int] = None,
+        reason: str = "",
+    ):
+        if status == OrderStatus.SUBMITTED:
+            self.generate_order_submitted(
+                strategy_id=order.strategy_id,
+                instrument_id=order.instrument_id,
+                client_order_id=order.client_order_id,
+                ts_event=self._clock.timestamp_ns(),
+            )
+        elif status == OrderStatus.ACCEPTED:
+            if order.status != OrderStatus.ACCEPTED:
+                self.generate_order_accepted(
+                    strategy_id=order.strategy_id,
+                    instrument_id=order.instrument_id,
+                    client_order_id=order.client_order_id,
+                    venue_order_id=VenueOrderId(str(order_id)),
+                    ts_event=self._clock.timestamp_ns(),
                 )
             else:
-                await self._http_account.cancel_order(
-                    symbol=instrument_id.symbol.value,
-                    orig_client_order_id=client_order_id.value,
+                self._log.debug(f"{order.client_order_id} already accepted.")
+        elif status == OrderStatus.PENDING_CANCEL:
+            # TODO: self.generate_order_pending_cancel
+            self._log.warning(f"{order.client_order_id} is {status}")
+        elif status == OrderStatus.CANCELED:
+            self.generate_order_canceled(
+                strategy_id=order.strategy_id,
+                instrument_id=order.instrument_id,
+                client_order_id=order.client_order_id,
+                venue_order_id=order.venue_order_id,
+                ts_event=self._clock.timestamp_ns(),
+            )
+        elif status == OrderStatus.REJECTED:
+            self.generate_order_rejected(
+                strategy_id=order.strategy_id,
+                instrument_id=order.instrument_id,
+                client_order_id=order.client_order_id,
+                reason=reason,
+                ts_event=self._clock.timestamp_ns(),
+            )
+
+    def _on_open_order(self, order_ref: str, order: IBOrder, order_state: IBOrderState):
+        if not order.orderRef:
+            self._log.warning(
+                f"ClientOrderId not available, order={order.__dict__}, state={order_state.__dict__}",
+            )
+            return
+        if not (nautilus_order := self._cache.order(ClientOrderId(order_ref))):
+            self._log.warning(
+                f"ClientOrderId not found in Cache, order={order.__dict__}, state={order_state.__dict__}",
+            )
+            return
+
+        if order.whatIf and order_state.status == "PreSubmitted":
+            # TODO: Is there more better approach for this use case?
+            # This tells the details about Pre and Post margin changes, user can request by setting whatIf flag
+            # order will not be placed by IB and instead returns simulation.
+            # example={'status': 'PreSubmitted', 'initMarginBefore': '52.88', 'maintMarginBefore': '52.88', 'equityWithLoanBefore': '23337.31', 'initMarginChange': '2517.5099999999998', 'maintMarginChange': '2517.5099999999998', 'equityWithLoanChange': '-0.6200000000026193', 'initMarginAfter': '2570.39', 'maintMarginAfter': '2570.39', 'equityWithLoanAfter': '23336.69', 'commission': 2.12362, 'minCommission': 1.7976931348623157e+308, 'maxCommission': 1.7976931348623157e+308, 'commissionCurrency': 'USD', 'warningText': '', 'completedTime': '', 'completedStatus': ''}  # noqa
+            self._handle_order_event(
+                status=OrderStatus.REJECTED,
+                order=nautilus_order,
+                reason=json.dumps({"whatIf": order_state.__dict__}),
+            )
+        elif order_state.status in [
+            "PreSubmitted",
+            "Submitted",
+        ]:  # nautilus_order.status != OrderStatus.ACCEPTED and
+            instrument = self.instrument_provider.find(nautilus_order.instrument_id)
+            total_qty = (
+                Quantity.from_int(0)
+                if order.totalQuantity == UNSET_DECIMAL
+                else Quantity.from_str(str(order.totalQuantity))
+            )
+            price = (
+                None if order.lmtPrice == UNSET_DOUBLE else instrument.make_price(order.lmtPrice)
+            )
+            trigger_price = (
+                None if order.auxPrice == UNSET_DOUBLE else instrument.make_price(order.auxPrice)
+            )
+            if (
+                nautilus_order.venue_order_id is None
+                or nautilus_order.venue_order_id != VenueOrderId(str(order.orderId))
+            ):
+                venue_order_id_modified = True
+            else:
+                venue_order_id_modified = False
+            if total_qty != nautilus_order.quantity or price or trigger_price:
+                self.generate_order_updated(
+                    strategy_id=nautilus_order.strategy_id,
+                    instrument_id=nautilus_order.instrument_id,
+                    client_order_id=nautilus_order.client_order_id,
+                    venue_order_id=VenueOrderId(str(order.orderId)),
+                    quantity=total_qty,
+                    price=price,
+                    trigger_price=trigger_price,
+                    ts_event=self._clock.timestamp_ns(),
+                    venue_order_id_modified=venue_order_id_modified,
                 )
-        except BinanceError as e:
-            self._log.exception(
-                f"Cannot cancel order "
-                f"{client_order_id!r}, "
-                f"{venue_order_id!r}: "
-                f"{e.message}",
-                e,
+            self._handle_order_event(
+                status=OrderStatus.ACCEPTED,
+                order=nautilus_order,
+                order_id=order.orderId,
             )
 
-    # -- WEBSOCKET EVENT HANDLERS --------------------------------------------------------------------
-
-    def _handle_user_ws_message(self, raw: bytes) -> None:
-        # Implement in child class
-        raise NotImplementedError
+    def _on_order_status(self, order_ref: str, order_status: str, reason: str = ""):
+        if order_status in ["ApiCancelled", "Cancelled"]:
+            status = OrderStatus.CANCELED
+        elif order_status == "PendingCancel":
+            status = OrderStatus.PENDING_CANCEL
+        elif order_status == "Rejected":
+            status = OrderStatus.REJECTED
+        else:
+            return
+
+        nautilus_order = self._cache.order(ClientOrderId(order_ref))
+        if nautilus_order:
+            self._handle_order_event(
+                status=status,
+                order=nautilus_order,
+                reason=reason,
+            )
+
+    def _on_exec_details(
+        self,
+        order_ref: str,
+        execution: Execution,
+        commission_report: CommissionReport,
+    ):
+        if not execution.orderRef:
+            self._log.warning(f"ClientOrderId not available, order={execution.__dict__}")
+            return
+        if not (nautilus_order := self._cache.order(ClientOrderId(order_ref))):
+            self._log.warning(f"ClientOrderId not found in Cache, order={execution.__dict__}")
+            return
+
+        instrument = self.instrument_provider.find(nautilus_order.instrument_id)
+
+        self.generate_order_filled(
+            strategy_id=nautilus_order.strategy_id,
+            instrument_id=nautilus_order.instrument_id,
+            client_order_id=nautilus_order.client_order_id,
+            venue_order_id=VenueOrderId(str(execution.orderId)),
+            venue_position_id=None,
+            trade_id=TradeId(execution.execId),
+            order_side=OrderSide[order_side_to_order_action[execution.side]],
+            order_type=nautilus_order.order_type,
+            last_qty=Quantity(execution.shares, precision=instrument.size_precision),
+            last_px=Price(execution.price, precision=instrument.price_precision),
+            quote_currency=instrument.quote_currency,
+            commission=Money(
+                commission_report.commission,
+                Currency.from_str(commission_report.currency),
+            ),
+            liquidity_side=LiquiditySide.NO_LIQUIDITY_SIDE,
+            ts_event=timestring_to_timestamp(execution.time).value,
+        )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/account.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/account.py`

 * *Files 5% similar despite different names*

```diff
@@ -27,14 +27,15 @@
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.execution.reports import OrderStatusReport
 from nautilus_trader.execution.reports import TradeReport
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.enums import ContingencyType
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OrderSide
+from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.enums import TrailingOffsetType
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import OrderListId
 from nautilus_trader.model.identifiers import PositionId
@@ -48,20 +49,17 @@
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceUserTrade(msgspec.Struct, frozen=True):
     """
-    HTTP response from `Binance Spot/Margin`
-        `GET /api/v3/myTrades`
-    HTTP response from `Binance USD-M Futures`
-        `GET /fapi/v1/userTrades`
-    HTTP response from `Binance COIN-M Futures`
-        `GET /dapi/v1/userTrades`
+    HTTP response from `Binance Spot/Margin` `GET /api/v3/myTrades` HTTP response from
+    `Binance USD-M Futures` `GET /fapi/v1/userTrades` HTTP response from `Binance COIN-M
+    Futures` `GET /dapi/v1/userTrades`
     """
 
     commission: str
     commissionAsset: str
     price: str
     qty: str
 
@@ -90,17 +88,18 @@
 
     def parse_to_trade_report(
         self,
         account_id: AccountId,
         instrument_id: InstrumentId,
         report_id: UUID4,
         ts_init: int,
+        use_position_ids: bool = True,
     ) -> TradeReport:
-        venue_position_id = None
-        if self.positionSide is not None:
+        venue_position_id: Optional[PositionId] = None
+        if self.positionSide is not None and use_position_ids:
             venue_position_id = PositionId(f"{instrument_id}-{self.positionSide}")
 
         order_side = OrderSide.BUY if self.isBuyer or self.buyer else OrderSide.SELL
         liquidity_side = LiquiditySide.MAKER if self.isMaker or self.maker else LiquiditySide.TAKER
 
         return TradeReport(
             account_id=account_id,
@@ -117,20 +116,17 @@
             report_id=report_id,
             ts_init=ts_init,
         )
 
 
 class BinanceOrder(msgspec.Struct, frozen=True):
     """
-    HTTP response from `Binance Spot/Margin`
-        `GET /api/v3/order`
-    HTTP response from `Binance USD-M Futures`
-        `GET /fapi/v1/order`
-    HTTP response from `Binance COIN-M Futures`
-        `GET /dapi/v1/order`
+    HTTP response from `Binance Spot/Margin` `GET /api/v3/order` HTTP response from
+    `Binance USD-M Futures` `GET /fapi/v1/order` HTTP response from `Binance COIN-M
+    Futures` `GET /dapi/v1/order`
     """
 
     symbol: str
     orderId: int
     clientOrderId: str
 
     # Parameters not in ACK response:
@@ -172,14 +168,15 @@
 
     def parse_to_order_status_report(
         self,
         account_id: AccountId,
         instrument_id: InstrumentId,
         report_id: UUID4,
         enum_parser: BinanceEnumParser,
+        treat_expired_as_canceled: bool,
         ts_init: int,
     ) -> OrderStatusReport:
         if self.price is None:
             raise RuntimeError(
                 "Cannot generate order status report from Binance ACK response.",
             )
 
@@ -187,45 +184,58 @@
         order_list_id = OrderListId(str(self.orderListId)) if self.orderListId is not None else None
         contingency_type = (
             ContingencyType.OCO
             if self.orderListId is not None and self.orderListId != -1
             else ContingencyType.NO_CONTINGENCY
         )
 
-        trigger_price = Decimal(self.stopPrice)
-        trigger_type = None
+        trigger_price = Decimal(self.stopPrice) if self.stopPrice is not None else Decimal()
+        trigger_type = TriggerType.NO_TRIGGER
         if self.workingType is not None:
             trigger_type = enum_parser.parse_binance_trigger_type(self.workingType)
         elif trigger_price > 0:
-            trigger_type = TriggerType.LAST_TRADE if trigger_price > 0 else None
+            trigger_type = TriggerType.LAST_TRADE
 
         trailing_offset = None
         trailing_offset_type = TrailingOffsetType.NO_TRAILING_OFFSET
         if self.priceRate is not None:
             trailing_offset = Decimal(self.priceRate)
             trailing_offset_type = TrailingOffsetType.BASIS_POINTS
 
         avg_px = Decimal(self.avgPrice) if self.avgPrice is not None else None
         post_only = (
             self.type == BinanceOrderType.LIMIT_MAKER or self.timeInForce == BinanceTimeInForce.GTX
         )
         reduce_only = self.reduceOnly if self.reduceOnly is not None else False
 
+        if self.side is None:
+            raise ValueError("`side` was `None` when a value was expected")
+        if self.type is None:
+            raise ValueError("`type` was `None` when a value was expected")
+        if self.timeInForce is None:
+            raise ValueError("`timeInForce` was `None` when a value was expected")
+        if self.status is None:
+            raise ValueError("`status` was `None` when a value was expected")
+
+        order_status = enum_parser.parse_binance_order_status(self.status)
+        if treat_expired_as_canceled and order_status == OrderStatus.EXPIRED:
+            order_status = OrderStatus.CANCELED
+
         return OrderStatusReport(
             account_id=account_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_list_id=order_list_id,
             venue_order_id=VenueOrderId(str(self.orderId)),
             order_side=enum_parser.parse_binance_order_side(self.side),
             order_type=enum_parser.parse_binance_order_type(self.type),
             contingency_type=contingency_type,
             time_in_force=enum_parser.parse_binance_time_in_force(self.timeInForce),
-            order_status=enum_parser.parse_binance_order_status(self.status),
-            price=Price.from_str(str(Decimal(self.price))),
+            order_status=order_status,
+            price=Price.from_str(self.price),
             trigger_price=Price.from_str(str(trigger_price)),
             trigger_type=trigger_type,
             trailing_offset=trailing_offset,
             trailing_offset_type=trailing_offset_type,
             quantity=Quantity.from_str(self.origQty),
             filled_qty=Quantity.from_str(self.executedQty),
             avg_px=avg_px,
@@ -236,12 +246,12 @@
             report_id=report_id,
             ts_init=ts_init,
         )
 
 
 class BinanceStatusCode(msgspec.Struct, frozen=True):
     """
-    HTTP response status code
+    HTTP response status code.
     """
 
     code: int
     msg: str
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/market.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/market.py`

 * *Files 9% similar despite different names*

```diff
@@ -46,16 +46,15 @@
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceTime(msgspec.Struct, frozen=True):
     """
-    Schema of current server time
-    GET response of `time`
+    Schema of current server time GET response of `time`
     """
 
     serverTime: int
 
 
 class BinanceExchangeFilter(msgspec.Struct):
     """
@@ -118,14 +117,15 @@
 
 
 class BinanceDepth(msgspec.Struct, frozen=True):
     """
     Schema of a binance orderbook depth.
 
     GET response of `depth`.
+
     """
 
     lastUpdateId: int
     bids: list[tuple[str, str]]
     asks: list[tuple[str, str]]
 
     symbol: Optional[str] = None  # COIN-M FUTURES only
@@ -160,43 +160,49 @@
             )
             for o in bids + asks
         ]
         return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceTrade(msgspec.Struct, frozen=True):
-    """Schema of a single trade."""
+    """
+    Schema of a single trade.
+    """
 
     id: int
     price: str
     qty: str
     quoteQty: str
     time: int
     isBuyerMaker: bool
     isBestMatch: Optional[bool] = None  # SPOT/MARGIN only
 
     def parse_to_trade_tick(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
     ) -> TradeTick:
-        """Parse Binance trade to internal TradeTick."""
+        """
+        Parse Binance trade to internal TradeTick.
+        """
         return TradeTick(
             instrument_id=instrument_id,
             price=Price.from_str(self.price),
             size=Quantity.from_str(self.qty),
             aggressor_side=AggressorSide.SELLER if self.isBuyerMaker else AggressorSide.BUYER,
             trade_id=TradeId(str(self.id)),
             ts_event=millis_to_nanos(self.time),
             ts_init=ts_init,
         )
 
 
 class BinanceAggTrade(msgspec.Struct, frozen=True):
-    """Schema of a single compressed aggregate trade."""
+    """
+    Schema of a single compressed aggregate trade.
+    """
 
     a: int  # Aggregate tradeId
     p: str  # Price
     q: str  # Quantity
     f: int  # First tradeId
     l: int  # Last tradeId
     T: int  # Timestamp
@@ -204,28 +210,32 @@
     M: Optional[bool] = None  # SPOT/MARGIN only, was the trade the best price match?
 
     def parse_to_trade_tick(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
     ) -> TradeTick:
-        """Parse Binance trade to internal TradeTick"""
+        """
+        Parse Binance trade to internal TradeTick.
+        """
         return TradeTick(
             instrument_id=instrument_id,
             price=Price.from_str(self.p),
             size=Quantity.from_str(self.q),
             aggressor_side=AggressorSide.SELLER if self.m else AggressorSide.BUYER,
             trade_id=TradeId(str(self.a)),
             ts_event=millis_to_nanos(self.T),
             ts_init=ts_init,
         )
 
 
 class BinanceKline(msgspec.Struct, array_like=True):
-    """Array-like schema of single Binance kline."""
+    """
+    Array-like schema of single Binance kline.
+    """
 
     open_time: int
     open: str
     high: str
     low: str
     close: str
     volume: str
@@ -237,15 +247,17 @@
     ignore: str
 
     def parse_to_binance_bar(
         self,
         bar_type: BarType,
         ts_init: int,
     ) -> BinanceBar:
-        """Parse kline to BinanceBar."""
+        """
+        Parse kline to BinanceBar.
+        """
         return BinanceBar(
             bar_type=bar_type,
             open=Price.from_str(self.open),
             high=Price.from_str(self.high),
             low=Price.from_str(self.low),
             close=Price.from_str(self.close),
             volume=Quantity.from_str(self.volume),
@@ -255,15 +267,17 @@
             taker_buy_quote_volume=Decimal(self.taker_quote_volume),
             ts_event=millis_to_nanos(self.open_time),
             ts_init=ts_init,
         )
 
 
 class BinanceTicker24hr(msgspec.Struct, frozen=True):
-    """Schema of single Binance 24hr ticker (FULL/MINI)."""
+    """
+    Schema of single Binance 24hr ticker (FULL/MINI).
+    """
 
     symbol: Optional[str]
     lastPrice: Optional[str]
     openPrice: Optional[str]
     highPrice: Optional[str]
     lowPrice: Optional[str]
     volume: Optional[str]
@@ -287,24 +301,28 @@
     pair: Optional[str] = None  # COIN-M FUTURES only
     baseVolume: Optional[str] = None  # COIN-M FUTURES only
 
     quoteVolume: Optional[str] = None  # SPOT/MARGIN & USD-M FUTURES only
 
 
 class BinanceTickerPrice(msgspec.Struct, frozen=True):
-    """Schema of single Binance Price Ticker."""
+    """
+    Schema of single Binance Price Ticker.
+    """
 
     symbol: Optional[str]
     price: Optional[str]
     time: Optional[int] = None  # FUTURES only
     ps: Optional[str] = None  # COIN-M FUTURES only, pair
 
 
 class BinanceTickerBook(msgspec.Struct, frozen=True):
-    """Schema of a single Binance Order Book Ticker."""
+    """
+    Schema of a single Binance Order Book Ticker.
+    """
 
     symbol: Optional[str]
     bidPrice: Optional[str]
     bidQty: Optional[str]
     askPrice: Optional[str]
     askQty: Optional[str]
     pair: Optional[str] = None  # USD-M FUTURES only
@@ -321,15 +339,17 @@
     Provides a wrapper for data WebSocket messages from `Binance`.
     """
 
     stream: str
 
 
 class BinanceOrderBookDelta(msgspec.Struct, array_like=True):
-    """Schema of single ask/bid delta."""
+    """
+    Schema of single ask/bid delta.
+    """
 
     price: str
     size: str
 
     def parse_to_order_book_delta(
         self,
         instrument_id: InstrumentId,
@@ -354,15 +374,20 @@
             ts_init=ts_init,
             sequence=update_id,
             flags=0,
         )
 
 
 class BinanceOrderBookData(msgspec.Struct, frozen=True):
-    """WebSocket message 'inner struct' for `Binance` Partial & Diff. Book Depth Streams."""
+    """
+    WebSocket message 'inner struct' for `Binance` Partial & Diff.
+
+    Book Depth Streams.
+
+    """
 
     e: str  # Event type
     E: int  # Event time
     s: str  # Symbol
     U: int  # First update ID in event
     u: int  # Final update ID in event
     b: list[BinanceOrderBookDelta]  # Bids to be updated
@@ -421,22 +446,29 @@
         deltas += [
             OrderBookDelta(instrument_id, BookAction.ADD, o, ts_event, ts_init) for o in bids + asks
         ]
         return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceOrderBookMsg(msgspec.Struct, frozen=True):
-    """WebSocket message from `Binance` Partial & Diff. Book Depth Streams."""
+    """
+    WebSocket message from `Binance` Partial & Diff.
+
+    Book Depth Streams.
+
+    """
 
     stream: str
     data: BinanceOrderBookData
 
 
 class BinanceQuoteData(msgspec.Struct, frozen=True):
-    """WebSocket message from `Binance` Individual Symbol Book Ticker Streams."""
+    """
+    WebSocket message from `Binance` Individual Symbol Book Ticker Streams.
+    """
 
     s: str  # symbol
     u: int  # order book updateId
     b: str  # best bid price
     B: str  # best bid qty
     a: str  # best ask price
     A: str  # best ask qty
@@ -454,22 +486,26 @@
             ask_size=Quantity.from_str(self.A),
             ts_event=ts_init,
             ts_init=ts_init,
         )
 
 
 class BinanceQuoteMsg(msgspec.Struct, frozen=True):
-    """WebSocket message from `Binance` Individual Symbol Book Ticker Streams."""
+    """
+    WebSocket message from `Binance` Individual Symbol Book Ticker Streams.
+    """
 
     stream: str
     data: BinanceQuoteData
 
 
 class BinanceAggregatedTradeData(msgspec.Struct, frozen=True):
-    """WebSocket message from `Binance` Aggregate Trade Streams."""
+    """
+    WebSocket message from `Binance` Aggregate Trade Streams.
+    """
 
     e: str  # Event type
     E: int  # Event time
     s: str  # Symbol
     a: int  # Aggregate trade ID
     p: str  # Price
     q: str  # Quantity
@@ -491,23 +527,25 @@
             trade_id=TradeId(str(self.a)),
             ts_event=millis_to_nanos(self.T),
             ts_init=ts_init,
         )
 
 
 class BinanceAggregatedTradeMsg(msgspec.Struct, frozen=True):
-    """WebSocket message."""
+    """
+    WebSocket message.
+    """
 
     stream: str
     data: BinanceAggregatedTradeData
 
 
 class BinanceTickerData(msgspec.Struct, kw_only=True, frozen=True):
     """
-    WebSocket message from `Binance` 24hr Ticker
+    WebSocket message from `Binance` 24hr Ticker.
 
     Fields
     ------
     - e: Event type
     - E: Event time
     - s: Symbol
     - p: Price change
@@ -526,14 +564,15 @@
     - v: Total traded base asset volume
     - q: Total traded quote asset volume
     - O: Statistics open time
     - C: Statistics close time
     - F: First trade ID
     - L: Last trade ID
     - n: Total number of trades
+
     """
 
     e: str  # Event type
     E: int  # Event time
     s: str  # Symbol
     p: str  # Price change
     P: str  # Price change percent
@@ -585,15 +624,17 @@
             count=self.n,
             ts_event=millis_to_nanos(self.E),
             ts_init=ts_init,
         )
 
 
 class BinanceTickerMsg(msgspec.Struct, frozen=True):
-    """WebSocket message."""
+    """
+    WebSocket message.
+    """
 
     stream: str
     data: BinanceTickerData
 
 
 class BinanceCandlestick(msgspec.Struct, frozen=True):
     """
@@ -614,14 +655,15 @@
     - v: Base asset volume
     - n: Number of trades
     - x: Is this kline closed?
     - q: Quote asset volume
     - V: Taker buy base asset volume
     - Q: Taker buy quote asset volume
     - B: Ignore
+
     """
 
     t: int  # Kline start time
     T: int  # Kline close time
     s: str  # Symbol
     i: BinanceKlineInterval  # Interval
     f: int  # First trade ID
@@ -662,20 +704,24 @@
             taker_buy_quote_volume=Decimal(self.Q),
             ts_event=millis_to_nanos(self.T),
             ts_init=ts_init,
         )
 
 
 class BinanceCandlestickData(msgspec.Struct, frozen=True):
-    """WebSocket message 'inner struct'."""
+    """
+    WebSocket message 'inner struct'.
+    """
 
     e: str
     E: int
     s: str
     k: BinanceCandlestick
 
 
 class BinanceCandlestickMsg(msgspec.Struct, frozen=True):
-    """WebSocket message for `Binance` Kline/Candlestick Streams."""
+    """
+    WebSocket message for `Binance` Kline/Candlestick Streams.
+    """
 
     stream: str
     data: BinanceCandlestickData
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/symbol.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/symbol.py`

 * *Files 5% similar despite different names*

```diff
@@ -21,39 +21,43 @@
 
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceSymbol(str):
-    """Binance compatible symbol."""
+    """
+    Binance compatible symbol.
+    """
 
     def __new__(cls, symbol: Optional[str]):
         if symbol is not None:
             # Format the string on construction to be Binance compatible
             return super().__new__(
                 cls,
                 symbol.upper().replace(" ", "").replace("/", "").replace("-PERP", ""),
             )
 
-    def parse_binance_to_internal(self, account_type: BinanceAccountType) -> str:
+    def parse_as_nautilus(self, account_type: BinanceAccountType) -> str:
         if account_type.is_spot_or_margin:
             return str(self)
 
         # Parse Futures symbol
         if self[-1].isdigit():
             return str(self)  # Deliverable
         if self.endswith("_PERP"):
             return str(self).replace("_", "-")
         else:
             return str(self) + "-PERP"
 
 
 class BinanceSymbols(str):
-    """Binance compatible list of symbols."""
+    """
+    Binance compatible list of symbols.
+    """
 
     def __new__(cls, symbols: Optional[list[str]]):
         if symbols is not None:
             binance_symbols: list[BinanceSymbol] = [BinanceSymbol(symbol) for symbol in symbols]
             return super().__new__(cls, json.dumps(binance_symbols).replace(" ", ""))
 
     def parse_str_to_list(self) -> list[BinanceSymbol]:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/user.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/schemas/user.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,10 +18,12 @@
 
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceListenKey(msgspec.Struct):
-    """HTTP response from creating a new `Binance` user listen key."""
+    """
+    HTTP response from creating a new `Binance` user listen key.
+    """
 
     listenKey: str
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/types.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/types.py`

 * *Files 0% similar despite different names*

```diff
@@ -57,14 +57,15 @@
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-data
     https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-data
+
     """
 
     def __init__(
         self,
         bar_type: BarType,
         open: Price,
         high: Price,
@@ -247,14 +248,15 @@
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics
     https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics
+
     """
 
     def __init__(
         self,
         instrument_id: InstrumentId,
         price_change: Decimal,
         price_change_percent: Decimal,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/config.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/config.py`

 * *Files 27% similar despite different names*

```diff
@@ -14,14 +14,16 @@
 # -------------------------------------------------------------------------------------------------
 
 from typing import Optional
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.config import LiveDataClientConfig
 from nautilus_trader.config import LiveExecClientConfig
+from nautilus_trader.config.validation import PositiveFloat
+from nautilus_trader.config.validation import PositiveInt
 
 
 class BinanceDataClientConfig(LiveDataClientConfig, frozen=True):
     """
     Configuration for ``BinanceDataClient`` instances.
 
     Parameters
@@ -43,14 +45,15 @@
     us : bool, default False
         If client is connecting to Binance US.
     testnet : bool, default False
         If the client is connecting to a Binance testnet.
     use_agg_trade_ticks : bool, default False
         Whether to use aggregated trade tick endpoints instead of raw trade ticks.
         TradeId of ticks will be the Aggregate tradeId returned by Binance.
+
     """
 
     api_key: Optional[str] = None
     api_secret: Optional[str] = None
     account_type: BinanceAccountType = BinanceAccountType.SPOT
     base_url_http: Optional[str] = None
     base_url_ws: Optional[str] = None
@@ -79,20 +82,38 @@
         The HTTP client custom endpoint override.
     base_url_ws : str, optional
         The WebSocket client custom endpoint override.
     us : bool, default False
         If client is connecting to Binance US.
     testnet : bool, default False
         If the client is connecting to a Binance testnet.
-    warn_gtd_to_gtc : bool, default True
-        If log warning for GTD time in force transformed to GTC.
+    use_reduce_only : bool, default True
+        If the `reduce_only` execution instruction on orders is sent through to the exchange.
+        If True then will assign the value on orders sent to the exchange, otherwise will always be False.
+    use_position_ids: bool, default True
+        If Binance Futures hedging position IDs should be used.
+        If False then order event `position_id`(s) from the execution client will be `None`, which
+        allows *virtual* positions with `OmsType.HEDGING`.
+    treat_expired_as_canceled : bool, default False
+        If the `EXPIRED` execution type is semantically treated as `CANCELED`.
+        Binance treats cancels with certain combinations of order type and time in force as expired
+        events. This config option allows you to treat these uniformally as cancels.
+    max_retries : PositiveInt, optional
+        The maximum number of times a submit or cancel order request will be retried.
+    retry_delay : PositiveFloat, optional
+        The delay (seconds) between retries.
+
     """
 
     api_key: Optional[str] = None
     api_secret: Optional[str] = None
     account_type: BinanceAccountType = BinanceAccountType.SPOT
     base_url_http: Optional[str] = None
     base_url_ws: Optional[str] = None
     us: bool = False
     testnet: bool = False
     clock_sync_interval_secs: int = 0
-    warn_gtd_to_gtc: bool = True
+    use_reduce_only: bool = True
+    use_position_ids: bool = True
+    treat_expired_as_canceled: bool = False
+    max_retries: Optional[PositiveInt] = None
+    retry_delay: Optional[PositiveFloat] = None
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/factories.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/factories.py`

 * *Files 2% similar despite different names*

```diff
@@ -101,14 +101,15 @@
 
 @lru_cache(1)
 def get_cached_binance_spot_instrument_provider(
     client: BinanceHttpClient,
     logger: Logger,
     clock: LiveClock,
     account_type: BinanceAccountType,
+    is_testnet: bool,
     config: InstrumentProviderConfig,
 ) -> BinanceSpotInstrumentProvider:
     """
     Cache and return an instrument provider for the `Binance Spot/Margin` exchange.
 
     If a cached provider already exists, then that provider will be returned.
 
@@ -118,27 +119,30 @@
         The client for the instrument provider.
     logger : Logger
         The logger for the instrument provider.
     clock : LiveClock
         The clock for the instrument provider.
     account_type : BinanceAccountType
         The Binance account type for the instrument provider.
+    is_testnet : bool, default False
+        If the provider is for the Spot testnet.
     config : InstrumentProviderConfig
         The configuration for the instrument provider.
 
     Returns
     -------
     BinanceSpotInstrumentProvider
 
     """
     return BinanceSpotInstrumentProvider(
         client=client,
         logger=logger,
         clock=clock,
         account_type=account_type,
+        is_testnet=is_testnet,
         config=config,
     )
 
 
 @lru_cache(1)
 def get_cached_binance_futures_instrument_provider(
     client: BinanceHttpClient,
@@ -246,29 +250,30 @@
         if config.account_type.is_spot_or_margin:
             # Get instrument provider singleton
             provider = get_cached_binance_spot_instrument_provider(
                 client=client,
                 logger=logger,
                 clock=clock,
                 account_type=config.account_type,
+                is_testnet=config.testnet,
                 config=config.instrument_provider,
             )
 
             # Create client
             return BinanceSpotDataClient(
                 loop=loop,
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 logger=logger,
                 instrument_provider=provider,
                 account_type=config.account_type,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
-                use_agg_trade_ticks=config.use_agg_trade_ticks,
+                config=config,
             )
         else:
             # Get instrument provider singleton
             provider = get_cached_binance_futures_instrument_provider(
                 client=client,
                 logger=logger,
                 clock=clock,
@@ -283,15 +288,15 @@
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 logger=logger,
                 instrument_provider=provider,
                 account_type=config.account_type,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
-                use_agg_trade_ticks=config.use_agg_trade_ticks,
+                config=config,
             )
 
 
 class BinanceLiveExecClientFactory(LiveExecClientFactory):
     """
     Provides a `Binance` live execution client factory.
     """
@@ -358,29 +363,30 @@
         if config.account_type.is_spot or config.account_type.is_margin:
             # Get instrument provider singleton
             provider = get_cached_binance_spot_instrument_provider(
                 client=client,
                 logger=logger,
                 clock=clock,
                 account_type=config.account_type,
+                is_testnet=config.testnet,
                 config=config.instrument_provider,
             )
 
             # Create client
             return BinanceSpotExecutionClient(
                 loop=loop,
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 logger=logger,
                 instrument_provider=provider,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
                 account_type=config.account_type,
-                warn_gtd_to_gtc=config.warn_gtd_to_gtc,
+                config=config,
             )
         else:
             # Get instrument provider singleton
             provider = get_cached_binance_futures_instrument_provider(
                 client=client,
                 logger=logger,
                 clock=clock,
@@ -395,15 +401,15 @@
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 logger=logger,
                 instrument_provider=provider,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
                 account_type=config.account_type,
-                warn_gtd_to_gtc=config.warn_gtd_to_gtc,
+                config=config,
             )
 
 
 def _get_api_key(account_type: BinanceAccountType, is_testnet: bool) -> str:
     if is_testnet:
         if account_type.is_spot_or_margin:
             return os.environ["BINANCE_TESTNET_API_KEY"]
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/data.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 import asyncio
 from typing import Optional, Union
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.data import BinanceCommonDataClient
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
+from nautilus_trader.adapters.binance.config import BinanceDataClientConfig
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesEnumParser
 from nautilus_trader.adapters.binance.futures.http.market import BinanceFuturesMarketHttpAPI
 from nautilus_trader.adapters.binance.futures.schemas.market import BinanceFuturesMarkPriceMsg
 from nautilus_trader.adapters.binance.futures.schemas.market import BinanceFuturesTradeMsg
 from nautilus_trader.adapters.binance.futures.types import BinanceFuturesMarkPriceUpdate
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.cache.cache import Cache
@@ -60,31 +61,31 @@
         The logger for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
     base_url_ws : str
         The base URL for the WebSocket client.
     account_type : BinanceAccountType
         The account type for the client.
-    use_agg_trade_ticks : bool, default False
-        Whether to use aggregated trade tick endpoints instead of raw trade ticks.
-        TradeId of ticks will be the Aggregate tradeId returned by Binance.
+    config : BinanceDataClientConfig
+        The configuration for the client.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InstrumentProvider,
         base_url_ws: str,
+        config: BinanceDataClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
-        use_agg_trade_ticks: bool = False,
     ):
         PyCondition.true(
             account_type.is_futures,
             "account_type was not USDT_FUTURE or COIN_FUTURE",
         )
 
         # Futures HTTP API
@@ -102,15 +103,15 @@
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
-            use_agg_trade_ticks=use_agg_trade_ticks,
+            config=config,
         )
 
         # Register additional futures websocket handlers
         self._ws_handlers["@markPrice"] = self._handle_mark_price
 
         # Websocket msgspec decoders
         self._decoder_futures_trade_msg = msgspec.json.Decoder(BinanceFuturesTradeMsg)
@@ -129,15 +130,15 @@
             instrument_id: Optional[InstrumentId] = data_type.metadata.get("instrument_id")
             if instrument_id is None:
                 self._log.error(
                     "Cannot subscribe to `BinanceFuturesMarkPriceUpdate` "
                     "no instrument ID in `data_type` metadata.",
                 )
                 return
-            self._ws_client.subscribe_mark_price(instrument_id.symbol.value, speed=1000)
+            await self._ws_client.subscribe_mark_price(instrument_id.symbol.value, speed=1000)
         else:
             self._log.error(
                 f"Cannot subscribe to {data_type.type} (not implemented).",
             )
 
     async def _unsubscribe(self, data_type: DataType) -> None:
         if data_type.type == BinanceFuturesMarkPriceUpdate:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/enums.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/enums.py`

 * *Files 14% similar despite different names*

```diff
@@ -8,89 +8,102 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
+"""
+Defines `Binance` Futures specific enums.
+
+References
+----------
+https://binance-docs.github.io/apidocs/futures/en/#public-endpoints-info
+
+"""
 
+
+from decimal import Decimal
 from enum import Enum
 from enum import unique
 
 from nautilus_trader.adapters.binance.common.enums import BinanceEnumParser
 from nautilus_trader.adapters.binance.common.enums import BinanceOrderType
 from nautilus_trader.model.enums import OrderType
 from nautilus_trader.model.enums import PositionSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.orders import Order
 
 
-"""
-Defines `Binance` Futures specific enums.
-
-References
-----------
-https://binance-docs.github.io/apidocs/futures/en/#public-endpoints-info
-"""
-
-
 @unique
 class BinanceFuturesContractType(Enum):
-    """Represents a `Binance Futures` derivatives contract type."""
+    """
+    Represents a `Binance Futures` derivatives contract type.
+    """
 
     PERPETUAL = "PERPETUAL"
     CURRENT_MONTH = "CURRENT_MONTH"
     NEXT_MONTH = "NEXT_MONTH"
     CURRENT_QUARTER = "CURRENT_QUARTER"
     NEXT_QUARTER = "NEXT_QUARTER"
 
 
 @unique
 class BinanceFuturesContractStatus(Enum):
-    """Represents a `Binance Futures` contract status."""
+    """
+    Represents a `Binance Futures` contract status.
+    """
 
     PENDING_TRADING = "PENDING_TRADING"
     TRADING = "TRADING"
     PRE_DELIVERING = "PRE_DELIVERING"
     DELIVERING = "DELIVERING"
     DELIVERED = "DELIVERED"
     PRE_SETTLE = "PRE_SETTLE"
     SETTLING = "SETTLING"
     CLOSE = "CLOSE"
 
 
 @unique
 class BinanceFuturesPositionSide(Enum):
-    """Represents a `Binance Futures` position side."""
+    """
+    Represents a `Binance Futures` position side.
+    """
 
     BOTH = "BOTH"
     LONG = "LONG"
     SHORT = "SHORT"
 
 
 @unique
 class BinanceFuturesWorkingType(Enum):
-    """Represents a `Binance Futures` working type."""
+    """
+    Represents a `Binance Futures` working type.
+    """
 
     MARK_PRICE = "MARK_PRICE"
     CONTRACT_PRICE = "CONTRACT_PRICE"
 
 
 @unique
 class BinanceFuturesMarginType(Enum):
-    """Represents a `Binance Futures` margin type."""
+    """
+    Represents a `Binance Futures` margin type.
+    """
 
     ISOLATED = "isolated"
     CROSS = "cross"
 
 
 @unique
 class BinanceFuturesPositionUpdateReason(Enum):
-    """Represents a `Binance Futures` position and balance update reason."""
+    """
+    Represents a `Binance Futures` position and balance update reason.
+    """
 
     DEPOSIT = "DEPOSIT"
     WITHDRAW = "WITHDRAW"
     ORDER = "ORDER"
     FUNDING_FEE = "FUNDING_FEE"
     WITHDRAW_REJECT = "WITHDRAW_REJECT"
     ADJUSTMENT = "ADJUSTMENT"
@@ -103,15 +116,17 @@
     OPTIONS_PREMIUM_FEE = "OPTIONS_PREMIUM_FEE"
     OPTIONS_SETTLE_PROFIT = "OPTIONS_SETTLE_PROFIT"
     AUTO_EXCHANGE = "AUTO_EXCHANGE"
 
 
 @unique
 class BinanceFuturesEventType(Enum):
-    """Represents a `Binance Futures` event type."""
+    """
+    Represents a `Binance Futures` event type.
+    """
 
     LISTEN_KEY_EXPIRED = "listenKeyExpired"
     MARGIN_CALL = "MARGIN_CALL"
     ACCOUNT_UPDATE = "ACCOUNT_UPDATE"
     ORDER_TRADE_UPDATE = "ORDER_TRADE_UPDATE"
     ACCOUNT_CONFIG_UPDATE = "ACCOUNT_CONFIG_UPDATE"
 
@@ -133,23 +148,17 @@
             BinanceOrderType.TAKE_PROFIT_MARKET: OrderType.MARKET_IF_TOUCHED,
             BinanceOrderType.TRAILING_STOP_MARKET: OrderType.TRAILING_STOP_MARKET,
         }
         self.futures_int_to_ext_order_type = {
             b: a for a, b in self.futures_ext_to_int_order_type.items()
         }
 
-        self.futures_ext_to_int_position_side = {
-            BinanceFuturesPositionSide.BOTH: PositionSide.FLAT,
-            BinanceFuturesPositionSide.LONG: PositionSide.LONG,
-            BinanceFuturesPositionSide.SHORT: PositionSide.SHORT,
-        }
-
         self.futures_valid_time_in_force = {
             TimeInForce.GTC,
-            TimeInForce.GTD,  # Will be transformed to GTC with warning
+            TimeInForce.GTD,  # Will be transformed to GTC
             TimeInForce.FOK,
             TimeInForce.IOC,
         }
 
         self.futures_valid_order_types = {
             OrderType.MARKET,
             OrderType.LIMIT,
@@ -182,15 +191,15 @@
         elif trigger_type == BinanceFuturesWorkingType.MARK_PRICE.value:
             return TriggerType.MARK_PRICE
         else:
             return None
 
     def parse_futures_position_side(
         self,
-        position_side: BinanceFuturesPositionSide,
+        net_size: Decimal,
     ) -> PositionSide:
-        try:
-            return self.futures_ext_to_int_position_side[position_side]
-        except KeyError:
-            raise RuntimeError(  # pragma: no cover (design-time error)
-                f"unrecognized binance futures position side, was {position_side}",  # pragma: no cover
-            )
+        if net_size > 0:
+            return PositionSide.LONG
+        elif net_size < 0:
+            return PositionSide.SHORT
+        else:
+            return PositionSide.FLAT
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/execution.py`

 * *Files 3% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 from typing import Optional
 
 import msgspec
 
 from nautilus_trader.accounting.accounts.margin import MarginAccount
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.execution import BinanceCommonExecutionClient
+from nautilus_trader.adapters.binance.config import BinanceExecClientConfig
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesEnumParser
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesEventType
 from nautilus_trader.adapters.binance.futures.http.account import BinanceFuturesAccountHttpAPI
 from nautilus_trader.adapters.binance.futures.http.market import BinanceFuturesMarketHttpAPI
 from nautilus_trader.adapters.binance.futures.http.user import BinanceFuturesUserDataHttpAPI
 from nautilus_trader.adapters.binance.futures.providers import BinanceFuturesInstrumentProvider
 from nautilus_trader.adapters.binance.futures.schemas.account import BinanceFuturesAccountInfo
@@ -70,30 +71,31 @@
         The logger for the client.
     instrument_provider : BinanceFuturesInstrumentProvider
         The instrument provider.
     base_url_ws : str
         The base URL for the WebSocket client.
     account_type : BinanceAccountType
         The account type for the client.
-    warn_gtd_to_gtc : bool, default True
-        If log warning for GTD time in force transformed to GTC.
+    config : BinanceExecClientConfig
+        The configuration for the client.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: BinanceFuturesInstrumentProvider,
         base_url_ws: str,
+        config: BinanceExecClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
-        warn_gtd_to_gtc: bool = True,
     ):
         PyCondition.true(
             account_type.is_futures,
             "account_type was not USDT_FUTURE or COIN_FUTURE",
         )
 
         # Futures HTTP API
@@ -115,15 +117,15 @@
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
-            warn_gtd_to_gtc=warn_gtd_to_gtc,
+            config=config,
         )
 
         # Register additional futures websocket user data event handlers
         self._futures_user_ws_handlers = {
             BinanceFuturesEventType.ACCOUNT_UPDATE: self._handle_account_update,
             BinanceFuturesEventType.ORDER_TRADE_UPDATE: self._handle_order_trade_update,
             BinanceFuturesEventType.MARGIN_CALL: self._handle_margin_call,
@@ -189,24 +191,24 @@
             self._log.debug(f"Received {report}.")
             reports.append(report)
         return reports
 
     async def _get_binance_active_position_symbols(
         self,
         symbol: Optional[str] = None,
-    ) -> list[str]:
+    ) -> set[str]:
         # Check Binance for all active positions
-        active_symbols: list[str] = []
+        active_symbols: set[str] = set()
         binance_positions: list[BinanceFuturesPositionRisk]
         binance_positions = await self._futures_http_account.query_futures_position_risk(symbol)
         for position in binance_positions:
             if Decimal(position.positionAmt) == 0:
                 continue  # Flat position
             # Add active symbol
-            active_symbols.append(position.symbol)
+            active_symbols.add(position.symbol)
         return active_symbols
 
     # -- COMMAND HANDLERS -------------------------------------------------------------------------
 
     def _check_order_validity(self, order: Order) -> None:
         # Check order type valid
         if order.order_type not in self._futures_enum_parser.futures_valid_order_types:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/account.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/account.py`

 * *Files 2% similar despite different names*

```diff
@@ -41,14 +41,15 @@
     `POST /fapi/v1/positionSide/dual`
     `POST /dapi/v1/positionSide/dual`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/futures/en/#change-position-mode-trade
     https://binance-docs.github.io/apidocs/delivery/en/#change-position-mode-trade
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -71,14 +72,15 @@
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         recvWindow: Optional[str] = None
 
     class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
@@ -89,14 +91,15 @@
         timestamp : str
             The millisecond timestamp of the request.
         dualSidePosition : str ('true', 'false')
             The dual side position mode to set...
             `true`: Hedge Mode, `false`: One-way mode.
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         dualSidePosition: str
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> BinanceFuturesDualSidePosition:
@@ -117,14 +120,15 @@
     `DELETE /fapi/v1/allOpenOrders`
     `DELETE /dapi/v1/allOpenOrders`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/futures/en/#cancel-all-open-orders-trade
     https://binance-docs.github.io/apidocs/delivery/en/#cancel-all-open-orders-trade
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -147,14 +151,15 @@
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         symbol : BinanceSymbol
             The symbol of the request
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         symbol: BinanceSymbol
         recvWindow: Optional[str] = None
 
     async def _delete(self, parameters: DeleteParameters) -> BinanceStatusCode:
@@ -170,14 +175,15 @@
     `GET /fapi/v2/account`
     `GET /dapi/v1/account`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/futures/en/#account-information-v2-user_data
     https://binance-docs.github.io/apidocs/delivery/en/#account-information-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -198,14 +204,15 @@
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> BinanceFuturesAccountInfo:
         method_type = BinanceMethodType.GET
@@ -220,14 +227,15 @@
     `GET /fapi/v2/positionRisk`
     `GET /dapi/v1/positionRisk`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/futures/en/#position-information-v2-user_data
     https://binance-docs.github.io/apidocs/delivery/en/#position-information-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -250,14 +258,15 @@
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         symbol : BinanceSymbol, optional
             The symbol of the request.
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         symbol: Optional[BinanceSymbol] = None
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceFuturesPositionRisk]:
@@ -272,14 +281,15 @@
 
     Parameters
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         clock: LiveClock,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
@@ -312,69 +322,82 @@
             v2_endpoint_base,
         )
 
     async def query_futures_hedge_mode(
         self,
         recv_window: Optional[str] = None,
     ) -> BinanceFuturesDualSidePosition:
-        """Check Binance Futures hedge mode (dualSidePosition)."""
+        """
+        Check Binance Futures hedge mode (dualSidePosition).
+        """
         return await self._endpoint_futures_position_mode._get(
             parameters=self._endpoint_futures_position_mode.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def set_futures_hedge_mode(
         self,
         dual_side_position: bool,
         recv_window: Optional[str] = None,
     ) -> BinanceStatusCode:
-        """Set Binance Futures hedge mode (dualSidePosition)."""
+        """
+        Set Binance Futures hedge mode (dualSidePosition).
+        """
         return await self._endpoint_futures_position_mode._post(
             parameters=self._endpoint_futures_position_mode.PostParameters(
                 timestamp=self._timestamp(),
                 dualSidePosition=str(dual_side_position).lower(),
                 recvWindow=recv_window,
             ),
         )
 
     async def cancel_all_open_orders(
         self,
         symbol: str,
         recv_window: Optional[str] = None,
     ) -> bool:
-        """Delete all Futures open orders. Returns whether successful."""
+        """
+        Delete all Futures open orders.
+
+        Returns whether successful.
+
+        """
         response = await self._endpoint_futures_all_open_orders._delete(
             parameters=self._endpoint_futures_all_open_orders.DeleteParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 recvWindow=recv_window,
             ),
         )
         return response.code == 200
 
     async def query_futures_account_info(
         self,
         recv_window: Optional[str] = None,
     ) -> BinanceFuturesAccountInfo:
-        """Check Binance Futures account information."""
+        """
+        Check Binance Futures account information.
+        """
         return await self._endpoint_futures_account._get(
             parameters=self._endpoint_futures_account.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def query_futures_position_risk(
         self,
         symbol: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceFuturesPositionRisk]:
-        """Check all Futures position's info for a symbol."""
+        """
+        Check all Futures position's info for a symbol.
+        """
         return await self._endpoint_futures_position_risk._get(
             parameters=self._endpoint_futures_position_risk.GetParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 recvWindow=recv_window,
             ),
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/market.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/market.py`

 * *Files 4% similar despite different names*

```diff
@@ -31,14 +31,15 @@
     `GET /fapi/v1/exchangeInfo`
     `GET /dapi/v1/exchangeInfo`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/futures/en/#exchange-information
     https://binance-docs.github.io/apidocs/delivery/en/#exchange-information
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -65,14 +66,15 @@
 
     Parameters
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
     ):
@@ -88,9 +90,11 @@
 
         self._endpoint_futures_exchange_info = BinanceFuturesExchangeInfoHttp(
             client,
             self.base_endpoint,
         )
 
     async def query_futures_exchange_info(self) -> BinanceFuturesExchangeInfo:
-        """Retrieve Binance Futures exchange information."""
+        """
+        Retrieve Binance Futures exchange information.
+        """
         return await self._endpoint_futures_exchange_info._get()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/user.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/user.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,14 +25,15 @@
 
     Parameters
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
     ):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/wallet.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/http/wallet.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,14 +34,15 @@
     `GET /fapi/v1/commissionRate`
     `GET /dapi/v1/commissionRate`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/futures/en/#user-commission-rate-user_data
     https://binance-docs.github.io/apidocs/delivery/en/#user-commission-rate-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -63,14 +64,15 @@
         ----------
         symbol : BinanceSymbol
             Receive commission rate of the provided symbol.
         timestamp : str
             Millisecond timestamp of the request.
         recvWindow : str, optional
             The number of milliseconds after timestamp the request is valid.
+
         """
 
         timestamp: str
         symbol: BinanceSymbol
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> BinanceFuturesCommissionRate:
@@ -83,14 +85,15 @@
     """
     Provides access to the `Binance Futures` Wallet HTTP REST API.
 
     Parameters
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         clock: LiveClock,
         account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
@@ -110,23 +113,27 @@
 
         self._endpoint_futures_commission_rate = BinanceFuturesCommissionRateHttp(
             client,
             self.base_endpoint,
         )
 
     def _timestamp(self) -> str:
-        """Create Binance timestamp from internal clock."""
+        """
+        Create Binance timestamp from internal clock.
+        """
         return str(self._clock.timestamp_ms())
 
     async def query_futures_commission_rate(
         self,
         symbol: str,
         recv_window: Optional[str] = None,
     ) -> BinanceFuturesCommissionRate:
-        """Get Futures commission rates for a given symbol."""
+        """
+        Get Futures commission rates for a given symbol.
+        """
         rate = await self._endpoint_futures_commission_rate._get(
             parameters=self._endpoint_futures_commission_rate.GetParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 recvWindow=recv_window,
             ),
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/providers.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/providers.py`

 * *Files 11% similar despite different names*

```diff
@@ -22,20 +22,21 @@
 from nautilus_trader.adapters.binance.common.constants import BINANCE_VENUE
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceSymbolFilterType
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceSymbolFilter
 from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesContractStatus
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesContractType
+from nautilus_trader.adapters.binance.futures.http.account import BinanceFuturesAccountHttpAPI
 from nautilus_trader.adapters.binance.futures.http.market import BinanceFuturesMarketHttpAPI
 from nautilus_trader.adapters.binance.futures.http.wallet import BinanceFuturesWalletHttpAPI
+from nautilus_trader.adapters.binance.futures.schemas.account import BinanceFuturesFeeRates
 from nautilus_trader.adapters.binance.futures.schemas.market import BinanceFuturesSymbolInfo
 from nautilus_trader.adapters.binance.futures.schemas.wallet import BinanceFuturesCommissionRate
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
-from nautilus_trader.adapters.binance.http.error import BinanceClientError
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.config import InstrumentProviderConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.datetime import millis_to_nanos
 from nautilus_trader.model.identifiers import InstrumentId
@@ -59,14 +60,15 @@
     ----------
     client : APIClient
         The client for the provider.
     logger : Logger
         The logger for the provider.
     config : InstrumentProviderConfig, optional
         The configuration for the provider.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         logger: Logger,
         clock: LiveClock,
@@ -75,55 +77,68 @@
     ):
         super().__init__(
             venue=BINANCE_VENUE,
             logger=logger,
             config=config,
         )
 
+        self._clock = clock
         self._client = client
         self._account_type = account_type
-        self._clock = clock
 
+        self._http_account = BinanceFuturesAccountHttpAPI(
+            self._client,
+            clock=self._clock,
+            account_type=account_type,
+        )
         self._http_wallet = BinanceFuturesWalletHttpAPI(
             self._client,
             clock=self._clock,
             account_type=account_type,
         )
         self._http_market = BinanceFuturesMarketHttpAPI(self._client, account_type=account_type)
 
         self._log_warnings = config.log_warnings if config else True
 
         self._decoder = msgspec.json.Decoder()
         self._encoder = msgspec.json.Encoder()
 
+        # This fee rates map is only applicable for backtesting, as live trading will utilise
+        # real-time account update messages provided by Binance.
+        # These fee rates assume USD-M Futures Trading without the 10% off for using BNB or BUSD.
+        # The next step is to enable users to pass their own fee rates map via the config.
+        # In the future, we aim to represent this fee model with greater accuracy for backtesting.
+        self._fee_rates = {
+            0: BinanceFuturesFeeRates(feeTier=0, maker="0.0200", taker="0.0180"),
+            1: BinanceFuturesFeeRates(feeTier=1, maker="0.0160", taker="0.0144"),
+            2: BinanceFuturesFeeRates(feeTier=2, maker="0.0140", taker="0.0126"),
+            3: BinanceFuturesFeeRates(feeTier=3, maker="0.0120", taker="0.0108"),
+            4: BinanceFuturesFeeRates(feeTier=4, maker="0.0100", taker="0.0090"),
+            5: BinanceFuturesFeeRates(feeTier=5, maker="0.0080", taker="0.0072"),
+            6: BinanceFuturesFeeRates(feeTier=6, maker="0.0060", taker="0.0054"),
+            7: BinanceFuturesFeeRates(feeTier=7, maker="0.0040", taker="0.0036"),
+            8: BinanceFuturesFeeRates(feeTier=8, maker="0.0020", taker="0.0018"),
+            9: BinanceFuturesFeeRates(feeTier=9, maker="0.0000", taker="0.0000"),
+        }
+
     async def load_all_async(self, filters: Optional[dict] = None) -> None:
         filters_str = "..." if not filters else f" with filters {filters}..."
         self._log.info(f"Loading all instruments{filters_str}")
 
         # Get exchange info for all assets
         exchange_info = await self._http_market.query_futures_exchange_info()
+        account_info = await self._http_account.query_futures_account_info(recv_window=str(5000))
+        fee_rates = self._fee_rates[account_info.feeTier]
 
-        self._log.warning(
-            "Currently not requesting actual trade fees. All instruments will have zero fees.",
-        )
         for symbol_info in exchange_info.symbols:
-            fee: Optional[BinanceFuturesCommissionRate] = None
-            # TODO(cs): This won't work for 174 instruments, we'll have to pre-request these
-            #  in some other way.
-            # if not self._client.base_url.__contains__("testnet.binancefuture.com"):
-            #     try:
-            #         # Get current commission rates for the symbol
-            #         fee = await self._http_wallet.query_futures_commission_rate(symbol_info.symbol)
-            #         print(fee)
-            #     except BinanceClientError as e:
-            #         self._log.error(
-            #             "Cannot load instruments: API key authentication failed "
-            #             f"(this is needed to fetch the applicable account fee tier). {e.message}",
-            #         )
-            #         return
+            fee = BinanceFuturesCommissionRate(
+                symbol=symbol_info.symbol,
+                makerCommissionRate=fee_rates.maker,
+                takerCommissionRate=fee_rates.taker,
+            )
 
             self._parse_instrument(
                 symbol_info=symbol_info,
                 fee=fee,
                 ts_event=millis_to_nanos(exchange_info.serverTime),
             )
 
@@ -149,31 +164,23 @@
         ]
 
         # Get exchange info for all assets
         exchange_info = await self._http_market.query_futures_exchange_info()
         symbol_info_dict: dict[str, BinanceFuturesSymbolInfo] = {
             info.symbol: info for info in exchange_info.symbols
         }
+        account_info = await self._http_account.query_futures_account_info(recv_window=str(5000))
+        fee_rates = self._fee_rates[account_info.feeTier]
 
-        self._log.warning(
-            "Currently not requesting actual trade fees. All instruments will have zero fees.",
-        )
         for symbol in symbols:
-            fee: Optional[BinanceFuturesCommissionRate] = None
-            # TODO(cs): This won't work for 174 instruments, we'll have to pre-request these
-            #  in some other way.
-            # if not self._client.base_url.__contains__("testnet.binancefuture.com"):
-            #     try:
-            #         # Get current commission rates for the symbol
-            #         fee = await self._http_wallet.query_futures_commission_rate(symbol)
-            #     except BinanceClientError as e:
-            #         self._log.error(
-            #             "Cannot load instruments: API key authentication failed "
-            #             f"(this is needed to fetch the applicable account fee tier). {e.message}",
-            #         )
+            fee = BinanceFuturesCommissionRate(
+                symbol=symbol,
+                makerCommissionRate=fee_rates.maker,
+                takerCommissionRate=fee_rates.taker,
+            )
 
             self._parse_instrument(
                 symbol_info=symbol_info_dict[symbol],
                 fee=fee,
                 ts_event=millis_to_nanos(exchange_info.serverTime),
             )
 
@@ -188,24 +195,21 @@
 
         # Get exchange info for all assets
         exchange_info = await self._http_market.query_futures_exchange_info()
         symbol_info_dict: dict[str, BinanceFuturesSymbolInfo] = {
             info.symbol: info for info in exchange_info.symbols
         }
 
-        fee: Optional[BinanceFuturesCommissionRate] = None
-        if not self._client.base_url.__contains__("testnet.binancefuture.com"):
-            try:
-                # Get current commission rates for the symbol
-                fee = await self._http_wallet.query_futures_commission_rate(symbol)
-            except BinanceClientError as e:
-                self._log.error(
-                    "Cannot load instruments: API key authentication failed "
-                    f"(this is needed to fetch the applicable account fee tier). {e.message}",
-                )
+        account_info = await self._http_account.query_futures_account_info(recv_window=str(5000))
+        fee_rates = self._fee_rates[account_info.feeTier]
+        fee = BinanceFuturesCommissionRate(
+            symbol=symbol,
+            makerCommissionRate=fee_rates.maker,
+            takerCommissionRate=fee_rates.taker,
+        )
 
         self._parse_instrument(
             symbol_info=symbol_info_dict[symbol],
             ts_event=millis_to_nanos(exchange_info.serverTime),
             fee=fee,
         )
 
@@ -226,19 +230,20 @@
 
         ts_init = self._clock.timestamp_ns()
         try:
             # Create quote and base assets
             base_currency = symbol_info.parse_to_base_currency()
             quote_currency = symbol_info.parse_to_quote_currency()
 
-            binance_symbol = BinanceSymbol(symbol_info.symbol).parse_binance_to_internal(
+            raw_symbol = Symbol(symbol_info.symbol)
+            parsed_symbol = BinanceSymbol(raw_symbol.value).parse_as_nautilus(
                 self._account_type,
             )
-            native_symbol = Symbol(binance_symbol)
-            instrument_id = InstrumentId(symbol=native_symbol, venue=BINANCE_VENUE)
+            nautilus_symbol = Symbol(parsed_symbol)
+            instrument_id = InstrumentId(symbol=nautilus_symbol, venue=BINANCE_VENUE)
 
             # Parse instrument filters
             filters: dict[BinanceSymbolFilterType, BinanceSymbolFilter] = {
                 f.filterType: f for f in symbol_info.filters
             }
             price_filter: BinanceSymbolFilter = filters.get(BinanceSymbolFilterType.PRICE_FILTER)
             lot_size_filter: BinanceSymbolFilter = filters.get(BinanceSymbolFilterType.LOT_SIZE)
@@ -278,15 +283,15 @@
             else:
                 raise ValueError(f"Unrecognized margin asset {symbol_info.marginAsset}")
 
             contract_type = BinanceFuturesContractType(contract_type_str)
             if contract_type == BinanceFuturesContractType.PERPETUAL:
                 instrument = CryptoPerpetual(
                     instrument_id=instrument_id,
-                    native_symbol=native_symbol,
+                    raw_symbol=raw_symbol,
                     base_currency=base_currency,
                     quote_currency=quote_currency,
                     settlement_currency=settlement_currency,
                     is_inverse=False,  # No inverse instruments trade on Binance
                     price_precision=price_precision,
                     size_precision=size_precision,
                     price_increment=price_increment,
@@ -310,15 +315,15 @@
                 BinanceFuturesContractType.CURRENT_MONTH,
                 BinanceFuturesContractType.CURRENT_QUARTER,
                 BinanceFuturesContractType.NEXT_MONTH,
                 BinanceFuturesContractType.NEXT_QUARTER,
             ):
                 instrument = CryptoFuture(
                     instrument_id=instrument_id,
-                    native_symbol=native_symbol,
+                    raw_symbol=raw_symbol,
                     underlying=base_currency,
                     quote_currency=quote_currency,
                     settlement_currency=settlement_currency,
                     expiry_date=dt.strptime(symbol_info.symbol.partition("_")[2], "%y%m%d").date(),
                     price_precision=price_precision,
                     size_precision=size_precision,
                     price_increment=price_increment,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/account.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/account.py`

 * *Files 3% similar despite different names*

```diff
@@ -34,15 +34,16 @@
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceFuturesBalanceInfo(msgspec.Struct, frozen=True):
     """
-    HTTP response 'inner struct' from `Binance Futures` GET /fapi/v2/account (HMAC SHA256).
+    HTTP response 'inner struct' from `Binance Futures` GET /fapi/v2/account (HMAC
+    SHA256).
     """
 
     asset: str  # asset name
     walletBalance: str  # wallet balance
     unrealizedProfit: str  # unrealized profit
     marginBalance: str  # margin balance
     maintMargin: str  # maintenance margin required
@@ -134,18 +135,17 @@
         self,
         account_id: AccountId,
         instrument_id: InstrumentId,
         enum_parser: BinanceFuturesEnumParser,
         report_id: UUID4,
         ts_init: int,
     ) -> PositionStatusReport:
-        position_side = enum_parser.parse_futures_position_side(
-            self.positionSide,
-        )
         net_size = Decimal(self.positionAmt)
+        position_side = enum_parser.parse_futures_position_side(net_size)
+
         return PositionStatusReport(
             account_id=account_id,
             instrument_id=instrument_id,
             position_side=position_side,
             quantity=Quantity.from_str(str(abs(net_size))),
             report_id=report_id,
             ts_last=ts_init,
@@ -155,7 +155,20 @@
 
 class BinanceFuturesDualSidePosition(msgspec.Struct, frozen=True):
     """
     HTTP response from `Binance Futures` GET /fapi/v1/positionSide/dual (HMAC SHA256).
     """
 
     dualSidePosition: bool
+
+
+class BinanceFuturesFeeRates(msgspec.Struct, frozen=True):
+    """
+    Represents a `BinanceFutures` fee tier.
+
+    https://www.binance.com/en/fee/futureFee
+
+    """
+
+    feeTier: int
+    maker: str
+    taker: str
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/market.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/market.py`

 * *Files 4% similar despite different names*

```diff
@@ -38,23 +38,27 @@
 
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceFuturesAsset(msgspec.Struct, frozen=True):
-    """HTTP response 'inner struct' from `Binance Futures` GET /fapi/v1/exchangeInfo."""
+    """
+    HTTP response 'inner struct' from `Binance Futures` GET /fapi/v1/exchangeInfo.
+    """
 
     asset: str
     marginAvailable: bool
     autoAssetExchange: str
 
 
 class BinanceFuturesSymbolInfo(msgspec.Struct, kw_only=True, frozen=True):
-    """HTTP response 'inner struct' from `Binance Futures` GET /fapi/v1/exchangeInfo."""
+    """
+    HTTP response 'inner struct' from `Binance Futures` GET /fapi/v1/exchangeInfo.
+    """
 
     symbol: str
     pair: str
     contractType: str  # Can be '' empty string
     deliveryDate: int
     onboardDate: int
     status: Optional[BinanceFuturesContractStatus] = None
@@ -93,39 +97,45 @@
             iso4217=0,  # Currently undetermined for crypto assets
             name=self.quoteAsset,
             currency_type=CurrencyType.CRYPTO,
         )
 
 
 class BinanceFuturesExchangeInfo(msgspec.Struct, kw_only=True, frozen=True):
-    """HTTP response from `Binance Futures` GET /fapi/v1/exchangeInfo."""
+    """
+    HTTP response from `Binance Futures` GET /fapi/v1/exchangeInfo.
+    """
 
     timezone: str
     serverTime: int
     rateLimits: list[BinanceRateLimit]
     exchangeFilters: list[BinanceExchangeFilter]
     assets: Optional[list[BinanceFuturesAsset]] = None
     symbols: list[BinanceFuturesSymbolInfo]
 
 
 class BinanceFuturesMarkFunding(msgspec.Struct, frozen=True):
-    """HTTP response from `Binance Future` GET /fapi/v1/premiumIndex."""
+    """
+    HTTP response from `Binance Future` GET /fapi/v1/premiumIndex.
+    """
 
     symbol: str
     markPrice: str  # Mark price
     indexPrice: str  # Index price
     estimatedSettlePrice: str  # Estimated Settle Price (only useful in the last hour before the settlement starts)
     lastFundingRate: str  # This is the lasted funding rate
     nextFundingTime: int
     interestRate: str
     time: int
 
 
 class BinanceFuturesFundRate(msgspec.Struct, frozen=True):
-    """HTTP response from `Binance Future` GET /fapi/v1/fundingRate."""
+    """
+    HTTP response from `Binance Future` GET /fapi/v1/fundingRate.
+    """
 
     symbol: str
     fundingRate: str
     fundingTime: str
 
 
 ################################################################################
@@ -145,14 +155,15 @@
     - t: Trade ID
     - p: Price
     - q: Quantity
     - b: Buyer order ID
     - a: Seller order ID
     - T: Trade time
     - m: Is the buyer the market maker?
+
     """
 
     e: str  # Event type
     E: int  # Event time
     T: int  # Trade time
     s: str  # Symbol
     t: int  # Trade ID
@@ -174,22 +185,26 @@
             trade_id=TradeId(str(self.t)),
             ts_event=millis_to_nanos(self.T),
             ts_init=ts_init,
         )
 
 
 class BinanceFuturesTradeMsg(msgspec.Struct, frozen=True):
-    """WebSocket message from `Binance Futures` Trade Streams."""
+    """
+    WebSocket message from `Binance Futures` Trade Streams.
+    """
 
     stream: str
     data: BinanceFuturesTradeData
 
 
 class BinanceFuturesMarkPriceData(msgspec.Struct, frozen=True):
-    """WebSocket message 'inner struct' for `Binance Futures` Mark Price Update events."""
+    """
+    WebSocket message 'inner struct' for `Binance Futures` Mark Price Update events.
+    """
 
     e: str  # Event type
     E: int  # Event time
     s: str  # Symbol
     p: str  # Mark price
     i: str  # Index price
     P: str  # Estimated Settle Price, only useful in the last hour before the settlement starts
@@ -210,11 +225,13 @@
             ts_next_funding=millis_to_nanos(self.T),
             ts_event=millis_to_nanos(self.E),
             ts_init=ts_init,
         )
 
 
 class BinanceFuturesMarkPriceMsg(msgspec.Struct, frozen=True):
-    """WebSocket message from `Binance Futures` Mark Price Update events."""
+    """
+    WebSocket message from `Binance Futures` Mark Price Update events.
+    """
 
     stream: str
     data: BinanceFuturesMarkPriceData
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/user.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/user.py`

 * *Files 7% similar despite different names*

```diff
@@ -51,50 +51,60 @@
 
 ################################################################################
 # WebSocket messages
 ################################################################################
 
 
 class BinanceFuturesUserMsgData(msgspec.Struct, frozen=True):
-    """Inner struct for execution WebSocket messages from `Binance`."""
+    """
+    Inner struct for execution WebSocket messages from `Binance`.
+    """
 
     e: BinanceFuturesEventType
 
 
 class BinanceFuturesUserMsgWrapper(msgspec.Struct, frozen=True):
-    """Provides a wrapper for execution WebSocket messages from `Binance`."""
+    """
+    Provides a wrapper for execution WebSocket messages from `Binance`.
+    """
 
     stream: str
     data: BinanceFuturesUserMsgData
 
 
 class MarginCallPosition(msgspec.Struct, frozen=True):
-    """Inner struct position for `Binance Futures` Margin Call events."""
+    """
+    Inner struct position for `Binance Futures` Margin Call events.
+    """
 
     s: str  # Symbol
     ps: BinanceFuturesPositionSide  # Position Side
     pa: str  # Position  Amount
     mt: str  # Margin Type
     iw: str  # Isolated Wallet(if isolated position)
     mp: str  # MarkPrice
     up: str  # Unrealized PnL
     mm: str  # Maintenance Margin Required
 
 
 class BinanceFuturesMarginCallMsg(msgspec.Struct, frozen=True):
-    """WebSocket message for `Binance Futures` Margin Call events."""
+    """
+    WebSocket message for `Binance Futures` Margin Call events.
+    """
 
     e: str  # Event Type
     E: int  # Event Time
     cw: float  # Cross Wallet Balance. Only pushed with crossed position margin call
     p: list[MarginCallPosition]
 
 
 class BinanceFuturesBalance(msgspec.Struct, frozen=True):
-    """Inner struct balance for `Binance Futures` Balance and Position update event."""
+    """
+    Inner struct balance for `Binance Futures` Balance and Position update event.
+    """
 
     a: str  # Asset
     wb: str  # Wallet Balance
     cw: str  # Cross Wallet Balance
     bc: str  # Balance Change except PnL and Commission
 
     def parse_to_account_balance(self) -> AccountBalance:
@@ -107,69 +117,80 @@
             total=Money(total, currency),
             locked=Money(locked, currency),
             free=Money(free, currency),
         )
 
 
 class BinanceFuturesPosition(msgspec.Struct, frozen=True):
-    """Inner struct position for `Binance Futures` Balance and Position update event."""
+    """
+    Inner struct position for `Binance Futures` Balance and Position update event.
+    """
 
     s: str  # Symbol
     pa: str  # Position amount
     ep: str  # Entry price
     cr: str  # (Pre-free) Accumulated Realized
     up: str  # Unrealized PnL
     mt: str  # Margin type
     iw: str  # Isolated wallet
     ps: BinanceFuturesPositionSide
 
 
 class BinanceFuturesAccountUpdateData(msgspec.Struct, frozen=True):
-    """WebSocket message for `Binance Futures` Balance and Position Update events."""
+    """
+    WebSocket message for `Binance Futures` Balance and Position Update events.
+    """
 
     m: BinanceFuturesPositionUpdateReason
     B: list[BinanceFuturesBalance]
     P: list[BinanceFuturesPosition]
 
     def parse_to_account_balances(self) -> list[AccountBalance]:
         return [balance.parse_to_account_balance() for balance in self.B]
 
 
 class BinanceFuturesAccountUpdateMsg(msgspec.Struct, frozen=True):
-    """WebSocket message for `Binance Futures` Balance and Position Update events."""
+    """
+    WebSocket message for `Binance Futures` Balance and Position Update events.
+    """
 
     e: str  # Event Type
     E: int  # Event Time
     T: int  # Transaction Time
     a: BinanceFuturesAccountUpdateData
 
     def handle_account_update(self, exec_client: BinanceCommonExecutionClient):
-        """Handle BinanceFuturesAccountUpdateMsg as payload of ACCOUNT_UPDATE."""
+        """
+        Handle BinanceFuturesAccountUpdateMsg as payload of ACCOUNT_UPDATE.
+        """
         exec_client.generate_account_state(
             balances=self.a.parse_to_account_balances(),
             margins=[],
             reported=True,
             ts_event=millis_to_nanos(self.T),
         )
 
 
 class BinanceFuturesAccountUpdateWrapper(msgspec.Struct, frozen=True):
-    """WebSocket message wrapper for `Binance Futures` Balance and Position Update events."""
+    """
+    WebSocket message wrapper for `Binance Futures` Balance and Position Update events.
+    """
 
     stream: str
     data: BinanceFuturesAccountUpdateMsg
 
 
 class BinanceFuturesOrderData(msgspec.Struct, kw_only=True, frozen=True):
     """
     WebSocket message 'inner struct' for `Binance Futures` Order Update events.
 
     Client Order ID 'c':
      - starts with "autoclose-": liquidation order/
      - starts with "adl_autoclose": ADL auto close order/
+
     """
 
     s: str  # Symbol
     c: str  # Client Order ID
     S: BinanceOrderSide
     o: BinanceOrderType
     f: BinanceTimeInForce
@@ -239,19 +260,21 @@
             reduce_only=self.R,
             report_id=UUID4(),
             ts_accepted=ts_event,
             ts_last=ts_event,
             ts_init=ts_init,
         )
 
-    def handle_order_trade_update(
+    def handle_order_trade_update(  # noqa: C901 (too complex)
         self,
         exec_client: BinanceCommonExecutionClient,
-    ):
-        """Handle BinanceFuturesOrderData as payload of ORDER_TRADE_UPDATE event."""
+    ) -> None:
+        """
+        Handle BinanceFuturesOrderData as payload of ORDER_TRADE_UPDATE event.
+        """
         client_order_id = ClientOrderId(self.c) if self.c != "" else None
         ts_event = millis_to_nanos(self.T)
         venue_order_id = VenueOrderId(str(self.i))
         instrument_id = exec_client._get_cached_instrument_id(self.s)
         strategy_id = exec_client._cache.strategy_id_for_order(client_order_id)
         if strategy_id is None:
             report = self.parse_to_order_status_report(
@@ -270,69 +293,95 @@
                 instrument_id=instrument_id,
                 client_order_id=client_order_id,
                 venue_order_id=venue_order_id,
                 ts_event=ts_event,
             )
         elif self.x == BinanceExecutionType.TRADE:
             instrument = exec_client._instrument_provider.find(instrument_id=instrument_id)
-            assert instrument is not None
+            if instrument is None:
+                raise ValueError(f"Cannot handle trade: instrument {instrument_id} not found")
 
             # Determine commission
             commission_asset: Optional[str] = self.N
             commission_amount: Optional[str] = self.n
             if commission_asset is not None:
                 commission = Money.from_str(f"{commission_amount} {commission_asset}")
             else:
                 # Commission in margin collateral currency
                 commission = Money(0, instrument.quote_currency)
 
+            venue_position_id: Optional[PositionId] = None
+            if exec_client.use_position_ids:
+                venue_position_id = PositionId(f"{instrument_id}-{self.ps.value}")
+
             exec_client.generate_order_filled(
                 strategy_id=strategy_id,
                 instrument_id=instrument_id,
                 client_order_id=client_order_id,
                 venue_order_id=venue_order_id,
-                venue_position_id=PositionId(f"{instrument_id}-{self.ps.value}"),
+                venue_position_id=venue_position_id,
                 trade_id=TradeId(str(self.t)),  # Trade ID
                 order_side=exec_client._enum_parser.parse_binance_order_side(self.S),
                 order_type=exec_client._enum_parser.parse_binance_order_type(self.o),
-                last_qty=Quantity.from_str(self.l),
-                last_px=Price.from_str(self.L),
+                last_qty=Quantity(float(self.l), instrument.size_precision),
+                last_px=Price(float(self.L), instrument.price_precision),
                 quote_currency=instrument.quote_currency,
                 commission=commission,
                 liquidity_side=LiquiditySide.MAKER if self.m else LiquiditySide.TAKER,
                 ts_event=ts_event,
             )
-        elif self.x == BinanceExecutionType.CANCELED:
+        elif self.x == BinanceExecutionType.CANCELED or (
+            exec_client.treat_expired_as_canceled and self.x == BinanceExecutionType.EXPIRED
+        ):
             exec_client.generate_order_canceled(
                 strategy_id=strategy_id,
                 instrument_id=instrument_id,
                 client_order_id=client_order_id,
                 venue_order_id=venue_order_id,
                 ts_event=ts_event,
             )
+        elif self.x == BinanceExecutionType.AMENDMENT:
+            instrument = exec_client._instrument_provider.find(instrument_id=instrument_id)
+            if instrument is None:
+                raise ValueError(f"Cannot handle amendment: instrument {instrument_id} not found")
+
+            exec_client.generate_order_updated(
+                strategy_id=strategy_id,
+                instrument_id=instrument_id,
+                client_order_id=client_order_id,
+                venue_order_id=venue_order_id,
+                quantity=Quantity(float(self.q), instrument.size_precision),
+                price=Price(float(self.p), instrument.price_precision),
+                trigger_price=None,
+                ts_event=ts_event,
+            )
         elif self.x == BinanceExecutionType.EXPIRED:
             exec_client.generate_order_expired(
                 strategy_id=strategy_id,
                 instrument_id=instrument_id,
                 client_order_id=client_order_id,
                 venue_order_id=venue_order_id,
                 ts_event=ts_event,
             )
         else:
             # Event not handled
             exec_client._log.warning(f"Received unhandled {self}")
 
 
 class BinanceFuturesOrderUpdateMsg(msgspec.Struct, frozen=True):
-    """WebSocket message for `Binance Futures` Order Update events."""
+    """
+    WebSocket message for `Binance Futures` Order Update events.
+    """
 
     e: str  # Event Type
     E: int  # Event Time
     T: int  # Transaction Time
     o: BinanceFuturesOrderData
 
 
 class BinanceFuturesOrderUpdateWrapper(msgspec.Struct, frozen=True):
-    """WebSocket message wrapper for `Binance Futures` Order Update events."""
+    """
+    WebSocket message wrapper for `Binance Futures` Order Update events.
+    """
 
     stream: str
     data: BinanceFuturesOrderUpdateMsg
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,12 +18,14 @@
 
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceFuturesCommissionRate(msgspec.Struct, frozen=True):
-    """Schema of a single `Binance Futures` commissionRate."""
+    """
+    Schema of a single `Binance Futures` commissionRate.
+    """
 
     symbol: str
     makerCommissionRate: str
     takerCommissionRate: str
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/types.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/futures/types.py`

 * *Files 1% similar despite different names*

```diff
@@ -44,14 +44,15 @@
         The UNIX timestamp (nanoseconds) when the data event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
 
     References
     ----------
     https://binance-docs.github.io/apidocs/futures/en/#mark-price-stream
+
     """
 
     def __init__(
         self,
         instrument_id: InstrumentId,
         mark: Price,
         index: Price,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/account.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/account.py`

 * *Files 2% similar despite different names*

```diff
@@ -46,62 +46,77 @@
     `POST /fapi/v1/order`
     `POST /dapi/v1/order`
 
     `DELETE /api/v3/order`
     `DELETE /fapi/v1/order`
     `DELETE /dapi/v1/order`
 
+    `PUT /fapi/v1/order`
+    `PUT /dapi/v1/order`
+
+    Notes
+    -----
+    `PUT` method is not available for Spot/Margin.
+
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#new-order-trade
     https://binance-docs.github.io/apidocs/futures/en/#new-order-trade
     https://binance-docs.github.io/apidocs/delivery/en/#new-order-trade
+    https://binance-docs.github.io/apidocs/futures/en/#modify-order-trade
+    https://binance-docs.github.io/apidocs/delivery/en/#modify-order-trade
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
         testing_endpoint: Optional[bool] = False,
     ):
         methods = {
             BinanceMethodType.GET: BinanceSecurityType.USER_DATA,
             BinanceMethodType.POST: BinanceSecurityType.TRADE,
             BinanceMethodType.DELETE: BinanceSecurityType.TRADE,
+            BinanceMethodType.PUT: BinanceSecurityType.TRADE,
         }
         url_path = base_endpoint + "order"
+
         if testing_endpoint:
             url_path = url_path + "/test"
+
         super().__init__(
             client,
             methods,
             url_path,
         )
+
         self._resp_decoder = msgspec.json.Decoder(BinanceOrder)
 
     class GetDeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
-        Order management GET & DELETE endpoint parameters
+        Order management GET & DELETE endpoint parameters.
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The symbol of the order
         timestamp : str
             The millisecond timestamp of the request
         orderId : int, optional
-            the order identifier
+            The order identifier.
         origClientOrderId : str, optional
-            the client specified order identifier
+            The client specified order identifier.
         recvWindow : str, optional
-            the millisecond timeout window.
+            The millisecond timeout window.
 
         Warnings
         --------
         Either orderId or origClientOrderId must be sent.
+
         """
 
         symbol: BinanceSymbol
         timestamp: str
         orderId: Optional[int] = None
         origClientOrderId: Optional[str] = None
         recvWindow: Optional[str] = None
@@ -184,14 +199,15 @@
             The response type for the order request.
             SPOT/MARGIN MARKET, LIMIT orders default to FULL.
             All others default to ACK.
             FULL response only for SPOT/MARGIN orders.
         recvWindow : str, optional
             The response receive window in milliseconds for the request.
             Cannot exceed 60000.
+
         """
 
         symbol: BinanceSymbol
         timestamp: str
         side: BinanceOrderSide
         type: BinanceOrderType
         timeInForce: Optional[BinanceTimeInForce] = None
@@ -209,14 +225,49 @@
         activationPrice: Optional[str] = None
         callbackRate: Optional[str] = None
         workingType: Optional[str] = None
         priceProtect: Optional[str] = None
         newOrderRespType: Optional[BinanceNewOrderRespType] = None
         recvWindow: Optional[str] = None
 
+    class PutParameters(msgspec.Struct, omit_defaults=True, frozen=True):
+        """
+        Order amendment PUT endpoint parameters.
+
+        Parameters
+        ----------
+        orderId : int, optional
+            The order ID for the request.
+        origClientOrderId : str, optional
+            The client specified order identifier.
+        symbol : BinanceSymbol
+            The symbol of the order.
+        side : BinanceOrderSide
+            The market side of the order (BUY, SELL).
+        quantity : str, optional
+            The order quantity in base asset units for the request.
+        price : str, optional
+            The order price for the request.
+        recvWindow : str, optional
+            The response receive window in milliseconds for the request.
+            Cannot exceed 60000.
+        timestamp : str
+            The millisecond timestamp of the request.
+
+        """
+
+        symbol: BinanceSymbol
+        side: BinanceOrderSide
+        quantity: str
+        price: str
+        timestamp: str
+        orderId: Optional[int] = None
+        origClientOrderId: Optional[str] = None
+        recvWindow: Optional[str] = None
+
     async def _get(self, parameters: GetDeleteParameters) -> BinanceOrder:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._resp_decoder.decode(raw)
 
     async def _delete(self, parameters: GetDeleteParameters) -> BinanceOrder:
         method_type = BinanceMethodType.DELETE
@@ -224,28 +275,34 @@
         return self._resp_decoder.decode(raw)
 
     async def _post(self, parameters: PostParameters) -> BinanceOrder:
         method_type = BinanceMethodType.POST
         raw = await self._method(method_type, parameters)
         return self._resp_decoder.decode(raw)
 
+    async def _put(self, parameters: PutParameters) -> BinanceOrder:
+        method_type = BinanceMethodType.PUT
+        raw = await self._method(method_type, parameters)
+        return self._resp_decoder.decode(raw)
+
 
 class BinanceAllOrdersHttp(BinanceHttpEndpoint):
     """
     Endpoint of all account orders, active, cancelled or filled.
 
     `GET /api/v3/allOrders`
     `GET /fapi/v1/allOrders`
     `GET /dapi/v1/allOrders`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#all-orders-user_data
     https://binance-docs.github.io/apidocs/futures/en/#all-orders-user_data
     https://binance-docs.github.io/apidocs/delivery/en/#all-orders-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -278,14 +335,15 @@
         endTime : int, optional
             The end time (UNIX milliseconds) filter for the request.
         limit : int, optional
             The limit for the response.
             Default 500, max 1000
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         symbol: BinanceSymbol
         timestamp: str
         orderId: Optional[int] = None
         startTime: Optional[int] = None
         endTime: Optional[int] = None
@@ -312,14 +370,15 @@
     The weight usage can be very large, which may cause rate limits to be hit.
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#current-open-orders-user_data
     https://binance-docs.github.io/apidocs/futures/en/#current-all-open-orders-user_data
     https://binance-docs.github.io/apidocs/futures/en/#current-all-open-orders-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
         methods: Optional[dict[BinanceMethodType, BinanceSecurityType]] = None,
@@ -344,14 +403,15 @@
         ----------
         timestamp : str
             The millisecond timestamp of the request
         symbol : BinanceSymbol, optional
             The symbol of the orders
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         symbol: Optional[BinanceSymbol] = None
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceOrder]:
@@ -369,14 +429,15 @@
     `GET /dapi/v1/userTrades`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#account-trade-list-user_data
     https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
     https://binance-docs.github.io/apidocs/delivery/en/#account-trade-list-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         url_path: str,
     ):
@@ -410,14 +471,15 @@
         fromId : int, optional
             TradeId to fetch from. Default gets most recent trades.
         limit : int, optional
             The limit for the response.
             Default 500, max 1000
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         symbol: BinanceSymbol
         timestamp: str
         orderId: Optional[int] = None
         startTime: Optional[int] = None
         endTime: Optional[int] = None
@@ -441,14 +503,15 @@
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint prefix
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         clock: LiveClock,
         account_type: BinanceAccountType,
@@ -474,25 +537,29 @@
         # Create endpoints
         self._endpoint_order = BinanceOrderHttp(client, self.base_endpoint)
         self._endpoint_all_orders = BinanceAllOrdersHttp(client, self.base_endpoint)
         self._endpoint_open_orders = BinanceOpenOrdersHttp(client, self.base_endpoint)
         self._endpoint_user_trades = BinanceUserTradesHttp(client, user_trades_url)
 
     def _timestamp(self) -> str:
-        """Create Binance timestamp from internal clock."""
+        """
+        Create Binance timestamp from internal clock.
+        """
         return str(self._clock.timestamp_ms())
 
     async def query_order(
         self,
         symbol: str,
         order_id: Optional[int] = None,
         orig_client_order_id: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceOrder:
-        """Check an order status."""
+        """
+        Check an order status.
+        """
         if order_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderId or origClientOrderId must be sent.",
             )
         binance_order = await self._endpoint_order._get(
             parameters=self._endpoint_order.GetDeleteParameters(
                 symbol=BinanceSymbol(symbol),
@@ -515,15 +582,17 @@
     async def cancel_order(
         self,
         symbol: str,
         order_id: Optional[int] = None,
         orig_client_order_id: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceOrder:
-        """Cancel an active order."""
+        """
+        Cancel an active order.
+        """
         if order_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderId or origClientOrderId must be sent.",
             )
         binance_order = await self._endpoint_order._delete(
             parameters=self._endpoint_order.GetDeleteParameters(
                 symbol=BinanceSymbol(symbol),
@@ -555,15 +624,17 @@
         activation_price: Optional[str] = None,
         callback_rate: Optional[str] = None,
         working_type: Optional[str] = None,
         price_protect: Optional[str] = None,
         new_order_resp_type: Optional[BinanceNewOrderRespType] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceOrder:
-        """Send in a new order to Binance."""
+        """
+        Send in a new order to Binance.
+        """
         binance_order = await self._endpoint_order._post(
             parameters=self._endpoint_order.PostParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 side=side,
                 type=order_type,
                 timeInForce=time_in_force,
@@ -584,24 +655,53 @@
                 priceProtect=price_protect,
                 newOrderRespType=new_order_resp_type,
                 recvWindow=recv_window,
             ),
         )
         return binance_order
 
+    async def modify_order(
+        self,
+        symbol: str,
+        side: BinanceOrderSide,
+        quantity: str,
+        price: str,
+        order_id: Optional[int] = None,
+        orig_client_order_id: Optional[str] = None,
+        recv_window: Optional[str] = None,
+    ) -> BinanceOrder:
+        """
+        Modify a LIMIT order with Binance.
+        """
+        binance_order = await self._endpoint_order._put(
+            parameters=self._endpoint_order.PutParameters(
+                symbol=BinanceSymbol(symbol),
+                timestamp=self._timestamp(),
+                orderId=order_id,
+                origClientOrderId=orig_client_order_id,
+                side=side,
+                quantity=quantity,
+                price=price,
+                recvWindow=recv_window,
+            ),
+        )
+        return binance_order
+
     async def query_all_orders(
         self,
         symbol: str,
         order_id: Optional[int] = None,
         start_time: Optional[int] = None,
         end_time: Optional[int] = None,
         limit: Optional[int] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceOrder]:
-        """Query all orders, active or filled."""
+        """
+        Query all orders, active or filled.
+        """
         return await self._endpoint_all_orders._get(
             parameters=self._endpoint_all_orders.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 orderId=order_id,
                 startTime=start_time,
                 endTime=end_time,
@@ -611,15 +711,17 @@
         )
 
     async def query_open_orders(
         self,
         symbol: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceOrder]:
-        """Query open orders."""
+        """
+        Query open orders.
+        """
         return await self._endpoint_open_orders._get(
             parameters=self._endpoint_open_orders.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
@@ -630,15 +732,17 @@
         order_id: Optional[int] = None,
         start_time: Optional[int] = None,
         end_time: Optional[int] = None,
         from_id: Optional[int] = None,
         limit: Optional[int] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceUserTrade]:
-        """Query user's trade history for a symbol, with provided filters."""
+        """
+        Query user's trade history for a symbol, with provided filters.
+        """
         if (order_id or from_id) is not None and (start_time or end_time) is not None:
             raise RuntimeError(
                 "Cannot specify both order_id/from_id AND start_time/end_time parameters.",
             )
         return await self._endpoint_user_trades._get(
             parameters=self._endpoint_user_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/client.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/client.py`

 * *Files 2% similar despite different names*

```diff
@@ -41,14 +41,15 @@
     logger : Logger
         The logger for the client.
     key : str
         The Binance API key for requests.
     secret : str
         The Binance API secret for signed requests.
     base_url : str, optional
+
     """
 
     def __init__(
         self,
         clock: LiveClock,
         logger: Logger,
         key: str,
@@ -145,18 +146,18 @@
             headers=self._headers,
             body=msgspec.json.encode(payload) if payload else None,
         )
 
         if 400 <= response.status < 500:
             raise BinanceClientError(
                 status=response.status,
-                message=response.body.decode(),
+                message=msgspec.json.decode(response.body) if response.body else None,
                 headers=response.headers,
             )
         elif response.status >= 500:
             raise BinanceServerError(
                 status=response.status,
-                message=response.body.decode(),
+                message=msgspec.json.decode(response.body) if response.body else None,
                 headers=response.headers,
             )
 
         return response.body
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/endpoint.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/endpoint.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,14 +36,15 @@
 class BinanceHttpEndpoint:
     """
     Base functionality of endpoints connecting to the Binance REST API.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         methods_desc: dict[BinanceMethodType, BinanceSecurityType],
         url_path: str,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/error.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/error.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,28 +11,34 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 
 class BinanceError(Exception):
-    """The base class for all `Binance` specific errors."""
+    """
+    The base class for all `Binance` specific errors.
+    """
 
     def __init__(self, status, message, headers):
         super().__init__(message)
         self.status = status
         self.message = message
         self.headers = headers
 
 
 class BinanceServerError(BinanceError):
-    """Represents an `Binance` specific 500 series HTTP error."""
+    """
+    Represents an `Binance` specific 500 series HTTP error.
+    """
 
     def __init__(self, status, message, headers):
         super().__init__(status, message, headers)
 
 
 class BinanceClientError(BinanceError):
-    """Represents an `Binance` specific 400 series HTTP error."""
+    """
+    Represents an `Binance` specific 400 series HTTP error.
+    """
 
     def __init__(self, status, message, headers):
         super().__init__(status, message, headers)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/market.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/market.py`

 * *Files 2% similar despite different names*

```diff
@@ -51,14 +51,15 @@
     `GET /dapi/v1/ping`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#test-connectivity
     https://binance-docs.github.io/apidocs/futures/en/#test-connectivity
     https://binance-docs.github.io/apidocs/delivery/en/#test-connectivity
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -88,14 +89,15 @@
     `GET /dapi/v1/time`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#check-server-time
     https://binance-docs.github.io/apidocs/futures/en/#check-server-time
     https://binance-docs.github.io/apidocs/delivery/en/#check-server-time
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -121,14 +123,15 @@
     `GET /dapi/v1/depth`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#order-book
     https://binance-docs.github.io/apidocs/futures/en/#order-book
     https://binance-docs.github.io/apidocs/delivery/en/#order-book
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -154,14 +157,15 @@
         limit : int, optional, default 100
             The limit for the response.
             SPOT/MARGIN (GET /api/v3/depth)
                 Default 100; max 5000.
             FUTURES (GET /*api/v1/depth)
                 Default 500; max 1000.
                 Valid limits:[5, 10, 20, 50, 100, 500, 1000].
+
         """
 
         symbol: BinanceSymbol
         limit: Optional[int] = None
 
     async def _get(self, parameters: GetParameters) -> BinanceDepth:
         method_type = BinanceMethodType.GET
@@ -178,14 +182,15 @@
     `GET /dapi/v1/trades`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#recent-trades-list
     https://binance-docs.github.io/apidocs/futures/en/#recent-trades-list
     https://binance-docs.github.io/apidocs/delivery/en/#recent-trades-list
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -198,46 +203,48 @@
             methods,
             url_path,
         )
         self._get_resp_decoder = msgspec.json.Decoder(list[BinanceTrade])
 
     class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
-        GET parameters for recent trades
+        GET parameters for recent trades.
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The trading pair.
         limit : int, optional
             The limit for the response. Default 500; max 1000.
+
         """
 
         symbol: BinanceSymbol
         limit: Optional[int] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceTrade]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceHistoricalTradesHttp(BinanceHttpEndpoint):
     """
-    Endpoint of older market historical trades
+    Endpoint of older market historical trades.
 
     `GET /api/v3/historicalTrades`
     `GET /fapi/v1/historicalTrades`
     `GET /dapi/v1/historicalTrades`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#old-trade-lookup-market_data
     https://binance-docs.github.io/apidocs/futures/en/#old-trades-lookup-market_data
     https://binance-docs.github.io/apidocs/delivery/en/#old-trades-lookup-market_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -250,51 +257,52 @@
             methods,
             url_path,
         )
         self._get_resp_decoder = msgspec.json.Decoder(list[BinanceTrade])
 
     class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
-        GET parameters for historical trades
+        GET parameters for historical trades.
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The trading pair.
         limit : int, optional
             The limit for the response. Default 500; max 1000.
         fromId : int, optional
             Trade id to fetch from. Default gets most recent trades
+
         """
 
         symbol: BinanceSymbol
         limit: Optional[int] = None
         fromId: Optional[int] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceTrade]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceAggTradesHttp(BinanceHttpEndpoint):
     """
-    Endpoint of compressed and aggregated market trades.
-    Market trades that fill in 100ms with the same price and same taking side
-    will have the quantity aggregated.
+    Endpoint of compressed and aggregated market trades. Market trades that fill in
+    100ms with the same price and same taking side will have the quantity aggregated.
 
     `GET /api/v3/aggTrades`
     `GET /fapi/v1/aggTrades`
     `GET /dapi/v1/aggTrades`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#compressed-aggregate-trades-list
     https://binance-docs.github.io/apidocs/futures/en/#compressed-aggregate-trades-list
     https://binance-docs.github.io/apidocs/delivery/en/#compressed-aggregate-trades-list
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -321,14 +329,15 @@
             The limit for the response. Default 500; max 1000.
         fromId : int, optional
             Trade id to fetch from INCLUSIVE.
         startTime : int, optional
             Timestamp in ms to get aggregate trades from INCLUSIVE.
         endTime : int, optional
             Timestamp in ms to get aggregate trades until INCLUSIVE.
+
         """
 
         symbol: BinanceSymbol
         limit: Optional[int] = None
         fromId: Optional[int] = None
         startTime: Optional[int] = None
         endTime: Optional[int] = None
@@ -337,26 +346,27 @@
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
 
 
 class BinanceKlinesHttp(BinanceHttpEndpoint):
     """
-    Endpoint of Kline/candlestick bars for a symbol.
-    Klines are uniquely identified by their open time.
+    Endpoint of Kline/candlestick bars for a symbol. Klines are uniquely identified by
+    their open time.
 
     `GET /api/v3/klines`
     `GET /fapi/v1/klines`
     `GET /dapi/v1/klines`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#kline-candlestick-data
     https://binance-docs.github.io/apidocs/futures/en/#kline-candlestick-data
     https://binance-docs.github.io/apidocs/delivery/en/#kline-candlestick-data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -383,14 +393,15 @@
             The interval of kline, e.g 1m, 5m, 1h, 1d, etc.
         limit : int, optional
             The limit for the response. Default 500; max 1000.
         startTime : int, optional
             Timestamp in ms to get klines from INCLUSIVE.
         endTime : int, optional
             Timestamp in ms to get klines until INCLUSIVE.
+
         """
 
         symbol: BinanceSymbol
         interval: BinanceKlineInterval
         limit: Optional[int] = None
         startTime: Optional[int] = None
         endTime: Optional[int] = None
@@ -415,14 +426,15 @@
     The weight usage can be very large, which may cause rate limits to be hit.
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics
     https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics
     https://binance-docs.github.io/apidocs/delivery/en/#24hr-ticker-price-change-statistics
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -449,14 +461,15 @@
             When omitted, endpoint will return a list of BinanceTicker24hr for all trading pairs.
         symbols : BinanceSymbols
             SPOT/MARGIN only!
             List of trading pairs. When given, endpoint will return a list of BinanceTicker24hr.
         type : str
             SPOT/MARGIN only!
             Select between FULL and MINI 24hr ticker responses to save bandwidth.
+
         """
 
         symbol: Optional[BinanceSymbol] = None
         symbols: Optional[BinanceSymbols] = None  # SPOT/MARGIN only
         type: Optional[str] = None  # SPOT/MARIN only
 
     async def _get(self, parameters: GetParameters) -> list[BinanceTicker24hr]:
@@ -477,14 +490,15 @@
     `GET /dapi/v1/ticker/price`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#symbol-price-ticker
     https://binance-docs.github.io/apidocs/futures/en/#symbol-price-ticker
     https://binance-docs.github.io/apidocs/delivery/en/#symbol-price-ticker
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -508,14 +522,15 @@
         ----------
         symbol : BinanceSymbol
             The trading pair. When given, endpoint will return a single BinanceTickerPrice.
             When omitted, endpoint will return a list of BinanceTickerPrice for all trading pairs.
         symbols : str
             SPOT/MARGIN only!
             List of trading pairs. When given, endpoint will return a list of BinanceTickerPrice.
+
         """
 
         symbol: Optional[BinanceSymbol] = None
         symbols: Optional[BinanceSymbols] = None  # SPOT/MARGIN only
 
     async def _get(self, parameters: GetParameters) -> list[BinanceTickerPrice]:
         method_type = BinanceMethodType.GET
@@ -535,14 +550,15 @@
     `GET /dapi/v1/ticker/bookTicker`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#symbol-order-book-ticker
     https://binance-docs.github.io/apidocs/futures/en/#symbol-order-book-ticker
     https://binance-docs.github.io/apidocs/delivery/en/#symbol-order-book-ticker
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -566,14 +582,15 @@
         ----------
         symbol : str
             The trading pair. When given, endpoint will return a single BinanceTickerBook
             When omitted, endpoint will return a list of BinanceTickerBook for all trading pairs.
         symbols : str
             SPOT/MARGIN only!
             List of trading pairs. When given, endpoint will return a list of BinanceTickerBook.
+
         """
 
         symbol: Optional[BinanceSymbol] = None
         symbols: Optional[BinanceSymbols] = None  # SPOT/MARGIN only
 
     async def _get(self, parameters: GetParameters) -> list[BinanceTickerBook]:
         method_type = BinanceMethodType.GET
@@ -594,14 +611,15 @@
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint prefix.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         account_type: BinanceAccountType,
     ):
@@ -628,68 +646,80 @@
         self._endpoint_agg_trades = BinanceAggTradesHttp(client, self.base_endpoint)
         self._endpoint_klines = BinanceKlinesHttp(client, self.base_endpoint)
         self._endpoint_ticker_24hr = BinanceTicker24hrHttp(client, self.base_endpoint)
         self._endpoint_ticker_price = BinanceTickerPriceHttp(client, self.base_endpoint)
         self._endpoint_ticker_book = BinanceTickerBookHttp(client, self.base_endpoint)
 
     async def ping(self) -> dict:
-        """Ping Binance REST API."""
+        """
+        Ping Binance REST API.
+        """
         return await self._endpoint_ping._get()
 
     async def request_server_time(self) -> int:
-        """Request server time from Binance."""
+        """
+        Request server time from Binance.
+        """
         response = await self._endpoint_time._get()
         return response.serverTime
 
     async def query_depth(
         self,
         symbol: str,
         limit: Optional[int] = None,
     ) -> BinanceDepth:
-        """Query order book depth for a symbol."""
+        """
+        Query order book depth for a symbol.
+        """
         return await self._endpoint_depth._get(
             parameters=self._endpoint_depth.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
             ),
         )
 
     async def request_order_book_snapshot(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
         limit: Optional[int] = None,
     ) -> OrderBookDeltas:
-        """Request snapshot of order book depth."""
+        """
+        Request snapshot of order book depth.
+        """
         depth = await self.query_depth(instrument_id.symbol.value, limit)
         return depth.parse_to_order_book_snapshot(
             instrument_id=instrument_id,
             ts_init=ts_init,
         )
 
     async def query_trades(
         self,
         symbol: str,
         limit: Optional[int] = None,
     ) -> list[BinanceTrade]:
-        """Query trades for symbol."""
+        """
+        Query trades for symbol.
+        """
         return await self._endpoint_trades._get(
             parameters=self._endpoint_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
             ),
         )
 
     async def request_trade_ticks(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
         limit: Optional[int] = None,
     ) -> list[TradeTick]:
-        """Request TradeTicks from Binance."""
+        """
+        Request TradeTicks from Binance.
+        """
         trades = await self.query_trades(instrument_id.symbol.value, limit)
         return [
             trade.parse_to_trade_tick(
                 instrument_id=instrument_id,
                 ts_init=ts_init,
             )
             for trade in trades
@@ -699,15 +729,17 @@
         self,
         symbol: str,
         limit: Optional[int] = None,
         start_time: Optional[int] = None,
         end_time: Optional[int] = None,
         from_id: Optional[int] = None,
     ) -> list[BinanceAggTrade]:
-        """Query aggregated trades for symbol."""
+        """
+        Query aggregated trades for symbol.
+        """
         return await self._endpoint_agg_trades._get(
             parameters=self._endpoint_agg_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
                 startTime=start_time,
                 endTime=end_time,
                 fromId=from_id,
@@ -721,16 +753,18 @@
         limit: int = 1000,
         start_time: Optional[int] = None,
         end_time: Optional[int] = None,
         from_id: Optional[int] = None,
     ) -> list[TradeTick]:
         """
         Request TradeTicks from Binance aggregated trades.
-        If start_time and end_time are both specified, will fetch *all* TradeTicks
-        in the interval, making multiple requests if necessary.
+
+        If start_time and end_time are both specified, will fetch *all* TradeTicks in
+        the interval, making multiple requests if necessary.
+
         """
         ticks: list[TradeTick] = []
         next_start_time = start_time
 
         if from_id is not None and (start_time or end_time) is not None:
             raise RuntimeError(
                 "Cannot specify both fromId and startTime or endTime.",
@@ -791,15 +825,17 @@
 
     async def query_historical_trades(
         self,
         symbol: str,
         limit: Optional[int] = None,
         from_id: Optional[int] = None,
     ) -> list[BinanceTrade]:
-        """Query historical trades for symbol."""
+        """
+        Query historical trades for symbol.
+        """
         return await self._endpoint_historical_trades._get(
             parameters=self._endpoint_historical_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
                 fromId=from_id,
             ),
         )
@@ -807,15 +843,17 @@
     async def request_historical_trade_ticks(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
         limit: Optional[int] = None,
         from_id: Optional[int] = None,
     ) -> list[TradeTick]:
-        """Request historical TradeTicks from Binance."""
+        """
+        Request historical TradeTicks from Binance.
+        """
         historical_trades = await self.query_historical_trades(
             symbol=instrument_id.symbol.value,
             limit=limit,
             from_id=from_id,
         )
         return [
             trade.parse_to_trade_tick(
@@ -829,15 +867,17 @@
         self,
         symbol: str,
         interval: BinanceKlineInterval,
         limit: Optional[int] = None,
         start_time: Optional[int] = None,
         end_time: Optional[int] = None,
     ) -> list[BinanceKline]:
-        """Query klines for a symbol over an interval."""
+        """
+        Query klines for a symbol over an interval.
+        """
         return await self._endpoint_klines._get(
             parameters=self._endpoint_klines.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 interval=interval,
                 limit=limit,
                 startTime=start_time,
                 endTime=end_time,
@@ -849,15 +889,17 @@
         bar_type: BarType,
         ts_init: int,
         interval: BinanceKlineInterval,
         limit: Optional[int] = None,
         start_time: Optional[int] = None,
         end_time: Optional[int] = None,
     ) -> list[BinanceBar]:
-        """Request Binance Bars from Klines."""
+        """
+        Request Binance Bars from Klines.
+        """
         end_time_ms = int(end_time) if end_time is not None else sys.maxsize
         all_bars: list[BinanceBar] = []
         while True:
             klines = await self.query_klines(
                 symbol=bar_type.instrument_id.symbol.value,
                 interval=interval,
                 limit=limit,
@@ -886,15 +928,17 @@
 
     async def query_ticker_24hr(
         self,
         symbol: Optional[str] = None,
         symbols: Optional[list[str]] = None,
         response_type: Optional[str] = None,
     ) -> list[BinanceTicker24hr]:
-        """Query 24hr ticker for symbol or symbols."""
+        """
+        Query 24hr ticker for symbol or symbols.
+        """
         if symbol is not None and symbols is not None:
             raise RuntimeError(
                 "Cannot specify both symbol and symbols parameters.",
             )
         return await self._endpoint_ticker_24hr._get(
             parameters=self._endpoint_ticker_24hr.GetParameters(
                 symbol=BinanceSymbol(symbol),
@@ -904,15 +948,17 @@
         )
 
     async def query_ticker_price(
         self,
         symbol: Optional[str] = None,
         symbols: Optional[list[str]] = None,
     ) -> list[BinanceTickerPrice]:
-        """Query price ticker for symbol or symbols."""
+        """
+        Query price ticker for symbol or symbols.
+        """
         if symbol is not None and symbols is not None:
             raise RuntimeError(
                 "Cannot specify both symbol and symbols parameters.",
             )
         return await self._endpoint_ticker_price._get(
             parameters=self._endpoint_ticker_price.GetParameters(
                 symbol=BinanceSymbol(symbol),
@@ -921,15 +967,17 @@
         )
 
     async def query_ticker_book(
         self,
         symbol: Optional[str] = None,
         symbols: Optional[list[str]] = None,
     ) -> list[BinanceTickerBook]:
-        """Query book ticker for symbol or symbols."""
+        """
+        Query book ticker for symbol or symbols.
+        """
         if symbol is not None and symbols is not None:
             raise RuntimeError(
                 "Cannot specify both symbol and symbols parameters.",
             )
         return await self._endpoint_ticker_book._get(
             parameters=self._endpoint_ticker_book.GetParameters(
                 symbol=BinanceSymbol(symbol),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/user.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/http/user.py`

 * *Files 8% similar despite different names*

```diff
@@ -51,14 +51,15 @@
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#listen-key-spot
     https://binance-docs.github.io/apidocs/spot/en/#listen-key-margin
     https://binance-docs.github.io/apidocs/futures/en/#start-user-data-stream-user_stream
     https://binance-docs.github.io/apidocs/delivery/en/#start-user-data-stream-user_stream
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         url_path: str,
     ):
@@ -80,28 +81,30 @@
         """
         POST parameters for creating listen keys.
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The trading pair. Only required for ISOLATED MARGIN accounts!
+
         """
 
         symbol: Optional[BinanceSymbol] = None  # MARGIN_ISOLATED only, mandatory
 
     class PutDeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
         PUT & DELETE parameters for managing listen keys.
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The trading pair. Only required for ISOLATED MARGIN accounts!
         listenKey : str
             The listen key to manage. Only required for SPOT/MARGIN accounts!
+
         """
 
         symbol: Optional[BinanceSymbol] = None  # MARGIN_ISOLATED only, mandatory
         listenKey: Optional[str] = None  # SPOT/MARGIN only, mandatory
 
     async def _post(self, parameters: Optional[PostParameters] = None) -> BinanceListenKey:
         method_type = BinanceMethodType.POST
@@ -129,14 +132,15 @@
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         account_type: BinanceAccountType,
     ):
@@ -166,40 +170,46 @@
 
         self._endpoint_listenkey = BinanceListenKeyHttp(client, listen_key_url)
 
     async def create_listen_key(
         self,
         symbol: Optional[str] = None,
     ) -> BinanceListenKey:
-        """Create Binance ListenKey."""
+        """
+        Create Binance ListenKey.
+        """
         key = await self._endpoint_listenkey._post(
             parameters=self._endpoint_listenkey.PostParameters(
                 symbol=BinanceSymbol(symbol),
             ),
         )
         return key
 
     async def keepalive_listen_key(
         self,
         symbol: Optional[str] = None,
         listen_key: Optional[str] = None,
     ):
-        """Ping/Keepalive Binance ListenKey."""
+        """
+        Ping/Keepalive Binance ListenKey.
+        """
         await self._endpoint_listenkey._put(
             parameters=self._endpoint_listenkey.PutDeleteParameters(
                 symbol=BinanceSymbol(symbol),
                 listenKey=listen_key,
             ),
         )
 
     async def delete_listen_key(
         self,
         symbol: Optional[str] = None,
         listen_key: Optional[str] = None,
     ):
-        """Delete Binance ListenKey."""
+        """
+        Delete Binance ListenKey.
+        """
         await self._endpoint_listenkey._delete(
             parameters=self._endpoint_listenkey.PutDeleteParameters(
                 symbol=BinanceSymbol(symbol),
                 listenKey=listen_key,
             ),
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/data.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/data.py`

 * *Files 4% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 import asyncio
 from typing import Optional, Union
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.data import BinanceCommonDataClient
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
+from nautilus_trader.adapters.binance.config import BinanceDataClientConfig
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.spot.enums import BinanceSpotEnumParser
 from nautilus_trader.adapters.binance.spot.http.market import BinanceSpotMarketHttpAPI
 from nautilus_trader.adapters.binance.spot.schemas.market import BinanceSpotOrderBookPartialDepthMsg
 from nautilus_trader.adapters.binance.spot.schemas.market import BinanceSpotTradeMsg
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
@@ -57,31 +58,31 @@
         The logger for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
     base_url_ws : str
         The base URL for the WebSocket client.
     account_type : BinanceAccountType
         The account type for the client.
-    use_agg_trade_ticks : bool, default False
-        Whether to use aggregated trade tick endpoints instead of raw trade ticks.
-        TradeId of ticks will be the Aggregate tradeId returned by Binance.
+    config : BinanceDataClientConfig
+        The configuration for the client.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InstrumentProvider,
         base_url_ws: str,
+        config: BinanceDataClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
-        use_agg_trade_ticks: bool = False,
     ):
         PyCondition.true(
             account_type.is_spot_or_margin,
             "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
         )
 
         # Spot HTTP API
@@ -98,15 +99,15 @@
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
-            use_agg_trade_ticks=use_agg_trade_ticks,
+            config=config,
         )
 
         # Websocket msgspec decoders
         self._decoder_spot_trade = msgspec.json.Decoder(BinanceSpotTradeMsg)
         self._decoder_spot_order_book_partial_depth = msgspec.json.Decoder(
             BinanceSpotOrderBookPartialDepthMsg,
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/enums.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/enums.py`

 * *Files 10% similar despite different names*

```diff
@@ -8,68 +8,83 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
+"""
+Defines `Binance` Spot/Margin specific enums.
+
+References
+----------
+https://binance-docs.github.io/apidocs/spot/en/#public-api-definitions
 
+"""
 from enum import Enum
 from enum import unique
 
 from nautilus_trader.adapters.binance.common.enums import BinanceEnumParser
 from nautilus_trader.adapters.binance.common.enums import BinanceOrderType
 from nautilus_trader.model.enums import OrderType
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import order_type_to_str
 from nautilus_trader.model.orders import Order
 
 
-"""
-Defines `Binance` Spot/Margin specific enums.
-
-References
-----------
-https://binance-docs.github.io/apidocs/spot/en/#public-api-definitions
-"""
-
-
 @unique
 class BinanceSpotPermissions(Enum):
-    """Represents `Binance Spot/Margin` trading permissions."""
+    """
+    Represents `Binance Spot/Margin` trading permissions.
+    """
 
     SPOT = "SPOT"
     MARGIN = "MARGIN"
     LEVERAGED = "LEVERAGED"
     TRD_GRP_002 = "TRD_GRP_002"
     TRD_GRP_003 = "TRD_GRP_003"
     TRD_GRP_004 = "TRD_GRP_004"
     TRD_GRP_005 = "TRD_GRP_005"
     TRD_GRP_006 = "TRD_GRP_006"
     TRD_GRP_007 = "TRD_GRP_007"
     TRD_GRP_008 = "TRD_GRP_008"
     TRD_GRP_009 = "TRD_GRP_009"
+    TRD_GRP_010 = "TRD_GRP_010"
+    TRD_GRP_011 = "TRD_GRP_011"
+    TRD_GRP_012 = "TRD_GRP_012"
+    TRD_GRP_013 = "TRD_GRP_013"
+    TRD_GRP_014 = "TRD_GRP_014"
+    TRD_GRP_015 = "TRD_GRP_015"
+    TRD_GRP_016 = "TRD_GRP_016"
+    TRD_GRP_017 = "TRD_GRP_017"
+    TRD_GRP_018 = "TRD_GRP_018"
+    TRD_GRP_019 = "TRD_GRP_019"
+    TRD_GRP_020 = "TRD_GRP_020"
 
 
 @unique
 class BinanceSpotSymbolStatus(Enum):
-    """Represents a `Binance Spot/Margin` symbol status."""
+    """
+    Represents a `Binance Spot/Margin` symbol status.
+    """
 
     PRE_TRADING = "PRE_TRADING"
     TRADING = "TRADING"
     POST_TRADING = "POST_TRADING"
     END_OF_DAY = "END_OF_DAY"
     HALT = "HALT"
     AUCTION_MATCH = "AUCTION_MATCH"
     BREAK = "BREAK"
 
 
 @unique
 class BinanceSpotEventType(Enum):
-    """Represents a `Binance Spot/Margin` event type."""
+    """
+    Represents a `Binance Spot/Margin` event type.
+    """
 
     outboundAccountPosition = "outboundAccountPosition"
     balanceUpdate = "balanceUpdate"
     executionReport = "executionReport"
     listStatus = "listStatus"
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/execution.py`

 * *Files 3% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 import asyncio
 from typing import Optional
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.execution import BinanceCommonExecutionClient
+from nautilus_trader.adapters.binance.config import BinanceExecClientConfig
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.spot.enums import BinanceSpotEnumParser
 from nautilus_trader.adapters.binance.spot.enums import BinanceSpotEventType
 from nautilus_trader.adapters.binance.spot.http.account import BinanceSpotAccountHttpAPI
 from nautilus_trader.adapters.binance.spot.http.market import BinanceSpotMarketHttpAPI
 from nautilus_trader.adapters.binance.spot.http.user import BinanceSpotUserDataHttpAPI
 from nautilus_trader.adapters.binance.spot.providers import BinanceSpotInstrumentProvider
@@ -61,34 +62,35 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
     instrument_provider : BinanceSpotInstrumentProvider
         The instrument provider.
+    base_url_ws : str
+        The base URL for the WebSocket client.
     account_type : BinanceAccountType
         The account type for the client.
-    base_url_ws : str, optional
-        The base URL for the WebSocket client.
-    warn_gtd_to_gtc : bool, default True
-        If log warning for GTD time in force transformed to GTC.
+    config : BinanceExecClientConfig
+        The configuration for the client.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: BinanceSpotInstrumentProvider,
+        base_url_ws: str,
+        config: BinanceExecClientConfig,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
-        base_url_ws: Optional[str] = None,
-        warn_gtd_to_gtc: bool = True,
     ):
         PyCondition.true(
             account_type.is_spot_or_margin,
             "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
         )
 
         # Spot HTTP API
@@ -110,15 +112,15 @@
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
             instrument_provider=instrument_provider,
             account_type=account_type,
             base_url_ws=base_url_ws,
-            warn_gtd_to_gtc=warn_gtd_to_gtc,
+            config=config,
         )
 
         # Register spot websocket user data event handlers
         self._spot_user_ws_handlers = {
             BinanceSpotEventType.outboundAccountPosition: self._handle_account_update,
             BinanceSpotEventType.executionReport: self._handle_execution_report,
             BinanceSpotEventType.listStatus: self._handle_list_status,
@@ -162,17 +164,17 @@
     ) -> list[PositionStatusReport]:
         # Never cash positions
         return []
 
     async def _get_binance_active_position_symbols(
         self,
         symbol: Optional[str] = None,
-    ) -> list[str]:
+    ) -> set[str]:
         # Never cash positions
-        return []
+        return set()
 
     # -- COMMAND HANDLERS -------------------------------------------------------------------------
 
     def _check_order_validity(self, order: Order) -> None:
         # Check order type valid
         if order.order_type not in self._spot_enum_parser.spot_valid_order_types:
             self._log.error(
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/account.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/account.py`

 * *Files 4% similar despite different names*

```diff
@@ -47,14 +47,15 @@
     Care should be taken when accessing this endpoint with no symbol specified.
     The weight usage can be very large, which may cause rate limits to be hit.
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#current-open-orders-user_data
     https://binance-docs.github.io/apidocs/spot/en/#cancel-all-open-orders-on-a-symbol-trade
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -67,25 +68,25 @@
             base_endpoint,
             methods,
         )
         self._delete_resp_decoder = msgspec.json.Decoder()
 
     class DeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
-        Parameters of openOrders SPOT/MARGIN DELETE request.
-        Includes OCO orders.
+        Parameters of openOrders SPOT/MARGIN DELETE request. Includes OCO orders.
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request
         symbol : BinanceSymbol
             The symbol of the orders
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         symbol: BinanceSymbol
         recvWindow: Optional[str] = None
 
     async def _delete(self, parameters: DeleteParameters) -> list[dict[str, Any]]:
@@ -99,14 +100,15 @@
     Endpoint for creating SPOT/MARGIN OCO orders.
 
     `POST /api/v3/order/oco`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#new-oco-trade
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -169,14 +171,15 @@
             The time in force of the stop limit order.
             Valid values: (GTC, FOK, IOC).
         newOrderRespType : BinanceNewOrderRespType, optional
             The response type for the order request.
         recvWindow : str, optional
             The response receive window in milliseconds for the request.
             Cannot exceed 60000.
+
         """
 
         symbol: BinanceSymbol
         timestamp: str
         side: BinanceOrderSide
         quantity: str
         price: str
@@ -209,14 +212,15 @@
     `GET /api/v3/orderList`
     `DELETE /api/v3/orderList`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#query-oco-user_data
     https://binance-docs.github.io/apidocs/spot/en/#cancel-oco-trade
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -230,39 +234,40 @@
             methods,
             url_path,
         )
         self._resp_decoder = msgspec.json.Decoder(BinanceSpotOrderOco)
 
     class GetParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
-        orderList (OCO) GET endpoint parameters.
+        OrderList (OCO) GET endpoint parameters.
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         orderListId : str, optional
             The unique identifier of the order list to retrieve.
         origClientOrderId : str, optional
             The client specified identifier of the order list to retrieve.
         recvWindow : str, optional
             The response receive window in milliseconds for the request.
             Cannot exceed 60000.
 
         NOTE: Either orderListId or origClientOrderId must be provided.
+
         """
 
         timestamp: str
         orderListId: Optional[str] = None
         origClientOrderId: Optional[str] = None
         recvWindow: Optional[str] = None
 
     class DeleteParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
-        orderList (OCO) DELETE endpoint parameters.
+        OrderList (OCO) DELETE endpoint parameters.
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         symbol : BinanceSymbol
             The symbol of the order.
@@ -274,14 +279,15 @@
             Used to uniquely identify this cancel. Automatically generated
             by default.
         recvWindow : str, optional
             The response receive window in milliseconds for the request.
             Cannot exceed 60000.
 
         NOTE: Either orderListId or listClientOrderId must be provided.
+
         """
 
         timestamp: str
         symbol: BinanceSymbol
         orderListId: Optional[str] = None
         listClientOrderId: Optional[str] = None
         newClientOrderId: Optional[str] = None
@@ -303,14 +309,15 @@
     Endpoint for querying all SPOT/MARGIN OCO orders.
 
     `GET /api/v3/allOrderList`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#query-all-oco-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -345,14 +352,15 @@
             Default 500, max 1000
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
 
         Warnings
         --------
         If fromId is specified, neither startTime endTime can be provided.
+
         """
 
         timestamp: str
         fromId: Optional[int] = None
         startTime: Optional[int] = None
         endTime: Optional[int] = None
         limit: Optional[int] = None
@@ -369,14 +377,15 @@
     Endpoint for querying all SPOT/MARGIN OPEN OCO orders.
 
     `GET /api/v3/openOrderList`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#query-open-oco-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -397,14 +406,15 @@
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceSpotOrderOco]:
         method_type = BinanceMethodType.GET
@@ -417,14 +427,15 @@
     Endpoint of current SPOT/MARGIN account information.
 
     `GET /api/v3/account`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#account-information-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -445,14 +456,15 @@
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> BinanceSpotAccountInfo:
         method_type = BinanceMethodType.GET
@@ -465,14 +477,15 @@
     Endpoint of current SPOT/MARGIN order count usage for all intervals.
 
     `GET /api/v3/rateLimit/order`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#query-current-order-count-usage-trade
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -493,14 +506,15 @@
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
+
         """
 
         timestamp: str
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceRateLimit]:
         method_type = BinanceMethodType.GET
@@ -516,14 +530,15 @@
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
     clock : LiveClock,
         The clock for the API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint prefix.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         clock: LiveClock,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
@@ -572,15 +587,17 @@
         stop_strategy_type: Optional[int] = None,
         stop_limit_price: Optional[str] = None,
         stop_iceberg_qty: Optional[str] = None,
         stop_limit_time_in_force: Optional[BinanceTimeInForce] = None,
         new_order_resp_type: Optional[BinanceNewOrderRespType] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceSpotOrderOco:
-        """Send in a new spot OCO order to Binance."""
+        """
+        Send in a new spot OCO order to Binance.
+        """
         if stop_limit_price is not None and stop_limit_time_in_force is None:
             raise RuntimeError(
                 "stopLimitPrice cannot be provided without stopLimitTimeInForce.",
             )
         if stop_limit_time_in_force == BinanceTimeInForce.GTX:
             raise RuntimeError(
                 "stopLimitTimeInForce, Good Till Crossing (GTX) not supported.",
@@ -612,15 +629,17 @@
 
     async def query_spot_oco(
         self,
         order_list_id: Optional[str] = None,
         orig_client_order_id: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceSpotOrderOco:
-        """Check single spot OCO order information."""
+        """
+        Check single spot OCO order information.
+        """
         if order_list_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderListId or origClientOrderId must be provided.",
             )
         return await self._endpoint_spot_order_list._get(
             parameters=self._endpoint_spot_order_list.GetParameters(
                 timestamp=self._timestamp(),
@@ -631,15 +650,20 @@
         )
 
     async def cancel_all_open_orders(
         self,
         symbol: str,
         recv_window: Optional[str] = None,
     ) -> bool:
-        """Cancel all active orders on a symbol, including OCO. Returns whether successful."""
+        """
+        Cancel all active orders on a symbol, including OCO.
+
+        Returns whether successful.
+
+        """
         await self._endpoint_spot_open_orders._delete(
             parameters=self._endpoint_spot_open_orders.DeleteParameters(
                 timestamp=self._timestamp(),
                 symbol=BinanceSymbol(symbol),
                 recvWindow=recv_window,
             ),
         )
@@ -649,15 +673,17 @@
         self,
         symbol: str,
         order_list_id: Optional[str] = None,
         list_client_order_id: Optional[str] = None,
         new_client_order_id: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceSpotOrderOco:
-        """Delete spot OCO order from Binance."""
+        """
+        Delete spot OCO order from Binance.
+        """
         if order_list_id is None and list_client_order_id is None:
             raise RuntimeError(
                 "Either orderListId or listClientOrderId must be provided.",
             )
         return await self._endpoint_spot_order_list._delete(
             parameters=self._endpoint_spot_order_list.DeleteParameters(
                 timestamp=self._timestamp(),
@@ -673,15 +699,17 @@
         self,
         from_id: Optional[int] = None,
         start_time: Optional[int] = None,
         end_time: Optional[int] = None,
         limit: Optional[int] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceSpotOrderOco]:
-        """Check all spot OCO orders' information, matching provided filter parameters."""
+        """
+        Check all spot OCO orders' information, matching provided filter parameters.
+        """
         if from_id is not None and (start_time or end_time) is not None:
             raise RuntimeError(
                 "Cannot specify both fromId and a startTime/endTime.",
             )
         return await self._endpoint_spot_all_order_list._get(
             parameters=self._endpoint_spot_all_order_list.GetParameters(
                 timestamp=self._timestamp(),
@@ -693,38 +721,44 @@
             ),
         )
 
     async def query_spot_all_open_oco(
         self,
         recv_window: Optional[str] = None,
     ) -> list[BinanceSpotOrderOco]:
-        """Check all OPEN spot OCO orders' information."""
+        """
+        Check all OPEN spot OCO orders' information.
+        """
         return await self._endpoint_spot_open_order_list._get(
             parameters=self._endpoint_spot_open_order_list.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def query_spot_account_info(
         self,
         recv_window: Optional[str] = None,
     ) -> BinanceSpotAccountInfo:
-        """Check SPOT/MARGIN Binance account information."""
+        """
+        Check SPOT/MARGIN Binance account information.
+        """
         return await self._endpoint_spot_account._get(
             parameters=self._endpoint_spot_account.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
 
     async def query_spot_order_rate_limit(
         self,
         recv_window: Optional[str] = None,
     ) -> list[BinanceRateLimit]:
-        """Check SPOT/MARGIN order count/rateLimit."""
+        """
+        Check SPOT/MARGIN order count/rateLimit.
+        """
         return await self._endpoint_spot_order_rate_limit._get(
             parameters=self._endpoint_spot_order_rate_limit.GetParameters(
                 timestamp=self._timestamp(),
                 recvWindow=recv_window,
             ),
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/market.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/market.py`

 * *Files 1% similar despite different names*

```diff
@@ -35,14 +35,15 @@
     Endpoint of SPOT/MARGIN exchange trading rules and symbol information.
 
     `GET /api/v3/exchangeInfo`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#exchange-information
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -65,14 +66,15 @@
         ----------
         symbol : BinanceSymbol, optional
             The specify trading pair to get exchange info for.
         symbols : BinanceSymbols, optional
             The specify list of trading pairs to get exchange info for.
         permissions : BinanceSpotPermissions, optional
             The filter symbols list by supported permissions.
+
         """
 
         symbol: Optional[BinanceSymbol] = None
         symbols: Optional[BinanceSymbols] = None
         permissions: Optional[BinanceSpotPermissions] = None
 
     async def _get(self, parameters: Optional[GetParameters] = None) -> BinanceSpotExchangeInfo:
@@ -86,14 +88,15 @@
     Endpoint of current average price of a symbol.
 
     `GET /api/v3/avgPrice`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#current-average-price
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -112,14 +115,15 @@
         """
         GET avgPrice parameters.
 
         Parameters
         ----------
         symbol : BinanceSymbol
             Specify trading pair to get average price for.
+
         """
 
         symbol: BinanceSymbol = None
 
     async def _get(self, parameters: GetParameters) -> BinanceSpotAvgPrice:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
@@ -132,14 +136,15 @@
 
     Parameters
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
     ):
@@ -158,25 +163,29 @@
 
     async def query_spot_exchange_info(
         self,
         symbol: Optional[str] = None,
         symbols: Optional[list[str]] = None,
         permissions: Optional[BinanceSpotPermissions] = None,
     ) -> BinanceSpotExchangeInfo:
-        """Check Binance Spot exchange information."""
+        """
+        Check Binance Spot exchange information.
+        """
         if symbol and symbols:
             raise ValueError("`symbol` and `symbols` cannot be sent together")
         return await self._endpoint_spot_exchange_info._get(
             parameters=self._endpoint_spot_exchange_info.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 symbols=BinanceSymbols(symbols),
                 permissions=permissions,
             ),
         )
 
     async def query_spot_average_price(self, symbol: str) -> BinanceSpotAvgPrice:
-        """Check average price for a provided symbol on the Spot exchange."""
+        """
+        Check average price for a provided symbol on the Spot exchange.
+        """
         return await self._endpoint_spot_average_price._get(
             parameters=self._endpoint_spot_average_price.GetParameters(
                 symbol=BinanceSymbol(symbol),
             ),
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/user.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/user.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,14 +25,15 @@
 
     Parameters
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
     ):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/wallet.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/http/wallet.py`

 * *Files 2% similar despite different names*

```diff
@@ -32,14 +32,15 @@
     Endpoint of maker/taker trade fee information.
 
     `GET /sapi/v1/asset/tradeFee`
 
     References
     ----------
     https://binance-docs.github.io/apidocs/spot/en/#trade-fee-user_data
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         base_endpoint: str,
     ):
@@ -62,14 +63,15 @@
         ----------
         symbol : BinanceSymbol
             Optional symbol to receive individual trade fee
         recvWindow : str
             Optional number of milliseconds after timestamp the request is valid
         timestamp : str
             Millisecond timestamp of the request
+
         """
 
         timestamp: str
         symbol: Optional[BinanceSymbol] = None
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceSpotTradeFee]:
@@ -85,14 +87,15 @@
     """
     Provides access to the `Binance Spot/Margin` Wallet HTTP REST API.
 
     Parameters
     ----------
     client : BinanceHttpClient
         The Binance REST API client.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         clock: LiveClock,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
@@ -105,15 +108,17 @@
             raise RuntimeError(  # pragma: no cover (design-time error)
                 f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover
             )
 
         self._endpoint_spot_trade_fee = BinanceSpotTradeFeeHttp(client, self.base_endpoint)
 
     def _timestamp(self) -> str:
-        """Create Binance timestamp from internal clock."""
+        """
+        Create Binance timestamp from internal clock.
+        """
         return str(self._clock.timestamp_ms())
 
     async def query_spot_trade_fees(
         self,
         symbol: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceSpotTradeFee]:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/providers.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/providers.py`

 * *Files 4% similar despite different names*

```diff
@@ -53,35 +53,44 @@
 
     Parameters
     ----------
     client : APIClient
         The client for the provider.
     logger : Logger
         The logger for the provider.
+    clock : LiveClock
+        The clock for the provider.
+    account_type : BinanceAccountType, default SPOT
+        The Binance account type for the provider.
+    is_testnet : bool, default False
+        If the provider is for the Spot testnet.
     config : InstrumentProviderConfig, optional
         The configuration for the provider.
+
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         logger: Logger,
         clock: LiveClock,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
+        is_testnet: bool = False,
         config: Optional[InstrumentProviderConfig] = None,
     ):
         super().__init__(
             venue=BINANCE_VENUE,
             logger=logger,
             config=config,
         )
 
+        self._clock = clock
         self._client = client
         self._account_type = account_type
-        self._clock = clock
+        self._is_testnet = is_testnet
 
         self._http_wallet = BinanceSpotWalletHttpAPI(
             self._client,
             clock=self._clock,
             account_type=account_type,
         )
         self._http_market = BinanceSpotMarketHttpAPI(self._client, account_type=account_type)
@@ -91,24 +100,25 @@
         self._decoder = msgspec.json.Decoder()
         self._encoder = msgspec.json.Encoder()
 
     async def load_all_async(self, filters: Optional[dict] = None) -> None:
         filters_str = "..." if not filters else f" with filters {filters}..."
         self._log.info(f"Loading all instruments{filters_str}")
 
-        # Get current commission rates
         try:
-            # response = await self._http_wallet.query_spot_trade_fees()
-            # fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
-            # TODO: Requests for testnet seem to fail auth
-            self._log.warning(
-                "Currently not requesting actual trade fees. "
-                "All instruments will have zero fees.",
-            )
-            fees_dict: dict[str, BinanceSpotTradeFee] = {}
+            # Get current commission rates
+            if not self._is_testnet:
+                response = await self._http_wallet.query_spot_trade_fees()
+                fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
+            else:
+                self._log.warning(
+                    "Currently not requesting actual trade fees for the SPOT testnet. "
+                    "All instruments will have zero fees.",
+                )
+                fees_dict = {}
         except BinanceClientError as e:
             self._log.error(
                 "Cannot load instruments: API key authentication failed "
                 f"(this is needed to fetch the applicable account fee tier). {e.message}",
             )
             return
 
@@ -133,24 +143,25 @@
         # Check all instrument IDs
         for instrument_id in instrument_ids:
             PyCondition.equal(instrument_id.venue, self.venue, "instrument_id.venue", "self.venue")
 
         filters_str = "..." if not filters else f" with filters {filters}..."
         self._log.info(f"Loading instruments {instrument_ids}{filters_str}.")
 
-        # Get current commission rates
         try:
-            # response = await self._http_wallet.query_spot_trade_fees()
-            # fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
-            # TODO: Requests for testnet seem to fail auth
-            self._log.warning(
-                "Currently not requesting actual trade fees. "
-                "All instruments will have zero fees.",
-            )
-            fees_dict: dict[str, BinanceSpotTradeFee] = {}
+            # Get current commission rates
+            if not self._is_testnet:
+                response = await self._http_wallet.query_spot_trade_fees()
+                fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
+            else:
+                fees_dict = {}
+                self._log.warning(
+                    "Currently not requesting actual trade fees for the SPOT testnet. "
+                    "All instruments will have zero fees.",
+                )
         except BinanceClientError as e:
             self._log.error(
                 "Cannot load instruments: API key authentication failed "
                 f"(this is needed to fetch the applicable account fee tier). {e.message}",
             )
             return
 
@@ -176,24 +187,25 @@
         PyCondition.equal(instrument_id.venue, self.venue, "instrument_id.venue", "self.venue")
 
         filters_str = "..." if not filters else f" with filters {filters}..."
         self._log.debug(f"Loading instrument {instrument_id}{filters_str}.")
 
         symbol = str(BinanceSymbol(instrument_id.symbol.value))
 
-        # Get current commission rates
         try:
-            # trade_fees = await self._http_wallet.query_spot_trade_fees(symbol=symbol)
-            # fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in trade_fees}
-            # TODO: Requests for testnet seem to fail auth
-            self._log.warning(
-                "Currently not requesting actual trade fees. "
-                "All instruments will have zero fees.",
-            )
-            fees_dict: dict[str, BinanceSpotTradeFee] = {}
+            # Get current commission rates
+            if not self._is_testnet:
+                response = await self._http_wallet.query_spot_trade_fees(symbol=symbol)
+                fees_dict: dict[str, BinanceSpotTradeFee] = {fee.symbol: fee for fee in response}
+            else:
+                self._log.warning(
+                    "Currently not requesting actual trade fees for the SPOT testnet. "
+                    "All instruments will have zero fees.",
+                )
+                fees_dict = {}
         except BinanceClientError as e:
             self._log.error(
                 "Cannot load instruments: API key authentication failed "
                 f"(this is needed to fetch the applicable account fee tier). {e}",
             )
             return
 
@@ -216,16 +228,16 @@
         ts_event: int,
     ) -> None:
         ts_init = self._clock.timestamp_ns()
         try:
             base_currency = symbol_info.parse_to_base_asset()
             quote_currency = symbol_info.parse_to_quote_asset()
 
-            native_symbol = Symbol(symbol_info.symbol)
-            instrument_id = InstrumentId(symbol=native_symbol, venue=BINANCE_VENUE)
+            raw_symbol = Symbol(symbol_info.symbol)
+            instrument_id = InstrumentId(symbol=raw_symbol, venue=BINANCE_VENUE)
 
             # Parse instrument filters
             filters: dict[BinanceSymbolFilterType, BinanceSymbolFilter] = {
                 f.filterType: f for f in symbol_info.filters
             }
             price_filter: BinanceSymbolFilter = filters.get(BinanceSymbolFilterType.PRICE_FILTER)
             lot_size_filter: BinanceSymbolFilter = filters.get(BinanceSymbolFilterType.LOT_SIZE)
@@ -275,15 +287,15 @@
                 assert fee.symbol == symbol_info.symbol
                 maker_fee = Decimal(fee.makerCommission)
                 taker_fee = Decimal(fee.takerCommission)
 
             # Create instrument
             instrument = CurrencyPair(
                 instrument_id=instrument_id,
-                native_symbol=native_symbol,
+                raw_symbol=raw_symbol,
                 base_currency=base_currency,
                 quote_currency=quote_currency,
                 price_precision=price_precision,
                 size_precision=size_precision,
                 price_increment=price_increment,
                 size_increment=size_increment,
                 lot_size=lot_size,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/websocket/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/account.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/account.py`

 * *Files 3% similar despite different names*

```diff
@@ -28,15 +28,16 @@
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceSpotBalanceInfo(msgspec.Struct, frozen=True):
     """
-    HTTP response 'inner struct' from `Binance Spot/Margin` GET /api/v3/account (HMAC SHA256).
+    HTTP response 'inner struct' from `Binance Spot/Margin` GET /api/v3/account (HMAC
+    SHA256).
     """
 
     asset: str
     free: str
     locked: str
 
     def parse_to_account_balance(self) -> AccountBalance:
@@ -71,16 +72,18 @@
     def parse_to_account_balances(self) -> list[AccountBalance]:
         return [balance.parse_to_account_balance() for balance in self.balances]
 
 
 class BinanceSpotOrderOco(msgspec.Struct, frozen=True):
     """
     HTTP response from `Binance Spot/Margin` GET /api/v3/orderList (HMAC SHA256).
-    HTTP response from `Binance Spot/Margin` POST /api/v3/order/oco (HMAC SHA256).
-    HTTP response from `Binance Spot/Margin` DELETE /api/v3/orderList (HMAC SHA256).
+
+    HTTP response from `Binance Spot/Margin` POST /api/v3/order/oco (HMAC SHA256). HTTP
+    response from `Binance Spot/Margin` DELETE /api/v3/orderList (HMAC SHA256).
+
     """
 
     orderListId: int
     contingencyType: str
     listStatusType: str
     listOrderStatus: str
     listClientOrderId: str
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/market.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/market.py`

 * *Files 7% similar despite different names*

```diff
@@ -39,15 +39,17 @@
 
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
 class BinanceSpotSymbolInfo(msgspec.Struct, frozen=True):
-    """HTTP response 'inner struct' from `Binance Spot/Margin` GET /api/v3/exchangeInfo."""
+    """
+    HTTP response 'inner struct' from `Binance Spot/Margin` GET /api/v3/exchangeInfo.
+    """
 
     symbol: str
     status: str
     baseAsset: str
     baseAssetPrecision: int
     quoteAsset: str
     quotePrecision: int
@@ -78,37 +80,44 @@
             iso4217=0,  # Currently undetermined for crypto assets
             name=self.quoteAsset,
             currency_type=CurrencyType.CRYPTO,
         )
 
 
 class BinanceSpotExchangeInfo(msgspec.Struct, frozen=True):
-    """HTTP response from `Binance Spot/Margin` GET /api/v3/exchangeInfo."""
+    """
+    HTTP response from `Binance Spot/Margin` GET /api/v3/exchangeInfo.
+    """
 
     timezone: str
     serverTime: int
     rateLimits: list[BinanceRateLimit]
     exchangeFilters: list[BinanceExchangeFilter]
     symbols: list[BinanceSpotSymbolInfo]
 
 
 class BinanceSpotAvgPrice(msgspec.Struct, frozen=True):
-    """HTTP response from `Binance Spot/Margin` GET /api/v3/avgPrice."""
+    """
+    HTTP response from `Binance Spot/Margin` GET /api/v3/avgPrice.
+    """
 
     mins: int
     price: str
 
 
 ################################################################################
 # WebSocket messages
 ################################################################################
 
 
 class BinanceSpotOrderBookPartialDepthData(msgspec.Struct):
-    """Websocket message 'inner struct' for 'Binance Spot/Margin Partial Book Depth Streams.'"""
+    """
+    Websocket message 'inner struct' for 'Binance Spot/Margin Partial Book Depth
+    Streams.'.
+    """
 
     lastUpdateId: int
     bids: list[BinanceOrderBookDelta]
     asks: list[BinanceOrderBookDelta]
 
     def parse_to_order_book_snapshot(
         self,
@@ -136,15 +145,17 @@
             )
             for o in bids + asks
         ]
         return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceSpotOrderBookPartialDepthMsg(msgspec.Struct):
-    """WebSocket message for 'Binance Spot/Margin' Partial Book Depth Streams."""
+    """
+    WebSocket message for 'Binance Spot/Margin' Partial Book Depth Streams.
+    """
 
     stream: str
     data: BinanceSpotOrderBookPartialDepthData
 
 
 class BinanceSpotTradeData(msgspec.Struct):
     """
@@ -158,14 +169,15 @@
     - t: Trade ID
     - p: Price
     - q: Quantity
     - b: Buyer order ID
     - a: Seller order ID
     - T: Trade time
     - m: Is the buyer the market maker?
+
     """
 
     e: str  # Event type
     E: int  # Event time
     s: str  # Symbol
     t: int  # Trade ID
     p: str  # Price
@@ -188,11 +200,13 @@
             trade_id=TradeId(str(self.t)),
             ts_event=millis_to_nanos(self.T),
             ts_init=ts_init,
         )
 
 
 class BinanceSpotTradeMsg(msgspec.Struct):
-    """WebSocket message from `Binance` Trade Streams."""
+    """
+    WebSocket message from `Binance` Trade Streams.
+    """
 
     stream: str
     data: BinanceSpotTradeData
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/user.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/user.py`

 * *Files 2% similar despite different names*

```diff
@@ -65,15 +65,17 @@
     """
 
     stream: str
     data: BinanceSpotUserMsgData
 
 
 class BinanceSpotBalance(msgspec.Struct, frozen=True):
-    """Inner struct for `Binance Spot/Margin` balances."""
+    """
+    Inner struct for `Binance Spot/Margin` balances.
+    """
 
     a: str  # Asset
     f: str  # Free
     l: str  # Locked
 
     def parse_to_account_balance(self) -> AccountBalance:
         currency = Currency.from_str(self.a)
@@ -84,45 +86,50 @@
             total=Money(total, currency),
             locked=Money(locked, currency),
             free=Money(free, currency),
         )
 
 
 class BinanceSpotAccountUpdateMsg(msgspec.Struct, frozen=True):
-    """WebSocket message for `Binance Spot/Margin` Account Update events."""
+    """
+    WebSocket message for `Binance Spot/Margin` Account Update events.
+    """
 
     e: str  # Event Type
     E: int  # Event Time
     u: int  # Transaction Time
     B: list[BinanceSpotBalance]
 
     def parse_to_account_balances(self) -> list[AccountBalance]:
         return [balance.parse_to_account_balance() for balance in self.B]
 
     def handle_account_update(self, exec_client: BinanceCommonExecutionClient):
-        """Handle BinanceSpotAccountUpdateMsg as payload of outboundAccountPosition."""
+        """
+        Handle BinanceSpotAccountUpdateMsg as payload of outboundAccountPosition.
+        """
         exec_client.generate_account_state(
             balances=self.parse_to_account_balances(),
             margins=[],
             reported=True,
             ts_event=millis_to_nanos(self.u),
         )
 
 
 class BinanceSpotAccountUpdateWrapper(msgspec.Struct, frozen=True):
-    """WebSocket message wrapper for `Binance Spot/Margin` Account Update events."""
+    """
+    WebSocket message wrapper for `Binance Spot/Margin` Account Update events.
+    """
 
     stream: str
     data: BinanceSpotAccountUpdateMsg
 
 
 class BinanceSpotOrderUpdateData(msgspec.Struct, kw_only=True):
     """
     WebSocket message 'inner struct' for `Binance Spot/Margin` Order Update events.
-
     """
 
     e: BinanceSpotEventType
     E: int  # Event time
     s: str  # Symbol
     c: str  # Client order ID
     S: BinanceOrderSide
@@ -202,15 +209,17 @@
             ts_init=ts_init,
         )
 
     def handle_execution_report(
         self,
         exec_client: BinanceCommonExecutionClient,
     ):
-        """Handle BinanceSpotOrderUpdateData as payload of executionReport event."""
+        """
+        Handle BinanceSpotOrderUpdateData as payload of executionReport event.
+        """
         client_order_id_str: str = self.c
         if not client_order_id_str or not client_order_id_str.startswith("O"):
             client_order_id_str = self.C
         client_order_id = ClientOrderId(client_order_id_str)
         ts_event = millis_to_nanos(self.T)
         venue_order_id = VenueOrderId(str(self.i))
         instrument_id = exec_client._get_cached_instrument_id(self.s)
@@ -280,11 +289,13 @@
             )
         else:
             # Event not handled
             exec_client._log.warning(f"Received unhandled {self}")
 
 
 class BinanceSpotOrderUpdateWrapper(msgspec.Struct, frozen=True):
-    """WebSocket message wrapper for `Binance Spot/Margin` Order Update events."""
+    """
+    WebSocket message wrapper for `Binance Spot/Margin` Order Update events.
+    """
 
     stream: str
     data: BinanceSpotOrderUpdateData
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py` & `nautilus_trader-1.176.0/nautilus_trader/indicators/bias.pxd`

 * *Files 16% similar despite different names*

```diff
@@ -9,21 +9,21 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import msgspec
+from nautilus_trader.indicators.average.moving_average cimport MovingAverage
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-################################################################################
-# HTTP responses
-################################################################################
+cdef class Bias(Indicator):
+    cdef MovingAverage _ma
 
+    cdef readonly int period
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
 
-class BinanceSpotTradeFee(msgspec.Struct, frozen=True):
-    """Schema of a single `Binance Spot/Margin` tradeFee."""
-
-    symbol: str
-    makerCommission: str
-    takerCommission: str
+    cpdef void update_raw(self, double close)
+    cdef void _check_initialized(self)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/client.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/websocket/client.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,18 +9,20 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+import asyncio
 from typing import Callable, Optional
 
 from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
 from nautilus_trader.common.clock import LiveClock
+from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.logging import LoggerAdapter
 from nautilus_trader.core.nautilus_pyo3.network import WebSocketClient
 
 
 class BinanceWebSocketClient:
     """
@@ -32,160 +34,132 @@
         The clock for the client.
     logger : Logger
         The logger for the client.
     base_url : str
         The base URL for the WebSocket connection.
     handler : Callable[[bytes], None]
         The callback handler for message events.
+
+    References
+    ----------
+    https://binance-docs.github.io/apidocs/spot/en/#websocket-market-streams
+
     """
 
     def __init__(
         self,
         clock: LiveClock,
         logger: Logger,
         base_url: str,
         handler: Callable[[bytes], None],
     ) -> None:
         self._clock = clock
         self._logger = logger
         self._log: LoggerAdapter = LoggerAdapter(type(self).__name__, logger=logger)
 
-        self._client: Optional[WebSocketClient] = None
         self._base_url: str = base_url
         self._handler: Callable[[bytes], None] = handler
-        self._streams: list[str] = []
-        self._msg_id: int = 0
+
+        self._streams_connecting: set[str] = set()
+        self._streams: dict[str, WebSocketClient] = {}
 
     @property
     def url(self) -> str:
         """
         Return the server URL being used by the client.
 
         Returns
         -------
         str
 
         """
         return self._base_url
 
     @property
-    def is_connected(self) -> bool:
-        """
-        Return whether the client is connected.
-
-        Returns
-        -------
-        bool
-
-        """
-        return self._client is not None and self._client.is_alive
-
-    @property
     def subscriptions(self) -> list[str]:
         """
         Return the current active subscriptions for the client.
 
         Returns
         -------
         str
 
         """
-        return self._streams.copy()
+        return list(self._streams.keys())
 
     @property
     def has_subscriptions(self) -> bool:
         """
         Return whether the client has subscriptions.
 
         Returns
         -------
         bool
 
         """
         return bool(self._streams)
 
-    async def connect(self, key: Optional[str] = None) -> None:
+    async def _connect(self, stream: str) -> None:
+        if stream not in self._streams and stream not in self._streams_connecting:
+            self._streams_connecting.add(stream)
+            await self.connect(stream)
+
+    async def connect(self, stream: str) -> None:
         """
-        Connect the client to the server.
+        Connect a websocket client to the server for the given `stream`.
         """
-        if not self._streams:
-            raise RuntimeError("no subscriptions for connection.")
-
-        # Always connecting combined streams for consistency
-        ws_url = self._base_url + "/stream?streams=" + "/".join(self._streams)
-        if key is not None:
-            ws_url += f"&listenKey={key}"
+        ws_url = self._base_url + f"/stream?streams={stream}"
 
-        self._log.info(f"Connecting to {ws_url}")
-        self._client = await WebSocketClient.connect(
+        self._log.debug(f"Connecting to {ws_url}...")
+        client = await WebSocketClient.connect(
             url=ws_url,
             handler=self._handler,
             heartbeat=60,
         )
-        self._log.info("Connected.")
+        self._log.info(f"Connected to {ws_url}.", LogColor.BLUE)
+
+        self._streams[stream] = client
+        self._streams_connecting.discard(stream)
 
     async def disconnect(self) -> None:
         """
         Disconnect the client from the server.
         """
-        if not self.is_connected:
-            self._log.error("Cannot disconnect websocket, not connected.")
-            return
-        assert self._client is not None  # Type checking
-
-        self._log.info("Disconnecting...")
-        await self._client.disconnect()
-        self._log.info("Disconnected.")
-
-    def _add_stream(self, stream: str) -> None:
-        if stream not in self._streams:
-            self._streams.append(stream)
-
-    async def subscribe(self, key: str) -> None:
-        """
-        Subscribe to the user data stream.
-
-        Parameters
-        ----------
-        key : str
-            The listen key for the subscription.
-
-        """
-        self._add_stream(key)
-        # self._msg_id += 1
-        # message = {
-        #     "method": "SUBSCRIBE",
-        #     "params": [key],
-        #     "id": self._msg_id,
-        # }
-        # await self.send(msgspec.json.encode(message))
+        client_disconnects = []
+        for stream, client in self._streams.items():
+            self._log.info(f"Disconnecting {stream}...")
+            client_disconnects.append(client.disconnect())
+
+        await asyncio.gather(*client_disconnects)
 
-    def subscribe_agg_trades(self, symbol: str) -> None:
+    async def subscribe_agg_trades(self, symbol: str) -> None:
         """
         Aggregate Trade Streams.
 
         The Aggregate Trade Streams push trade information that is aggregated for a single taker order.
         Stream Name: <symbol>@aggTrade
         Update Speed: Real-time
 
         """
-        self._add_stream(f"{BinanceSymbol(symbol).lower()}@aggTrade")
+        stream = f"{BinanceSymbol(symbol).lower()}@aggTrade"
+        await self._connect(stream)
 
-    def subscribe_trades(self, symbol: str) -> None:
+    async def subscribe_trades(self, symbol: str) -> None:
         """
         Trade Streams.
 
         The Trade Streams push raw trade information; each trade has a unique buyer and seller.
         Stream Name: <symbol>@trade
         Update Speed: Real-time
 
         """
-        self._add_stream(f"{BinanceSymbol(symbol).lower()}@trade")
+        stream = f"{BinanceSymbol(symbol).lower()}@trade"
+        await self._connect(stream)
 
-    def subscribe_bars(
+    async def subscribe_bars(
         self,
         symbol: str,
         interval: str,
     ) -> None:
         """
         Subscribe to bar (kline/candlestick) stream.
 
@@ -207,114 +181,122 @@
         - 1d
         - 3d
         - 1w
         - 1M
         Update Speed: 2000ms
 
         """
-        self._add_stream(f"{BinanceSymbol(symbol).lower()}@kline_{interval}")
+        stream = f"{BinanceSymbol(symbol).lower()}@kline_{interval}"
+        await self._connect(stream)
 
-    def subscribe_mini_ticker(
+    async def subscribe_mini_ticker(
         self,
         symbol: Optional[str] = None,
     ) -> None:
         """
         Individual symbol or all symbols mini ticker.
 
         24hr rolling window mini-ticker statistics.
         These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs
         Stream Name: <symbol>@miniTicker or
         Stream Name: !miniTicker@arr
         Update Speed: 1000ms
 
         """
         if symbol is None:
-            self._add_stream("!miniTicker@arr")
+            stream = "!miniTicker@arr"
         else:
-            self._add_stream(f"{BinanceSymbol(symbol).lower()}@miniTicker")
+            stream = f"{BinanceSymbol(symbol).lower()}@miniTicker"
+        await self._connect(stream)
 
-    def subscribe_ticker(
+    async def subscribe_ticker(
         self,
         symbol: Optional[str] = None,
     ) -> None:
         """
         Individual symbol or all symbols ticker.
 
         24hr rolling window ticker statistics for a single symbol.
         These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs.
         Stream Name: <symbol>@ticker or
         Stream Name: !ticker@arr
         Update Speed: 1000ms
 
         """
         if symbol is None:
-            self._add_stream("!ticker@arr")
+            stream = "!ticker@arr"
         else:
-            self._add_stream(f"{BinanceSymbol(symbol).lower()}@ticker")
+            stream = f"{BinanceSymbol(symbol).lower()}@ticker"
+        await self._connect(stream)
 
-    def subscribe_book_ticker(
+    async def subscribe_book_ticker(
         self,
         symbol: Optional[str] = None,
     ) -> None:
         """
         Individual symbol or all book ticker.
 
         Pushes any update to the best bid or ask's price or quantity in real-time for a specified symbol.
         Stream Name: <symbol>@bookTicker or
         Stream Name: !bookTicker
         Update Speed: realtime
 
         """
         if symbol is None:
-            self._add_stream("!bookTicker")
+            stream = "!bookTicker"
         else:
-            self._add_stream(f"{BinanceSymbol(symbol).lower()}@bookTicker")
+            stream = f"{BinanceSymbol(symbol).lower()}@bookTicker"
+        await self._connect(stream)
 
-    def subscribe_partial_book_depth(
+    async def subscribe_partial_book_depth(
         self,
         symbol: str,
         depth: int,
         speed: int,
     ) -> None:
         """
         Partial Book Depth Streams.
 
         Top bids and asks, Valid are 5, 10, or 20.
         Stream Names: <symbol>@depth<levels> OR <symbol>@depth<levels>@100ms.
         Update Speed: 1000ms or 100ms
 
         """
-        self._add_stream(f"{BinanceSymbol(symbol).lower()}@depth{depth}@{speed}ms")
+        stream = f"{BinanceSymbol(symbol).lower()}@depth{depth}@{speed}ms"
+        await self._connect(stream)
 
-    def subscribe_diff_book_depth(
+    async def subscribe_diff_book_depth(
         self,
         symbol: str,
         speed: int,
     ) -> None:
         """
         Diff book depth stream.
 
         Stream Name: <symbol>@depth OR <symbol>@depth@100ms
         Update Speed: 1000ms or 100ms
         Order book price and quantity depth updates used to locally manage an order book.
 
         """
-        self._add_stream(f"{BinanceSymbol(symbol).lower()}@depth@{speed}ms")
+        stream = f"{BinanceSymbol(symbol).lower()}@depth@{speed}ms"
+        await self._connect(stream)
 
-    def subscribe_mark_price(
+    async def subscribe_mark_price(
         self,
         symbol: Optional[str] = None,
         speed: Optional[int] = None,
     ) -> None:
         """
         Aggregate Trade Streams.
 
         The Aggregate Trade Streams push trade information that is aggregated for a single taker order.
         Stream Name: <symbol>@aggTrade
         Update Speed: 3000ms or 1000ms
 
         """
-        assert speed in (1000, 3000), "`speed` options are 1000ms or 3000ms only"
+        if speed not in (1000, 3000):
+            raise ValueError(f"`speed` options are 1000ms or 3000ms only, was {speed}")
         if symbol is None:
-            self._add_stream("!markPrice@arr")
+            stream = "!markPrice@arr"
         else:
-            self._add_stream(f"{BinanceSymbol(symbol).lower()}@markPrice@{int(speed / 1000)}s")
+            stream = f"{BinanceSymbol(symbol).lower()}@markPrice@{int(speed / 1000)}s"
+        await self._connect(stream)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/backtest/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/error.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/config.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,35 +9,28 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-
-class DeribitError(Exception):
-    """
-    The base class for all `Deribit` specific errors.
-    """
-
-    def __init__(self, status, message, headers):
-        self.status = status
-        self.message = message
-        self.headers = headers
+from nautilus_trader.config import LiveExecClientConfig
 
 
-class DeribitServerError(DeribitError):
+class SandboxExecutionClientConfig(LiveExecClientConfig, frozen=True):
     """
-    Represents an `Deribit` specific 500 series HTTP error.
-    """
-
-    def __init__(self, status, message, headers):
-        super().__init__(status, message, headers)
+    Configuration for ``SandboxExecClient`` instances.
 
+    Parameters
+    ----------
+    venue : str
+        The venue to generate a sandbox execution client for
+    currency: str
+        The currency for this venue
+    balance : int
+        The starting balance for this venue
 
-class DeribitClientError(DeribitError):
-    """
-    Represents an `Deribit` specific 400 series HTTP error.
     """
 
-    def __init__(self, status, message, headers):
-        super().__init__(status, message, headers)
+    venue: str  # type: ignore
+    currency: str  # type: ignore
+    balance: int  # type: ignore
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -8,11 +8,10 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 Provides an API integration for Interactive Brokers.
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx`

 * *Files 9% similar despite different names*

```diff
@@ -9,11 +9,11 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from .client import InteractiveBrokersClient
+from nautilus_trader.indicators.fuzzy_enums.candle_size cimport CandleSize
 
 
-__all__ = ("InteractiveBrokersClient",)
+__all__ = ["CandleSize"]
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/client.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/client/client.py`

 * *Files 0% similar despite different names*

```diff
@@ -199,16 +199,16 @@
         self,
         coro: Coroutine,
         log_msg: Optional[str] = None,
         actions: Optional[Callable] = None,
         success: Optional[str] = None,
     ) -> asyncio.Task:
         """
-        Run the given coroutine with error handling and optional callback
-        actions when done.
+        Run the given coroutine with error handling and optional callback actions when
+        done.
 
         Parameters
         ----------
         coro : Coroutine
             The coroutine to run.
         log_msg : str, optional
             The log message for the task.
@@ -256,15 +256,17 @@
                         f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
                         f"{e!r}",
                     )
             if success:
                 self._log.info(success, LogColor.GREEN)
 
     def _next_req_id(self) -> int:
-        """Get next available request ID."""
+        """
+        Get next available request ID.
+        """
         new_id = self._request_id_seq
         self._request_id_seq += 1
         return new_id
 
     def _reset(self):
         self._stop()
         self._client.reset()
@@ -280,15 +282,15 @@
         self._connection_attempt_counter = 0
 
     def _degrade(self):
         self.is_ready.clear()
         self._accounts = set()
 
     def _stop(self):
-        if not self.registered_nautilus_clients == set():
+        if self.registered_nautilus_clients != set():
             self._log.warning(
                 f"Any registered Clients from {self.registered_nautilus_clients} will disconnect.",
             )
 
         # Cancel tasks
         if self._watch_dog_task:
             self._log.debug("Canceling `watch_dog` task...")
@@ -303,28 +305,28 @@
         self._client.disconnect()
         self.is_ready.clear()
         self._accounts = set()
 
     ##########################################################################
     # Connectivity
     ##########################################################################
-    def error(  # noqa: too complex, Override the EWrapper
+    def error(  # noqa: C901 too complex
         self,
-        req_id,
-        error_code,
-        error_string,
-        advanced_order_reject_json="",
+        req_id: int,
+        error_code: int,
+        error_string: str,
+        advanced_order_reject_json: str = "",
     ) -> None:
         warning_codes = {1101, 1102, 110, 165, 202, 399, 404, 434, 492, 10167}
         is_warning = error_code in warning_codes or 2100 <= error_code < 2200
         msg = f"{'Warning' if is_warning else 'Error'} {error_code} {req_id=}: {error_string}"
 
         # 2104, 2158, 2106: Data connectivity restored
         # 10197: No market data during competing live session
-        if not req_id == -1:
+        if req_id != -1:
             # TODO: Order events & Cleanup/split the Error method
             # Error 10147 req_id=195: OrderId 195 that needs to be cancelled is not found.  # Send cancel event
             # Warning 202 req_id=2078: Order Canceled - reason:  # Send cancel event
             # fields %s(b'4', b'2', b'10019', b'162', b'Historical Market Data Service error message:Trading TWS session is connected from a different IP address', b'')  # noqa
             # fields %s(b'4', b'2', b'10036', b'10190', b'Max number of tick-by-tick requests has been reached.', b'')
             # 10187: Failed to request historical ticks:No market data permissions for ISLAND STK
             if subscription := self.subscriptions.get(req_id=req_id):
@@ -348,15 +350,15 @@
                             f"`is_ib_ready` cleared by {subscription.name}",
                             LogColor.BLUE,
                         )
                         self.is_ib_ready.clear()
             elif request := self.requests.get(req_id=req_id):
                 self._log.warning(f"{error_code}: {error_string}, {request}")
                 self._end_request(req_id, success=False)
-            elif req_id in self._order_id_to_order.keys():
+            elif req_id in self._order_id_to_order:
                 if error_code == 321:
                     # --> Error 321: Error validating request.-'bN' : cause - The API interface is currently in Read-Only mode.
                     order = self._order_id_to_order.get(req_id, None)
                     if order:
                         name = f"orderStatus-{order.account}"
                         if handler := self._event_subscriptions.get(name, None):
                             handler(
@@ -500,15 +502,15 @@
                 f"Unable to connect {self._host}:{self._port} w/ id:{self._client_id}",
             )
         except Exception as e:
             self._log.exception("failed connection", e)
 
     async def _socket_connect(self):
         """
-        Create socket connection with TWS/Gateway
+        Create socket connection with TWS/Gateway.
         """
         try:
             self._client.host = self._host
             self._client.port = self._port
             self._client.clientId = self._client_id
             self._connection_attempt_counter += 1
             self._log.info(
@@ -918,22 +920,23 @@
         if not (cache := self._exec_id_details.get(execution.execId, None)):
             self._exec_id_details[execution.execId] = {}
             cache = self._exec_id_details[execution.execId]
         cache["execution"] = execution
         cache["order_ref"] = execution.orderRef.rsplit(":", 1)[0]
 
         name = f"execDetails-{execution.acctNumber}"
-        if handler := self._event_subscriptions.get(name, None):
-            if cache.get("commission_report"):
-                handler(
-                    order_ref=cache["order_ref"],
-                    execution=cache["execution"],
-                    commission_report=cache["commission_report"],
-                )
-                cache.pop(execution.execId, None)
+        if (handler := self._event_subscriptions.get(name, None)) and cache.get(
+            "commission_report",
+        ):
+            handler(
+                order_ref=cache["order_ref"],
+                execution=cache["execution"],
+                commission_report=cache["commission_report"],
+            )
+            cache.pop(execution.execId, None)
 
     def commissionReport(  # : Override the EWrapper
         self,
         commission_report: CommissionReport,
     ):
         self.logAnswer(current_fn_name(), vars())
         if not (cache := self._exec_id_details.get(commission_report.execId, None)):
@@ -1041,15 +1044,17 @@
     # -- Market Depth ------------------------------------------------------------------------------------
     # -- News Bulletins ----------------------------------------------------------------------------------
     # -- Financial Advisors ------------------------------------------------------------------------------
     def accounts(self):
         return self._accounts.copy()
 
     def managedAccounts(self, accounts_list: str):  # : Override the EWrapper
-        """Received once the connection is established."""
+        """
+        Received once the connection is established.
+        """
         self.logAnswer(current_fn_name(), vars())
         self._accounts = {a for a in accounts_list.split(",") if a}
         if self._next_valid_order_id >= 0 and not self.is_ib_ready.is_set():
             self._log.info("`is_ib_ready` set by managedAccounts", LogColor.BLUE)
             self.is_ib_ready.set()
 
     # -- Historical Data ---------------------------------------------------------------------------------
@@ -1472,15 +1477,17 @@
             if not future.done():
                 future.set_exception(error)
         self._client.reset()
 
     def _end_request(self, req_id, success=True, exception=None):
         """
         Finish the future of corresponding key with the given result.
+
         If no result is given then it will be popped of the general results.
+
         """
         if not (request := self.requests.get(req_id=req_id)):
             return
 
         if not request.future.done():
             if success:
                 request.future.set_result(request.result)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/common.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/client/common.py`

 * *Files 5% similar despite different names*

```diff
@@ -67,26 +67,26 @@
 
     def __init__(self):
         self._req_id_to_name: dict[int, Union[str, tuple]] = {}  # type: ignore
         self._req_id_to_handle: dict[int, Callable] = {}  # type: ignore
         self._req_id_to_cancel: dict[int, Callable] = {}  # type: ignore
 
     def __repr__(self):
-        return f"{self.__class__.__name__}:\n{[self.get(req_id=k) for k in self._req_id_to_name.keys()]!r}"
+        return f"{self.__class__.__name__}:\n{[self.get(req_id=k) for k in self._req_id_to_name]!r}"
 
     def _name_to_req_id(self, name: Any):
         try:
             return list(self._req_id_to_name.keys())[
                 list(self._req_id_to_name.values()).index(name)
             ]
         except ValueError:
             pass
 
     def _validation_check(self, req_id: int, name: Any):
-        if req_id in self._req_id_to_name.keys():
+        if req_id in self._req_id_to_name:
             raise KeyError(
                 f"Duplicate entry not allowed for {req_id=}, found {self.get(req_id=req_id)}",
             )
         elif name in self._req_id_to_name.values():
             raise KeyError(f"Duplicate entry not allowed for {name=}, found {self.get(name=name)}")
 
     def remove(
@@ -97,22 +97,22 @@
         if not req_id:
             req_id = self._name_to_req_id(name)
         for d in [x for x in list(dir(self)) if x.startswith("_req_id_to_")]:
             getattr(self, d).pop(req_id, None)
 
     def get_all(self):
         result = []
-        for req_id in self._req_id_to_name.keys():
+        for req_id in self._req_id_to_name:
             result.append(self.get(req_id=req_id))
         return result
 
     def get(
         self,
         req_id: Optional[int] = None,
-        name: Union[str, tuple] = None,
+        name: Optional[Union[str, tuple]] = None,
     ):
         raise NotImplementedError("method must be implemented in the subclass")
 
 
 class Subscriptions(Base):
     """
     Container for holding the Subscriptions.
@@ -135,15 +135,15 @@
         self._req_id_to_cancel[req_id] = cancel
         self._req_id_to_last[req_id] = None
         return self.get(req_id=req_id)
 
     def get(
         self,
         req_id: Optional[int] = None,
-        name: Union[str, tuple] = None,
+        name: Optional[Union[str, tuple]] = None,
     ):
         if not req_id:
             req_id = self._name_to_req_id(name)
         if not req_id or not (name := self._req_id_to_name.get(req_id, None)):
             return
         return Subscription(
             req_id=req_id,
@@ -184,15 +184,15 @@
         self._req_id_to_future[req_id] = asyncio.Future()
         self._req_id_to_result[req_id] = []
         return self.get(req_id=req_id)
 
     def get(
         self,
         req_id: Optional[int] = None,
-        name: Union[str, tuple] = None,
+        name: Optional[Union[str, tuple]] = None,
     ):
         if not req_id:
             req_id = self._name_to_req_id(name)
         if not req_id or not (name := self._req_id_to_name.get(req_id, None)):
             return
         return Request(
             req_id=req_id,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/common.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/common.py`

 * *Files 1% similar despite different names*

```diff
@@ -70,15 +70,16 @@
     conId: int = 0
     delta: float = 0.0
     price: float = 0.0
 
 
 class IBContract(NautilusConfig, frozen=True, repr_omit_defaults=True):
     """
-    Class describing an instrument's definition with additional fields for options/futures.
+    Class describing an instrument's definition with additional fields for
+    options/futures.
 
     Parameters
     ----------
     secType: str
         Security Type of the contract i.e STK, OPT, FUT, CONTFUT
     exchange: str
         Exchange where security is traded. Will be SMART for Stocks.
@@ -92,14 +93,15 @@
         Search for full futures chain
     min_expiry_days: int (default: None)
         Filters the options_chain and futures_chain which are expiring after number of days specified.
     max_expiry_days: int (default: None)
         Filters the options_chain and futures_chain which are expiring before number of days specified.
     lastTradeDateOrContractMonth: str (%Y%m%d or %Y%m) (default: '')
         Filters the options_chain and futures_chain specific for this expiry date
+
     """
 
     secType: Literal["CASH", "STK", "OPT", "FUT", "FOP", "CONTFUT", "CRYPTO", ""] = ""
     conId: int = 0
     exchange: str = ""
     primaryExchange: str = ""
     symbol: str = ""
@@ -168,15 +170,16 @@
 
     def __str__(self):
         return self.value
 
 
 class IBContractDetails(NautilusConfig, frozen=True, repr_omit_defaults=True):
     """
-    ContractDetails class to be used internally in Nautilus for ease of encoding/decoding.
+    ContractDetails class to be used internally in Nautilus for ease of
+    encoding/decoding.
     """
 
     contract: IBContract = None
     marketName: str = ""
     minTick: float = 0
     orderTypes: str = ""
     validExchanges: str = ""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/config.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/config.py`

 * *Files 4% similar despite different names*

```diff
@@ -40,14 +40,15 @@
         paper or live.
     start: bool, optional
         Start or not internal tws docker container.
     read_only_api: bool, optional, default True
         Read only; no execution. Set read_only_api=False to allow executing live orders.
     timeout: int, optional
         The timeout for trying to start gateway
+
     """
 
     username: Optional[str] = None
     password: Optional[str] = None
     trading_mode: Literal["paper", "live"] = "paper"
     start: bool = False
     read_only_api: bool = True
@@ -72,14 +73,15 @@
         Global setting for all applicable instruments.
     cache_validity_days: int (default: None)
         Default None, will request fresh pull upon starting of TradingNode [only once].
         Setting value will pull the instruments at specified interval, useful when TradingNode runs for many days.
         Example: value set to 1, InstrumentProvider will make fresh pull every day even if TradingNode is not restarted.
     pickle_path: str (default: None)
         If provided valid path, will store the ContractDetails as pickle, and use during cache_validity period.
+
     """
 
     def __eq__(self, other):
         return (
             self.load_ids == other.load_ids
             and self.load_contracts == other.load_contracts
             and self.min_expiry_days == other.min_expiry_days
@@ -126,14 +128,15 @@
         The clients gateway container configuration.
     use_regular_trading_hours : bool
         If True will request data for Regular Trading Hours only.
         Mostly applies to 'STK' security type. Check with InteractiveBrokers for RTH Info.
     market_data_type : bool, default REALTIME
         Set which IBMarketDataTypeEnum to be used by InteractiveBrokersClient.
         Configure `IBMarketDataTypeEnum.DELAYED_FROZEN` to use with account without data subscription.
+
     """
 
     instrument_provider: InteractiveBrokersInstrumentProviderConfig = (
         InteractiveBrokersInstrumentProviderConfig()
     )
 
     ibg_host: str = "127.0.0.1"
@@ -155,19 +158,20 @@
     ibg_port : int, default for "paper" 4002, or "live" 4001
         The port for the gateway server.
     ibg_client_id: int, default 1
         The client_id to be passed into connect call.
     ibg_account_id : str
         The Interactive Brokers account id to which TWS/Gateway is logged on.
         If ``None`` then will source the `TWS_ACCOUNT`.
+
     """
 
     instrument_provider: InteractiveBrokersInstrumentProviderConfig = (
         InteractiveBrokersInstrumentProviderConfig()
     )
     ibg_host: str = "127.0.0.1"
     ibg_port: Optional[int] = None
     ibg_client_id: int = 1
     gateway: InteractiveBrokersGatewayConfig = InteractiveBrokersGatewayConfig()
-    account_id: str = None
+    account_id: Optional[str] = None
 
     # trade_outside_regular_hours (possible to set flag in order)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/data.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/data.py`

 * *Files 1% similar despite different names*

```diff
@@ -83,14 +83,15 @@
             The logger for the client.
         instrument_provider : InteractiveBrokersInstrumentProvider
             The instrument provider.
         ibg_client_id : int
             Client ID used to connect TWS/Gateway.
         config : InteractiveBrokersDataClientConfig
             Configuration for the client.
+
         """
         super().__init__(
             loop=loop,
             client_id=ClientId(f"{IB_VENUE.value}-{ibg_client_id:03d}"),
             venue=None,
             instrument_provider=instrument_provider,
             msgbus=msgbus,
@@ -145,26 +146,26 @@
         )
 
     async def _subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: Optional[int] = None,
-        kwargs: dict[str, Any] = None,
+        kwargs: Optional[dict[str, Any]] = None,
     ) -> None:
         raise NotImplementedError(  # pragma: no cover
             "implement the `_subscribe_order_book_deltas` coroutine",  # pragma: no cover
         )
 
     async def _subscribe_order_book_snapshots(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
         depth: Optional[int] = None,
-        kwargs: dict[str, Any] = None,
+        kwargs: Optional[dict[str, Any]] = None,
     ) -> None:
         raise NotImplementedError(  # pragma: no cover
             "implement the `_subscribe_order_book_snapshots` coroutine",  # pragma: no cover
         )
 
     async def _subscribe_ticker(self, instrument_id: InstrumentId) -> None:
         raise NotImplementedError(  # pragma: no cover
@@ -415,18 +416,15 @@
 
         if not start:
             limit = self._cache.bar_capacity
 
         if not end:
             end = pd.Timestamp.utcnow()
 
-        if bar_type.spec.timedelta.total_seconds() >= 60:
-            duration_str = "7 D"
-        else:
-            duration_str = "1 D"
+        duration_str = "7 D" if bar_type.spec.timedelta.total_seconds() >= 60 else "1 D"
         bars: list[Bar] = []
         while (start and end > start) or (len(bars) < limit):
             self._log.info(f"{start=}", LogColor.MAGENTA)
             self._log.info(f"{end=}", LogColor.MAGENTA)
             self._log.info(f"{limit=}", LogColor.MAGENTA)
             bars_part = await self._client.get_historical_bars(
                 bar_type=bar_type,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/common/execution.py`

 * *Files 21% similar despite different names*

```diff
@@ -10,831 +10,923 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
-import json
-from typing import Any, Optional
+from decimal import Decimal
+from typing import Optional
 
 import pandas as pd
-from ibapi.commission_report import CommissionReport
-from ibapi.common import UNSET_DECIMAL
-from ibapi.common import UNSET_DOUBLE
-from ibapi.execution import Execution
-from ibapi.order import Order as IBOrder
-from ibapi.order_state import OrderState as IBOrderState
-
-# fmt: off
-from nautilus_trader.adapters.interactive_brokers.client import InteractiveBrokersClient
-from nautilus_trader.adapters.interactive_brokers.client.common import IBPosition
-from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_action
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_fields
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_status
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_order_type
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_time_in_force
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import map_trigger_method
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import order_side_to_order_action
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import timestring_to_timestamp
-from nautilus_trader.adapters.interactive_brokers.providers import InteractiveBrokersInstrumentProvider
+
+from nautilus_trader.adapters.binance.common.constants import BINANCE_VENUE
+from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
+from nautilus_trader.adapters.binance.common.enums import BinanceEnumParser
+from nautilus_trader.adapters.binance.common.enums import BinanceErrorCode
+from nautilus_trader.adapters.binance.common.enums import BinanceTimeInForce
+from nautilus_trader.adapters.binance.common.schemas.account import BinanceOrder
+from nautilus_trader.adapters.binance.common.schemas.account import BinanceUserTrade
+from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
+from nautilus_trader.adapters.binance.common.schemas.user import BinanceListenKey
+from nautilus_trader.adapters.binance.config import BinanceExecClientConfig
+from nautilus_trader.adapters.binance.http.account import BinanceAccountHttpAPI
+from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
+from nautilus_trader.adapters.binance.http.error import BinanceError
+from nautilus_trader.adapters.binance.http.market import BinanceMarketHttpAPI
+from nautilus_trader.adapters.binance.http.user import BinanceUserDataHttpAPI
+from nautilus_trader.adapters.binance.websocket.client import BinanceWebSocketClient
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
+from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
+from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.core.rust.common import LogColor
+from nautilus_trader.core.datetime import secs_to_millis
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.execution.messages import CancelAllOrders
 from nautilus_trader.execution.messages import CancelOrder
 from nautilus_trader.execution.messages import ModifyOrder
 from nautilus_trader.execution.messages import SubmitOrder
 from nautilus_trader.execution.messages import SubmitOrderList
 from nautilus_trader.execution.reports import OrderStatusReport
 from nautilus_trader.execution.reports import PositionStatusReport
 from nautilus_trader.execution.reports import TradeReport
 from nautilus_trader.live.execution_client import LiveExecutionClient
-from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.enums import AccountType
-from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OmsType
 from nautilus_trader.model.enums import OrderSide
-from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.enums import OrderType
-from nautilus_trader.model.enums import PositionSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TrailingOffsetType
 from nautilus_trader.model.enums import TriggerType
+from nautilus_trader.model.enums import trailing_offset_type_to_str
+from nautilus_trader.model.enums import trigger_type_to_str
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import TradeId
+from nautilus_trader.model.identifiers import Symbol
 from nautilus_trader.model.identifiers import VenueOrderId
-from nautilus_trader.model.objects import AccountBalance
-from nautilus_trader.model.objects import MarginBalance
-from nautilus_trader.model.objects import Money
 from nautilus_trader.model.objects import Price
-from nautilus_trader.model.objects import Quantity
-from nautilus_trader.model.orders.base import Order
-from nautilus_trader.model.orders.limit_if_touched import LimitIfTouchedOrder
-from nautilus_trader.model.orders.market_if_touched import MarketIfTouchedOrder
-from nautilus_trader.model.orders.stop_limit import StopLimitOrder
-from nautilus_trader.model.orders.stop_market import StopMarketOrder
-from nautilus_trader.model.orders.trailing_stop_limit import TrailingStopLimitOrder
-from nautilus_trader.model.orders.trailing_stop_market import TrailingStopMarketOrder
+from nautilus_trader.model.orders import LimitOrder
+from nautilus_trader.model.orders import MarketOrder
+from nautilus_trader.model.orders import Order
+from nautilus_trader.model.orders import StopLimitOrder
+from nautilus_trader.model.orders import StopMarketOrder
+from nautilus_trader.model.orders import TrailingStopMarketOrder
+from nautilus_trader.model.position import Position
 from nautilus_trader.msgbus.bus import MessageBus
 
 
-# fmt: on
-
-ib_to_nautilus_trigger_method = dict(zip(map_trigger_method.values(), map_trigger_method.keys()))
-ib_to_nautilus_time_in_force = dict(zip(map_time_in_force.values(), map_time_in_force.keys()))
-ib_to_nautilus_order_side = dict(zip(map_order_action.values(), map_order_action.keys()))
-ib_to_nautilus_order_type = dict(zip(map_order_type.values(), map_order_type.keys()))
-
-
-class InteractiveBrokersExecutionClient(LiveExecutionClient):
+class BinanceCommonExecutionClient(LiveExecutionClient):
     """
-    Provides an execution client for Interactive Brokers TWS API.
+    Execution client providing common functionality for the `Binance` exchanges.
 
     Parameters
     ----------
     loop : asyncio.AbstractEventLoop
         The event loop for the client.
-    client : InteractiveBrokersClient
-        The nautilus InteractiveBrokersClient using ibapi.
-    account_id: AccountId
-        Account ID associated with this client.
+    client : BinanceHttpClient
+        The binance HTTP client.
+    account : BinanceAccountHttpAPI
+        The binance Account HTTP API.
+    market : BinanceMarketHttpAPI
+        The binance Market HTTP API.
+    user : BinanceUserHttpAPI
+        The binance User HTTP API.
+    enum_parser : BinanceEnumParser
+        The parser for Binance enums.
     msgbus : MessageBus
         The message bus for the client.
     cache : Cache
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
-    instrument_provider : InteractiveBrokersInstrumentProvider
+    instrument_provider : BinanceSpotInstrumentProvider
         The instrument provider.
-    ibg_client_id : int
-        Client ID used to connect TWS/Gateway.
+    account_type : BinanceAccountType
+        The account type for the client.
+    base_url_ws : str
+        The base URL for the WebSocket client.
+    config : BinanceExecClientConfig
+        The configuration for the client.
+
+    Warnings
+    --------
+    This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: InteractiveBrokersClient,
-        account_id: AccountId,
+        client: BinanceHttpClient,
+        account: BinanceAccountHttpAPI,
+        market: BinanceMarketHttpAPI,
+        user: BinanceUserDataHttpAPI,
+        enum_parser: BinanceEnumParser,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        instrument_provider: InteractiveBrokersInstrumentProvider,
-        ibg_client_id: int,
-    ):
+        instrument_provider: InstrumentProvider,
+        account_type: BinanceAccountType,
+        base_url_ws: str,
+        config: BinanceExecClientConfig,
+    ) -> None:
         super().__init__(
             loop=loop,
-            # client_id=ClientId(f"{IB_VENUE.value}-{ibg_client_id:03d}"), # TODO: Fix account_id.get_id()
-            client_id=ClientId(f"{IB_VENUE.value}"),
-            venue=IB_VENUE,
-            oms_type=OmsType.NETTING,
+            client_id=ClientId(BINANCE_VENUE.value),
+            venue=BINANCE_VENUE,
+            oms_type=OmsType.HEDGING if account_type.is_futures else OmsType.NETTING,
             instrument_provider=instrument_provider,
-            account_type=AccountType.MARGIN,
-            base_currency=None,  # IB accounts are multi-currency
+            account_type=AccountType.CASH if account_type.is_spot else AccountType.MARGIN,
+            base_currency=None,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
-            config={
-                "name": f"{type(self).__name__}-{ibg_client_id:03d}",
-                "client_id": ibg_client_id,
-            },
-        )
-        self._client: InteractiveBrokersClient = client
-        self._set_account_id(account_id)
-        self._account_summary_tags = {
-            "NetLiquidation",
-            "FullAvailableFunds",
-            "FullInitMarginReq",
-            "FullMaintMarginReq",
-        }
+        )
 
-        self._account_summary_loaded: asyncio.Event = asyncio.Event()
+        self._binance_account_type = account_type
+        self._use_reduce_only = config.use_reduce_only
+        self._use_position_ids = config.use_position_ids
+        self._treat_expired_as_canceled = config.treat_expired_as_canceled
+        self._log.info(f"Account type: {self._binance_account_type.value}.", LogColor.BLUE)
+        self._log.info(f"{config.use_reduce_only=}", LogColor.BLUE)
+        self._log.info(f"{config.use_position_ids=}", LogColor.BLUE)
+        self._log.info(f"{config.treat_expired_as_canceled=}", LogColor.BLUE)
+        self._log.info(f"{config.max_retries=}", LogColor.BLUE)
+        self._log.info(f"{config.retry_delay=}", LogColor.BLUE)
+
+        self._set_account_id(AccountId(f"{BINANCE_VENUE.value}-spot-master"))
+
+        # Enum parser
+        self._enum_parser = enum_parser
+
+        # Http API
+        self._http_client = client
+        self._http_account = account
+        self._http_market = market
+        self._http_user = user
+
+        # Listen keys
+        self._ping_listen_keys_interval: int = 60 * 5  # Once every 5 mins (hardcode)
+        self._ping_listen_keys_task: Optional[asyncio.Task] = None
+        self._listen_key: Optional[str] = None
+
+        # WebSocket API
+        self._ws_client = BinanceWebSocketClient(
+            clock=clock,
+            logger=logger,
+            handler=self._handle_user_ws_message,
+            base_url=base_url_ws,
+        )
 
         # Hot caches
-        self._account_summary: dict[str, dict[str, Any]] = {}
+        self._instrument_ids: dict[str, InstrumentId] = {}
+        self._generate_order_status_retries: dict[ClientOrderId, int] = {}
+        self._modifying_orders: dict[ClientOrderId, VenueOrderId] = {}
+
+        # Order submission method hashmap
+        self._submit_order_method = {
+            OrderType.MARKET: self._submit_market_order,
+            OrderType.LIMIT: self._submit_limit_order,
+            OrderType.STOP_LIMIT: self._submit_stop_limit_order,
+            OrderType.LIMIT_IF_TOUCHED: self._submit_stop_limit_order,
+            OrderType.STOP_MARKET: self._submit_stop_market_order,
+            OrderType.MARKET_IF_TOUCHED: self._submit_stop_market_order,
+            OrderType.TRAILING_STOP_MARKET: self._submit_trailing_stop_market_order,
+        }
+
+        self._recv_window = 5_000
+
+        # Retry logic (hard coded for now)
+        self._max_retries: int = config.max_retries or 0
+        self._retry_delay: float = config.retry_delay or 1.0
+        self._retry_errors: set[BinanceErrorCode] = {
+            BinanceErrorCode.DISCONNECTED,
+            BinanceErrorCode.TOO_MANY_REQUESTS,  # Short retry delays may result in bans
+            BinanceErrorCode.TIMEOUT,
+            BinanceErrorCode.INVALID_TIMESTAMP,
+            BinanceErrorCode.CANCEL_REJECTED,
+            BinanceErrorCode.ME_RECVWINDOW_REJECT,
+        }
+
+        self._order_retries: dict[ClientOrderId, int] = {}
+
+        self._log.info(f"Base URL HTTP {self._http_client.base_url}.", LogColor.BLUE)
+        self._log.info(f"Base URL WebSocket {base_url_ws}.", LogColor.BLUE)
 
     @property
-    def instrument_provider(self) -> InteractiveBrokersInstrumentProvider:
-        return self._instrument_provider  # type: ignore
+    def use_position_ids(self) -> bool:
+        """
+        Whether a `position_id` will be assigned to order events generated by the
+        client.
 
-    async def _connect(self):
-        # Connect client
-        await self._client.is_running_async()
-        await self.instrument_provider.initialize()
+        Returns
+        -------
+        bool
 
-        # Validate if connected to expected TWS/Gateway using Account
-        if self.account_id.get_id() in self._client.accounts():
-            self._log.info(
-                f"Account `{self.account_id.get_id()}` found in the connected TWS/Gateway.",
-                LogColor.GREEN,
-            )
-        else:
-            self.fault()
-            raise ValueError(
-                f"Account `{self.account_id.get_id()}` not found in the connected TWS/Gateway. "
-                f"Available accounts are {self._client.accounts()}",
-            )
-
-        # Event hooks
-        account = self.account_id.get_id()
-        self._client.registered_nautilus_clients.add(self.id)
-        self._client.subscribe_event(f"accountSummary-{account}", self._on_account_summary)
-        self._client.subscribe_event(f"openOrder-{account}", self._on_open_order)
-        self._client.subscribe_event(f"orderStatus-{account}", self._on_order_status)
-        self._client.subscribe_event(f"execDetails-{account}", self._on_exec_details)
-
-        # Load account balance
-        self._client.subscribe_account_summary()
-        await self._account_summary_loaded.wait()
-
-        self._set_connected(True)
-
-    async def _disconnect(self):
-        self._client.registered_nautilus_clients.discard(self.id)
-        if self._client.is_running and self._client.registered_nautilus_clients == set():
-            self._client.stop()
-        self._set_connected(False)
+        """
+        return self._use_position_ids
+
+    @property
+    def treat_expired_as_canceled(self) -> bool:
+        """
+        Whether the `EXPIRED` execution type is treated as a `CANCEL`.
+
+        Returns
+        -------
+        bool
+
+        """
+        return self._treat_expired_as_canceled
+
+    async def _connect(self) -> None:
+        try:
+            # Initialize instrument provider
+            await self._instrument_provider.initialize()
+
+            # Authenticate API key and update account(s)
+            await self._update_account_state()
+
+            # Get listen keys
+            response: BinanceListenKey = await self._http_user.create_listen_key()
+        except BinanceError as e:
+            self._log.exception(f"Error on connect: {e.message}", e)
+            return
+
+        # Check Binance-Nautilus clock sync
+        server_time: int = await self._http_market.request_server_time()
+        self._log.info(f"Binance server time {server_time} UNIX (ms).")
+
+        nautilus_time: int = self._clock.timestamp_ms()
+        self._log.info(f"Nautilus clock time {nautilus_time} UNIX (ms).")
+
+        # Setup WebSocket listen key
+        self._listen_key = response.listenKey
+        self._log.info(f"Listen key {self._listen_key}")
+        self._ping_listen_keys_task = self.create_task(self._ping_listen_keys())
+
+        # Connect WebSocket client
+        await self._ws_client.connect(self._listen_key)
+
+    async def _update_account_state(self) -> None:
+        # Replace method in child class
+        raise NotImplementedError
+
+    async def _ping_listen_keys(self) -> None:
+        try:
+            while True:
+                self._log.debug(
+                    f"Scheduled `ping_listen_keys` to run in "
+                    f"{self._ping_listen_keys_interval}s.",
+                )
+                await asyncio.sleep(self._ping_listen_keys_interval)
+                if self._listen_key:
+                    self._log.debug(f"Pinging WebSocket listen key {self._listen_key}...")
+                    await self._http_user.keepalive_listen_key(listen_key=self._listen_key)
+        except asyncio.CancelledError:
+            self._log.debug("`ping_listen_keys` task was canceled.")
+
+    async def _disconnect(self) -> None:
+        # Cancel tasks
+        if self._ping_listen_keys_task:
+            self._log.debug("Canceling `ping_listen_keys` task...")
+            self._ping_listen_keys_task.cancel()
+            self._ping_listen_keys_task = None
+
+        # if self._ws_client.is_connected:
+        await self._ws_client.disconnect()
+
+    # -- EXECUTION REPORTS ------------------------------------------------------------------------
 
     async def generate_order_status_report(
         self,
         instrument_id: InstrumentId,
         client_order_id: Optional[ClientOrderId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
     ) -> Optional[OrderStatusReport]:
-        """
-        Generate an `OrderStatusReport` for the given order identifier parameter(s).
-        If the order is not found, or an error occurs, then logs and returns ``None``.
-
-        Parameters
-        ----------
-        instrument_id : InstrumentId
-            The instrument ID for the report.
-        client_order_id : ClientOrderId, optional
-            The client order ID for the report.
-        venue_order_id : VenueOrderId, optional
-            The venue order ID for the report.
-
-        Returns
-        -------
-        OrderStatusReport or ``None``
-        Raises
-        ------
-        ValueError
-            If both the `client_order_id` and `venue_order_id` are ``None``.
-        """
-        PyCondition.type_or_none(client_order_id, ClientOrderId, "client_order_id")
-        PyCondition.type_or_none(venue_order_id, VenueOrderId, "venue_order_id")
-        if not (client_order_id or venue_order_id):
-            self._log.debug("Both `client_order_id` and `venue_order_id` cannot be None.")
-            return None
+        PyCondition.false(
+            client_order_id is None and venue_order_id is None,
+            "both `client_order_id` and `venue_order_id` were `None`",
+        )
 
-        report = None
-        ib_orders = await self._client.get_open_orders(self.account_id.get_id())
-        for ib_order in ib_orders:
-            if (client_order_id and client_order_id.value == ib_order.orderRef) or (
-                venue_order_id
-                and venue_order_id.value
-                == str(
-                    ib_order.orderId,
-                )
-            ):
-                report = await self._parse_ib_order_to_order_status_report(ib_order)
-                break
-        if report is None:  # TODO: Further testing
-            self._log.warning(
-                f"Order {client_order_id=}, {venue_order_id} not found, Cancelling...",
-            )
-            self._on_order_status(
-                order_ref=client_order_id.value,
-                order_status="Cancelled",
-                reason="Not found in query",
+        retries = self._generate_order_status_retries.get(client_order_id, 0)
+        if retries > 3:
+            self._log.error(
+                f"Reached maximum retries 3/3 for generating OrderStatusReport for "
+                f"{repr(client_order_id) if client_order_id else ''} "
+                f"{repr(venue_order_id) if venue_order_id else ''}...",
             )
-        return report
+            return None
 
-    async def _parse_ib_order_to_order_status_report(self, ib_order: IBOrder):
-        self._log.debug(f"Trying OrderStatusReport for {ib_order}")
-        instrument = await self.instrument_provider.find_with_contract_id(
-            ib_order.contract.conId,
-        )
-
-        total_qty = (
-            Quantity.from_int(0)
-            if ib_order.totalQuantity == UNSET_DECIMAL
-            else Quantity.from_str(str(ib_order.totalQuantity))
-        )
-        filled_qty = (
-            Quantity.from_int(0)
-            if ib_order.filledQuantity == UNSET_DECIMAL
-            else Quantity.from_str(str(ib_order.filledQuantity))
-        )
-        if total_qty.as_double() > filled_qty.as_double() > 0:
-            order_status = OrderStatus.PARTIALLY_FILLED
-        else:
-            order_status = map_order_status[ib_order.order_state.status]
-        ts_init = self._clock.timestamp_ns()
-        price = (
-            None if ib_order.lmtPrice == UNSET_DOUBLE else Price.from_str(str(ib_order.lmtPrice))
+        self._log.info(
+            f"Generating OrderStatusReport for "
+            f"{repr(client_order_id) if client_order_id else ''} "
+            f"{repr(venue_order_id) if venue_order_id else ''}...",
         )
-        if ib_order.tif == "GTD":
-            expire_time = timestring_to_timestamp(ib_order.goodTillDate)
-        else:
-            expire_time = None
 
-        # TODO: Testing for advanced Open orders
-        order_status = OrderStatusReport(
+        try:
+            if venue_order_id:
+                binance_order = await self._http_account.query_order(
+                    symbol=instrument_id.symbol.value,
+                    order_id=int(venue_order_id.value),
+                )
+            else:
+                binance_order = await self._http_account.query_order(
+                    symbol=instrument_id.symbol.value,
+                    orig_client_order_id=client_order_id.value
+                    if client_order_id is not None
+                    else None,
+                )
+        except BinanceError as e:
+            retries += 1
+            self._log.error(
+                f"Cannot generate order status report for {client_order_id!r}: {e.message}. Retry {retries}/3",
+            )
+            self._generate_order_status_retries[client_order_id] = retries
+            if not client_order_id:
+                self._log.warning("Cannot retry without a client order ID.")
+            else:
+                order: Optional[Order] = self._cache.order(client_order_id)
+                if order is None:
+                    self._log.warning("Order not found in cache.")
+                    return None
+                elif order.is_closed:
+                    return None  # Nothing else to do
+
+                if retries >= 3:
+                    # Order will no longer be considered in-flight once this event is applied.
+                    # We could pop the value out of the hashmap here, but better to leave it in
+                    # so that there are no longer subsequent retries (we don't expect many of these).
+                    self.generate_order_rejected(
+                        strategy_id=order.strategy_id,
+                        instrument_id=instrument_id,
+                        client_order_id=client_order_id,
+                        reason=str(e.message),
+                        ts_event=self._clock.timestamp_ns(),
+                    )
+            return None  # Error now handled
+
+        if not binance_order or (binance_order.origQty and Decimal(binance_order.origQty) == 0):
+            # Cannot proceed to generating report
+            self._log.error(
+                f"Cannot generate `OrderStatusReport` for {client_order_id=!r}, {venue_order_id=!r}: "
+                "order not found.",
+            )
+            return None
+
+        report: OrderStatusReport = binance_order.parse_to_order_status_report(
             account_id=self.account_id,
-            instrument_id=instrument.id,
-            venue_order_id=VenueOrderId(str(ib_order.orderId)),
-            order_side=ib_to_nautilus_order_side[ib_order.action],
-            order_type=ib_to_nautilus_order_type[ib_order.orderType],
-            time_in_force=ib_to_nautilus_time_in_force[ib_order.tif],
-            order_status=order_status,
-            quantity=total_qty,
-            filled_qty=filled_qty,
+            instrument_id=self._get_cached_instrument_id(binance_order.symbol),
             report_id=UUID4(),
-            ts_accepted=ts_init,
-            ts_last=ts_init,
-            ts_init=ts_init,
-            client_order_id=ClientOrderId(ib_order.orderRef),
-            # order_list_id=,
-            # contingency_type=,
-            expire_time=expire_time,
-            price=price,
-            trigger_price=Price.from_str(str(ib_order.auxPrice)),
-            trigger_type=TriggerType.BID_ASK,
-            # limit_offset=,
-            # trailing_offset=,
+            enum_parser=self._enum_parser,
+            treat_expired_as_canceled=self._treat_expired_as_canceled,
+            ts_init=self._clock.timestamp_ns(),
         )
-        self._log.debug(f"Received {order_status!r}")
-        return order_status
+
+        self._log.debug(f"Received {report}.")
+        return report
+
+    def _get_cache_active_symbols(self) -> set[str]:
+        # Check cache for all active symbols
+        open_orders: list[Order] = self._cache.orders_open(venue=self.venue)
+        open_positions: list[Position] = self._cache.positions_open(venue=self.venue)
+        active_symbols: set[str] = set()
+        for o in open_orders:
+            active_symbols.add(BinanceSymbol(o.instrument_id.symbol.value))
+        for p in open_positions:
+            active_symbols.add(BinanceSymbol(p.instrument_id.symbol.value))
+        return active_symbols
+
+    async def _get_binance_position_status_reports(
+        self,
+        symbol: Optional[str] = None,
+    ) -> list[PositionStatusReport]:
+        # Implement in child class
+        raise NotImplementedError
+
+    async def _get_binance_active_position_symbols(
+        self,
+        symbol: Optional[str] = None,
+    ) -> set[str]:
+        # Implement in child class
+        raise NotImplementedError
 
     async def generate_order_status_reports(
         self,
         instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
         open_only: bool = False,
     ) -> list[OrderStatusReport]:
-        """
-        Generate a list of `OrderStatusReport`s with optional query filters.
-        The returned list may be empty if no orders match the given parameters.
-
-        Parameters
-        ----------
-        instrument_id : InstrumentId, optional
-            The instrument ID query filter.
-        start : pd.Timestamp, optional
-            The start datetime query filter.
-        end : pd.Timestamp, optional
-            The end datetime query filter.
-        open_only : bool, default False
-            If the query is for open orders only.
+        self._log.info("Requesting OrderStatusReports...")
 
-        Returns
-        -------
-        list[OrderStatusReport]
-        """
-        report = []
-        # Create the Filled OrderStatusReport from Open Positions
-        positions: list[IBPosition] = await self._client.get_positions(self.account_id.get_id())
-        ts_init = self._clock.timestamp_ns()
-        for position in positions:
-            self._log.debug(f"Trying OrderStatusReport for {position.contract.conId}")
-            if position.quantity > 0:
-                order_side = OrderSide.BUY
-            elif position.quantity < 0:
-                order_side = OrderSide.SELL
-            else:
-                order_side = OrderSide.NO_ORDER_SIDE
-                continue  # Skip, IB may continue to display closed positions
-
-            instrument = await self.instrument_provider.find_with_contract_id(
-                position.contract.conId,
-            )
-            avg_px = instrument.make_price(
-                position.avg_cost / instrument.multiplier,
-            ).as_decimal()
-            quantity = Quantity.from_str(str(position.quantity.copy_abs()))
-            order_status = OrderStatusReport(
+        try:
+            # Check Binance for all order active symbols
+            symbol = instrument_id.symbol.value if instrument_id is not None else None
+            active_symbols = self._get_cache_active_symbols()
+            active_symbols.update(await self._get_binance_active_position_symbols(symbol))
+            binance_open_orders = await self._http_account.query_open_orders(symbol)
+            for order in binance_open_orders:
+                active_symbols.add(order.symbol)
+            # Get all orders for those active symbols
+            binance_orders: list[BinanceOrder] = []
+            for symbol in active_symbols:
+                response = await self._http_account.query_all_orders(
+                    symbol=symbol,
+                    start_time=secs_to_millis(start.timestamp()) if start is not None else None,
+                    end_time=secs_to_millis(end.timestamp()) if end is not None else None,
+                )
+                binance_orders.extend(response)
+        except BinanceError as e:
+            self._log.exception(f"Cannot generate OrderStatusReport: {e.message}", e)
+            return []
+
+        reports: list[OrderStatusReport] = []
+        for order in binance_orders:
+            if order.origQty and Decimal(order.origQty) == 0:
+                continue  # Cannot parse zero quantity order (filter for Binance)
+            report = order.parse_to_order_status_report(
                 account_id=self.account_id,
-                instrument_id=instrument.id,
-                venue_order_id=VenueOrderId(instrument.id.value),
-                order_side=order_side,
-                order_type=OrderType.MARKET,
-                time_in_force=TimeInForce.FOK,
-                order_status=OrderStatus.FILLED,
-                quantity=quantity,
-                filled_qty=quantity,
-                avg_px=avg_px,
+                instrument_id=self._get_cached_instrument_id(order.symbol),
                 report_id=UUID4(),
-                ts_accepted=ts_init,
-                ts_last=ts_init,
-                ts_init=ts_init,
-                client_order_id=ClientOrderId(instrument.id.value),
-            )
-            self._log.debug(f"Received {order_status!r}")
-            report.append(order_status)
-
-        # Create the Open OrderStatusReport from Open Orders
-        ib_orders = await self._client.get_open_orders(self.account_id.get_id())
-        for ib_order in ib_orders:
-            order_status = await self._parse_ib_order_to_order_status_report(ib_order)
-            report.append(order_status)
-        return report
+                enum_parser=self._enum_parser,
+                treat_expired_as_canceled=self._treat_expired_as_canceled,
+                ts_init=self._clock.timestamp_ns(),
+            )
+            self._log.debug(f"Received {reports}.")
+            reports.append(report)
+
+        len_reports = len(reports)
+        plural = "" if len_reports == 1 else "s"
+        self._log.info(f"Received {len(reports)} OrderStatusReport{plural}.")
+
+        return reports
 
     async def generate_trade_reports(
         self,
         instrument_id: Optional[InstrumentId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[TradeReport]:
-        """
-        Generate a list of `TradeReport`s with optional query filters.
-        The returned list may be empty if no trades match the given parameters.
+        self._log.info("Requesting TradeReports...")
+
+        try:
+            # Check Binance for all trades on active symbols
+            symbol = instrument_id.symbol.value if instrument_id is not None else None
+            active_symbols = self._get_cache_active_symbols()
+            active_symbols.update(await self._get_binance_active_position_symbols(symbol))
+            binance_trades: list[BinanceUserTrade] = []
+            for symbol in active_symbols:
+                response = await self._http_account.query_user_trades(
+                    symbol=symbol,
+                    start_time=secs_to_millis(start.timestamp()) if start is not None else None,
+                    end_time=secs_to_millis(end.timestamp()) if end is not None else None,
+                )
+                binance_trades.extend(response)
+        except BinanceError as e:
+            self._log.exception(f"Cannot generate TradeReport: {e.message}", e)
+            return []
+
+        # Parse all Binance trades
+        reports: list[TradeReport] = []
+        for trade in binance_trades:
+            if trade.symbol is None:
+                self._log.warning(f"No symbol for trade {trade}.")
+                continue
+            report = trade.parse_to_trade_report(
+                account_id=self.account_id,
+                instrument_id=self._get_cached_instrument_id(trade.symbol),
+                report_id=UUID4(),
+                ts_init=self._clock.timestamp_ns(),
+                use_position_ids=self._use_position_ids,
+            )
+            self._log.debug(f"Received {report}.")
+            reports.append(report)
 
-        Parameters
-        ----------
-        instrument_id : InstrumentId, optional
-            The instrument ID query filter.
-        venue_order_id : VenueOrderId, optional
-            The venue order ID (assigned by the venue) query filter.
-        start : pd.Timestamp, optional
-            The start datetime query filter.
-        end : pd.Timestamp, optional
-            The end datetime query filter.
+        # Confirm sorting in ascending order
+        reports = sorted(reports, key=lambda x: x.trade_id)
 
-        Returns
-        -------
-        list[TradeReport]
-        """
-        self._log.warning("Cannot generate `list[TradeReport]`: not yet implemented.")
+        len_reports = len(reports)
+        plural = "" if len_reports == 1 else "s"
+        self._log.info(f"Received {len(reports)} TradeReport{plural}.")
 
-        return []  # TODO: Implement
+        return reports
 
     async def generate_position_status_reports(
         self,
         instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[PositionStatusReport]:
-        """
-        Generate a list of `PositionStatusReport`s with optional query filters.
-        The returned list may be empty if no positions match the given parameters.
+        self._log.info("Requesting PositionStatusReports...")
 
-        Parameters
-        ----------
-        instrument_id : InstrumentId, optional
-            The instrument ID query filter.
-        start : pd.Timestamp, optional
-            The start datetime query filter.
-        end : pd.Timestamp, optional
-            The end datetime query filter.
+        try:
+            symbol = instrument_id.symbol.value if instrument_id is not None else None
+            reports = await self._get_binance_position_status_reports(symbol)
+        except BinanceError as e:
+            self._log.exception(f"Cannot generate PositionStatusReport: {e.message}", e)
+            return []
+
+        len_reports = len(reports)
+        plural = "" if len_reports == 1 else "s"
+        self._log.info(f"Received {len(reports)} PositionStatusReport{plural}.")
+
+        return reports
+
+    # -- COMMAND HANDLERS -------------------------------------------------------------------------
+
+    def _check_order_validity(self, order: Order) -> None:
+        # Implement in child class
+        raise NotImplementedError
+
+    def _should_retry(self, error_code: BinanceErrorCode, retries: int) -> bool:
+        if (
+            error_code not in self._retry_errors
+            or not self._max_retries
+            or retries > self._max_retries
+        ):
+            return False
+        return True
 
-        Returns
-        -------
-        list[PositionStatusReport]
-        """
-        report = []
-        positions: list[IBPosition] = await self._client.get_positions(self.account_id.get_id())
-        for position in positions:
-            self._log.debug(f"Trying PositionStatusReport for {position.contract.conId}")
-            if position.quantity > 0:
-                side = PositionSide.LONG
-            elif position.quantity < 0:
-                side = PositionSide.SHORT
-            else:
-                continue  # Skip, IB may continue to display closed positions
+    def _determine_reduce_only(self, order: Order) -> bool:
+        return order.is_reduce_only if self._use_reduce_only else False
 
-            instrument = await self.instrument_provider.find_with_contract_id(
-                position.contract.conId,
-            )
-            if not self._cache.instrument(instrument.id):
-                self._msgbus.send(endpoint="DataEngine.process", msg=instrument)
+    def _determine_reduce_only_str(self, order: Order) -> Optional[str]:
+        if self._binance_account_type.is_futures:
+            return str(self._determine_reduce_only(order))
+        return None
 
-            position_status = PositionStatusReport(
-                account_id=self.account_id,
-                instrument_id=instrument.id,
-                position_side=side,
-                quantity=Quantity.from_str(str(abs(position.quantity))),
-                report_id=UUID4(),
-                ts_last=self._clock.timestamp_ns(),
-                ts_init=self._clock.timestamp_ns(),
-            )
-            self._log.debug(f"Received {position_status!r}")
-            report.append(position_status)
+    async def _submit_order(self, command: SubmitOrder) -> None:
+        await self._submit_order_inner(command.order)
 
-        return report
+    async def _submit_order_inner(self, order: Order) -> None:
+        if order.is_closed:
+            self._log.warning(f"Cannot submit already closed order {order}.")
+            return
 
-    def _transform_order(self, order: Order) -> IBOrder:
-        ib_order = IBOrder()
-        for key, field, fn in map_order_fields:
-            if value := getattr(order, key, None):
-                setattr(ib_order, field, fn(value))
-
-        if isinstance(order, TrailingStopLimitOrder) or isinstance(order, TrailingStopMarketOrder):
-            ib_order.auxPrice = float(order.trailing_offset)
-            if order.trigger_price:
-                ib_order.trailStopPrice = order.trigger_price.as_double()
-                ib_order.triggerMethod = map_trigger_method[order.trigger_type]
-        elif (
-            isinstance(order, MarketIfTouchedOrder)
-            or isinstance(order, LimitIfTouchedOrder)
-            or isinstance(order, StopLimitOrder)
-            or isinstance(order, StopMarketOrder)
-        ):
-            if order.trigger_price:
-                ib_order.auxPrice = order.trigger_price.as_double()
+        # Check validity
+        self._check_order_validity(order)
+        self._log.debug(f"Submitting {order}.")
+
+        # Generate event here to ensure correct ordering of events
+        self.generate_order_submitted(
+            strategy_id=order.strategy_id,
+            instrument_id=order.instrument_id,
+            client_order_id=order.client_order_id,
+            ts_event=self._clock.timestamp_ns(),
+        )
 
-        details = self.instrument_provider.contract_details[order.instrument_id.value]
-        ib_order.contract = details.contract
-        ib_order.account = self.account_id.get_id()
-        ib_order.clearingAccount = self.account_id.get_id()
+        while True:
+            try:
+                await self._submit_order_method[order.order_type](order)
+                self._order_retries.pop(order.client_order_id, None)
+                break  # Successful request
+            except KeyError:
+                raise RuntimeError(f"unsupported order type, was {order.order_type}")
+            except BinanceError as e:
+                error_code = BinanceErrorCode(e.message["code"])
+
+                retries = self._order_retries.get(order.client_order_id, 0) + 1
+                self._order_retries[order.client_order_id] = retries
+
+                if not self._should_retry(error_code, retries):
+                    self.generate_order_rejected(
+                        strategy_id=order.strategy_id,
+                        instrument_id=order.instrument_id,
+                        client_order_id=order.client_order_id,
+                        reason=str(e.message),
+                        ts_event=self._clock.timestamp_ns(),
+                    )
+                    break
+
+                self._log.warning(
+                    f"{error_code.name}: retrying {order.client_order_id!r} "
+                    f"{retries}/{self._max_retries} in {self._retry_delay}s ...",
+                )
+                await asyncio.sleep(self._retry_delay)
 
-        if order.tags:
-            return self._attach_order_tags(ib_order, order)
-        else:
-            return ib_order
+    async def _submit_market_order(self, order: MarketOrder) -> None:
+        await self._http_account.new_order(
+            symbol=order.instrument_id.symbol.value,
+            side=self._enum_parser.parse_internal_order_side(order.side),
+            order_type=self._enum_parser.parse_internal_order_type(order),
+            quantity=str(order.quantity),
+            reduce_only=self._determine_reduce_only_str(order),
+            new_client_order_id=order.client_order_id.value,
+            recv_window=str(self._recv_window),
+        )
 
-    def _attach_order_tags(self, ib_order: IBOrder, order: Order) -> IBOrder:
-        try:
-            tags: dict = json.loads(order.tags)
-            for tag in tags:
-                if tag == "conditions":
-                    for condition in tags[tag]:
-                        pass  # TODO:
-                else:
-                    setattr(ib_order, tag, tags[tag])
-            return ib_order
-        except (json.JSONDecodeError, TypeError):
-            self._log.warning(
-                f"{order.client_order_id} {order.tags=} ignored, must be valid IBOrderTags.value",
+    async def _submit_limit_order(self, order: LimitOrder) -> None:
+        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
+        if order.time_in_force == TimeInForce.GTD and time_in_force == BinanceTimeInForce.GTC:
+            self._log.info(
+                f"Converted GTD `time_in_force` to GTC for {order.client_order_id}.",
+                LogColor.BLUE,
             )
-            return ib_order
+        if order.is_post_only and self._binance_account_type.is_spot_or_margin:
+            time_in_force = None
+        elif order.is_post_only and self._binance_account_type.is_futures:
+            time_in_force = BinanceTimeInForce.GTX
+
+        await self._http_account.new_order(
+            symbol=order.instrument_id.symbol.value,
+            side=self._enum_parser.parse_internal_order_side(order.side),
+            order_type=self._enum_parser.parse_internal_order_type(order),
+            time_in_force=time_in_force,
+            quantity=str(order.quantity),
+            price=str(order.price),
+            iceberg_qty=str(order.display_qty) if order.display_qty is not None else None,
+            reduce_only=self._determine_reduce_only_str(order),
+            new_client_order_id=order.client_order_id.value,
+            recv_window=str(self._recv_window),
+        )
 
-    async def _submit_order(self, command: SubmitOrder) -> None:
-        PyCondition.type(command, SubmitOrder, "command")
-        # Reject the non-compliant orders.
-        # These conditions are based on available info and can be relaxed if there is use case.
-        reject_reason = None
-        if getattr(command.order, "trailing_offset_type", None) not in [
-            TrailingOffsetType.PRICE,
-            None,
-        ]:
-            reject_reason = f"{command.order.trailing_offset_type!r} not implemented"
-        elif getattr(command.order, "is_post_only", None) is True:
-            reject_reason = (
-                "post_only=True, `Marketing making` not supported by InteractiveBrokers."
-            )
-        if reject_reason:
-            self._handle_order_event(
-                status=OrderStatus.REJECTED,
-                order=command.order,
-                reason=reject_reason,
+    async def _submit_stop_limit_order(self, order: StopLimitOrder) -> None:
+        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
+
+        if self._binance_account_type.is_spot_or_margin:
+            working_type = None
+        elif order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
+            working_type = "CONTRACT_PRICE"
+        elif order.trigger_type == TriggerType.MARK_PRICE:
+            working_type = "MARK_PRICE"
+        else:
+            self._log.error(
+                f"Cannot submit order: invalid `order.trigger_type`, was "
+                f"{trigger_type_to_str(order.trigger_price)}. {order}",
             )
             return
 
-        ib_order: IBOrder = self._transform_order(command.order)
-        ib_order.orderId = self._client.next_order_id()
-        self._client.place_order(ib_order)
-        self._handle_order_event(status=OrderStatus.SUBMITTED, order=command.order)
+        await self._http_account.new_order(
+            symbol=order.instrument_id.symbol.value,
+            side=self._enum_parser.parse_internal_order_side(order.side),
+            order_type=self._enum_parser.parse_internal_order_type(order),
+            time_in_force=time_in_force,
+            quantity=str(order.quantity),
+            price=str(order.price),
+            stop_price=str(order.trigger_price),
+            working_type=working_type,
+            iceberg_qty=str(order.display_qty) if order.display_qty is not None else None,
+            reduce_only=self._determine_reduce_only_str(order),
+            new_client_order_id=order.client_order_id.value,
+            recv_window=str(self._recv_window),
+        )
 
     async def _submit_order_list(self, command: SubmitOrderList) -> None:
-        PyCondition.type(command, SubmitOrderList, "command")
-
-        order_id_map = {}
-        client_id_to_orders = {}
-        ib_orders = []
-
-        # Translate orders
         for order in command.order_list.orders:
-            order_id_map[order.client_order_id.value] = self._client.next_order_id()
-            client_id_to_orders[order.client_order_id.value] = order
-
-            ib_order = self._transform_order(order)
-            ib_order.transmit = False
-            ib_order.orderId = order_id_map[order.client_order_id.value]
-            ib_orders.append(ib_order)
-
-        # Mark last order to transmit
-        ib_orders[-1].transmit = True
-
-        for ib_order in ib_orders:
-            # Map the Parent Order Ids
-            if parent_id := order_id_map.get(ib_order.parentId):
-                ib_order.parentId = parent_id
-            # Place orders
-            order_ref = ib_order.orderRef
-            self._client.place_order(ib_order)
-            self._handle_order_event(
-                status=OrderStatus.SUBMITTED,
-                order=client_id_to_orders[order_ref],
+            self.generate_order_submitted(
+                strategy_id=order.strategy_id,
+                instrument_id=order.instrument_id,
+                client_order_id=order.client_order_id,
+                ts_event=self._clock.timestamp_ns(),
             )
 
-    async def _modify_order(self, command: ModifyOrder) -> None:
-        PyCondition.not_none(command, "command")
-        if not (command.quantity or command.price or command.trigger_price):
+        for order in command.order_list.orders:
+            if order.linked_order_ids:  # TODO(cs): Implement
+                self._log.warning(f"Cannot yet handle OCO conditional orders, {order}.")
+            await self._submit_order_inner(order)
+
+    async def _submit_stop_market_order(self, order: StopMarketOrder) -> None:
+        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
+
+        if self._binance_account_type.is_spot_or_margin:
+            working_type = None
+        elif order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
+            working_type = "CONTRACT_PRICE"
+        elif order.trigger_type == TriggerType.MARK_PRICE:
+            working_type = "MARK_PRICE"
+        else:
+            self._log.error(
+                f"Cannot submit order: invalid `order.trigger_type`, was "
+                f"{trigger_type_to_str(order.trigger_price)}. {order}",
+            )
             return
 
-        nautilus_order: Order = self._cache.order(command.client_order_id)
-        self._log.info(f"Nautilus order status is {nautilus_order.status!r}", LogColor.GREEN)
-        ib_order: IBOrder = self._transform_order(nautilus_order)
-        ib_order.orderId = int(command.venue_order_id.value)
-        if ib_order.parentId:
-            parent_nautilus_order = self._cache.order(ClientOrderId(ib_order.parentId))
-            if parent_nautilus_order:
-                ib_order.parentId = int(parent_nautilus_order.venue_order_id.value)
-            else:
-                ib_order.parentId = 0
-        if command.quantity and command.quantity != ib_order.totalQuantity:
-            ib_order.totalQuantity = command.quantity.as_double()
-        if command.price and command.price.as_double() != getattr(ib_order, "lmtPrice", None):
-            ib_order.lmtPrice = command.price.as_double()
-        if command.trigger_price and command.trigger_price.as_double() != getattr(
-            ib_order,
-            "auxPrice",
-            None,
-        ):
-            ib_order.auxPrice = command.trigger_price.as_double()
-        self._log.info(f"Placing {ib_order!r}")
-        self._client.place_order(ib_order)
+        await self._http_account.new_order(
+            symbol=order.instrument_id.symbol.value,
+            side=self._enum_parser.parse_internal_order_side(order.side),
+            order_type=self._enum_parser.parse_internal_order_type(order),
+            time_in_force=time_in_force,
+            quantity=str(order.quantity),
+            stop_price=str(order.trigger_price),
+            working_type=working_type,
+            reduce_only=self._determine_reduce_only_str(order),
+            new_client_order_id=order.client_order_id.value,
+            recv_window=str(self._recv_window),
+        )
 
-    async def _cancel_order(self, command: CancelOrder) -> None:
-        PyCondition.not_none(command, "command")
+    async def _submit_trailing_stop_market_order(self, order: TrailingStopMarketOrder) -> None:
+        time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
 
-        venue_order_id = command.venue_order_id
-        if venue_order_id:
-            self._client.cancel_order(int(venue_order_id.value))
+        if order.trigger_type in (TriggerType.DEFAULT, TriggerType.LAST_TRADE):
+            working_type = "CONTRACT_PRICE"
+        elif order.trigger_type == TriggerType.MARK_PRICE:
+            working_type = "MARK_PRICE"
         else:
-            self._log.error(f"VenueOrderId not found for {command.client_order_id}")
-
-    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
-        for order in self._cache.orders_open(
-            instrument_id=command.instrument_id,
-        ):
-            venue_order_id = order.venue_order_id
-            if venue_order_id:
-                self._client.cancel_order(int(venue_order_id.value))
-            else:
-                self._log.error(f"VenueOrderId not found for {order.client_order_id}")
+            self._log.error(
+                f"Cannot submit order: invalid `order.trigger_type`, was "
+                f"{trigger_type_to_str(order.trigger_price)}. {order}",
+            )
+            return
 
-    def _on_account_summary(self, tag: str, value: str, currency: str):
-        if not self._account_summary.get(currency):
-            self._account_summary[currency] = {}
-        try:
-            self._account_summary[currency][tag] = float(value)
-        except ValueError:
-            self._account_summary[currency][tag] = value
+        if order.trailing_offset_type != TrailingOffsetType.BASIS_POINTS:
+            self._log.error(
+                f"Cannot submit order: invalid `order.trailing_offset_type`, was "
+                f"{trailing_offset_type_to_str(order.trailing_offset_type)} (use `BASIS_POINTS`). "
+                f"{order}",
+            )
+            return
 
-        for currency in self._account_summary.keys():
-            if not currency:
-                continue
-            if self._account_summary_tags - set(self._account_summary[currency].keys()) == set():
-                self._log.info(f"{self._account_summary}", LogColor.GREEN)
-                free = self._account_summary[currency]["FullAvailableFunds"]
-                locked = self._account_summary[currency]["FullMaintMarginReq"]
-                # total = self._account_summary[currency]["NetLiquidation"]
-                total = 400000  # TODO: Bug; Cannot recalculate balance when no current balance
-                free = total - locked
-                account_balance = AccountBalance(
-                    total=Money(total, Currency.from_str(currency)),
-                    free=Money(free, Currency.from_str(currency)),
-                    locked=Money(locked, Currency.from_str(currency)),
-                )
-
-                margin_balance = MarginBalance(
-                    initial=Money(
-                        self._account_summary[currency]["FullInitMarginReq"],
-                        currency=Currency.from_str(currency),
-                    ),
-                    maintenance=Money(
-                        self._account_summary[currency]["FullMaintMarginReq"],
-                        currency=Currency.from_str(currency),
-                    ),
-                )
-
-                self.generate_account_state(
-                    balances=[account_balance],
-                    margins=[margin_balance],
-                    reported=True,
-                    ts_event=self._clock.timestamp_ns(),
-                )
-
-                # Store all available fields to Cache (for now until permanent solution)
-                self._cache.add(
-                    f"accountSummary:{self.account_id.get_id()}",
-                    json.dumps(self._account_summary).encode("utf-8"),
+        # Ensure activation price
+        activation_price: Optional[Price] = order.trigger_price
+        if not activation_price:
+            quote = self._cache.quote_tick(order.instrument_id)
+            trade = self._cache.trade_tick(order.instrument_id)
+            if quote:
+                if order.side == OrderSide.BUY:
+                    activation_price = quote.ask
+                elif order.side == OrderSide.SELL:
+                    activation_price = quote.bid
+            elif trade:
+                activation_price = trade.price
+            else:
+                self._log.error(
+                    "Cannot submit order: no trigger price specified for Binance activation price "
+                    f"and could not find quotes or trades for {order.instrument_id}",
                 )
 
-        self._account_summary_loaded.set()
+        await self._http_account.new_order(
+            symbol=order.instrument_id.symbol.value,
+            side=self._enum_parser.parse_internal_order_side(order.side),
+            order_type=self._enum_parser.parse_internal_order_type(order),
+            time_in_force=time_in_force,
+            quantity=str(order.quantity),
+            activation_price=str(activation_price),
+            callback_rate=str(order.trailing_offset / 100),
+            working_type=working_type,
+            reduce_only=self._determine_reduce_only_str(order),
+            new_client_order_id=order.client_order_id.value,
+            recv_window=str(self._recv_window),
+        )
+
+    def _get_cached_instrument_id(self, symbol: str) -> InstrumentId:
+        # Parse instrument ID
+        nautilus_symbol: str = BinanceSymbol(symbol).parse_as_nautilus(
+            self._binance_account_type,
+        )
+        instrument_id: Optional[InstrumentId] = self._instrument_ids.get(nautilus_symbol)
+        if not instrument_id:
+            instrument_id = InstrumentId(Symbol(nautilus_symbol), BINANCE_VENUE)
+            self._instrument_ids[nautilus_symbol] = instrument_id
+        return instrument_id
 
-    def _handle_order_event(
-        self,
-        status: OrderStatus,
-        order: Order,
-        order_id: int = None,
-        reason: str = "",
-    ):
-        if status == OrderStatus.SUBMITTED:
-            self.generate_order_submitted(
-                strategy_id=order.strategy_id,
-                instrument_id=order.instrument_id,
-                client_order_id=order.client_order_id,
-                ts_event=self._clock.timestamp_ns(),
-            )
-        elif status == OrderStatus.ACCEPTED:
-            if order.status != OrderStatus.ACCEPTED:
-                self.generate_order_accepted(
-                    strategy_id=order.strategy_id,
-                    instrument_id=order.instrument_id,
-                    client_order_id=order.client_order_id,
-                    venue_order_id=VenueOrderId(str(order_id)),
-                    ts_event=self._clock.timestamp_ns(),
-                )
-            else:
-                self._log.debug(f"{order.client_order_id} already accepted.")
-        elif status == OrderStatus.PENDING_CANCEL:
-            # TODO: self.generate_order_pending_cancel
-            self._log.warning(f"{order.client_order_id} is {status}")
-        elif status == OrderStatus.CANCELED:
-            self.generate_order_canceled(
-                strategy_id=order.strategy_id,
-                instrument_id=order.instrument_id,
-                client_order_id=order.client_order_id,
-                venue_order_id=order.venue_order_id,
-                ts_event=self._clock.timestamp_ns(),
-            )
-        elif status == OrderStatus.REJECTED:
-            self.generate_order_rejected(
-                strategy_id=order.strategy_id,
-                instrument_id=order.instrument_id,
-                client_order_id=order.client_order_id,
-                reason=reason,
-                ts_event=self._clock.timestamp_ns(),
+    async def _modify_order(self, command: ModifyOrder) -> None:
+        if self._binance_account_type.is_spot_or_margin:
+            self._log.error(
+                "Cannot modify order: only supported for `USDT_FUTURE` and `COIN_FUTURE` account types.",
             )
+            return
 
-    def _on_open_order(self, order_ref: str, order: IBOrder, order_state: IBOrderState):
-        if not order.orderRef:
-            self._log.warning(
-                f"ClientOrderId not available, order={order.__dict__}, state={order_state.__dict__}",
-            )
+        order: Optional[Order] = self._cache.order(command.client_order_id)
+        if order is None:
+            self._log.error(f"{command.client_order_id!r} not found to modify.")
             return
-        if not (nautilus_order := self._cache.order(ClientOrderId(order_ref))):
-            self._log.warning(
-                f"ClientOrderId not found in Cache, order={order.__dict__}, state={order_state.__dict__}",
+
+        if order.order_type != OrderType.LIMIT:
+            self._log.error(
+                "Cannot modify order: "
+                f"only LIMIT orders supported by the venue (was {order.type_string()}).",
             )
             return
 
-        if order.whatIf and order_state.status == "PreSubmitted":
-            # TODO: Is there more better approach for this use case?
-            # This tells the details about Pre and Post margin changes, user can request by setting whatIf flag
-            # order will not be placed by IB and instead returns simulation.
-            # example={'status': 'PreSubmitted', 'initMarginBefore': '52.88', 'maintMarginBefore': '52.88', 'equityWithLoanBefore': '23337.31', 'initMarginChange': '2517.5099999999998', 'maintMarginChange': '2517.5099999999998', 'equityWithLoanChange': '-0.6200000000026193', 'initMarginAfter': '2570.39', 'maintMarginAfter': '2570.39', 'equityWithLoanAfter': '23336.69', 'commission': 2.12362, 'minCommission': 1.7976931348623157e+308, 'maxCommission': 1.7976931348623157e+308, 'commissionCurrency': 'USD', 'warningText': '', 'completedTime': '', 'completedStatus': ''}  # noqa
-            self._handle_order_event(
-                status=OrderStatus.REJECTED,
-                order=nautilus_order,
-                reason=json.dumps({"whatIf": order_state.__dict__}),
-            )
-        elif order_state.status in [
-            "PreSubmitted",
-            "Submitted",
-        ]:  # nautilus_order.status != OrderStatus.ACCEPTED and
-            instrument = self.instrument_provider.find(nautilus_order.instrument_id)
-            total_qty = (
-                Quantity.from_int(0)
-                if order.totalQuantity == UNSET_DECIMAL
-                else Quantity.from_str(str(order.totalQuantity))
-            )
-            price = (
-                None if order.lmtPrice == UNSET_DOUBLE else instrument.make_price(order.lmtPrice)
-            )
-            trigger_price = (
-                None if order.auxPrice == UNSET_DOUBLE else instrument.make_price(order.auxPrice)
-            )
-            if (
-                nautilus_order.venue_order_id is None
-                or nautilus_order.venue_order_id != VenueOrderId(str(order.orderId))
-            ):
-                venue_order_id_modified = True
+        while True:
+            try:
+                await self._http_account.modify_order(
+                    symbol=order.instrument_id.symbol.value,
+                    order_id=int(order.venue_order_id.value) if order.venue_order_id else None,
+                    side=self._enum_parser.parse_internal_order_side(order.side),
+                    quantity=str(command.quantity) if command.quantity else str(order.quantity),
+                    price=str(command.price) if command.price else str(order.price),
+                )
+                self._order_retries.pop(command.client_order_id, None)
+                break  # Successful request
+            except BinanceError as e:
+                error_code = BinanceErrorCode(e.message["code"])
+
+                retries = self._order_retries.get(command.client_order_id, 0) + 1
+                self._order_retries[command.client_order_id] = retries
+
+                if not self._should_retry(error_code, retries):
+                    break
+
+                self._log.warning(
+                    f"{error_code.name}: retrying {command.client_order_id!r} "
+                    f"{retries}/{self._max_retries} in {self._retry_delay}s ...",
+                )
+                await asyncio.sleep(self._retry_delay)
+
+    async def _cancel_order(self, command: CancelOrder) -> None:
+        while True:
+            try:
+                await self._cancel_order_single(
+                    instrument_id=command.instrument_id,
+                    client_order_id=command.client_order_id,
+                    venue_order_id=command.venue_order_id,
+                )
+                self._order_retries.pop(command.client_order_id, None)
+                break  # Successful request
+            except BinanceError as e:
+                error_code = BinanceErrorCode(e.message["code"])
+
+                retries = self._order_retries.get(command.client_order_id, 0) + 1
+                self._order_retries[command.client_order_id] = retries
+
+                if not self._should_retry(error_code, retries):
+                    break
+
+                self._log.warning(
+                    f"{error_code.name}: retrying {command.client_order_id!r} "
+                    f"{retries}/{self._max_retries} in {self._retry_delay}s ...",
+                )
+                await asyncio.sleep(self._retry_delay)
+
+    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
+        open_orders_strategy: list[Order] = self._cache.orders_open(
+            instrument_id=command.instrument_id,
+            strategy_id=command.strategy_id,
+        )
+        for order in open_orders_strategy:
+            if order.is_pending_cancel:
+                continue  # Already pending cancel
+
+        # Check total orders for instrument
+        open_orders_total_count = self._cache.orders_open_count(
+            instrument_id=command.instrument_id,
+        )
+
+        try:
+            if open_orders_total_count == len(open_orders_strategy):
+                await self._http_account.cancel_all_open_orders(
+                    symbol=command.instrument_id.symbol.value,
+                )
             else:
-                venue_order_id_modified = False
-            if total_qty != nautilus_order.quantity or price or trigger_price:
-                self.generate_order_updated(
-                    strategy_id=nautilus_order.strategy_id,
-                    instrument_id=nautilus_order.instrument_id,
-                    client_order_id=nautilus_order.client_order_id,
-                    venue_order_id=VenueOrderId(str(order.orderId)),
-                    quantity=total_qty,
-                    price=price,
-                    trigger_price=trigger_price,
-                    ts_event=self._clock.timestamp_ns(),
-                    venue_order_id_modified=venue_order_id_modified,
-                )
-            self._handle_order_event(
-                status=OrderStatus.ACCEPTED,
-                order=nautilus_order,
-                order_id=order.orderId,
-            )
-
-    def _on_order_status(self, order_ref: str, order_status: str, reason: str = ""):
-        if order_status in ["ApiCancelled", "Cancelled"]:
-            status = OrderStatus.CANCELED
-        elif order_status == "PendingCancel":
-            status = OrderStatus.PENDING_CANCEL
-        elif order_status == "Rejected":
-            status = OrderStatus.REJECTED
-        else:
+                for order in open_orders_strategy:
+                    await self._cancel_order_single(
+                        instrument_id=order.instrument_id,
+                        client_order_id=order.client_order_id,
+                        venue_order_id=order.venue_order_id,
+                    )
+        except BinanceError as e:
+            if "Unknown order sent" in e.message:
+                self._log.info(
+                    "No open orders to cancel according to Binance.",
+                    LogColor.GREEN,
+                )
+            else:
+                self._log.exception(f"Cannot cancel open orders: {e.message}", e)
+
+    async def _cancel_order_single(
+        self,
+        instrument_id: InstrumentId,
+        client_order_id: ClientOrderId,
+        venue_order_id: Optional[VenueOrderId],
+    ) -> None:
+        order: Optional[Order] = self._cache.order(client_order_id)
+        if order is None:
+            self._log.error(f"{client_order_id!r} not found to cancel.")
             return
 
-        nautilus_order = self._cache.order(ClientOrderId(order_ref))
-        if nautilus_order:
-            self._handle_order_event(
-                status=status,
-                order=nautilus_order,
-                reason=reason,
+        if order.is_closed:
+            self._log.warning(
+                f"CancelOrder command for {client_order_id!r} when order already {order.status_string()} "
+                "(will not send to exchange).",
             )
+            return
 
-    def _on_exec_details(
-        self,
-        order_ref: str,
-        execution: Execution,
-        commission_report: CommissionReport,
-    ):
-        if not execution.orderRef:
-            self._log.warning(f"ClientOrderId not available, order={execution.__dict__}")
-            return
-        if not (nautilus_order := self._cache.order(ClientOrderId(order_ref))):
-            self._log.warning(f"ClientOrderId not found in Cache, order={execution.__dict__}")
-            return
-
-        instrument = self.instrument_provider.find(nautilus_order.instrument_id)
-
-        self.generate_order_filled(
-            strategy_id=nautilus_order.strategy_id,
-            instrument_id=nautilus_order.instrument_id,
-            client_order_id=nautilus_order.client_order_id,
-            venue_order_id=VenueOrderId(str(execution.orderId)),
-            venue_position_id=None,
-            trade_id=TradeId(execution.execId),
-            order_side=OrderSide[order_side_to_order_action[execution.side]],
-            order_type=nautilus_order.order_type,
-            last_qty=Quantity(execution.shares, precision=instrument.size_precision),
-            last_px=Price(execution.price, precision=instrument.price_precision),
-            quote_currency=instrument.quote_currency,
-            commission=Money(
-                commission_report.commission,
-                Currency.from_str(commission_report.currency),
-            ),
-            liquidity_side=LiquiditySide.NO_LIQUIDITY_SIDE,
-            ts_event=timestring_to_timestamp(execution.time).value,
-        )
+        try:
+            await self._http_account.cancel_order(
+                symbol=instrument_id.symbol.value,
+                order_id=int(venue_order_id.value) if venue_order_id else None,
+                orig_client_order_id=client_order_id.value if client_order_id else None,
+            )
+        except BinanceError as e:
+            self._log.exception(
+                f"Cannot cancel order "
+                f"{client_order_id!r}, "
+                f"{venue_order_id!r}: "
+                f"{e.message}",
+                e,
+            )
+
+    # -- WEBSOCKET EVENT HANDLERS --------------------------------------------------------------------
+
+    def _handle_user_ws_message(self, raw: bytes) -> None:
+        # Implement in child class
+        raise NotImplementedError
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/factories.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/factories.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/gateway.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/gateway.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 # -------------------------------------------------------------------------------------------------
 
 import logging
 import os
 import warnings
 from enum import IntEnum
 from time import sleep
-from typing import Optional
+from typing import ClassVar, Optional
 
 
 try:
     import docker
 except ImportError as e:
     warnings.warn(
         f"Docker required for Gateway, install manually via `pip install docker` ({e})",
@@ -38,20 +38,20 @@
     NOT_LOGGED_IN = 5
     READY = 6
     UNKNOWN = 7
 
 
 class InteractiveBrokersGateway:
     """
-    A class to manage starting an Interactive Brokers Gateway docker container
+    A class to manage starting an Interactive Brokers Gateway docker container.
     """
 
-    IMAGE = "ghcr.io/unusualalpha/ib-gateway:stable"
-    CONTAINER_NAME = "nautilus-ib-gateway"
-    PORTS = {"paper": 4002, "live": 4001}
+    IMAGE: ClassVar[str] = "ghcr.io/unusualalpha/ib-gateway:stable"
+    CONTAINER_NAME: ClassVar[str] = "nautilus-ib-gateway"
+    PORTS: ClassVar[dict[str, int]] = {"paper": 4002, "live": 4001}
 
     def __init__(
         self,
         username: str,
         password: str,
         host: Optional[str] = "localhost",
         port: Optional[int] = None,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/historic.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/historic.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import datetime
 import logging
-from typing import Literal, Union
+from typing import Literal, Optional, Union
 
 import pandas as pd
 import pytz
 from ib_insync import IB
 from ib_insync import BarData
 from ib_insync import BarDataList
 from ib_insync import Contract
@@ -86,14 +86,15 @@
     tz_name : str
         The timezone of the contracts
     kinds : tuple[str] (default: ('BID_ASK', 'TRADES')
         The kinds to query data for, can be any of:
         - BID_ASK
         - TRADES
         - A bar specification, i.e. BARS-1-MINUTE-LAST or BARS-5-SECOND-MID
+
     """
     for date in pd.bdate_range(start_date, end_date, tz=tz_name):
         for contract in contracts:
             [details] = ib.reqContractDetails(contract=contract)
             instrument = parse_instrument(contract_details=details)
 
             # Check if this instrument exists in the catalog, if not, write it.
@@ -126,15 +127,15 @@
 
 def request_data(
     contract: Contract,
     instrument: Instrument,
     date: datetime.date,
     kind: str,
     tz_name: str,
-    ib: IB = None,
+    ib: Optional[IB] = None,
 ):
     if kind in ("TRADES", "BID_ASK"):
         raw = request_tick_data(contract=contract, date=date, kind=kind, tz_name=tz_name, ib=ib)
     elif kind.split("-")[0] == "BARS":
         bar_spec = BarSpecification.from_str(kind.split("-", maxsplit=1)[1])
         raw = request_bar_data(
             contract=contract,
@@ -301,16 +302,17 @@
         useRTH=False,
         formatDate=2,
     )
 
 
 def _determine_next_timestamp(timestamps: list[pd.Timestamp], date: datetime.date, tz_name: str):
     """
-    While looping over available data, it is possible for very liquid products that a 1s period may contain 1000 ticks,
-    at which point we need to step the time forward to avoid getting stuck when iterating.
+    While looping over available data, it is possible for very liquid products that a 1s
+    period may contain 1000 ticks, at which point we need to step the time forward to
+    avoid getting stuck when iterating.
     """
     if not timestamps:
         return pd.Timestamp(date, tz=tz_name).tz_convert("UTC")
     unique_values = set(timestamps)
     if len(unique_values) == 1:
         timestamp = timestamps[-1]
         return timestamp + pd.Timedelta(seconds=1)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/cache/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py`

 * *Files 1% similar despite different names*

```diff
@@ -144,15 +144,15 @@
 
 def parse_equity_contract(details: IBContractDetails) -> Equity:
     price_precision: int = _tick_size_to_precision(details.minTick)
     timestamp = time.time_ns()
     instrument_id = ib_contract_to_instrument_id(details.contract)
     return Equity(
         instrument_id=instrument_id,
-        native_symbol=Symbol(details.contract.localSymbol),
+        raw_symbol=Symbol(details.contract.localSymbol),
         currency=Currency.from_str(details.contract.currency),
         price_precision=price_precision,
         price_increment=Price(details.minTick, price_precision),
         multiplier=Quantity.from_int(1),
         lot_size=Quantity.from_int(1),
         isin=_extract_isin(details),
         ts_event=timestamp,
@@ -165,15 +165,15 @@
     details: IBContractDetails,
 ) -> FuturesContract:
     price_precision: int = _tick_size_to_precision(details.minTick)
     timestamp = time.time_ns()
     instrument_id = ib_contract_to_instrument_id(details.contract)
     return FuturesContract(
         instrument_id=instrument_id,
-        native_symbol=Symbol(details.contract.localSymbol),
+        raw_symbol=Symbol(details.contract.localSymbol),
         asset_class=sec_type_to_asset_class(details.underSecType),
         currency=Currency.from_str(details.contract.currency),
         price_precision=price_precision,
         price_increment=Price(details.minTick, price_precision),
         multiplier=Quantity.from_str(details.contract.multiplier),
         lot_size=Quantity.from_int(1),
         underlying=details.underSymbol,
@@ -196,15 +196,15 @@
     asset_class = sec_type_to_asset_class(details.underSecType)
     kind = {
         "C": OptionKind.CALL,
         "P": OptionKind.PUT,
     }[details.contract.right]
     return OptionsContract(
         instrument_id=instrument_id,
-        native_symbol=Symbol(details.contract.localSymbol),
+        raw_symbol=Symbol(details.contract.localSymbol),
         asset_class=asset_class,
         currency=Currency.from_str(details.contract.currency),
         price_precision=price_precision,
         price_increment=Price(details.minTick, price_precision),
         multiplier=Quantity.from_str(details.contract.multiplier),
         lot_size=Quantity.from_int(1),
         underlying=details.underSymbol,
@@ -225,15 +225,15 @@
 ) -> CurrencyPair:
     price_precision: int = _tick_size_to_precision(details.minTick)
     size_precision: int = _tick_size_to_precision(details.minSize)
     timestamp = time.time_ns()
     instrument_id = ib_contract_to_instrument_id(details.contract)
     return CurrencyPair(
         instrument_id=instrument_id,
-        native_symbol=Symbol(details.contract.localSymbol),
+        raw_symbol=Symbol(details.contract.localSymbol),
         base_currency=Currency.from_str(details.contract.symbol),
         quote_currency=Currency.from_str(details.contract.currency),
         price_precision=price_precision,
         size_precision=size_precision,
         price_increment=Price(details.minTick, price_precision),
         size_increment=Quantity(details.sizeIncrement, size_precision),
         lot_size=None,
@@ -258,15 +258,15 @@
 ) -> CryptoPerpetual:
     price_precision: int = _tick_size_to_precision(details.minTick)
     size_precision: int = _tick_size_to_precision(details.minSize)
     timestamp = time.time_ns()
     instrument_id = ib_contract_to_instrument_id(details.contract)
     return CryptoPerpetual(
         instrument_id=instrument_id,
-        native_symbol=Symbol(details.contract.localSymbol),
+        raw_symbol=Symbol(details.contract.localSymbol),
         base_currency=Currency.from_str(details.contract.symbol),
         quote_currency=Currency.from_str(details.contract.currency),
         settlement_currency=Currency.from_str(details.contract.currency),
         is_inverse=False,  # No inverse instruments trade on InteractiveBrokers?
         price_precision=price_precision,
         size_precision=size_precision,
         price_increment=Price(details.minTick, price_precision),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/providers.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/providers.py`

 * *Files 1% similar despite different names*

```diff
@@ -236,23 +236,24 @@
 
     async def load_async(
         self,
         instrument_id: Union[InstrumentId, IBContract],
         filters: Optional[dict] = None,
     ):
         """
-        Search and load the instrument for the given IBContract.
-        It is important that the Contract shall have enough parameters so only one match is returned.
+        Search and load the instrument for the given IBContract. It is important that
+        the Contract shall have enough parameters so only one match is returned.
 
         Parameters
         ----------
         instrument_id : IBContract
             InteractiveBroker's Contract.
         filters : dict, optional
             Not applicable in this case.
+
         """
         if isinstance(instrument_id, InstrumentId):
             try:
                 contract = instrument_id_to_ib_contract(instrument_id)
             except ValueError as e:
                 self._log.error(f"{e}")
                 return
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/web.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/web.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,27 +18,27 @@
 
 import requests
 from lxml.html import fromstring
 
 
 class ProductClass(enum.Enum):
     """
-    Interactive Brokers Web ProductClass
+    Interactive Brokers Web ProductClass.
     """
 
     ETFS = "ETF"
     INDICES = "IND"
     STOCKS = "STK"
     OPTIONS = "OPTGRP"
     WARRANTS = "WNT"
 
 
 class Exchange(enum.Enum):
     """
-    Interactive Brokers Exchange
+    Interactive Brokers Exchange.
     """
 
     AEB = "aeb"
     ALPHA = "alpha"
     AMEX = "amex"
     ARCA = "arca"
     ARCAEDGE = "arcaedge"
@@ -119,15 +119,15 @@
     VIRTX = "virtx"
     VSE = "vse"
     WSE = "wse"
 
 
 class Product(namedtuple("Product", "ib_symbol, description, native_symbol, currency")):
     """
-    Interactive Brokers Web Product
+    Interactive Brokers Web Product.
     """
 
 
 def _parse_products(table):
     for row in table.xpath(".//tr")[1:]:
         ib_symbol, desc, symbol, currency = list(
             filter(None, map(str.strip, row.xpath(".//text()"))),
@@ -143,15 +143,16 @@
 def load_product_list(
     exchange: Exchange,
     product_class: ProductClass,
     limit: int = 500,
     debug: bool = False,
 ):
     """
-    Load all instruments for a given `exchange` and `product_class` via the Interactive Brokers web interface
+    Load all instruments for a given `exchange` and `product_class` via the Interactive
+    Brokers web interface.
 
     >>> products = load_product_list(exchange=Exchange.NYSE, product_class=ProductClass.STOCKS)
 
     """
     url = "https://www.interactivebrokers.com/en/index.php"
     params = {
         "f": "2222",
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/common/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/config.py` & `nautilus_trader-1.176.0/nautilus_trader/backtest/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -8,28 +8,10 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-from nautilus_trader.config import LiveExecClientConfig
-
-
-class SandboxExecutionClientConfig(LiveExecClientConfig, frozen=True):
-    """
-    Configuration for ``SandboxExecClient`` instances.
-
-    Parameters
-    ----------
-    venue : str
-        The venue to generate a sandbox execution client for
-    currency: str
-        The currency for this venue
-    balance : int
-        The starting balance for this venue
-    """
-
-    venue: str  # type: ignore
-    currency: str  # type: ignore
-    balance: int  # type: ignore
+"""
+The `backtest` subpackage groups components relating to backtesting.
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/execution.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
 from decimal import Decimal
-from typing import Optional
+from typing import ClassVar, Optional
 
 import pandas as pd
 
 from nautilus_trader.backtest.exchange import SimulatedExchange
 from nautilus_trader.backtest.execution_client import BacktestExecClient
 from nautilus_trader.backtest.models import FillModel
 from nautilus_trader.backtest.models import LatencyModel
@@ -64,17 +64,18 @@
         The message bus for the client.
     cache : Cache
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
+
     """
 
-    INSTRUMENTS: list[Instrument] = []
+    INSTRUMENTS: ClassVar[list[Instrument]] = []
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/factory.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/sandbox/factory.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,11 +8,11 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `analysis` subpackage groups components relating to trading performance statistics and analysis.
+The `persistence` subpackage handles data storage and retrieval, mainly to support
+backtesting.
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/analyzer.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/analyzer.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,17 +9,19 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 from datetime import datetime
 from decimal import Decimal
-from typing import Any, Optional
+from typing import Any
 
 import pandas as pd
 from numpy import float64
 
 from nautilus_trader.accounting.accounts.base import Account
 from nautilus_trader.analysis.statistic import PortfolioStatistic
 from nautilus_trader.core.correctness import PyCondition
@@ -28,16 +30,16 @@
 from nautilus_trader.model.identifiers import PositionId
 from nautilus_trader.model.objects import Money
 from nautilus_trader.model.position import Position
 
 
 class PortfolioAnalyzer:
     """
-    Provides a portfolio performance analyzer for tracking and generating
-    performance metrics and statistics.
+    Provides a portfolio performance analyzer for tracking and generating performance
+    metrics and statistics.
     """
 
     def __init__(self) -> None:
         self._statistics: dict[str, PortfolioStatistic] = {}
 
         # Data
         self._account_balances_starting: dict[Currency, Money] = {}
@@ -59,30 +61,29 @@
         PyCondition.not_none(statistic, "statistic")
 
         self._statistics[statistic.name] = statistic
 
     def deregister_statistic(self, statistic: PortfolioStatistic) -> None:
         """
         Deregister a statistic from the analyzer.
-
         """
         self._statistics.pop(statistic.name, None)
 
     def deregister_statistics(self) -> None:
         """
         Deregister all statistics from the analyzer.
-
         """
         self._statistics.clear()
 
     def reset(self) -> None:
         """
         Reset the analyzer.
 
         All stateful fields are reset to their initial value.
+
         """
         self._account_balances_starting = {}
         self._account_balances = {}
         self._realized_pnls = {}
         self._returns = pd.Series(dtype=float64)
 
     def _get_max_length_name(self) -> int:
@@ -100,15 +101,15 @@
         Returns
         -------
         list[Currency]
 
         """
         return list(self._account_balances.keys())
 
-    def statistic(self, name: str) -> Optional[PortfolioStatistic]:
+    def statistic(self, name: str) -> PortfolioStatistic | None:
         """
         Return the statistic with the given name (if found).
 
         Returns
         -------
         PortfolioStatistic or ``None``
 
@@ -190,15 +191,15 @@
             The return value to add.
 
         """
         if timestamp not in self._returns:
             self._returns.loc[timestamp] = 0.0
         self._returns.loc[timestamp] += float(value)
 
-    def realized_pnls(self, currency: Currency = None) -> Optional[pd.Series]:
+    def realized_pnls(self, currency: Currency | None = None) -> pd.Series | None:
         """
         Return the realized PnL for the portfolio.
 
         For multi-currency portfolios, specify the currency for the result.
 
         Parameters
         ----------
@@ -223,16 +224,16 @@
             ), "currency was None for multi-currency portfolio"
             currency = next(iter(self._account_balances.keys()))
 
         return self._realized_pnls.get(currency)
 
     def total_pnl(
         self,
-        currency: Optional[Currency] = None,
-        unrealized_pnl: Optional[Money] = None,
+        currency: Currency | None = None,
+        unrealized_pnl: Money | None = None,
     ) -> float:
         """
         Return the total PnL for the portfolio.
 
         For multi-currency portfolios, specify the currency for the result.
 
         Parameters
@@ -274,16 +275,16 @@
             return 0.0
 
         unrealized_pnl_f64 = 0.0 if unrealized_pnl is None else unrealized_pnl.as_double()
         return float(account_balance - account_balance_starting) + unrealized_pnl_f64
 
     def total_pnl_percentage(
         self,
-        currency: Currency = None,
-        unrealized_pnl: Optional[Money] = None,
+        currency: Currency | None = None,
+        unrealized_pnl: Money | None = None,
     ) -> float:
         """
         Return the percentage change of the total PnL for the portfolio.
 
         For multi-currency accounts, specify the currency for the result.
 
         Parameters
@@ -335,19 +336,20 @@
         starting = account_balance_starting
         difference = current - starting
 
         return float((difference / starting) * 100)
 
     def get_performance_stats_pnls(
         self,
-        currency: Currency = None,
-        unrealized_pnl: Optional[Money] = None,
+        currency: Currency | None = None,
+        unrealized_pnl: Money | None = None,
     ) -> dict[str, float]:
         """
-        Return the 'PnL' (profit and loss) performance statistics, optionally includes the unrealized PnL.
+        Return the 'PnL' (profit and loss) performance statistics, optionally includes
+        the unrealized PnL.
 
         Money objects are converted to floats.
 
         Parameters
         ----------
         currency : Currency
             The currency for the performance.
@@ -415,20 +417,20 @@
                 value = str(value)
             output[name] = value
 
         return output
 
     def get_stats_pnls_formatted(
         self,
-        currency: Currency = None,
-        unrealized_pnl: Optional[Money] = None,
+        currency: Currency | None = None,
+        unrealized_pnl: Money | None = None,
     ) -> list[str]:
         """
-        Return the performance statistics from the last backtest run formatted
-        for printing in the backtest run footer.
+        Return the performance statistics from the last backtest run formatted for
+        printing in the backtest run footer.
 
         Parameters
         ----------
         currency : Currency
             The currency for the performance.
         unrealized_pnl : Money, optional
             The unrealized PnL for the performance.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/reporter.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/reporter.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import msgspec
 import pandas as pd
 
 from nautilus_trader.accounting.accounts.base import Account
 from nautilus_trader.core.datetime import unix_nanos_to_dt
 from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.events import AccountState
@@ -70,15 +72,15 @@
             return pd.DataFrame()
 
         filled_orders = [o.to_dict() for o in orders if o.status == OrderStatus.FILLED]
         if not filled_orders:
             return pd.DataFrame()
 
         report = pd.DataFrame(data=filled_orders).set_index("client_order_id").sort_index()
-        report["ts_last"] = [unix_nanos_to_dt(ts_last) for ts_last in report["ts_last"]]
+        report["ts_last"] = [unix_nanos_to_dt(ts_last or 0) for ts_last in report["ts_last"]]
         report["ts_init"] = [unix_nanos_to_dt(ts_init) for ts_init in report["ts_init"]]
 
         return report
 
     @staticmethod
     def generate_positions_report(positions: list[Position]) -> pd.DataFrame:
         """
@@ -103,17 +105,19 @@
 
         sort = ["ts_opened", "ts_closed", "position_id"]
         report = pd.DataFrame(data=positions).set_index("position_id").sort_values(sort)
         del report["signed_qty"]
         del report["quantity"]
         del report["quote_currency"]
         del report["base_currency"]
-        del report["cost_currency"]
+        del report["settlement_currency"]
         report["ts_opened"] = [unix_nanos_to_dt(ts_opened) for ts_opened in report["ts_opened"]]
-        report["ts_closed"] = [unix_nanos_to_dt(ts_closed) for ts_closed in report["ts_closed"]]
+        report["ts_closed"] = [
+            unix_nanos_to_dt(ts_closed or 0) for ts_closed in report["ts_closed"]
+        ]
 
         return report
 
     @staticmethod
     def generate_account_report(account: Account) -> pd.DataFrame:
         """
         Generate an account report for the given optional time range.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistic.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistic.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,30 +9,33 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import re
-from typing import Any, Optional
+from typing import Any
 
 import pandas as pd
 
 from nautilus_trader.model.orders import Order
 from nautilus_trader.model.position import Position
 
 
 class PortfolioStatistic:
     """
     The base class for all portfolio performance statistics.
 
     Notes
     -----
     The return value should be a JSON serializable primitive.
+
     """
 
     @classmethod
     def fully_qualified_name(cls) -> str:
         """
         Return the fully qualified name for the `PortfolioStatistic` class.
 
@@ -57,15 +60,15 @@
         str
 
         """
         klass = type(self).__name__
         matches = re.finditer(".+?(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|$)", klass)
         return " ".join([m.group(0) for m in matches])
 
-    def calculate_from_returns(self, returns: pd.Series) -> Optional[Any]:
+    def calculate_from_returns(self, returns: pd.Series) -> Any | None:
         """
         Calculate the statistic value from the given raw returns.
 
         Parameters
         ----------
         returns : pd.Series
             The returns to use for the calculation.
@@ -74,15 +77,15 @@
         -------
         Any or ``None``
             A JSON serializable primitive.
 
         """
         # Override in implementation
 
-    def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
+    def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Any | None:
         """
         Calculate the statistic value from the given raw realized PnLs.
 
         Parameters
         ----------
         realized_pnls : pd.Series
             The raw PnLs for the calculation.
@@ -91,15 +94,15 @@
         -------
         Any or ``None``
             A JSON serializable primitive.
 
         """
         # Override in implementation
 
-    def calculate_from_orders(self, orders: list[Order]) -> Optional[Any]:
+    def calculate_from_orders(self, orders: list[Order]) -> Any | None:
         """
         Calculate the statistic value from the given orders.
 
         Parameters
         ----------
         orders : list[Order]
             The positions to use for the calculation.
@@ -108,15 +111,15 @@
         -------
         Any or ``None``
             A JSON serializable primitive.
 
         """
         # Override in implementation
 
-    def calculate_from_positions(self, positions: list[Position]) -> Optional[Any]:
+    def calculate_from_positions(self, positions: list[Position]) -> Any | None:
         """
         Calculate the statistic value from the given positions.
 
         Parameters
         ----------
         positions : list[Position]
             The positions to use for the calculation.
@@ -126,14 +129,14 @@
         Any or ``None``
             A JSON serializable primitive.
 
         """
         ...  # Override in implementation
 
     def _check_valid_returns(self, returns: pd.Series) -> bool:
-        if returns is None or returns.empty or returns.isnull().all():
+        if returns is None or returns.empty or returns.isna().all():
             return False
         else:
             return True
 
     def _downsample_to_daily_bins(self, returns: pd.Series) -> pd.Series:
         return returns.dropna().resample("1D").sum()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/expectancy.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/expectancy.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/long_ratio.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/long_ratio.py`

 * *Files 1% similar despite different names*

```diff
@@ -24,14 +24,15 @@
     """
     Calculates the ratio of long (to short) positions.
 
     Parameters
     ----------
     precision : int, default 2
         The decimal precision for the output.
+
     """
 
     def __init__(self, precision: int = 2):
         self.precision = precision
 
     def calculate_from_positions(self, positions: list[Position]) -> Optional[Any]:
         # Preconditions
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_avg.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/loser_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_max.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/loser_max.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_min.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/loser_min.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/profit_factor.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/profit_factor.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_loss.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_avg_loss.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_win.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_avg_win.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_volatility.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/returns_volatility.py`

 * *Files 1% similar despite different names*

```diff
@@ -27,14 +27,15 @@
 
     The returns will be downsampled into daily bins.
 
     Parameters
     ----------
     period : int, default 252
         The trading period in days.
+
     """
 
     def __init__(self, period: int = 252):
         self.period = period
 
     @property
     def name(self) -> str:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/risk_return_ratio.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/risk_return_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sharpe_ratio.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/sharpe_ratio.py`

 * *Files 0% similar despite different names*

```diff
@@ -27,14 +27,15 @@
 
     The returns will be downsampled into daily bins.
 
     Parameters
     ----------
     period : int, default 252
         The trading period in days.
+
     """
 
     def __init__(self, period: int = 252):
         self.period = period
 
     @property
     def name(self) -> str:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sortino_ratio.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/sortino_ratio.py`

 * *Files 5% similar despite different names*

```diff
@@ -27,14 +27,15 @@
 
     The returns will be downsampled into daily bins.
 
     Parameters
     ----------
     period : int, default 252
         The trading period in days.
+
     """
 
     def __init__(self, period: int = 252):
         self.period = period
 
     @property
     def name(self) -> str:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/win_rate.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/win_rate.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_avg.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/winner_max.py`

 * *Files 13% similar despite different names*

```diff
@@ -16,24 +16,19 @@
 from typing import Any, Optional
 
 import pandas as pd
 
 from nautilus_trader.analysis.statistic import PortfolioStatistic
 
 
-class AvgWinner(PortfolioStatistic):
+class MaxWinner(PortfolioStatistic):
     """
-    Calculates the average winner from a series of PnLs.
+    Calculates the maximum winner from a series of PnLs.
     """
 
     def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
         # Preconditions
         if realized_pnls is None or realized_pnls.empty:
             return 0.0
 
         # Calculate statistic
-        pnls = realized_pnls.to_numpy()
-        winners = pnls[pnls > 0.0]
-        if len(winners) == 0:
-            return 0.0
-        else:
-            return winners.mean()
+        return max(realized_pnls)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_max.py` & `nautilus_trader-1.176.0/nautilus_trader/analysis/statistics/winner_min.py`

 * *Files 18% similar despite different names*

```diff
@@ -11,24 +11,29 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from typing import Any, Optional
 
+import numpy as np
 import pandas as pd
 
 from nautilus_trader.analysis.statistic import PortfolioStatistic
 
 
-class MaxWinner(PortfolioStatistic):
+class MinWinner(PortfolioStatistic):
     """
-    Calculates the maximum winner from a series of PnLs.
+    Calculates the minimum winner from a series of PnLs.
     """
 
     def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
         # Preconditions
         if realized_pnls is None or realized_pnls.empty:
             return 0.0
 
         # Calculate statistic
-        return max(realized_pnls)
+        winners = [x for x in realized_pnls if x > 0.0]
+        if not winners:
+            return 0.0
+
+        return min(np.asarray(winners, dtype=np.float64))
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_min.py` & `nautilus_trader-1.176.0/nautilus_trader/indicators/obv.pxd`

 * *Files 25% similar despite different names*

```diff
@@ -9,31 +9,19 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from typing import Any, Optional
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
-import numpy as np
-import pandas as pd
 
-from nautilus_trader.analysis.statistic import PortfolioStatistic
+cdef class OnBalanceVolume(Indicator):
+    cdef object _obv
 
+    cdef readonly int period
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
 
-class MinWinner(PortfolioStatistic):
-    """
-    Calculates the minimum winner from a series of PnLs.
-    """
-
-    def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
-        # Preconditions
-        if realized_pnls is None or realized_pnls.empty:
-            return 0.0
-
-        # Calculate statistic
-        winners = [x for x in realized_pnls if x > 0.0]
-        if not winners:
-            return 0.0
-
-        return min(np.asarray(winners, dtype=np.float64))
+    cpdef void update_raw(self, double open, double close, double volume)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/portfolio/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -8,9 +8,10 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""The `backtest` subpackage groups components relating to backtesting."""
+"""
+The `portfolio` subpackage provides portfolio management functionality.
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/__main__.py` & `nautilus_trader-1.176.0/nautilus_trader/backtest/__main__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/auction.py` & `nautilus_trader-1.176.0/nautilus_trader/backtest/auction.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pxd` & `nautilus_trader-1.176.0/nautilus_trader/backtest/data_client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pyx` & `nautilus_trader-1.176.0/nautilus_trader/backtest/data_client.pyx`

 * *Files 17% similar despite different names*

```diff
@@ -164,62 +164,110 @@
         for instrument in self._cache.instruments(Venue(self.id.value)):
             self.subscribe_instrument(instrument.id)
         # Do nothing else for backtest
 
     cpdef void subscribe_instrument(self, InstrumentId instrument_id):
         Condition.not_none(instrument_id, "instrument_id")
 
+        if not self._cache.instrument(instrument_id):
+            self._log.error(
+                f"Cannot find instrument {instrument_id} to subscribe for `Instrument` data.",
+            )
+            return
+
         self._add_subscription_instrument(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_order_book_deltas(
         self,
         InstrumentId instrument_id,
         BookType book_type,
         int depth = 0,
         dict kwargs = None,
     ):
         Condition.not_none(instrument_id, "instrument_id")
 
+        if not self._cache.instrument(instrument_id):
+            self._log.error(
+                f"Cannot find instrument {instrument_id} to subscribe for `OrderBookDelta` data. "
+                "No data has been loaded for this instrument.",
+            )
+            return
+
         self._add_subscription_order_book_deltas(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_order_book_snapshots(
         self,
         InstrumentId instrument_id,
         BookType book_type,
         int depth = 0,
         dict kwargs = None,
     ):
         Condition.not_none(instrument_id, "instrument_id")
 
+        if not self._cache.instrument(instrument_id):
+            self._log.error(
+                f"Cannot find instrument {instrument_id} to subscribe for `OrderBook` data. "
+                "No data has been loaded for this instrument.",
+            )
+            return
+
         self._add_subscription_order_book_snapshots(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_ticker(self, InstrumentId instrument_id):
         Condition.not_none(instrument_id, "instrument_id")
 
+        if not self._cache.instrument(instrument_id):
+            self._log.error(
+                f"Cannot find instrument {instrument_id} to subscribe for `Ticker` data. "
+                "No data has been loaded for this instrument.",
+            )
+            return
+
         self._add_subscription_ticker(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_quote_ticks(self, InstrumentId instrument_id):
         Condition.not_none(instrument_id, "instrument_id")
 
+        if not self._cache.instrument(instrument_id):
+            self._log.error(
+                f"Cannot find instrument {instrument_id} to subscribe for `QuoteTick` data. "
+                "No data has been loaded for this instrument.",
+            )
+            return
+
         self._add_subscription_quote_ticks(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_trade_ticks(self, InstrumentId instrument_id):
         Condition.not_none(instrument_id, "instrument_id")
 
+        if not self._cache.instrument(instrument_id):
+            self._log.error(
+                f"Cannot find instrument {instrument_id} to subscribe for `TradeTick` data. "
+                "No data has been loaded for this instrument.",
+            )
+            return
+
         self._add_subscription_trade_ticks(instrument_id)
         # Do nothing else for backtest
 
     cpdef void subscribe_bars(self, BarType bar_type):
         Condition.not_none(bar_type, "bar_type")
 
+        if not self._cache.instrument(bar_type.instrument_id):
+            self._log.error(
+                f"Cannot find instrument {bar_type.instrument_id} to subscribe for `Bar` data. "
+                "No data has been loaded for this instrument.",
+            )
+            return
+
         self._add_subscription_bars(bar_type)
         # Do nothing else for backtest
 
     cpdef void subscribe_venue_status_updates(self, Venue venue):
         Condition.not_none(venue, "venue")
 
         self._add_subscription_venue_status_updates(venue)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pxd` & `nautilus_trader-1.176.0/nautilus_trader/backtest/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pyx` & `nautilus_trader-1.176.0/nautilus_trader/backtest/engine.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -358,14 +358,15 @@
         book_type: BookType = BookType.L1_TBBO,
         routing: bool = False,
         frozen_account: bool = False,
         bar_execution: bool = True,
         reject_stop_orders: bool = True,
         support_gtd_orders: bool = True,
         use_random_ids: bool = False,
+        use_reduce_only: bool = True,
     ) -> None:
         """
         Add a `SimulatedExchange` with the given parameters to the backtest engine.
 
         Parameters
         ----------
         venue : Venue
@@ -399,14 +400,16 @@
             If bars should be processed by the matching engine(s) (and move the market).
         reject_stop_orders : bool, default True
             If stop orders are rejected on submission if trigger price is in the market.
         support_gtd_orders : bool, default True
             If orders with GTD time in force will be supported by the venue.
         use_random_ids : bool, default False
             If venue order and position IDs will be randomly generated UUID4s.
+        use_reduce_only : bool, default True
+            If the `reduce_only` execution instruction on orders will be honored.
 
         Raises
         ------
         ValueError
             If `venue` is already registered with the engine.
 
         """
@@ -746,16 +749,14 @@
         if self.kernel.data_engine.is_running:
             self.kernel.data_engine.stop()
         self.kernel.data_engine.reset()
 
         # Reset ExecEngine
         if self.kernel.exec_engine.is_running:
             self.kernel.exec_engine.stop()
-        if self._config.cache_database is not None and self._config.cache_database.flush:
-            self.kernel.exec_engine.flush_db()
         self.kernel.exec_engine.reset()
 
         # Reset RiskEngine
         if self.kernel.risk_engine.is_running:
             self.kernel.risk_engine.stop()
         self.kernel.risk_engine.reset()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pxd` & `nautilus_trader-1.176.0/nautilus_trader/backtest/exchange.pxd`

 * *Files 1% similar despite different names*

```diff
@@ -83,14 +83,16 @@
     """If bars should be processed by the matching engine(s) (and move the market).\n\n:returns: `bool`"""
     cdef readonly bint reject_stop_orders
     """If stop orders are rejected on submission if in the market.\n\n:returns: `bool`"""
     cdef readonly bint support_gtd_orders
     """If orders with GTD time in force will be supported by the venue.\n\n:returns: `bool`"""
     cdef readonly bint use_random_ids
     """If venue order and position IDs will be randomly generated UUID4s.\n\n:returns: `bool`"""
+    cdef readonly bint use_reduce_only
+    """If the `reduce_only` option on orders will be honored.\n\n:returns: `bool`"""
     cdef readonly list modules
     """The simulation modules registered with the exchange.\n\n:returns: `list[SimulationModule]`"""
     cdef readonly dict instruments
     """The exchange instruments.\n\n:returns: `dict[InstrumentId, Instrument]`"""
 
     cdef dict _matching_engines
     cdef Queue _message_queue
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pyx` & `nautilus_trader-1.176.0/nautilus_trader/backtest/exchange.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -99,14 +99,16 @@
         If bars should be processed by the matching engine(s) (and move the market).
     reject_stop_orders : bool, default True
         If stop orders are rejected on submission if in the market.
     support_gtd_orders : bool, default True
         If orders with GTD time in force will be supported by the venue.
     use_random_ids : bool, default False
         If venue order and position IDs will be randomly generated UUID4s.
+    use_reduce_only : bool, default True
+        If the `reduce_only` execution instruction on orders will be honored.
 
     Raises
     ------
     ValueError
         If `instruments` is empty.
     ValueError
         If `instruments` contains a type other than `Instrument`.
@@ -139,14 +141,15 @@
         LatencyModel latency_model = None,
         BookType book_type = BookType.L1_TBBO,
         bint frozen_account = False,
         bint bar_execution = True,
         bint reject_stop_orders = True,
         bint support_gtd_orders = True,
         bint use_random_ids = False,
+        bint use_reduce_only = True,
     ):
         Condition.list_type(instruments, Instrument, "instruments", "Instrument")
         Condition.not_empty(starting_balances, "starting_balances")
         Condition.list_type(starting_balances, Money, "starting_balances")
         Condition.list_type(modules, SimulationModule, "modules", "SimulationModule")
         if base_currency:
             Condition.true(len(starting_balances) == 1, "single-currency account has multiple starting currencies")
@@ -177,14 +180,15 @@
         self.is_frozen_account = frozen_account
 
         # Execution
         self.bar_execution = bar_execution
         self.reject_stop_orders = reject_stop_orders
         self.support_gtd_orders = support_gtd_orders
         self.use_random_ids = use_random_ids
+        self.use_reduce_only = use_reduce_only
         self.fill_model = fill_model
         self.latency_model = latency_model
 
         # Load modules
         self.modules = []
         for module in modules:
             Condition.not_in(module, self.modules, "module", "modules")
@@ -323,14 +327,15 @@
             cache=self.cache,
             clock=self._clock,
             logger=self._log.get_logger(),
             bar_execution=self.bar_execution,
             reject_stop_orders=self.reject_stop_orders,
             support_gtd_orders=self.support_gtd_orders,
             use_random_ids=self.use_random_ids,
+            use_reduce_only=self.use_reduce_only,
         )
 
         self._matching_engines[instrument.id] = matching_engine
 
         self._log.info(f"Added instrument {instrument.id} and created matching engine.")
 
 # -- QUERIES --------------------------------------------------------------------------------------
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pxd` & `nautilus_trader-1.176.0/nautilus_trader/backtest/execution_client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pyx` & `nautilus_trader-1.176.0/nautilus_trader/backtest/execution_client.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pxd` & `nautilus_trader-1.176.0/nautilus_trader/backtest/matching_engine.pxd`

 * *Files 0% similar despite different names*

```diff
@@ -75,14 +75,15 @@
     cdef OrderBook _closing_auction_book
     cdef FillModel _fill_model
     # cdef object _auction_match_algo
     cdef bint _bar_execution
     cdef bint _reject_stop_orders
     cdef bint _support_gtd_orders
     cdef bint _use_random_ids
+    cdef bint _use_reduce_only
     cdef dict _account_ids
 
     cdef readonly Venue venue
     """The venue for the matching engine.\n\n:returns: `Venue`"""
     cdef readonly Instrument instrument
     """The instrument for the matching engine.\n\n:returns: `Instrument`"""
     cdef readonly uint32_t raw_id
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pyx` & `nautilus_trader-1.176.0/nautilus_trader/backtest/matching_engine.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -119,14 +119,16 @@
         If bars should be processed by the matching engine(s) (and move the market).
     reject_stop_orders : bool, default True
         If stop orders are rejected if already in the market on submitting.
     support_gtd_orders : bool, default True
         If orders with GTD time in force will be supported by the venue.
     use_random_ids : bool, default False
         If venue order and position IDs will be randomly generated UUID4s.
+    use_reduce_only : bool, default True
+        If the `reduce_only` execution instruction on orders will be honored.
     auction_match_algo : Callable[[Ladder, Ladder], Tuple[List, List], optional
         The auction matching algorithm.
     """
 
     def __init__(
         self,
         Instrument instrument not None,
@@ -138,14 +140,15 @@
         CacheFacade cache not None,
         TestClock clock not None,
         Logger logger not None,
         bint bar_execution = True,
         bint reject_stop_orders = True,
         bint support_gtd_orders = True,
         bint use_random_ids = False,
+        bint use_reduce_only = True,
         # auction_match_algo = default_auction_match
     ):
         self._clock = clock
         self._log = LoggerAdapter(
             component_name=f"{type(self).__name__}({instrument.id.venue})",
             logger=logger,
         )
@@ -159,14 +162,15 @@
         self.oms_type = oms_type
         self.market_status = MarketStatus.OPEN
 
         self._bar_execution = bar_execution
         self._reject_stop_orders = reject_stop_orders
         self._support_gtd_orders = support_gtd_orders
         self._use_random_ids = use_random_ids
+        self._use_reduce_only = use_reduce_only
         # self._auction_match_algo = auction_match_algo
         self._fill_model = fill_model
         self._book = OrderBook(
             instrument_id=instrument.id,
             book_type=book_type,
         )
         self._opening_auction_book = OrderBook(
@@ -178,15 +182,16 @@
             book_type=BookType.L3_MBO,
         )
 
         self._account_ids: dict[TraderId, AccountId]  = {}
 
         # Market
         self._core = MatchingCore(
-            instrument=instrument,
+            instrument_id=instrument.id,
+            price_increment=instrument.price_increment,
             trigger_stop_order=self.trigger_stop_order,
             fill_market_order=self.fill_market_order,
             fill_limit_order=self.fill_limit_order,
         )
 
         self._target_bid = 0
         self._target_ask = 0
@@ -630,15 +635,15 @@
                 return  # Order rejected
             elif parent.status_c() == OrderStatus.ACCEPTED or parent.status_c() == OrderStatus.TRIGGERED:
                 self._log.info(f"Pending OTO {order.client_order_id} triggers from {parent.client_order_id}")
                 return  # Pending trigger
 
         # Check reduce-only instruction
         cdef Position position
-        if order.is_reduce_only and not order.is_closed_c():
+        if self._use_reduce_only and order.is_reduce_only and not order.is_closed_c():
             position = self.cache.position_for_order(order.client_order_id)
             if (
                 not position
                 or position.is_closed_c()
                 or (order.is_buy_c() and position.is_long_c())
                 or (order.is_sell_c() and position.is_short_c())
             ):
@@ -1084,15 +1089,15 @@
                     self.fill_limit_order(order)  # Immediate fill as TAKER
                     return  # Filled
 
         self._generate_order_updated(order, qty, price, trigger_price or order.trigger_price)
 
     cdef void _update_trailing_stop_order(self, Order order):
         cdef tuple output = TrailingStopCalculator.calculate(
-            instrument=self.instrument,
+            price_increment=self.instrument.price_increment,
             order=order,
             bid=self._core.bid,
             ask=self._core.ask,
             last=self._core.last,
         )
 
         cdef Price new_trigger_price = output[0]
@@ -1342,15 +1347,15 @@
             The order to fill.
 
         """
         cdef PositionId venue_position_id = self._get_position_id(order)
         cdef Position position = None
         if venue_position_id is not None:
             position = self.cache.position(venue_position_id)
-        if order.is_reduce_only and position is None:
+        if self._use_reduce_only and order.is_reduce_only and position is None:
             self._log.warning(
                 f"Canceling REDUCE_ONLY {order.type_string_c()} "
                 f"as would increase position.",
             )
             self.cancel_order(order)
             return  # Order canceled
 
@@ -1389,15 +1394,15 @@
             elif order.side == OrderSide.SELL and self._core.ask_raw == price._mem.raw and not self._fill_model.is_limit_filled():
                 return  # Not filled
 
         cdef PositionId venue_position_id = self._get_position_id(order)
         cdef Position position = None
         if venue_position_id is not None:
             position = self.cache.position(venue_position_id)
-        if order.is_reduce_only and position is None:
+        if self._use_reduce_only and order.is_reduce_only and position is None:
             self._log.warning(
                 f"Canceling REDUCE_ONLY {order.type_string_c()} "
                 f"as would increase position.",
             )
             self.cancel_order(order)
             return  # Order canceled
 
@@ -1419,14 +1424,16 @@
         PositionId venue_position_id: Optional[PositionId] = None,
         Position position: Optional[Position] = None,
     ):
         """
         Apply the given list of fills to the given order. Optionally provide
         existing position details.
 
+        If the `fills` list is empty, then an error will be logged.
+
         Parameters
         ----------
         order : Order
             The order to fill.
         fills : list[tuple[Price, Quantity]]
             The fills to apply to the order.
         liquidity_side : LiquiditySide
@@ -1449,34 +1456,35 @@
         Condition.not_none(order, "order")
         Condition.not_none(fills, "fills")
         Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")
 
         order.liquidity_side = liquidity_side
 
         if not fills:
+            self._log.error(
+                "Cannot fill order: no fills from book when fills were expected (check sizes in data).",
+            )
             return  # No fills
 
         if self.oms_type == OmsType.NETTING:
             venue_position_id = None  # No position IDs generated by the venue
 
         if not self._log.is_bypassed:
             self._log.debug(
                 f"Applying fills to {order}, "
                 f"venue_position_id={venue_position_id}, "
                 f"position={position}, "
                 f"fills={fills}.",
             )
 
         cdef:
-            uint64_t raw_org_qty
-            uint64_t raw_adj_qty
             Price fill_px
             Quantity fill_qty
-            Quantity updated_qty
             bint initial_market_to_limit_fill = False
+            Price last_fill_px = None
         for fill_px, fill_qty in fills:
             if order.filled_qty._mem.raw == 0:
                 if order.order_type == OrderType.MARKET_TO_LIMIT:
                     self._generate_order_updated(
                         order,
                         qty=order.quantity,
                         price=fill_px,
@@ -1488,53 +1496,55 @@
                     self.cancel_order(order)
                     return
             elif order.time_in_force == TimeInForce.IOC:
                 # IOC order has already filled at one price - cancel remaining
                 self.cancel_order(order)
                 return
 
-            if order.is_reduce_only and order.leaves_qty._mem.raw == 0:
-                return  # Done early
             if self.book_type == BookType.L1_TBBO and self._fill_model.is_slipped():
                 if order.side == OrderSide.BUY:
                     fill_px = fill_px.add(self.instrument.price_increment)
                 elif order.side == OrderSide.SELL:
                     fill_px = fill_px.sub(self.instrument.price_increment)
                 else:
                     raise ValueError(  # pragma: no cover (design-time error)
                         f"invalid `OrderSide`, was {order.side}",  # pragma: no cover (design-time error)
                     )
-            if order.is_reduce_only and fill_qty._mem.raw > position.quantity._mem.raw:
-                # Adjust fill to honor reduce only execution
-                raw_org_qty = fill_qty._mem.raw
-                raw_adj_qty = fill_qty._mem.raw - (fill_qty._mem.raw - position.quantity._mem.raw)
-                fill_qty = Quantity.from_raw_c(raw_adj_qty, fill_qty._mem.precision)
-                updated_qty = Quantity.from_raw_c(
-                    order.quantity._mem.raw - (raw_org_qty - raw_adj_qty),
-                    fill_qty._mem.precision)
-                if updated_qty._mem.raw > 0:
-                    self._generate_order_updated(
-                        order=order,
-                        qty=updated_qty,
-                        price=None,
-                        trigger_price=None,
-                    )
-            if not fill_qty._mem.raw > 0:
+
+            # Check reduce only order
+            if self._use_reduce_only and order.is_reduce_only and fill_qty._mem.raw > position.quantity._mem.raw:
+                if position.quantity._mem.raw == 0:
+                    return  # Done
+
+                # Adjust fill to honor reduce only execution (fill remaining position size only)
+                fill_qty = Quantity.from_raw_c(position.quantity._mem.raw, fill_qty._mem.precision)
+
+                self._generate_order_updated(
+                    order=order,
+                    qty=fill_qty,
+                    price=None,
+                    trigger_price=None,
+                )
+
+            if fill_qty._mem.raw == 0:
                 return  # Done
+
             self.fill_order(
                 order=order,
                 last_px=fill_px,
                 last_qty=fill_qty,
                 liquidity_side=order.liquidity_side,
                 venue_position_id=venue_position_id,
                 position=position,
             )
             if order.order_type == OrderType.MARKET_TO_LIMIT and initial_market_to_limit_fill:
                 return  # Filled initial level
 
+            last_fill_px = fill_px
+
         if (
             order.is_open_c()
             and self.book_type == BookType.L1_TBBO
             and (
             order.order_type == OrderType.MARKET
             or order.order_type == OrderType.MARKET_IF_TOUCHED
             or order.order_type == OrderType.STOP_MARKET
@@ -1542,19 +1552,20 @@
         ):
             if order.time_in_force == TimeInForce.IOC:
                 # IOC order has already filled at one price - cancel remaining
                 self.cancel_order(order)
                 return
 
             # Exhausted simulated book volume (continue aggressive filling into next level)
-            fill_px = fills[-1][0]
+            # This is a very basic implementation of slipping by a single tick, in the future
+            # we will implement more detailed fill modeling.
             if order.side == OrderSide.BUY:
-                fill_px = fill_px.add(self.instrument.price_increment)
+                fill_px = last_fill_px.add(self.instrument.price_increment)
             elif order.side == OrderSide.SELL:
-                fill_px = fill_px.sub(self.instrument.price_increment)
+                fill_px = last_fill_px.sub(self.instrument.price_increment)
             else:
                 raise ValueError(  # pragma: no cover (design-time error)
                     f"invalid `OrderSide`, was {order.side}",  # pragma: no cover (design-time error)
                 )
 
             self.fill_order(
                 order=order,
@@ -1692,15 +1703,16 @@
 
         if position is None:
             return  # Fill completed
 
         # Check reduce only orders for position
         for order in self.cache.orders_for_position(position.id):
             if (
-                order.is_reduce_only
+                self._use_reduce_only
+                and order.is_reduce_only
                 and order.is_open_c()
                 and order.is_passive_c()
             ):
                 if position.quantity._mem.raw == 0:
                     self.cancel_order(order)
                 elif order.leaves_qty._mem.raw != position.quantity._mem.raw:
                     self.update_order(
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/models.pxd` & `nautilus_trader-1.176.0/nautilus_trader/backtest/models.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/models.pyx` & `nautilus_trader-1.176.0/nautilus_trader/backtest/models.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pxd` & `nautilus_trader-1.176.0/nautilus_trader/backtest/modules.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pyx` & `nautilus_trader-1.176.0/nautilus_trader/backtest/modules.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/node.py` & `nautilus_trader-1.176.0/nautilus_trader/backtest/node.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,16 +9,17 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 from decimal import Decimal
-from typing import Optional
 
 import pandas as pd
 
 from nautilus_trader.backtest.engine import BacktestEngine
 from nautilus_trader.backtest.engine import BacktestEngineConfig
 from nautilus_trader.backtest.results import BacktestResult
 from nautilus_trader.config import ActorFactory
@@ -53,14 +54,15 @@
 
     Raises
     ------
     ValueError
         If `configs` is ``None`` or empty.
     ValueError
         If `configs` contains a type other than `BacktestRunConfig`.
+
     """
 
     def __init__(self, configs: list[BacktestRunConfig]):
         PyCondition.not_none(configs, "configs")
         PyCondition.not_empty(configs, "configs")
         PyCondition.true(
             all(isinstance(config, BacktestRunConfig) for config in configs),
@@ -81,18 +83,17 @@
         Returns
         -------
         list[BacktestRunConfig]
 
         """
         return self._configs
 
-    def get_engine(self, run_config_id: str) -> Optional[BacktestEngine]:
+    def get_engine(self, run_config_id: str) -> BacktestEngine | None:
         """
-        Return the backtest engine associated with the given run config ID
-        (if found).
+        Return the backtest engine associated with the given run config ID (if found).
 
         Parameters
         ----------
         run_config_id : str
             The run configuration ID for the created engine.
 
         Returns
@@ -161,15 +162,15 @@
     ) -> BacktestEngine:
         # Build the backtest engine
         engine = BacktestEngine(config=config)
         self._engines[run_config_id] = engine
 
         # Add venues (must be added prior to instruments)
         for config in venue_configs:
-            base_currency: Optional[str] = config.base_currency
+            base_currency: str | None = config.base_currency
             leverages = (
                 {InstrumentId.from_str(i): Decimal(v) for i, v in config.leverages.items()}
                 if config.leverages
                 else {}
             )
             engine.add_venue(
                 venue=Venue(config.name),
@@ -180,14 +181,17 @@
                 default_leverage=Decimal(config.default_leverage),
                 leverages=leverages,
                 book_type=book_type_from_str(config.book_type),
                 routing=config.routing,
                 modules=[ActorFactory.create(module) for module in (config.modules or [])],
                 frozen_account=config.frozen_account,
                 reject_stop_orders=config.reject_stop_orders,
+                support_gtd_orders=config.support_gtd_orders,
+                use_random_ids=config.use_random_ids,
+                use_reduce_only=config.use_reduce_only,
             )
 
         # Add instruments
         for config in data_configs:
             if is_nautilus_class(config.data_type):
                 instruments = config.catalog().instruments(
                     instrument_ids=config.instrument_id,
@@ -211,15 +215,15 @@
 
     def _run(
         self,
         run_config_id: str,
         engine_config: BacktestEngineConfig,
         venue_configs: list[BacktestVenueConfig],
         data_configs: list[BacktestDataConfig],
-        batch_size_bytes: Optional[int] = None,
+        batch_size_bytes: int | None = None,
     ) -> BacktestResult:
         engine: BacktestEngine = self._create_engine(
             run_config_id=run_config_id,
             config=engine_config,
             venue_configs=venue_configs,
             data_configs=data_configs,
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/backtest/results.py` & `nautilus_trader-1.176.0/nautilus_trader/backtest/results.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,33 +9,34 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 from dataclasses import dataclass
-from typing import Optional
 
 
 @dataclass
 class BacktestResult:
     """
     Represents the results of a single complete backtest run.
     """
 
     trader_id: str
     machine_id: str
-    run_config_id: Optional[str]
+    run_config_id: str | None
     instance_id: str
     run_id: str
-    run_started: Optional[int]
-    run_finished: Optional[int]
-    backtest_start: Optional[int]
-    backtest_end: Optional[int]
+    run_started: int | None
+    run_finished: int | None
+    backtest_start: int | None
+    backtest_end: int | None
     elapsed_time: float
     iterations: int
     total_events: int
     total_orders: int
     total_positions: int
     stats_pnls: dict[str, dict[str, float]]
     stats_returns: dict[str, float]
@@ -58,15 +59,17 @@
     #     return f"{self.__class__.__name__}({self.run_id}, {repr_balance()})"
 
 
 def ensure_plotting(func):
     """
     Decorate a function that require a plotting library.
 
-    Ensures library is installed and providers a better error about how to install if not found.
+    Ensures library is installed and providers a better error about how to install if
+    not found.
+
     """
 
     def inner(*args, **kwargs):
         try:
             import hvplot.pandas
 
             assert hvplot.pandas
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/cache/__init__.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -8,14 +8,14 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 The `cache` subpackage provides common caching infrastructure.
 
 A running Nautilus system generally uses a single centralized cache which can be
 accessed by many components.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/base.pxd` & `nautilus_trader-1.176.0/nautilus_trader/cache/base.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -20,33 +20,35 @@
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.ticker cimport Ticker
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.identifiers cimport AccountId
+from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.identifiers cimport VenueOrderId
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orderbook.book cimport OrderBook
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.orders.list cimport OrderList
 from nautilus_trader.model.position cimport Position
 
 
 cdef class CacheFacade:
 
-# -- GENERAL --------------------------------------------------------------------------------------  # noqa
+# -- GENERAL --------------------------------------------------------------------------------------
 
     cpdef bytes get(self, str key)
     cpdef void add(self, str key, bytes value)
 
 # -- DATA QUERIES ---------------------------------------------------------------------------------
 
     cpdef list tickers(self, InstrumentId instrument_id)
@@ -80,14 +82,20 @@
 
 # -- INSTRUMENT QUERIES ---------------------------------------------------------------------------
 
     cpdef Instrument instrument(self, InstrumentId instrument_id)
     cpdef list instrument_ids(self, Venue venue=*)
     cpdef list instruments(self, Venue venue=*)
 
+# -- SYNTHETIC QUERIES ---------------------------------------------------------------------------
+
+    cpdef SyntheticInstrument synthetic(self, InstrumentId instrument_id)
+    cpdef list synthetic_ids(self)
+    cpdef list synthetics(self)
+
 # -- ACCOUNT QUERIES ------------------------------------------------------------------------------
 
     cpdef Account account(self, AccountId account_id)
     cpdef Account account_for_venue(self, Venue venue)
     cpdef AccountId account_id(self, Venue venue)
     cpdef list accounts(self)
 
@@ -107,14 +115,15 @@
     cpdef set exec_algorithm_ids(self)
 
 # -- ORDER QUERIES --------------------------------------------------------------------------------
 
     cpdef Order order(self, ClientOrderId client_order_id)
     cpdef ClientOrderId client_order_id(self, VenueOrderId venue_order_id)
     cpdef VenueOrderId venue_order_id(self, ClientOrderId client_order_id)
+    cpdef ClientId client_id(self, ClientOrderId client_order_id)
     cpdef list orders(self, Venue venue=*, InstrumentId instrument_id=*, StrategyId strategy_id=*, OrderSide side=*)
     cpdef list orders_open(self, Venue venue=*, InstrumentId instrument_id=*, StrategyId strategy_id=*, OrderSide side=*)
     cpdef list orders_closed(self, Venue venue=*, InstrumentId instrument_id=*, StrategyId strategy_id=*, OrderSide side=*)
     cpdef list orders_emulated(self, Venue venue=*, InstrumentId instrument_id=*, StrategyId strategy_id=*, OrderSide side=*)
     cpdef list orders_inflight(self, Venue venue=*, InstrumentId instrument_id=*, StrategyId strategy_id=*, OrderSide side=*)
     cpdef list orders_for_position(self, PositionId position_id)
     cpdef list orders_for_exec_algorithm(self, ExecAlgorithmId exec_algorithm_id, Venue venue=*, InstrumentId instrument_id=*, StrategyId strategy_id=*, OrderSide side=*)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/cache/base.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -17,23 +17,25 @@
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.bar cimport BarType
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.ticker cimport Ticker
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.identifiers cimport AccountId
+from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.identifiers cimport VenueOrderId
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
 
 
 cdef class CacheFacade:
     """
     Provides a read-only facade for the common `Cache`.
     """
 
@@ -149,14 +151,28 @@
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef list instruments(self, Venue venue = None):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
+# -- SYNTHETIC QUERIES ---------------------------------------------------------------------------
+
+    cpdef SyntheticInstrument synthetic(self, InstrumentId instrument_id):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
+    cpdef list synthetic_ids(self):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
+    cpdef list synthetics(self):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
 # -- ACCOUNT QUERIES ------------------------------------------------------------------------------
 
     cpdef Account account(self, AccountId account_id):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef Account account_for_venue(self, Venue venue):
@@ -231,14 +247,18 @@
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef VenueOrderId venue_order_id(self, ClientOrderId client_order_id):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
+    cpdef ClientId client_id(self, ClientOrderId client_order_id):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
     cpdef list orders(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef list orders_open(self, Venue venue = None, InstrumentId instrument_id = None, StrategyId strategy_id = None, OrderSide side = OrderSide.NO_ORDER_SIDE):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/cache.pxd` & `nautilus_trader-1.176.0/nautilus_trader/cache/cache.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from cpython.datetime cimport datetime
+
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.accounting.calculators cimport ExchangeRateCalculator
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.cache.database cimport CacheDatabase
 from nautilus_trader.common.actor cimport Actor
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.execution.messages cimport SubmitOrder
@@ -26,21 +28,24 @@
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.ticker cimport Ticker
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.identifiers cimport AccountId
+from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.orderbook.book cimport OrderBook
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.orders.list cimport OrderList
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.trading.strategy cimport Strategy
 
 
@@ -56,28 +61,28 @@
     cdef dict _trade_ticks
     cdef dict _order_books
     cdef dict _bars
     cdef dict _bars_bid
     cdef dict _bars_ask
     cdef dict _currencies
     cdef dict _instruments
+    cdef dict _synthetics
     cdef dict _accounts
     cdef dict _orders
     cdef dict _order_lists
     cdef dict _positions
     cdef dict _position_snapshots
-    cdef dict _submit_order_commands
-    cdef dict _submit_order_list_commands
 
     cdef dict _index_venue_account
     cdef dict _index_venue_orders
     cdef dict _index_venue_positions
     cdef dict _index_order_ids
     cdef dict _index_order_position
     cdef dict _index_order_strategy
+    cdef dict _index_order_client
     cdef dict _index_position_strategy
     cdef dict _index_position_orders
     cdef dict _index_instrument_orders
     cdef dict _index_instrument_positions
     cdef dict _index_strategy_orders
     cdef dict _index_strategy_positions
     cdef dict _index_exec_algorithm_orders
@@ -94,23 +99,27 @@
     cdef set _index_strategies
     cdef set _index_exec_algorithms
 
     cdef readonly int tick_capacity
     """The caches tick capacity.\n\n:returns: `int`"""
     cdef readonly int bar_capacity
     """The caches bar capacity.\n\n:returns: `int`"""
+    cdef readonly bint snapshot_orders
+    """If order state snapshots should be taken.\n\n:returns: `bool`"""
+    cdef readonly bint snapshot_positions
+    """If position state snapshots should be taken.\n\n:returns: `bool`"""
 
     cpdef void cache_general(self)
     cpdef void cache_currencies(self)
     cpdef void cache_instruments(self)
+    cpdef void cache_synthetics(self)
     cpdef void cache_accounts(self)
     cpdef void cache_orders(self)
     cpdef void cache_order_lists(self)
     cpdef void cache_positions(self)
-    cpdef void cache_commands(self)
     cpdef void build_index(self)
     cpdef bint check_integrity(self)
     cpdef bint check_residuals(self)
     cpdef void clear_index(self)
     cpdef void reset(self)
     cpdef void flush_db(self)
 
@@ -119,43 +128,47 @@
     cdef void _cache_venue_account_id(self, AccountId account_id)
     cdef void _build_indexes_from_orders(self)
     cdef void _build_indexes_from_positions(self)
     cdef set _build_order_query_filter_set(self, Venue venue, InstrumentId instrument_id, StrategyId strategy_id)
     cdef set _build_position_query_filter_set(self, Venue venue, InstrumentId instrument_id, StrategyId strategy_id)
     cdef list _get_orders_for_ids(self, set client_order_ids, OrderSide side)
     cdef list _get_positions_for_ids(self, set position_ids, PositionSide side)
+    cdef void _assign_position_id_to_contingencies(self, Order order)
+    cdef Money _calculate_unrealized_pnl(self, Position position)
 
     cpdef Instrument load_instrument(self, InstrumentId instrument_id)
+    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id)
     cpdef Account load_account(self, AccountId account_id)
     cpdef Order load_order(self, ClientOrderId order_id)
     cpdef Position load_position(self, PositionId position_id)
     cpdef void load_actor(self, Actor actor)
     cpdef void load_strategy(self, Strategy strategy)
-    cpdef SubmitOrder load_submit_order_command(self, ClientOrderId client_order_id)
-    cpdef SubmitOrderList load_submit_order_list_command(self, OrderListId order_list_id)
 
     cpdef void add_order_book(self, OrderBook order_book)
     cpdef void add_ticker(self, Ticker ticker)
     cpdef void add_quote_tick(self, QuoteTick tick)
     cpdef void add_trade_tick(self, TradeTick tick)
     cpdef void add_bar(self, Bar bar)
     cpdef void add_quote_ticks(self, list ticks)
     cpdef void add_trade_ticks(self, list ticks)
     cpdef void add_bars(self, list bars)
     cpdef void add_currency(self, Currency currency)
     cpdef void add_instrument(self, Instrument instrument)
+    cpdef void add_synthetic(self, SyntheticInstrument synthetic)
     cpdef void add_account(self, Account account)
-    cpdef void add_order(self, Order order, PositionId position_id, bint override=*)
+    cpdef void add_order(self, Order order, PositionId position_id=*, ClientId client_id=*, bint override=*)
     cpdef void add_order_list(self, OrderList order_list)
     cpdef void add_position_id(self, PositionId position_id, Venue venue, ClientOrderId client_order_id, StrategyId strategy_id)
     cpdef void add_position(self, Position position, OmsType oms_type)
     cpdef void snapshot_position(self, Position position)
-    cpdef void add_submit_order_command(self, SubmitOrder command)
-    cpdef void add_submit_order_list_command(self, SubmitOrderList command)
+    cpdef void snapshot_position_state(self, Position position)
+    cpdef void snapshot_order_state(self, Order order)
 
     cpdef void update_account(self, Account account)
     cpdef void update_order(self, Order order)
     cpdef void update_position(self, Position position)
     cpdef void update_actor(self, Actor actor)
     cpdef void delete_actor(self, Actor actor)
     cpdef void update_strategy(self, Strategy strategy)
     cpdef void delete_strategy(self, Strategy strategy)
+
+    cpdef void heartbeat(self, datetime timestamp)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/cache.pyx` & `nautilus_trader-1.176.0/nautilus_trader/cache/cache.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 import uuid
 from collections import deque
 from decimal import Decimal
 from typing import Optional
 
 from nautilus_trader.config import CacheConfig
 
+from cpython.datetime cimport datetime
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.accounting.calculators cimport ExchangeRateCalculator
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.logging cimport LogColor
 from nautilus_trader.common.logging cimport Logger
@@ -42,26 +43,29 @@
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.identifiers cimport AccountId
+from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ComponentId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.identifiers cimport VenueOrderId
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.instruments.crypto_perpetual cimport CryptoPerpetual
 from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.orders.list cimport OrderList
 from nautilus_trader.trading.strategy cimport Strategy
 
 
 cdef class Cache(CacheFacade):
@@ -96,42 +100,44 @@
         self._database = database
         self._log = LoggerAdapter(component_name=type(self).__name__, logger=logger)
         self._xrate_calculator = ExchangeRateCalculator()
 
         # Configuration
         self.tick_capacity = config.tick_capacity
         self.bar_capacity = config.bar_capacity
+        self.snapshot_orders = config.snapshot_orders
+        self.snapshot_positions = config.snapshot_positions
 
         # Caches
         self._general: dict[str, bytes] = {}
         self._xrate_symbols: dict[InstrumentId, str] = {}
         self._tickers: dict[InstrumentId, deque[Ticker]] = {}
         self._quote_ticks: dict[InstrumentId, deque[QuoteTick]] = {}
         self._trade_ticks: dict[InstrumentId, deque[TradeTick]] = {}
         self._order_books: dict[InstrumentId, OrderBook] = {}
         self._bars: dict[BarType, deque[Bar]] = {}
         self._bars_bid: dict[InstrumentId, Bar] = {}
         self._bars_ask: dict[InstrumentId, Bar] = {}
         self._currencies: dict[str, Currency] = {}
         self._instruments: dict[InstrumentId, Instrument] = {}
+        self._synthetics: dict[InstrumentId, SyntheticInstrument] = {}
         self._accounts: dict[AccountId, Account] = {}
         self._orders: dict[ClientOrderId, Order] = {}
         self._order_lists: dict[OrderListId, OrderList] = {}
         self._positions: dict[PositionId, Position] = {}
         self._position_snapshots: dict[PositionId, list[bytes]] = {}
-        self._submit_order_commands: dict[ClientOrderId, SubmitOrder] = {}
-        self._submit_order_list_commands: dict[OrderListId, SubmitOrderList] = {}
 
         # Cache index
         self._index_venue_account: dict[Venue, AccountId] = {}
         self._index_venue_orders: dict[Venue, set[ClientOrderId]] = {}
         self._index_venue_positions: dict[Venue, set[PositionId]] = {}
         self._index_order_ids: dict[VenueOrderId, ClientOrderId] = {}
         self._index_order_position: dict[ClientOrderId, PositionId] = {}
         self._index_order_strategy: dict[ClientOrderId, StrategyId] = {}
+        self._index_order_client: dict[ClientOrderId, ClientId] = {}
         self._index_position_strategy: dict[PositionId, StrategyId] = {}
         self._index_position_orders: dict[PositionId, set[ClientOrderId]] = {}
         self._index_instrument_orders: dict[InstrumentId, set[ClientOrderId]] = {}
         self._index_instrument_positions: dict[InstrumentId, set[PositionId]] = {}
         self._index_strategy_orders: dict[StrategyId, set[ClientOrderId]] = {}
         self._index_strategy_positions: dict[StrategyId, set[PositionId]] = {}
         self._index_exec_algorithm_orders: dict[ExecAlgorithmId, set[ClientOrderId]] = {}
@@ -207,14 +213,32 @@
 
         cdef int count = len(self._instruments)
         self._log.info(
             f"Cached {count} instrument{'' if count == 1 else 's'} from database.",
             color=LogColor.BLUE if self._instruments else LogColor.NORMAL,
         )
 
+    cpdef void cache_synthetics(self):
+        """
+        Clear the current synthetic instruments cache and load synthetic instruments from the cache
+        database.
+        """
+        self._log.debug(f"Loading synthetic instruments from database...")
+
+        if self._database is not None:
+            self._synthetics = self._database.load_synthetics()
+        else:
+            self._synthetics = {}
+
+        cdef int count = len(self._synthetics)
+        self._log.info(
+            f"Cached {count} synthetic instrument{'' if count == 1 else 's'} from database.",
+            color=LogColor.BLUE if self._synthetics else LogColor.NORMAL,
+        )
+
     cpdef void cache_accounts(self):
         """
         Clear the current accounts cache and load accounts from the cache
         database.
         """
         self._log.debug(f"Loading accounts from database...")
 
@@ -233,32 +257,24 @@
         """
         Clear the current orders cache and load orders from the cache database.
         """
         self._log.debug(f"Loading orders from database...")
 
         if self._database is not None:
             self._orders = self._database.load_orders()
+            self._index_order_position = self._database.load_index_order_position()
+            self._index_order_client = self._database.load_index_order_client()
         else:
             self._orders = {}
 
         # Assign position IDs to contingent orders
         cdef Order order
-        cdef Order contingent_order
-        cdef ClientOrderId client_order_id
         for order in self._orders.values():
-            if order.contingency_type == ContingencyType.OTO:
-                for client_order_id in order.linked_order_ids or []:
-                    contingent_order = self._orders.get(client_order_id)
-                    if contingent_order is None:
-                        self._log.error(f"Contingency order {client_order_id!r} not found.")
-                        continue
-                    # Assign the parents position ID
-                    if contingent_order.position_id is None:
-                        self._log.info(f"Assigned {order.position_id!r} to {client_order_id!r}.")
-                        contingent_order.position_id = order.position_id
+            if order.contingency_type == ContingencyType.OTO and order.position_id is not None:
+                self._assign_position_id_to_contingencies(order)
 
         cdef int count = len(self._orders)
         self._log.info(
             f"Cached {count} order{'' if count == 1 else 's'} from database.",
             color=LogColor.BLUE if self._orders else LogColor.NORMAL,
         )
 
@@ -313,40 +329,14 @@
 
         cdef int count = len(self._positions)
         self._log.info(
             f"Cached {count} position{'' if count == 1 else 's'} from database.",
             color=LogColor.BLUE if self._positions else LogColor.NORMAL
         )
 
-    cpdef void cache_commands(self):
-        """
-        Clear the current submit order commands cache and load commands from the
-        cache database.
-        """
-        self._log.debug(f"Loading commands from database...")
-
-        if self._database is not None:
-            self._submit_order_commands = self._database.load_submit_order_commands()
-            self._submit_order_list_commands = self._database.load_submit_order_list_commands()
-        else:
-            self._submit_order_commands = {}
-            self._submit_order_list_commands = {}
-
-        cdef int count = len(self._submit_order_commands)
-        self._log.info(
-            f"Cached {count} submit_order command{'' if count == 1 else 's'} from database.",
-            color=LogColor.BLUE if self._submit_order_commands else LogColor.NORMAL
-        )
-
-        count = len(self._submit_order_list_commands)
-        self._log.info(
-            f"Cached {count} submit_order_list command{'' if count == 1 else 's'} from database.",
-            color=LogColor.BLUE if self._submit_order_list_commands else LogColor.NORMAL
-        )
-
     cpdef void build_index(self):
         """
         Clear the current cache index and re-build.
         """
         self.clear_index()
 
         self._log.debug(f"Building index...")
@@ -378,17 +368,18 @@
         # caches and indexes, each cache and index must be checked individually
 
         cdef uint64_t timestamp_us = unix_timestamp_us()
         self._log.info("Checking data integrity...")
 
         # Needed type defs
         # ----------------
-        cdef AccountId account_id
-        cdef Order order
-        cdef Position position
+        cdef:
+            AccountId account_id
+            Order order
+            Position position
 
         # Check object caches
         # -------------------
         for account_id in self._accounts:
             if Venue(account_id.get_issuer()) not in self._index_venue_account:
                 self._log.error(
                     f"{failure} in _cached_accounts: "
@@ -685,14 +676,15 @@
 
         self._index_venue_account.clear()
         self._index_venue_orders.clear()
         self._index_venue_positions.clear()
         self._index_order_ids.clear()
         self._index_order_position.clear()
         self._index_order_strategy.clear()
+        self._index_order_client.clear()
         self._index_position_strategy.clear()
         self._index_position_orders.clear()
         self._index_instrument_orders.clear()
         self._index_instrument_positions.clear()
         self._index_strategy_orders.clear()
         self._index_strategy_positions.clear()
         self._index_exec_algorithm_orders.clear()
@@ -726,21 +718,20 @@
         self._trade_ticks.clear()
         self._order_books.clear()
         self._bars.clear()
         self._bars_bid.clear()
         self._bars_ask.clear()
         self._currencies.clear()
         self._instruments.clear()
+        self._synthetics.clear()
         self._accounts.clear()
         self._orders.clear()
         self._order_lists.clear()
         self._positions.clear()
         self._position_snapshots.clear()
-        self._submit_order_commands.clear()
-        self._submit_order_list_commands.clear()
         self.clear_index()
 
         self._log.debug(f"Reset cache.")
 
     cpdef void flush_db(self):
         """
         Flush the caches database which permanently removes all persisted data.
@@ -878,14 +869,54 @@
             # 8: Build _index_positions_closed -> {PositionId}
             elif position.is_closed_c():
                 self._index_positions_closed.add(position_id)
 
             # 9: Build _index_strategies -> {StrategyId}
             self._index_strategies.add(position.strategy_id)
 
+    cdef void _assign_position_id_to_contingencies(self, Order order):
+        cdef:
+            ClientOrderId client_order_id
+            Order contingent_order
+        for client_order_id in order.linked_order_ids or []:
+            contingent_order = self._orders.get(client_order_id)
+            if contingent_order is None:
+                self._log.error(f"Contingency order {client_order_id!r} not found.")
+                continue
+            if contingent_order.position_id is None:
+                # Assign the parents position ID
+                contingent_order.position_id = order.position_id
+
+                self.add_position_id(
+                    order.position_id,
+                    order.instrument_id.venue,
+                    contingent_order.client_order_id,
+                    order.strategy_id,
+                )
+                self._log.info(f"Assigned {order.position_id!r} to {client_order_id!r}.")
+
+    cdef Money _calculate_unrealized_pnl(self, Position position):
+        cdef QuoteTick quote = self.quote_tick(position.instrument_id)
+        if quote is None:
+            self._log.warning(
+                f"Cannot calculate unrealized PnL for {position.id!r}, "
+                f"no quotes for {position.instrument_id}.",
+            )
+            return None
+
+        cdef Price last
+        if position.side == PositionSide.FLAT:
+            return Money(0.0, position.settlement_currency)
+        elif position.side == PositionSide.LONG:
+            last = quote.ask
+        else:
+            last = quote.bid
+
+        return position.unrealized_pnl(last)
+
     cpdef void load_actor(self, Actor actor):
         """
         Load the state dictionary into the given actor.
 
         Parameters
         ----------
         actor : Actor
@@ -937,27 +968,57 @@
         Parameters
         ----------
         instrument_id : InstrumentId
             The instrument ID to load.
 
         Returns
         -------
-        Account or ``None``
+        Instrument or ``None``
 
         """
         Condition.not_none(instrument_id, "instrument_id")
 
         cdef Instrument instrument = self._instruments.get(instrument_id)
         if instrument is None and self._database is not None:
             instrument = self._database.load_instrument(instrument_id)
             if instrument is not None:
                 self._instruments[instrument.id] = instrument
 
         return instrument
 
+    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id):
+        """
+        Load the synthetic instrument associated with the given `instrument_id` (if found).
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId
+            The synthetic instrument ID to load.
+
+        Returns
+        -------
+        SyntheticInstrument or ``None``
+
+        Raises
+        ------
+        ValueError
+            If `instrument_id` is not a synthetic instrument ID.
+
+        """
+        Condition.not_none(instrument_id, "instrument_id")
+        Condition.true(instrument_id.is_synthetic(), "instrument_id was not a synthetic")
+
+        cdef SyntheticInstrument synthetic = self._synthetics.get(instrument_id)
+        if synthetic is None and self._database is not None:
+            synthetic = self._database.load_synthetic(instrument_id)
+            if synthetic is not None:
+                self._synthetics[synthetic.id] = synthetic
+
+        return synthetic
+
     cpdef Account load_account(self, AccountId account_id):
         """
         Load the account associated with the given account_id (if found).
 
         Parameters
         ----------
         account_id : AccountId
@@ -1004,50 +1065,14 @@
         Position or ``None``
 
         """
         Condition.not_none(position_id, "position_id")
 
         return self._positions.get(position_id)
 
-    cpdef SubmitOrder load_submit_order_command(self, ClientOrderId client_order_id):
-        """
-        Load the command associated with the given client order ID (if found).
-
-        Parameters
-        ----------
-        client_order_id : ClientOrderId
-            The client order ID for the command to load.
-
-        Returns
-        -------
-        SubmitOrder or ``None``
-
-        """
-        Condition.not_none(client_order_id, "client_order_id")
-
-        return self._submit_order_commands.get(client_order_id)
-
-    cpdef SubmitOrderList load_submit_order_list_command(self, OrderListId order_list_id):
-        """
-        Load the command associated with the given order list ID (if found).
-
-        Parameters
-        ----------
-        order_list_id : OrderListId
-            The order list ID for the command to load.
-
-        Returns
-        -------
-        SubmitOrderList or ``None``
-
-        """
-        Condition.not_none(order_list_id, "order_list_id")
-
-        return self._submit_order_list_commands.get(order_list_id)
-
     cpdef void add(self, str key, bytes value):
         """
         Add the given general object to the cache.
 
         The cache is agnostic to what the object actually is (and how it may
         be serialized), offering maximum flexibility.
 
@@ -1333,14 +1358,32 @@
 
         self._log.debug(f"Added instrument {instrument.id}.")
 
         # Update database
         if self._database is not None:
             self._database.add_instrument(instrument)
 
+    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
+        """
+        Add the given synthetic instrument to the cache.
+
+        Parameters
+        ----------
+        synthetic : SyntheticInstrument
+            The synthetic instrument to add.
+
+        """
+        self._synthetics[synthetic.id] = synthetic
+
+        self._log.debug(f"Added synthetic instrument {synthetic.id}.")
+
+        # Update database
+        if self._database is not None:
+            self._database.add_synthetic(synthetic)
+
     cpdef void add_account(self, Account account):
         """
         Add the given account to the cache.
 
         Parameters
         ----------
         account : Account
@@ -1361,25 +1404,33 @@
         self._log.debug(f"Added Account(id={account.id.to_str()}).")
         self._log.debug(f"Indexed {repr(account.id)}.")
 
         # Update database
         if self._database is not None:
             self._database.add_account(account)
 
-    cpdef void add_order(self, Order order, PositionId position_id, bint override = False):
+    cpdef void add_order(
+        self,
+        Order order,
+        PositionId position_id = None,
+        ClientId client_id = None,
+        bint override = False,
+    ):
         """
         Add the given order to the cache indexed with the given position
         ID.
 
         Parameters
         ----------
         order : Order
             The order to add.
-        position_id : PositionId
+        position_id : PositionId, optional
             The position ID to index for the order.
+        client_id : ClientId, optional
+            The execution client ID for order routing.
         override : bool, default False
             If the added order should 'override' any existing order and replace
             it in the cache. This is currently used for emulated orders which are
             being released and transformed into another type.
 
         Raises
         ------
@@ -1452,28 +1503,37 @@
 
         # Update emulation
         if order.emulation_trigger == TriggerType.NO_TRIGGER:
             self._index_orders_emulated.discard(order.client_order_id)
         else:
             self._index_orders_emulated.add(order.client_order_id)
 
-        # Update database
-        if self._database is not None:
-            self._database.add_order(order)  # Logs
+        self._log.debug(f"Added {order}.")
 
         if position_id is not None:
+            # Index position ID
             self.add_position_id(
                 position_id,
                 order.instrument_id.venue,
                 order.client_order_id,
                 order.strategy_id,
             )
 
-        cdef str position_id_str = f", for {position_id.to_str()}" if position_id is not None else ""
-        self._log.debug(f"Added {order}{position_id_str}.")
+        # Index: ClientOrderId -> ClientId (execution client routing)
+        if client_id is not None:
+            self._index_order_client[order.client_order_id] = client_id
+            self._log.debug(f"Indexed {client_id!r}.")
+
+        if self._database is None:
+            return
+
+        # Update database
+        self._database.add_order(order, position_id, client_id)
+        if self.snapshot_orders:
+            self._database.snapshot_order_state(order)
 
     cpdef void add_order_list(self, OrderList order_list):
         """
         Add the given order list to the cache.
 
         Parameters
         ----------
@@ -1518,14 +1578,16 @@
         Condition.not_none(position_id, "position_id")
         Condition.not_none(venue, "venue")
         Condition.not_none(client_order_id, "client_order_id")
         Condition.not_none(strategy_id, "strategy_id")
 
         # Index: ClientOrderId -> PositionId
         self._index_order_position[client_order_id] = position_id
+        if self._database is not None:
+            self._database.index_order_position(client_order_id, position_id)
 
         # Index: PositionId -> StrategyId
         self._index_position_strategy[position_id] = strategy_id
 
         # Index: PositionId -> set[ClientOrderId]
         cdef set position_orders = self._index_position_orders.get(position_id)
         if not position_orders:
@@ -1537,15 +1599,15 @@
         cdef set strategy_positions = self._index_strategy_positions.get(strategy_id)
         if not strategy_positions:
             self._index_strategy_positions[strategy_id] = {position_id}
         else:
             strategy_positions.add(position_id)
 
         self._log.debug(
-            f"Indexed {repr(position_id)}, "
+            f"Indexed {position_id!r}, "
             f"client_order_id={client_order_id}, "
             f"strategy_id={strategy_id}).",
         )
 
     cpdef void add_position(self, Position position, OmsType oms_type):
         """
         Add the given position to the cache.
@@ -1594,17 +1656,24 @@
         if not instrument_positions:
             self._index_instrument_positions[instrument_id] = {position.id}
         else:
             instrument_positions.add(position.id)
 
         self._log.debug(f"Added Position(id={position.id.to_str()}, strategy_id={position.strategy_id.to_str()}).")
 
+        if self._database is None:
+            return
+
         # Update database
-        if self._database is not None:
-            self._database.add_position(position)
+        self._database.add_position(position)
+        if self.snapshot_positions:
+            self._database.snapshot_position_state(
+                position,
+                self._calculate_unrealized_pnl(position),
+            )
 
     cpdef void snapshot_position(self, Position position):
         """
         Snapshot the given position in its current state.
 
         The position ID will be appended with a UUID v4 string.
 
@@ -1625,65 +1694,60 @@
         if snapshots is not None:
             snapshots.append(position_pickled)
         else:
             self._position_snapshots[position_id] = [position_pickled]
 
         self._log.debug(f"Snapshot {repr(copied_position)}.")
 
-    cpdef void add_submit_order_command(self, SubmitOrder command):
+    cpdef void snapshot_position_state(self, Position position):
         """
-        Add the given command to the cache.
+        Snapshot the state dictionary for the given `position`.
+
+        This method will persist to the backing cache database.
 
         Parameters
         ----------
-        command : SubmitOrder
-            The command to add to the cache.
+        position : Position
+            The position to snapshot the state for.
 
         """
-        Condition.not_none(command, "command")
-        Condition.not_in(
-            command.order.client_order_id,
-            self._submit_order_commands,
-            "command.order.client_order_id",
-            "self._submit_order_commands",
-        )
-
-        self._submit_order_commands[command.order.client_order_id] = command
+        Condition.not_none(position, "position")
 
-        self._log.debug(f"Added command {command}")
+        if self._database is None:
+            self._log.warning(
+                "Cannot snapshot position state for {position.id:r!} (no database configured).",
+            )
+            return
 
-        # Update database
-        if self._database is not None:
-            self._database.add_submit_order_command(command)
+        self._database.snapshot_position_state(
+            position,
+            self._calculate_unrealized_pnl(position),
+        )
 
-    cpdef void add_submit_order_list_command(self, SubmitOrderList command):
+    cpdef void snapshot_order_state(self, Order order):
         """
-        Add the given command to the cache.
+        Snapshot the state dictionary for the given `order`.
+
+        This method will persist to the backing cache database.
 
         Parameters
         ----------
-        command : SubmitOrderList
-            The command to add to the cache.
+        order : Order
+            The order to snapshot the state for.
 
         """
-        Condition.not_none(command, "command")
-        Condition.not_in(
-            command.order_list.id,
-            self._submit_order_list_commands,
-            "command.order_list.id",
-            "self._submit_order_list_commands",
-        )
-
-        self._submit_order_list_commands[command.order_list.id] = command
+        Condition.not_none(order, "order")
 
-        self._log.debug(f"Added command {command}")
+        if self._database is None:
+            self._log.warning(
+                "Cannot snapshot order state for {order.client_order_id:r!} (no database configured).",
+            )
+            return
 
-        # Update database
-        if self._database is not None:
-            self._database.add_submit_order_list_command(command)
+        self._database.snapshot_order_state(order)
 
     cpdef void update_account(self, Account account):
         """
         Update the given account in the cache.
 
         Parameters
         ----------
@@ -1704,14 +1768,15 @@
         ----------
         order : Order
             The order to update (from last event).
 
         """
         Condition.not_none(order, "order")
 
+        # Update venue order ID
         if order.venue_order_id is not None:
             # Assumes order_id does not change
             self._index_order_ids[order.venue_order_id] = order.client_order_id
 
         # Update in-flight state
         if order.is_inflight_c():
             self._index_orders_inflight.add(order.client_order_id)
@@ -1728,17 +1793,21 @@
 
         # Update emulation
         if order.emulation_trigger == TriggerType.NO_TRIGGER:
             self._index_orders_emulated.discard(order.client_order_id)
         else:
             self._index_orders_emulated.add(order.client_order_id)
 
+        if self._database is None:
+            return
+
         # Update database
-        if self._database is not None:
-            self._database.update_order(order)
+        self._database.update_order(order)
+        if self.snapshot_orders:
+            self._database.snapshot_order_state(order)
 
     cpdef void update_position(self, Position position):
         """
         Update the given position in the cache.
 
         Parameters
         ----------
@@ -1751,17 +1820,24 @@
         if position.is_open_c():
             self._index_positions_open.add(position.id)
             self._index_positions_closed.discard(position.id)
         elif position.is_closed_c():
             self._index_positions_closed.add(position.id)
             self._index_positions_open.discard(position.id)
 
+        if self._database is None:
+            return
+
         # Update database
-        if self._database is not None:
-            self._database.update_position(position)
+        self._database.update_position(position)
+        if self.snapshot_positions:
+            self._database.snapshot_position_state(
+                position,
+                self._calculate_unrealized_pnl(position),
+            )
 
     cpdef void update_actor(self, Actor actor):
         """
         Update the given actor state in the cache.
 
         Parameters
         ----------
@@ -2440,14 +2516,62 @@
         Returns
         -------
         list[Instrument]
 
         """
         return [x for x in self._instruments.values() if venue is None or venue == x.id.venue]
 
+# -- SYNTHETIC QUERIES ---------------------------------------------------------------------------
+
+    cpdef SyntheticInstrument synthetic(self, InstrumentId instrument_id):
+        """
+        Return the synthetic instrument corresponding to the given instrument ID.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId
+            The instrument ID of the synthetic instrument to return.
+
+        Returns
+        -------
+        SyntheticInstrument or ``None``
+
+        Raises
+        ------
+        ValueError
+            If `instrument_id` is not a synthetic instrument ID.
+
+        """
+        Condition.not_none(instrument_id, "instrument_id")
+        Condition.true(instrument_id.is_synthetic(), "instrument_id was not a synthetic")
+
+        return self._synthetics.get(instrument_id)
+
+    cpdef list synthetic_ids(self):
+        """
+        Return all synthetic instrument IDs held by the cache.
+
+        Returns
+        -------
+        list[InstrumentId]
+
+        """
+        return sorted(self._synthetics.keys())
+
+    cpdef list synthetics(self):
+        """
+        Return all synthetic instruments held by the cache.
+
+        Returns
+        -------
+        list[SyntheticInstrument]
+
+        """
+        return list(self._synthetics.values())
+
 # -- ACCOUNT QUERIES ------------------------------------------------------------------------------
 
     cpdef Account account(self, AccountId account_id):
         """
         Return the account matching the given ID (if found).
 
         Parameters
@@ -2936,14 +3060,27 @@
         Condition.not_none(client_order_id, "client_order_id")
 
         cdef Order order = self._orders.get(client_order_id)
         if order is None:
             return None
         return order.venue_order_id
 
+    cpdef ClientId client_id(self, ClientOrderId client_order_id):
+        """
+        Return the specific execution client ID matching the given client order ID (if found).
+
+        Returns
+        -------
+        ClientId or ``None``
+
+        """
+        Condition.not_none(client_order_id, "client_order_id")
+
+        self._index_order_client.get(client_order_id)
+
     cpdef list orders(
         self,
         Venue venue = None,
         InstrumentId instrument_id = None,
         StrategyId strategy_id = None,
         OrderSide side = OrderSide.NO_ORDER_SIDE,
     ):
@@ -3816,7 +3953,25 @@
         -------
         StrategyId or ``None``
 
         """
         Condition.not_none(position_id, "position_id")
 
         return self._index_position_strategy.get(position_id)
+
+    cpdef void heartbeat(self, datetime timestamp):
+        """
+        Add a heartbeat at the given `timestamp`.
+
+        Parameters
+        ----------
+        timestamp : datetime
+            The timestamp for the heartbeat.
+
+        """
+        Condition.not_none(timestamp, "timestamp")
+
+        if self._database is None:
+            self._log.warning(f"Cannot set heartbeat {timestamp} (no database configured).")
+            return
+
+        self._database.heartbeat(timestamp)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/database.pxd` & `nautilus_trader-1.176.0/nautilus_trader/cache/database.pxd`

 * *Files 9% similar despite different names*

```diff
@@ -9,64 +9,75 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from cpython.datetime cimport datetime
+
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.common.actor cimport Actor
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.identifiers cimport AccountId
+from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ComponentId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.trading.strategy cimport Strategy
 
 
 cdef class CacheDatabase:
     cdef LoggerAdapter _log
 
     cpdef void flush(self)
     cpdef dict load(self)
     cpdef dict load_currencies(self)
     cpdef dict load_instruments(self)
+    cpdef dict load_synthetics(self)
     cpdef dict load_accounts(self)
     cpdef dict load_orders(self)
     cpdef dict load_positions(self)
-    cpdef dict load_submit_order_commands(self)
-    cpdef dict load_submit_order_list_commands(self)
+    cpdef dict load_index_order_position(self)
+    cpdef dict load_index_order_client(self)
     cpdef Currency load_currency(self, str code)
     cpdef Instrument load_instrument(self, InstrumentId instrument_id)
+    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id)
     cpdef Account load_account(self, AccountId account_id)
     cpdef Order load_order(self, ClientOrderId order_id)
     cpdef Position load_position(self, PositionId position_id)
     cpdef dict load_actor(self, ComponentId component_id)
     cpdef void delete_actor(self, ComponentId component_id)
     cpdef dict load_strategy(self, StrategyId strategy_id)
     cpdef void delete_strategy(self, StrategyId strategy_id)
-    cpdef SubmitOrder load_submit_order_command(self, ClientOrderId client_order_id)
-    cpdef SubmitOrderList load_submit_order_list_command(self, OrderListId order_list_id)
 
     cpdef void add(self, str key, bytes value)
     cpdef void add_currency(self, Currency currency)
     cpdef void add_instrument(self, Instrument instrument)
+    cpdef void add_synthetic(self, SyntheticInstrument instrument)
     cpdef void add_account(self, Account account)
-    cpdef void add_order(self, Order order)
+    cpdef void add_order(self, Order order, PositionId position_id=*, ClientId client_id=*)
     cpdef void add_position(self, Position position)
-    cpdef void add_submit_order_command(self, SubmitOrder command)
-    cpdef void add_submit_order_list_command(self, SubmitOrderList command)
+
+    cpdef void index_order_position(self, ClientOrderId client_order_id, PositionId position_id)
 
     cpdef void update_account(self, Account account)
     cpdef void update_order(self, Order order)
     cpdef void update_position(self, Position position)
     cpdef void update_actor(self, Actor actor)
     cpdef void update_strategy(self, Strategy strategy)
+
+    cpdef void snapshot_order_state(self, Order order)
+    cpdef void snapshot_position_state(self, Position position, Money unrealized_pnl=*)
+
+    cpdef void heartbeat(self, datetime timestamp)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/cache/database.pyx` & `nautilus_trader-1.176.0/nautilus_trader/cache/database.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -9,26 +9,33 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from cpython.datetime cimport datetime
+
+from nautilus_trader.config import CacheDatabaseConfig
+
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.common.actor cimport Actor
 from nautilus_trader.common.logging cimport Logger
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
 from nautilus_trader.model.identifiers cimport AccountId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
+from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.trading.strategy cimport Strategy
 
 
 cdef class CacheDatabase:
     """
@@ -40,15 +47,19 @@
         The logger for the database.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
     """
 
-    def __init__(self, Logger logger not None):
+    def __init__(
+        self,
+        Logger logger not None,
+        config: Optional[CacheDatabaseConfig] = None,
+    ):
         self._log = LoggerAdapter(component_name=type(self).__name__, logger=logger)
 
         self._log.info("READY.")
 
     cpdef void flush(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
@@ -61,42 +72,50 @@
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef dict load_instruments(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
+    cpdef dict load_synthetics(self):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
     cpdef dict load_accounts(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef dict load_orders(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef dict load_positions(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef dict load_submit_order_commands(self):
+    cpdef dict load_index_order_position(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef dict load_submit_order_list_commands(self):
+    cpdef dict load_index_order_client(self):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef Currency load_currency(self, str code):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef Instrument load_instrument(self, InstrumentId instrument_id):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
+    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
     cpdef Account load_account(self, AccountId account_id):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef Order load_order(self, ClientOrderId client_order_id):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
@@ -117,66 +136,70 @@
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef void delete_strategy(self, StrategyId strategy_id):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef SubmitOrder load_submit_order_command(self, ClientOrderId client_order_id):
+    cpdef void add(self, str key, bytes value):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef SubmitOrderList load_submit_order_list_command(self, OrderListId order_list_id):
+    cpdef void add_currency(self, Currency currency):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add_submit_order_command(self, SubmitOrder command):
+    cpdef void add_instrument(self, Instrument instrument):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add_submit_order_list_command(self, SubmitOrderList command):
+    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add(self, str key, bytes value):
+    cpdef void add_account(self, Account account):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add_currency(self, Currency currency):
+    cpdef void add_order(self, Order order, PositionId position_id = None, ClientId client_id = None):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add_instrument(self, Instrument instrument):
+    cpdef void add_position(self, Position position):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add_account(self, Account account):
+    cpdef void index_order_position(self, ClientOrderId client_order_id, PositionId position_id):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add_order(self, Order order):
+    cpdef void update_account(self, Account event):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void add_position(self, Position position):
+    cpdef void update_order(self, Order order):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void update_account(self, Account event):
+    cpdef void update_position(self, Position position):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void update_order(self, Order order):
+    cpdef void update_actor(self, Actor actor):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void update_position(self, Position position):
+    cpdef void update_strategy(self, Strategy strategy):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void update_actor(self, Actor actor):
+    cpdef void snapshot_order_state(self, Order order):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-    cpdef void update_strategy(self, Strategy strategy):
+    cpdef void snapshot_position_state(self, Position position, Money unrealized_pnl = None):
+        """Abstract method (implement in subclass)."""
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+
+    cpdef void heartbeat(self, datetime timestamp):
         """Abstract method (implement in subclass)."""
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/data/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/common/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,24 +8,25 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `common` subpackage provides generic/common parts for assembling the frameworks various components.
+The `common` subpackage provides generic/common parts for assembling the frameworks
+various components.
 
 More domain specific concepts are introduced above the `core` base layer. The
 ID cache is implemented, a base `Clock` with `Test` and `Live`
 implementations which can control many `Timer` instances.
 
 Trading domain specific components for generating `Order` and `Identifier` objects,
 common logging components, a high performance `Queue` and `UUID4` factory.
+
 """
 
 from enum import Enum
 from enum import unique
 
 
 @unique
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/actor.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/actor.pxd`

 * *Files 8% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from typing import Callable
+
 from cpython.datetime cimport datetime
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.component cimport Component
 from nautilus_trader.common.logging cimport Logger
@@ -38,21 +40,23 @@
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
 from nautilus_trader.model.orderbook.book cimport OrderBook
 from nautilus_trader.msgbus.bus cimport MessageBus
 
 
 cdef class Actor(Component):
     cdef set _warning_events
     cdef dict _signal_classes
+    cdef dict _pending_requests
 
     cdef readonly config
     """The actors configuration.\n\n:returns: `NautilusConfig`"""
     cdef readonly Clock clock
     """The actors clock.\n\n:returns: `Clock`"""
     cdef readonly LoggerAdapter log
     """The actors logger.\n\n:returns: `LoggerAdapter`"""
@@ -82,32 +86,34 @@
     cpdef void on_quote_tick(self, QuoteTick tick)
     cpdef void on_trade_tick(self, TradeTick tick)
     cpdef void on_bar(self, Bar bar)
     cpdef void on_data(self, Data data)
     cpdef void on_historical_data(self, Data data)
     cpdef void on_event(self, Event event)
 
-# -- ACTOR COMMANDS -------------------------------------------------------------------------------
-
-    cpdef dict save(self)
-    cpdef void load(self, dict state)
-
 # -- REGISTRATION ---------------------------------------------------------------------------------
 
     cpdef void register_base(
         self,
         MessageBus msgbus,
         CacheFacade cache,
         Clock clock,
         Logger logger,
     )
 
     cpdef void register_warning_event(self, type event)
     cpdef void deregister_warning_event(self, type event)
 
+# -- ACTOR COMMANDS -------------------------------------------------------------------------------
+
+    cpdef dict save(self)
+    cpdef void load(self, dict state)
+    cpdef void add_synthetic(self, SyntheticInstrument synthetic)
+    cpdef void update_synthetic(self, SyntheticInstrument synthetic)
+
 # -- SUBSCRIPTIONS --------------------------------------------------------------------------------
 
     cpdef void subscribe_data(self, DataType data_type, ClientId client_id=*)
     cpdef void subscribe_instruments(self, Venue venue, ClientId client_id=*)
     cpdef void subscribe_instrument(self, InstrumentId instrument_id, ClientId client_id=*)
     cpdef void subscribe_order_book_deltas(
         self,
@@ -145,41 +151,44 @@
     cpdef void unsubscribe_venue_status_updates(self, Venue venue, ClientId client_id=*)
     cpdef void unsubscribe_instrument_status_updates(self, InstrumentId instrument_id, ClientId client_id=*)
     cpdef void publish_data(self, DataType data_type, Data data)
     cpdef void publish_signal(self, str name, value, uint64_t ts_event=*)
 
 # -- REQUESTS -------------------------------------------------------------------------------------
 
-    cpdef void request_data(self, ClientId client_id, DataType data_type, UUID4 request_id=*)
-    cpdef void request_instrument(self, InstrumentId instrument_id, ClientId client_id=*, UUID4 request_id=*)
-    cpdef void request_instruments(self, Venue venue, ClientId client_id=*, UUID4 request_id=*)
-    cpdef void request_quote_ticks(
+    cpdef UUID4 request_data(self, DataType data_type, ClientId client_id, callback=*)
+    cpdef UUID4 request_instrument(self, InstrumentId instrument_id, ClientId client_id=*, callback=*)
+    cpdef UUID4 request_instruments(self, Venue venue, ClientId client_id=*, callback=*)
+    cpdef UUID4 request_quote_ticks(
         self,
         InstrumentId instrument_id,
         datetime start=*,
         datetime end=*,
         ClientId client_id=*,
-        UUID4 request_id=*,
+        callback=*,
     )
-    cpdef void request_trade_ticks(
+    cpdef UUID4 request_trade_ticks(
         self,
         InstrumentId instrument_id,
         datetime start=*,
         datetime end=*,
         ClientId client_id=*,
-        UUID4 request_id= *,
+        callback=*,
     )
-    cpdef void request_bars(
+    cpdef UUID4 request_bars(
         self,
         BarType bar_type,
         datetime start=*,
         datetime end=*,
         ClientId client_id=*,
-        UUID4 request_id= *,
+        callback=*,
     )
+    cpdef bint is_pending_request(self, UUID4 request_id)
+    cpdef bint has_pending_requests(self)
+    cpdef set pending_requests(self)
 
 # -- HANDLERS -------------------------------------------------------------------------------------
 
     cpdef void handle_instrument(self, Instrument instrument)
     cpdef void handle_instruments(self, list instruments)
     cpdef void handle_order_book(self, OrderBook order_book)
     cpdef void handle_order_book_deltas(self, OrderBookDeltas deltas)
@@ -199,12 +208,13 @@
 
     cpdef void _handle_data_response(self, DataResponse response)
     cpdef void _handle_instrument_response(self, DataResponse response)
     cpdef void _handle_instruments_response(self, DataResponse response)
     cpdef void _handle_quote_ticks_response(self, DataResponse response)
     cpdef void _handle_trade_ticks_response(self, DataResponse response)
     cpdef void _handle_bars_response(self, DataResponse response)
+    cpdef void _finish_response(self, UUID4 request_id)
 
 # -- EGRESS ---------------------------------------------------------------------------------------
 
     cdef void _send_data_cmd(self, DataCommand command)
     cdef void _send_data_req(self, DataRequest request)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/actor.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/actor.pyx`

 * *Files 7% similar despite different names*

```diff
@@ -66,14 +66,15 @@
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ComponentId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
 from nautilus_trader.msgbus.bus cimport MessageBus
 
 
 cdef class Actor(Component):
     """
     The base class for all actor components.
 
@@ -98,24 +99,24 @@
         Condition.type(config, ActorConfig, "config")
 
         if config.component_id is not None:
             component_id = ComponentId(config.component_id)
         else:
             component_id = None
 
-        clock = LiveClock()
         super().__init__(
-            clock=clock,
-            logger=Logger(clock=clock),
+            clock=Clock(),  # Use placeholder abstract clock until registered
+            logger=Logger(clock=Clock(), dummy=True),  # Use dummy logger until registered
             component_id=component_id,
             config=config.dict(),
         )
 
         self._warning_events: set[type] = set()
         self._signal_classes: dict[str, type] = {}
+        self._pending_requests: dict[UUID4, Callable[[UUID4], None] | None] = {}
 
         # Configuration
         self.config = config
 
         self.trader_id = None  # Initialized when registered
         self.msgbus = None     # Initialized when registered
         self.cache = None      # Initialized when registered
@@ -551,16 +552,14 @@
             The event class to register.
 
         """
         Condition.not_none(event, "event")
 
         self._warning_events.add(event)
 
-        self._log.debug(f"Registered `{event.__name__}` for warning log levels.")
-
     cpdef void deregister_warning_event(self, type event):
         """
         Deregister the given event type from warning log levels.
 
         Parameters
         ----------
         event : type
@@ -639,14 +638,63 @@
             self.log.debug(f"Loading state...")
             self.on_load(state)
             self.log.info(f"Loaded state {list(state.keys())}.", color=LogColor.BLUE)
         except Exception as e:
             self.log.exception(f"Error on load {repr(state)}", e)
             raise
 
+    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
+        """
+        Add the created synthetic instrument to the cache.
+
+        Parameters
+        ----------
+        synthetic : SyntheticInstrument
+            The synthetic instrument to add to the cache.
+
+        Raises
+        ------
+        KeyError
+            If `synthetic` is already in the cache.
+
+        Notes
+        -----
+        If you are updating the synthetic instrument then you should use the `update_synthetic` method.
+
+        """
+        Condition.not_none(synthetic, "synthetic")
+        Condition.true(self.cache.synthetic(synthetic.id) is None, f"`synthetic` {synthetic.id} already exists")
+
+        self.cache.add_synthetic(synthetic)
+
+    cpdef void update_synthetic(self, SyntheticInstrument synthetic):
+        """
+        Update the synthetic instrument in the cache.
+
+        Parameters
+        ----------
+        synthetic : SyntheticInstrument
+            The synthetic instrument to update in the cache.
+
+        Raises
+        ------
+        KeyError
+            If `synthetic` does not already exist in the cache.
+
+        Notes
+        -----
+        If you are adding a new synthetic instrument then you should use the `add_synthetic` method.
+
+        """
+        Condition.not_none(synthetic, "synthetic")
+        Condition.true(self.cache.synthetic(synthetic.id) is not None, f"`synthetic` {synthetic.id} does not exist")
+
+        # This will replace the previous synthetic
+        self.cache.add_synthetic(synthetic)
+
 # -- ACTION IMPLEMENTATIONS -----------------------------------------------------------------------
 
     cpdef void _start(self):
         self.on_start()
 
     cpdef void _stop(self):
         # Clean up clock
@@ -659,14 +707,15 @@
 
         self.on_stop()
 
     cpdef void _resume(self):
         self.on_resume()
 
     cpdef void _reset(self):
+        self._pending_requests.clear()
         self.on_reset()
 
     cpdef void _dispose(self):
         self.on_dispose()
 
     cpdef void _degrade(self):
         self.on_degrade()
@@ -706,72 +755,72 @@
             data_type=data_type,
             command_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
         self._send_data_cmd(command)
 
-    cpdef void subscribe_instrument(self, InstrumentId instrument_id, ClientId client_id = None):
+    cpdef void subscribe_instruments(self, Venue venue, ClientId client_id = None):
         """
-        Subscribe to update `Instrument` data for the given instrument ID.
+        Subscribe to update `Instrument` data for the given venue.
 
         Parameters
         ----------
-        instrument_id : InstrumentId
-            The instrument ID for the subscription.
+        venue : Venue
+            The venue for the subscription.
         client_id : ClientId, optional
             The specific client ID for the command.
-            If ``None`` then will be inferred from the venue in the instrument ID.
+            If ``None`` then will be inferred from the venue.
 
         """
-        Condition.not_none(instrument_id, "instrument_id")
+        Condition.not_none(venue, "venue")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
 
         self._msgbus.subscribe(
-            topic=f"data.instrument"
-                  f".{instrument_id.venue}"
-                  f".{instrument_id.symbol}",
+            topic=f"data.instrument.{venue}.*",
             handler=self.handle_instrument,
         )
 
         cdef Subscribe command = Subscribe(
             client_id=client_id,
-            venue=instrument_id.venue,
-            data_type=DataType(Instrument, metadata={"instrument_id": instrument_id}),
+            venue=venue,
+            data_type=DataType(Instrument),
             command_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
         self._send_data_cmd(command)
 
-    cpdef void subscribe_instruments(self, Venue venue, ClientId client_id = None):
+    cpdef void subscribe_instrument(self, InstrumentId instrument_id, ClientId client_id = None):
         """
-        Subscribe to update `Instrument` data for the given venue.
+        Subscribe to update `Instrument` data for the given instrument ID.
 
         Parameters
         ----------
-        venue : Venue
-            The venue for the subscription.
+        instrument_id : InstrumentId
+            The instrument ID for the subscription.
         client_id : ClientId, optional
             The specific client ID for the command.
-            If ``None`` then will be inferred from the venue.
+            If ``None`` then will be inferred from the venue in the instrument ID.
 
         """
-        Condition.not_none(venue, "venue")
+        Condition.not_none(instrument_id, "instrument_id")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
 
         self._msgbus.subscribe(
-            topic=f"data.instrument.{venue}.*",
+            topic=f"data.instrument"
+                  f".{instrument_id.venue}"
+                  f".{instrument_id.symbol}",
             handler=self.handle_instrument,
         )
 
         cdef Subscribe command = Subscribe(
             client_id=client_id,
-            venue=venue,
-            data_type=DataType(Instrument),
+            venue=instrument_id.venue,
+            data_type=DataType(Instrument, metadata={"instrument_id": instrument_id}),
             command_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
         self._send_data_cmd(command)
 
     cpdef void subscribe_order_book_deltas(
@@ -1547,113 +1596,173 @@
             ts_event=ts_event or now,
             ts_init=now,
         )
         self.publish_data(data_type=DataType(cls), data=data)
 
 # -- REQUESTS -------------------------------------------------------------------------------------
 
-    cpdef void request_data(self, ClientId client_id, DataType data_type, UUID4 request_id = None):
+    cpdef UUID4 request_data(
+        self,
+        DataType data_type,
+        ClientId client_id,
+        callback: Callable[[UUID4], None] | None = None,
+    ):
         """
         Request custom data for the given data type from the given data client.
 
         Parameters
         ----------
-        client_id : ClientId
-            The data client ID.
         data_type : DataType
             The data type for the request.
-        request_id : UUID4, optional
-            The specific request ID for the command.
-            If ``None`` then will be generated.
+        client_id : ClientId
+            The data client ID.
+        callback : Callable[[UUID4], None], optional
+            The registered callback, to be called with the request ID when the response has
+            completed processing.
+
+        Returns
+        -------
+        UUID4
+            The `request_id` for the request.
+
+        Raises
+        ------
+        TypeError
+            If `callback` is not `None` and not of type `Callable`.
 
         """
         Condition.not_none(client_id, "client_id")
         Condition.not_none(data_type, "data_type")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
+        Condition.callable_or_none(callback, "callback")
 
+        cdef UUID4 request_id = UUID4()
         cdef DataRequest request = DataRequest(
             client_id=client_id,
             venue=None,
             data_type=data_type,
             callback=self._handle_data_response,
-            request_id=request_id or UUID4(),
+            request_id=request_id,
             ts_init=self._clock.timestamp_ns(),
         )
 
+        self._pending_requests[request_id] = callback
         self._send_data_req(request)
 
-    cpdef void request_instrument(self, InstrumentId instrument_id, ClientId client_id = None, UUID4 request_id = None):
+        return request_id
+
+    cpdef UUID4 request_instrument(
+        self,
+        InstrumentId instrument_id,
+        ClientId client_id = None,
+        callback: Callable[[UUID4], None] | None = None,
+    ):
         """
         Request `Instrument` data for the given instrument ID.
 
         Parameters
         ----------
         instrument_id : InstrumentId
             The instrument ID for the request.
         client_id : ClientId, optional
             The specific client ID for the command.
             If ``None`` then will be inferred from the venue in the instrument ID.
-        request_id : UUID4, optional
-            The specific request ID for the command.
-            If ``None`` then will be generated.
+        callback : Callable[[UUID4], None], optional
+            The registered callback, to be called with the request ID when the response has
+            completed processing.
+
+        Returns
+        -------
+        UUID4
+            The `request_id` for the request.
+
+        Raises
+        ------
+        TypeError
+            If `callback` is not `None` and not of type `Callable`.
 
         """
         Condition.not_none(instrument_id, "instrument_id")
+        Condition.callable_or_none(callback, "callback")
 
+        cdef UUID4 request_id = UUID4()
         cdef DataRequest request = DataRequest(
             client_id=client_id,
             venue=instrument_id.venue,
             data_type=DataType(Instrument, metadata={
                 "instrument_id": instrument_id,
             }),
             callback=self._handle_instrument_response,
-            request_id=request_id or UUID4(),
+            request_id=request_id,
             ts_init=self._clock.timestamp_ns(),
         )
 
+        self._pending_requests[request_id] = callback
         self._send_data_req(request)
 
-    cpdef void request_instruments(self, Venue venue, ClientId client_id = None, UUID4 request_id = None):
+        return request_id
+
+    cpdef UUID4 request_instruments(
+        self,
+        Venue venue,
+        ClientId client_id = None,
+        callback: Callable[[UUID4], None] | None = None,
+    ):
         """
         Request all `Instrument` data for the given venue.
 
         Parameters
         ----------
         venue : Venue
             The venue for the request.
         client_id : ClientId, optional
             The specific client ID for the command.
             If ``None`` then will be inferred from the venue in the instrument ID.
-        request_id : UUID4, optional
-            The specific request ID for the command.
-            If ``None`` then will be generated.
+        callback : Callable[[UUID4], None], optional
+            The registered callback, to be called with the request ID when the response has
+            completed processing.
+
+        Returns
+        -------
+        UUID4
+            The `request_id` for the request.
+
+        Raises
+        ------
+        TypeError
+            If `callback` is not `None` and not of type `Callable`.
 
         """
         Condition.not_none(venue, "venue")
+        Condition.callable_or_none(callback, "callback")
 
+        cdef UUID4 request_id = UUID4()
         cdef DataRequest request = DataRequest(
             client_id=client_id,
             venue=venue,
             data_type=DataType(Instrument, metadata={
                 "venue": venue,
             }),
             callback=self._handle_instruments_response,
-            request_id=request_id or UUID4(),
+            request_id=request_id,
             ts_init=self._clock.timestamp_ns(),
         )
 
+        self._pending_requests[request_id] = callback
         self._send_data_req(request)
 
-    cpdef void request_quote_ticks(
+        return request_id
+
+    cpdef UUID4 request_quote_ticks(
         self,
         InstrumentId instrument_id,
         datetime start = None,
         datetime end = None,
         ClientId client_id = None,
-        UUID4 request_id = None,
+        callback: Callable[[UUID4], None] | None = None,
     ):
         """
         Request historical `QuoteTick` data.
 
         If `end` is ``None`` then will request up to the most recent data.
 
         Parameters
@@ -1664,51 +1773,63 @@
             The start datetime (UTC) of request time range (inclusive).
         end : datetime, optional
             The end datetime (UTC) of request time range (inclusive).
             If ``None`` then will default to the current datetime (UTC).
         client_id : ClientId, optional
             The specific client ID for the command.
             If ``None`` then will be inferred from the venue in the instrument ID.
-        request_id : UUID4, optional
-            The specific request ID for the command.
-            If ``None`` then will be generated.
+        callback : Callable[[UUID4], None], optional
+            The registered callback, to be called with the request ID when the response has
+            completed processing.
+
+        Returns
+        -------
+        UUID4
+            The `request_id` for the request.
 
         Raises
         ------
         ValueError
             If `start` is not less than `end`.
+        TypeError
+            If `callback` is not `None` and not of type `Callable`.
 
         """
         Condition.not_none(instrument_id, "instrument_id")
         if start is not None and end is not None:
             Condition.true(start < end, "start was >= end")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
+        Condition.callable_or_none(callback, "callback")
 
+        cdef UUID4 request_id = UUID4()
         cdef DataRequest request = DataRequest(
             client_id=client_id,
             venue=instrument_id.venue,
             data_type=DataType(QuoteTick, metadata={
                 "instrument_id": instrument_id,
                 "start": start,
                 "end": end,
             }),
             callback=self._handle_quote_ticks_response,
-            request_id=request_id or UUID4(),
+            request_id=request_id,
             ts_init=self._clock.timestamp_ns(),
         )
 
+        self._pending_requests[request_id] = callback
         self._send_data_req(request)
 
-    cpdef void request_trade_ticks(
+        return request_id
+
+    cpdef UUID4 request_trade_ticks(
         self,
         InstrumentId instrument_id,
         datetime start = None,
         datetime end = None,
         ClientId client_id = None,
-        UUID4 request_id = None,
+        callback: Callable[[UUID4], None] | None = None,
     ):
         """
         Request historical `TradeTick` data.
 
         If `end` is ``None`` then will request up to the most recent data.
 
         Parameters
@@ -1719,51 +1840,63 @@
             The start datetime (UTC) of request time range (inclusive).
         end : datetime, optional
             The end datetime (UTC) of request time range (inclusive).
             If ``None`` then will default to the current datetime (UTC).
         client_id : ClientId, optional
             The specific client ID for the command.
             If ``None`` then will be inferred from the venue in the instrument ID.
-        request_id : UUID4, optional
-            The specific request ID for the command.
-            If ``None`` then will be generated.
+        callback : Callable[[UUID4], None], optional
+            The registered callback, to be called with the request ID when the response has
+            completed processing.
+
+        Returns
+        -------
+        UUID4
+            The `request_id` for the request.
 
         Raises
         ------
         ValueError
             If `start` is not less than `end`.
+        TypeError
+            If `callback` is not `None` and not of type `Callable`.
 
         """
         Condition.not_none(instrument_id, "instrument_id")
         if start is not None and end is not None:
             Condition.true(start < end, "start was >= end")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
+        Condition.callable_or_none(callback, "callback")
 
+        cdef UUID4 request_id = UUID4()
         cdef DataRequest request = DataRequest(
             client_id=client_id,
             venue=instrument_id.venue,
             data_type=DataType(TradeTick, metadata={
                 "instrument_id": instrument_id,
                 "start": start,
                 "end": end,
             }),
             callback=self._handle_trade_ticks_response,
-            request_id=request_id or UUID4(),
+            request_id=request_id,
             ts_init=self._clock.timestamp_ns(),
         )
 
+        self._pending_requests[request_id] = callback
         self._send_data_req(request)
 
-    cpdef void request_bars(
+        return request_id
+
+    cpdef UUID4 request_bars(
         self,
         BarType bar_type,
         datetime start = None,
         datetime end = None,
         ClientId client_id = None,
-        UUID4 request_id = None,
+        callback: Callable[[UUID4], None] | None = None,
     ):
         """
         Request historical `Bar` data.
 
         If `end` is ``None`` then will request up to the most recent data.
 
         Parameters
@@ -1774,44 +1907,96 @@
             The start datetime (UTC) of request time range (inclusive).
         end : datetime, optional
             The end datetime (UTC) of request time range (inclusive).
             If ``None`` then will default to the current datetime (UTC).
         client_id : ClientId, optional
             The specific client ID for the command.
             If ``None`` then will be inferred from the venue in the instrument ID.
-        request_id : UUID4, optional
-            The specific request ID for the command.
-            If ``None`` then will be generated.
+        callback : Callable[[UUID4], None], optional
+            The registered callback, to be called with the request ID when the response has
+            completed processing.
+
+        Returns
+        -------
+        UUID4
+            The `request_id` for the request.
 
         Raises
         ------
         ValueError
             If `start` is not less than `end`.
+        TypeError
+            If `callback` is not `None` and not of type `Callable`.
 
         """
         Condition.not_none(bar_type, "bar_type")
         if start is not None and end is not None:
             Condition.true(start < end, "start was >= end")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
+        Condition.callable_or_none(callback, "callback")
 
+        cdef UUID4 request_id = UUID4()
         cdef DataRequest request = DataRequest(
             client_id=client_id,
             venue=bar_type.instrument_id.venue,
             data_type=DataType(Bar, metadata={
                 "bar_type": bar_type,
                 "start": start,
                 "end": end,
             }),
             callback=self._handle_bars_response,
-            request_id=request_id or UUID4(),
+            request_id=request_id,
             ts_init=self._clock.timestamp_ns(),
         )
 
+        self._pending_requests[request_id] = callback
         self._send_data_req(request)
 
+        return request_id
+
+    cpdef bint is_pending_request(self, UUID4 request_id):
+        """
+        Return whether the request for the given identifier is pending processing.
+
+        Parameters
+        ----------
+        request_id : UUID4
+            The request ID to check.
+
+        Returns
+        -------
+        bool
+            True if request is pending, else False.
+
+        """
+        return request_id in self._pending_requests
+
+    cpdef bint has_pending_requests(self):
+        """
+        Return whether the actor is pending processing for any requests.
+
+        Returns
+        -------
+        bool
+            True if any requests are pending, else False.
+
+        """
+        return len(self._pending_requests) > 0
+
+    cpdef set pending_requests(self):
+        """
+        Return the request IDs which are currently pending processing.
+
+        Returns
+        -------
+        set[UUID4]
+
+        """
+        return set(self._pending_requests.keys())
+
 # -- HANDLERS -------------------------------------------------------------------------------------
 
     cpdef void handle_instrument(self, Instrument instrument):
         """
         Handle the given instrument.
 
         Passes to `on_instrument` if state is ``RUNNING``.
@@ -2263,29 +2448,40 @@
     cpdef void _handle_data_response(self, DataResponse response):
         cdef Data data
         if isinstance(response.data, list):
             for data in response.data:
                 self.handle_historical_data(data)
         else:
             self.handle_historical_data(response.data)
+        self._finish_response(response.correlation_id)
 
     cpdef void _handle_instrument_response(self, DataResponse response):
         self.handle_instrument(response.data)
+        self._finish_response(response.correlation_id)
 
     cpdef void _handle_instruments_response(self, DataResponse response):
         self.handle_instruments(response.data)
+        self._finish_response(response.correlation_id)
 
     cpdef void _handle_quote_ticks_response(self, DataResponse response):
         self.handle_quote_ticks(response.data)
+        self._finish_response(response.correlation_id)
 
     cpdef void _handle_trade_ticks_response(self, DataResponse response):
         self.handle_trade_ticks(response.data)
+        self._finish_response(response.correlation_id)
 
     cpdef void _handle_bars_response(self, DataResponse response):
         self.handle_bars(response.data)
+        self._finish_response(response.correlation_id)
+
+    cpdef void _finish_response(self, UUID4 request_id):
+        callback: Callable | None = self._pending_requests.pop(request_id, None)
+        if callback is not None:
+            callback(request_id)
 
 # -- EGRESS ---------------------------------------------------------------------------------------
 
     cdef void _send_data_cmd(self, DataCommand command):
         if not self._log.is_bypassed:
             self._log.info(f"{CMD}{SENT} {command}.")
         self._msgbus.send(endpoint="DataEngine.execute", msg=command)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/clock.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/clock.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/clock.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/clock.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/component.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/component.pxd`

 * *Files 4% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 from typing import Callable
 
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.enums_c cimport ComponentTrigger
 from nautilus_trader.common.logging cimport Logger
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.core.fsm cimport FiniteStateMachine
-from nautilus_trader.model.identifiers cimport ComponentId
+from nautilus_trader.model.identifiers cimport Identifier
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.msgbus.bus cimport MessageBus
 
 
 cdef class ComponentFSMFactory:
 
     @staticmethod
@@ -36,15 +36,15 @@
     cdef readonly LoggerAdapter _log
     cdef readonly MessageBus _msgbus
     cdef FiniteStateMachine _fsm
     cdef dict _config
 
     cdef readonly TraderId trader_id
     """The trader ID associated with the component.\n\n:returns: `TraderId`"""
-    cdef readonly ComponentId id
+    cdef readonly Identifier id
     """The components ID.\n\n:returns: `ComponentId`"""
     cdef readonly type type
     """The components type.\n\n:returns: `type`"""
 
     cdef void _change_clock(self, Clock clock)
     cdef void _change_logger(self, Logger logger)
     cdef void _change_msgbus(self, MessageBus msgbus)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/component.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/component.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -28,14 +28,15 @@
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.common.messages cimport ComponentStateChanged
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.fsm cimport FiniteStateMachine
 from nautilus_trader.core.fsm cimport InvalidStateTrigger
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.identifiers cimport ComponentId
+from nautilus_trader.model.identifiers cimport Identifier
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.msgbus.bus cimport MessageBus
 
 
 cdef dict _COMPONENT_STATE_TABLE = {
     (ComponentState.PRE_INITIALIZED, ComponentTrigger.INITIALIZE): ComponentState.READY,
     (ComponentState.READY, ComponentTrigger.RESET): ComponentState.RESETTING,  # Transitional state
@@ -117,15 +118,15 @@
     ----------
     clock : Clock
         The clock for the component.
     logger : Logger
         The logger for the component.
     trader_id : TraderId, optional
         The trader ID associated with the component.
-    component_id : ComponentId, optional
+    component_id : Identifier, optional
         The component ID. If ``None`` is passed then the identifier will be
         taken from `type(self).__name__`.
     component_name : str, optional
         The custom component name.
     msgbus : MessageBus, optional
         The message bus for the component (required before initialized).
     config : dict[str, Any], optional
@@ -142,15 +143,15 @@
     """
 
     def __init__(
         self,
         Clock clock not None,
         Logger logger not None,
         TraderId trader_id = None,
-        ComponentId component_id = None,
+        Identifier component_id = None,
         str component_name = None,
         MessageBus msgbus = None,
         dict config = None,
     ):
         if config is None:
             config = {}
         if component_id is None:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/enums.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/enums.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/enums_c.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/enums_c.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/factories.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/factories.pxd`

 * *Files 0% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
 
 from cpython.datetime cimport datetime
 
+from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.generators cimport ClientOrderIdGenerator
 from nautilus_trader.common.generators cimport OrderListIdGenerator
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport TimeInForce
@@ -44,14 +45,15 @@
 from nautilus_trader.model.orders.stop_market cimport StopMarketOrder
 from nautilus_trader.model.orders.trailing_stop_limit cimport TrailingStopLimitOrder
 from nautilus_trader.model.orders.trailing_stop_market cimport TrailingStopMarketOrder
 
 
 cdef class OrderFactory:
     cdef Clock _clock
+    cdef CacheFacade _cache
     cdef ClientOrderIdGenerator _order_id_generator
     cdef OrderListIdGenerator _order_list_id_generator
 
     cdef readonly TraderId trader_id
     """The order factories trader ID.\n\n:returns: `TraderId`"""
     cdef readonly StrategyId strategy_id
     """The order factories trading strategy ID.\n\n:returns: `StrategyId`"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/factories.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/factories.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from cpython.datetime cimport datetime
 
+from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.generators cimport ClientOrderIdGenerator
 from nautilus_trader.common.generators cimport OrderListIdGenerator
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.datetime cimport dt_to_unix_nanos
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.enums_c cimport ContingencyType
@@ -56,14 +57,16 @@
     ----------
     trader_id : TraderId
         The trader ID (only numerical tag sent to venue).
     strategy_id : StrategyId
         The strategy ID (only numerical tag sent to venue).
     clock : Clock
         The clock for the factory.
+    cache : CacheFacade, optional
+        The cache facade for the order factory.
     initial_order_id_count : int, optional
         The initial order ID count for the factory.
     initial_order_list_id_count : int, optional
         The initial order list ID count for the factory.
 
     Raises
     ------
@@ -74,18 +77,20 @@
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         Clock clock not None,
+        CacheFacade cache: Optional[CacheFacade]=None,
         int initial_order_id_count=0,
         int initial_order_list_id_count=0,
     ):
         self._clock = clock
+        self._cache = cache
         self.trader_id = trader_id
         self.strategy_id = strategy_id
 
         self._order_id_generator = ClientOrderIdGenerator(
             trader_id=trader_id,
             strategy_id=strategy_id,
             clock=clock,
@@ -137,28 +142,38 @@
         The identifier will be the next in the logical sequence.
 
         Returns
         -------
         ClientOrderId
 
         """
-        return self._order_id_generator.generate()
+        cdef ClientOrderId client_order_id = self._order_id_generator.generate()
+        if self._cache is not None:
+            while self._cache.order(client_order_id) is not None:
+                client_order_id = self._order_id_generator.generate()
+
+        return client_order_id
 
     cpdef OrderListId generate_order_list_id(self):
         """
         Generate and return a new order list ID.
 
         The identifier will be the next in the logical sequence.
 
         Returns
         -------
         OrderListId
 
         """
-        return self._order_list_id_generator.generate()
+        cdef OrderListId order_list_id = self._order_list_id_generator.generate()
+        if self._cache is not None:
+            while self._cache.order_list(order_list_id) is not None:
+                order_list_id = self._order_list_id_generator.generate()
+
+        return order_list_id
 
     cpdef void reset(self):
         """
         Reset the order factory.
 
         All stateful fields are reset to their initial value.
         """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/functions.py` & `nautilus_trader-1.176.0/nautilus_trader/common/functions.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/generators.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/generators.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/generators.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/generators.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/logging.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/logging.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/logging.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/logging.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -16,15 +16,14 @@
 import platform
 import socket
 import sys
 import traceback
 from platform import python_version
 from typing import Optional
 
-import aiohttp
 import msgspec
 import numpy as np
 import pandas as pd
 import psutil
 import pyarrow
 import pytz
 
@@ -89,16 +88,18 @@
         If ``None`` will not log to a file (unless `file_auto` is True).
     file_format : str { 'JSON' }, optional
         The log file format. If ``None`` (default) then will log in plain text.
         If set to 'JSON' then logs will be in JSON format.
     component_levels : dict[ComponentId, LogLevel]
         The additional per component log level filters, where keys are component
         IDs (e.g. actor/strategy IDs) and values are log levels.
-    bypass : bool
+    bypass : bool, default False
         If the log output is bypassed.
+    dummy : bool, default False
+        If logger is a 'dummy' logger (intended as a placeholder during initialization).
     """
 
     def __init__(
         self,
         Clock clock not None,
         TraderId trader_id = None,
         str machine_id = None,
@@ -107,26 +108,31 @@
         LogLevel level_file = LogLevel.DEBUG,
         bint file_logging = False,
         str directory = None,
         str file_name = None,
         str file_format = None,
         dict component_levels: dict[ComponentId, LogLevel] = None,
         bint bypass = False,
+        bint dummy = False,
     ):
         if trader_id is None:
             trader_id = TraderId("TRADER-000")
         if instance_id is None:
             instance_id = UUID4()
         if machine_id is None:
             machine_id = socket.gethostname()
 
         self._clock = clock
 
         cdef str trader_id_str = trader_id.to_str()
         cdef str instance_id_str = instance_id.to_str()
+
+        if dummy:
+            return  # Do not initialize core Rust logger
+
         self._mem = logger_new(
             pystr_to_cstr(trader_id_str),
             pystr_to_cstr(machine_id),
             pystr_to_cstr(instance_id_str),
             level_stdout,
             level_file,
             file_logging,
@@ -147,50 +153,58 @@
         Return the loggers trader ID.
 
         Returns
         -------
         TraderId
 
         """
+        if self._mem._0 == NULL:
+            return None  # Not initialized
         return TraderId(cstr_to_pystr(logger_get_trader_id_cstr(&self._mem)))
 
     @property
     def machine_id(self) -> str:
         """
         Return the loggers machine ID.
 
         Returns
         -------
         str
 
         """
+        if self._mem._0 == NULL:
+            return None  # Not initialized
         return cstr_to_pystr(logger_get_machine_id_cstr(&self._mem))
 
     @property
     def instance_id(self) -> UUID4:
         """
         Return the loggers system instance ID.
 
         Returns
         -------
         UUID4
 
         """
+        if self._mem._0 == NULL:
+            return None  # Not initialized
         return UUID4.from_mem_c(logger_get_instance_id(&self._mem))
 
     @property
     def is_bypassed(self) -> bool:
         """
         Return whether the logger is in bypass mode.
 
         Returns
         -------
         bool
 
         """
+        if self._mem._0 == NULL:
+            return False  # Not initialized
         return logger_is_bypassed(&self._mem)
 
     cpdef void change_clock(self, Clock clock):
         """
         Change the loggers internal clock to the given clock.
 
         Parameters
@@ -225,14 +239,18 @@
         uint64_t timestamp,
         LogLevel level,
         LogColor color,
         str component,
         str message,
         dict annotations,
     ):
+        if self._mem._0 == NULL:
+            print("ERROR: Logger has not been initialized.")
+            return  # Not initialized
+
         logger_log(
             &self._mem,
             timestamp,
             level,
             color,
             pystr_to_cstr(component),
             pystr_to_cstr(message),
@@ -573,15 +591,14 @@
     logger.info("\033[36m=================================================================")
     logger.info("\033[36m VERSIONING")
     logger.info("\033[36m=================================================================")
     logger.info(f"nautilus-trader {__version__}")
     logger.info(f"python {python_version()}")
     logger.info(f"numpy {np.__version__}")
     logger.info(f"pandas {pd.__version__}")
-    logger.info(f"aiohttp {aiohttp.__version__}")
     logger.info(f"msgspec {msgspec.__version__}")
     logger.info(f"psutil {psutil.__version__}")
     logger.info(f"pyarrow {pyarrow.__version__}")
     logger.info(f"pytz {pytz.__version__}")  # type: ignore
     try:
         import redis
         logger.info(f"redis {redis.__version__}")
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/messages.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/messages.pxd`

 * *Files 3% similar despite different names*

```diff
@@ -13,22 +13,23 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.common.enums_c cimport ComponentState
 from nautilus_trader.core.message cimport Event
 from nautilus_trader.model.enums_c cimport TradingState
 from nautilus_trader.model.identifiers cimport ComponentId
+from nautilus_trader.model.identifiers cimport Identifier
 from nautilus_trader.model.identifiers cimport TraderId
 
 
 cdef class ComponentStateChanged(Event):
     cdef readonly TraderId trader_id
     """The trader ID associated with the event.\n\n:returns: `TraderId`"""
-    cdef readonly ComponentId component_id
-    """The component ID associated with the event.\n\n:returns: `ComponentId`"""
+    cdef readonly Identifier component_id
+    """The component ID associated with the event.\n\n:returns: `Identifier`"""
     cdef readonly str component_type
     """The component type associated with the event.\n\n:returns: `str`"""
     cdef readonly ComponentState state
     """The component state.\n\n:returns: `ComponentState`"""
     cdef readonly dict config
     """The component configuration.\n\n:returns: `dict[str, Any]`"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/messages.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/messages.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -27,26 +27,27 @@
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.message cimport Event
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.enums_c cimport TradingState
 from nautilus_trader.model.enums_c cimport trading_state_from_str
 from nautilus_trader.model.enums_c cimport trading_state_to_str
 from nautilus_trader.model.identifiers cimport ComponentId
+from nautilus_trader.model.identifiers cimport Identifier
 from nautilus_trader.model.identifiers cimport TraderId
 
 
 cdef class ComponentStateChanged(Event):
     """
     Represents an event which includes information on the state of a component.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the event.
-    component_id : ComponentId
+    component_id : Identifier
         The component ID associated with the event.
     component_type : str
         The component type.
     state : ComponentState
         The component state.
     event_id : UUID4
         The event ID.
@@ -55,15 +56,15 @@
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
-        ComponentId component_id not None,
+        Identifier component_id not None,
         str component_type not None,
         ComponentState state,
         dict config not None,
         UUID4 event_id not None,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/providers.py` & `nautilus_trader-1.176.0/nautilus_trader/common/providers.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,16 +9,17 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
-from typing import Optional
 
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.logging import LoggerAdapter
 from nautilus_trader.config import InstrumentProviderConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.identifiers import InstrumentId
@@ -38,21 +39,22 @@
         The logger for the provider.
     config :InstrumentProviderConfig, optional
         The instrument provider config.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         venue: Venue,
         logger: Logger,
-        config: Optional[InstrumentProviderConfig] = None,
+        config: InstrumentProviderConfig | None = None,
     ) -> None:
         PyCondition.not_none(venue, "venue")
         PyCondition.not_none(logger, "logger")
 
         if config is None:
             config = InstrumentProviderConfig()
         self._log = LoggerAdapter(type(self).__name__, logger)
@@ -90,29 +92,29 @@
         Returns
         -------
         int
 
         """
         return len(self._instruments)
 
-    async def load_all_async(self, filters: Optional[dict] = None) -> None:
+    async def load_all_async(self, filters: dict | None = None) -> None:
         """
         Load the latest instruments into the provider asynchronously, optionally
         applying the given filters.
         """
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def load_ids_async(
         self,
         instrument_ids: list[InstrumentId],
-        filters: Optional[dict] = None,
+        filters: dict | None = None,
     ) -> None:
         """
-        Load the instruments for the given IDs into the provider, optionally
-        applying the given filters.
+        Load the instruments for the given IDs into the provider, optionally applying
+        the given filters.
 
         Parameters
         ----------
         instrument_ids : list[InstrumentId]
             The instrument IDs to load.
         filters : dict, optional
             The venue specific instrument loading filters to apply.
@@ -124,19 +126,19 @@
 
         """
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def load_async(
         self,
         instrument_id: InstrumentId,
-        filters: Optional[dict] = None,
+        filters: dict | None = None,
     ) -> None:
         """
-        Load the instrument for the given ID into the provider asynchronously, optionally
-        applying the given filters.
+        Load the instrument for the given ID into the provider asynchronously,
+        optionally applying the given filters.
 
         Parameters
         ----------
         instrument_id : InstrumentId
             The instrument ID to load.
         filters : dict, optional
             The venue specific instrument loading filters to apply.
@@ -150,14 +152,15 @@
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def initialize(self) -> None:
         """
         Initialize the instrument provider.
 
         If `initialize()` then will immediately return.
+
         """
         if self._loaded:
             return  # Already loaded
 
         if not self._loading:
             # Set async loading flag
             self._loading = True
@@ -173,18 +176,18 @@
                 # Wait 100ms
                 await asyncio.sleep(0.1)
 
         # Set async loading flags
         self._loading = False
         self._loaded = True
 
-    def load_all(self, filters: Optional[dict] = None) -> None:
+    def load_all(self, filters: dict | None = None) -> None:
         """
-        Load the latest instruments into the provider, optionally applying the
-        given filters.
+        Load the latest instruments into the provider, optionally applying the given
+        filters.
 
         Parameters
         ----------
         filters : dict, optional
             The venue specific instrument loading filters to apply.
 
         """
@@ -193,19 +196,19 @@
             loop.create_task(self.load_all_async(filters))
         else:
             loop.run_until_complete(self.load_all_async(filters))
 
     def load_ids(
         self,
         instrument_ids: list[InstrumentId],
-        filters: Optional[dict] = None,
+        filters: dict | None = None,
     ) -> None:
         """
-        Load the instruments for the given IDs into the provider, optionally
-        applying the given filters.
+        Load the instruments for the given IDs into the provider, optionally applying
+        the given filters.
 
         Parameters
         ----------
         instrument_ids : list[InstrumentId]
             The instrument IDs to load.
         filters : dict, optional
             The venue specific instrument loading filters to apply.
@@ -218,19 +221,19 @@
             loop.create_task(self.load_ids_async(instrument_ids, filters))
         else:
             loop.run_until_complete(self.load_ids_async(instrument_ids, filters))
 
     def load(
         self,
         instrument_id: InstrumentId,
-        filters: Optional[dict] = None,
+        filters: dict | None = None,
     ) -> None:
         """
-        Load the instrument for the given ID into the provider, optionally
-        applying the given filters.
+        Load the instrument for the given ID into the provider, optionally applying the
+        given filters.
 
         Parameters
         ----------
         instrument_id : InstrumentId
             The instrument ID to load.
         filters : dict, optional
             The venue specific instrument loading filters to apply.
@@ -319,15 +322,15 @@
         Returns
         -------
         dict[str, Currency]
 
         """
         return self._currencies.copy()
 
-    def currency(self, code: str) -> Optional[Currency]:
+    def currency(self, code: str) -> Currency | None:
         """
         Return the currency with the given code (if found).
 
         Parameters
         ----------
         code : str
             The currency code.
@@ -345,15 +348,15 @@
         PyCondition.valid_string(code, "code")
 
         ccy = self._currencies.get(code)
         if ccy is None:
             ccy = Currency.from_str(code)
         return ccy
 
-    def find(self, instrument_id: InstrumentId) -> Optional[Instrument]:
+    def find(self, instrument_id: InstrumentId) -> Instrument | None:
         """
         Return the instrument for the given instrument ID (if found).
 
         Parameters
         ----------
         instrument_id : InstrumentId
             The ID for the instrument
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/queue.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/queue.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/queue.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/queue.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/throttler.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/throttler.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/throttler.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/throttler.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/timer.pxd` & `nautilus_trader-1.176.0/nautilus_trader/common/timer.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/common/timer.pyx` & `nautilus_trader-1.176.0/nautilus_trader/common/timer.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,14 @@
 from nautilus_trader.core.message cimport Event
 from nautilus_trader.core.rust.common cimport time_event_clone
 from nautilus_trader.core.rust.common cimport time_event_drop
 from nautilus_trader.core.rust.common cimport time_event_name_to_cstr
 from nautilus_trader.core.rust.common cimport time_event_new
 from nautilus_trader.core.rust.common cimport time_event_to_cstr
 from nautilus_trader.core.rust.core cimport nanos_to_secs
-from nautilus_trader.core.rust.core cimport uuid4_clone
 from nautilus_trader.core.rust.core cimport uuid4_from_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
 from nautilus_trader.core.uuid cimport UUID4
 
 
 cdef class TimeEvent(Event):
@@ -58,15 +57,15 @@
         uint64_t ts_init,
     ):
         # Precondition: `name` validated in Rust
         super().__init__(event_id, ts_event, ts_init)
 
         self._mem = time_event_new(
             pystr_to_cstr(name),
-            uuid4_clone(&event_id._mem),
+            event_id._mem,
             ts_event,
             ts_init,
         )
 
     def __del__(self) -> None:
         if self._mem.name != NULL:
             time_event_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/config/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/config/__init__.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -8,19 +8,19 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 The `config` subpackage groups all configuration classes and factories.
 
 All configurations inherit from :class:`msgspec.Struct`.
+
 """
 
 from nautilus_trader.config.backtest import BacktestDataConfig
 from nautilus_trader.config.backtest import BacktestEngineConfig
 from nautilus_trader.config.backtest import BacktestRunConfig
 from nautilus_trader.config.backtest import BacktestVenueConfig
 from nautilus_trader.config.common import ActorConfig
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/config/backtest.py` & `nautilus_trader-1.176.0/nautilus_trader/config/backtest.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,14 +47,17 @@
     default_leverage: float = 1.0
     leverages: Optional[dict[str, float]] = None
     book_type: str = "L1_TBBO"
     routing: bool = False
     frozen_account: bool = False
     bar_execution: bool = True
     reject_stop_orders: bool = True
+    support_gtd_orders: bool = True
+    use_random_ids: bool = False
+    use_reduce_only: bool = True
     # fill_model: Optional[FillModel] = None  # TODO(cs): Implement
     modules: Optional[list[ImportableConfig]] = None
 
 
 class BacktestDataConfig(NautilusConfig, frozen=True):
     """
     Represents the data configuration for one specific backtest run.
@@ -214,14 +217,15 @@
         The backtest engine configuration (represents the core system kernel).
     venues : list[BacktestVenueConfig]
         The venue configurations for the backtest run.
     data : list[BacktestDataConfig]
         The data configurations for the backtest run.
     batch_size_bytes : optional
         The batch block size in bytes (will then run in streaming mode).
+
     """
 
     engine: Optional[BacktestEngineConfig] = None
     venues: Optional[list[BacktestVenueConfig]] = None
     data: Optional[list[BacktestDataConfig]] = None
     batch_size_bytes: Optional[int] = None
 
@@ -252,15 +256,15 @@
 
     def safer_eval(input_string):
         allowed_names = {"field": field}
         code = compile(input_string, "<string>", "eval")
         for name in code.co_names:
             if name not in allowed_names:
                 raise NameError(f"Use of {name} not allowed")
-        return eval(code, {}, allowed_names)
+        return eval(code, {}, allowed_names)  # noqa
 
     return safer_eval(s)  # Only allow use of the field object
 
 
 CUSTOM_ENCODINGS: dict[type, Callable] = {
     pd.DataFrame: lambda x: x.to_json(),
 }
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/config/common.py` & `nautilus_trader-1.176.0/nautilus_trader/config/common.py`

 * *Files 3% similar despite different names*

```diff
@@ -23,18 +23,18 @@
 from nautilus_trader.common import Environment
 from nautilus_trader.config.validation import PositiveFloat
 from nautilus_trader.config.validation import PositiveInt
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog
 
 
-def resolve_path(path: str):
-    module, cls = path.rsplit(":", maxsplit=1)
+def resolve_path(path: str) -> type:
+    module, cls_str = path.rsplit(":", maxsplit=1)
     mod = importlib.import_module(module)
-    cls = getattr(mod, cls)
+    cls: type = getattr(mod, cls_str)
     return cls
 
 
 class NautilusConfig(msgspec.Struct, kw_only=True, frozen=True):
     """
     The base class for all Nautilus configuration objects.
     """
@@ -110,22 +110,39 @@
 
 class CacheConfig(NautilusConfig, frozen=True):
     """
     Configuration for ``Cache`` instances.
 
     Parameters
     ----------
-    tick_capacity : PositiveInt
+    tick_capacity : PositiveInt, default 10_000
         The maximum length for internal tick dequeues.
-    bar_capacity : PositiveInt
+    bar_capacity : PositiveInt, default 10_000
         The maximum length for internal bar dequeues.
+    snapshot_orders : bool, default False
+        If order state snapshot lists should be persisted.
+        Snapshots will be taken at every order state update (when events are applied).
+    snapshot_positions : bool, default False
+        If position state snapshot lists should be persisted.
+        Snapshots will be taken at position opened, changed and closed (when events are applied).
+        To include the unrealized PnL in the snapshot then quotes for the positions instrument must
+        be available in the cache.
+    snapshot_positions_interval : PositiveFloat, optional
+        The interval (seconds) at which additional position state snapshots are persisted.
+        If ``None`` then no additional snapshots will be taken.
+        To include the unrealized PnL in the snapshot then quotes for the positions instrument must
+        be available in the cache.
+
     """
 
-    tick_capacity: PositiveInt = 1000
-    bar_capacity: PositiveInt = 1000
+    tick_capacity: PositiveInt = 10_000
+    bar_capacity: PositiveInt = 10_000
+    snapshot_orders: bool = False
+    snapshot_positions: bool = False
+    snapshot_positions_interval: Optional[PositiveFloat] = None
 
 
 class CacheDatabaseConfig(NautilusConfig, frozen=True):
     """
     Configuration for ``CacheDatabase`` instances.
 
     Parameters
@@ -138,25 +155,30 @@
         The database port.
     username : str, optional
         The account username for the database connection.
     password : str, optional
         The account password for the database connection.
     ssl : bool, default False
         If database should use an SSL enabled connection.
-    flush : bool, default False
-        If database should be flushed before start.
+    flush_on_start : bool, default False
+        If database should be flushed on start.
+    timestamps_as_iso8601, default False
+        If timestamps should be persisted as ISO 8601 strings.
+        If `False` then will persit as UNIX nanoseconds.
+
     """
 
     type: str = "in-memory"
     host: str = "localhost"
     port: Optional[int] = None
     username: Optional[str] = None
     password: Optional[str] = None
     ssl: bool = False
-    flush: bool = False
+    flush_on_start: bool = False
+    timestamps_as_iso8601: bool = False
 
 
 class InstrumentProviderConfig(NautilusConfig, frozen=True):
     """
     Configuration for ``InstrumentProvider`` instances.
 
     Parameters
@@ -168,14 +190,15 @@
     filters : frozendict, optional
         The venue specific instrument loading filters to apply.
     filter_callable: str, optional
         A fully qualified path to a callable that takes a single argument, `instrument` and returns a bool, indicating
         whether the instrument should be loaded
     log_warnings : bool, default True
         If parser warnings should be logged.
+
     """
 
     def __eq__(self, other):
         return (
             self.load_all == other.load_all
             and self.load_ids == other.load_ids
             and self.filters == other.filters
@@ -202,14 +225,15 @@
     time_bars_timestamp_on_close : bool, default True
         If time bar aggregators will timestamp `ts_event` on bar close.
         If False then will timestamp on bar open.
     validate_data_sequence : bool, default False
         If data objects timestamp sequencing will be validated and handled.
     debug : bool, default False
         If debug mode is active (will provide extra debug logging).
+
     """
 
     time_bars_build_with_no_updates: bool = True
     time_bars_timestamp_on_close: bool = True
     validate_data_sequence: bool = False
     debug: bool = False
 
@@ -227,14 +251,15 @@
     max_order_modify_rate : str, default 100/00:00:01
         The maximum rate of modify order commands per timedelta.
     max_notional_per_order : dict[str, int], default empty dict
         The maximum notional value of an order per instrument ID.
         The value should be a valid decimal format.
     debug : bool, default False
         If debug mode is active (will provide extra debug logging).
+
     """
 
     bypass: bool = False
     max_order_submit_rate: str = "100/00:00:01"
     max_order_modify_rate: str = "100/00:00:01"
     max_notional_per_order: dict[str, int] = {}
     debug: bool = False
@@ -246,23 +271,21 @@
 
     Parameters
     ----------
     load_cache : bool, default True
         If the cache should be loaded on initialization.
     allow_cash_positions : bool, default True
         If unleveraged spot/cash assets should generate positions.
-    filter_unclaimed_external_orders : bool, default False
-        If unclaimed order events with an EXTERNAL strategy ID should be filtered/dropped.
     debug : bool, default False
         If debug mode is active (will provide extra debug logging).
+
     """
 
     load_cache: bool = True
     allow_cash_positions: bool = True
-    filter_unclaimed_external_orders: bool = False
     debug: bool = False
 
 
 class OrderEmulatorConfig(NautilusConfig, frozen=True):
     """
     Configuration for ``OrderEmulator`` instances.
     """
@@ -280,14 +303,15 @@
         The `fsspec` filesystem protocol for the catalog.
     fs_storage_options : dict, optional
         The `fsspec` storage options.
     flush_interval_ms : int, optional
         The flush interval (milliseconds) for writing chunks.
     replace_existing: bool, default False
         If any existing feather files should be replaced.
+
     """
 
     catalog_path: str
     fs_protocol: Optional[str] = None
     fs_storage_options: Optional[dict] = None
     flush_interval_ms: Optional[int] = None
     replace_existing: bool = False
@@ -315,14 +339,15 @@
         The path to the data catalog.
     fs_protocol : str, optional
         The fsspec file system protocol for the data catalog.
     fs_storage_options : dict, optional
         The fsspec storage options for the data catalog.
     use_rust : bool, default False
         If queries will be for Rust schema versions (when implemented).
+
     """
 
     path: str
     fs_protocol: Optional[str] = None
     fs_storage_options: Optional[dict] = None
     use_rust: bool = False
 
@@ -332,14 +357,15 @@
     The base model for all actor configurations.
 
     Parameters
     ----------
     component_id : str, optional
         The component ID. If ``None`` then the identifier will be taken from
         `type(self).__name__`.
+
     """
 
     component_id: Optional[str] = None
 
 
 class ImportableActorConfig(NautilusConfig, frozen=True):
     """
@@ -349,14 +375,15 @@
     ----------
     actor_path : str
         The fully qualified name of the Actor class.
     config_path : str
         The fully qualified name of the Actor Config class.
     config : dict
         The actor configuration.
+
     """
 
     actor_path: str
     config_path: str
     config: dict
 
 
@@ -403,14 +430,16 @@
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType, optional
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
     external_order_claims : list[str], optional
         The external order claim instrument IDs.
+        External orders for matching instrument IDs will be associated with (claimed by) the strategy.
+
     """
 
     strategy_id: Optional[str] = None
     order_id_tag: Optional[str] = None
     oms_type: Optional[str] = None
     external_order_claims: Optional[list[str]] = None
 
@@ -423,14 +452,15 @@
     ----------
     strategy_path : str
         The fully qualified name of the strategy class.
     config_path : str
         The fully qualified name of the config class.
     config : dict[str, Any]
         The strategy configuration.
+
     """
 
     strategy_path: str
     config_path: str
     config: dict[str, Any]
 
 
@@ -470,14 +500,15 @@
     The base model for all execution algorithm configurations.
 
     Parameters
     ----------
     exec_algorithm_id : str, optional
         The unique ID for the execution algorithm.
         If not ``None`` then will become the execution algorithm ID.
+
     """
 
     exec_algorithm_id: Optional[str] = None
 
 
 class ImportableExecAlgorithmConfig(NautilusConfig, frozen=True):
     """
@@ -487,14 +518,15 @@
     ----------
     exec_algorithm_path : str
         The fully qualified name of the execution algorithm class.
     config_path : str
         The fully qualified name of the config class.
     config : dict[str, Any]
         The execution algorithm configuration.
+
     """
 
     exec_algorithm_path: str
     config_path: str
     config: dict[str, Any]
 
 
@@ -527,15 +559,16 @@
         exec_algorithm_cls = resolve_path(config.exec_algorithm_path)
         config_cls = resolve_path(config.config_path)
         return exec_algorithm_cls(config=config_cls(**config.config))
 
 
 class LoggingConfig(NautilusConfig, frozen=True):
     """
-    Configuration for standard output and file logging for a ``NautilusKernel`` instance.
+    Configuration for standard output and file logging for a ``NautilusKernel``
+    instance.
 
     Parameters
     ----------
     log_level : str, default "INFO"
         The minimum log level to write to stdout.
         Will always write ERROR level logs to stderr (unless `bypass_logging` is True).
     log_level_file : str, optional
@@ -550,14 +583,15 @@
     log_file_format : str { 'JSON' }, optional
         The log file format. If ``None`` (default) then will log in plain text.
     log_component_levels : dict[str, LogLevel]
         The additional per component log level filters, where keys are component
         IDs (e.g. actor/strategy IDs) and values are log levels.
     bypass_logging : bool, default False
         If all logging should be bypassed.
+
     """
 
     log_level: str = "INFO"
     log_level_file: Optional[str] = None
     log_directory: Optional[str] = None
     log_file_name: Optional[str] = None
     log_file_format: Optional[str] = None
@@ -605,14 +639,15 @@
         The timeout for execution state to reconcile.
     timeout_portfolio : PositiveFloat (seconds)
         The timeout for portfolio to initialize margins and unrealized PnLs.
     timeout_disconnection : PositiveFloat (seconds)
         The timeout for all engine clients to disconnect.
     timeout_post_stop : PositiveFloat (seconds)
         The timeout after stopping the node to await residual events before final shutdown.
+
     """
 
     environment: Environment
     trader_id: str
     instance_id: Optional[str] = None
     cache: Optional[CacheConfig] = None
     cache_database: Optional[CacheDatabaseConfig] = None
@@ -645,15 +680,16 @@
     def create(self):
         cls = resolve_path(self.path)
         return cls()
 
 
 class ImportableConfig(NautilusConfig, frozen=True):
     """
-    Represents an importable configuration (typically live data client or live execution client).
+    Represents an importable configuration (typically live data client or live execution
+    client).
     """
 
     path: str
     config: dict = {}
     factory: Optional[ImportableFactoryConfig] = None
 
     @staticmethod
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/config/error.py` & `nautilus_trader-1.176.0/nautilus_trader/config/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/config/live.py` & `nautilus_trader-1.176.0/nautilus_trader/config/live.py`

 * *Files 6% similar despite different names*

```diff
@@ -19,41 +19,44 @@
 from nautilus_trader.config.common import DataEngineConfig
 from nautilus_trader.config.common import ExecEngineConfig
 from nautilus_trader.config.common import InstrumentProviderConfig
 from nautilus_trader.config.common import NautilusConfig
 from nautilus_trader.config.common import NautilusKernelConfig
 from nautilus_trader.config.common import RiskEngineConfig
 from nautilus_trader.config.validation import NonNegativeInt
+from nautilus_trader.config.validation import PositiveFloat
 from nautilus_trader.config.validation import PositiveInt
 
 
 class LiveDataEngineConfig(DataEngineConfig, frozen=True):
     """
     Configuration for ``LiveDataEngine`` instances.
 
     Parameters
     ----------
-    qsize : PositiveInt, default 10_000
+    qsize : PositiveInt, default 100_000
         The queue size for the engines internal queue buffers.
+
     """
 
-    qsize: PositiveInt = 10_000
+    qsize: PositiveInt = 100_000
 
 
 class LiveRiskEngineConfig(RiskEngineConfig, frozen=True):
     """
     Configuration for ``LiveRiskEngine`` instances.
 
     Parameters
     ----------
-    qsize : PositiveInt, default 10_000
+    qsize : PositiveInt, default 100_000
         The queue size for the engines internal queue buffers.
+
     """
 
-    qsize: PositiveInt = 10_000
+    qsize: PositiveInt = 100_000
 
 
 class LiveExecEngineConfig(ExecEngineConfig, frozen=True):
     """
     Configuration for ``LiveExecEngine`` instances.
 
     The purpose of the in-flight order check is for live reconciliation, events
@@ -63,45 +66,55 @@
     Parameters
     ----------
     reconciliation : bool, default True
         If reconciliation is active at start-up.
     reconciliation_lookback_mins : NonNegativeInt, optional
         The maximum lookback minutes to reconcile state for.
         If ``None`` or 0 then will use the maximum lookback available from the venues.
+    filter_unclaimed_external_orders : bool, default False
+        If unclaimed order events with an EXTERNAL strategy ID should be filtered/dropped.
+    filter_position_reports : bool, default False
+        If `PositionStatusReport`s are filtered from reconciliation.
+        This may be applicable when other nodes are trading the same instrument(s), on the same
+        account - which could cause conflicts in position status.
     inflight_check_interval_ms : NonNegativeInt, default 2_000
         The interval (milliseconds) between checking whether in-flight orders
         have exceeded their time-in-flight threshold.
         This should not be set less than the `inflight_check_interval_ms`.
     inflight_check_threshold_ms : NonNegativeInt, default 5_000
         The threshold (milliseconds) beyond which an in-flight orders status
         is checked with the venue.
         As a rule of thumb, you shouldn't consider reducing this setting unless you
         are colocated with the venue (to avoid the potential for race conditions).
-    qsize : PositiveInt, default 10_000
+    qsize : PositiveInt, default 100_000
         The queue size for the engines internal queue buffers.
+
     """
 
     reconciliation: bool = True
     reconciliation_lookback_mins: Optional[NonNegativeInt] = None
+    filter_unclaimed_external_orders: bool = False
+    filter_position_reports: bool = False
     inflight_check_interval_ms: NonNegativeInt = 2_000
     inflight_check_threshold_ms: NonNegativeInt = 5_000
-    qsize: PositiveInt = 10_000
+    qsize: PositiveInt = 100_000
 
 
 class RoutingConfig(NautilusConfig, frozen=True):
     """
     Configuration for live client message routing.
 
     Parameters
     ----------
     default : bool
         If the client should be registered as the default routing client
         (when a specific venue routing cannot be found).
     venues : list[str], optional
         The venues to register for routing.
+
     """
 
     default: bool = False
     venues: Optional[frozenset[str]] = None
 
 
 class LiveDataClientConfig(NautilusConfig, frozen=True):
@@ -112,14 +125,15 @@
     ----------
     handle_revised_bars : bool
         If DataClient will emit bar updates as soon new bar opens.
     instrument_provider : InstrumentProviderConfig
         The clients instrument provider configuration.
     routing : RoutingConfig
         The clients message routing config.
+
     """
 
     handle_revised_bars: bool = False
     instrument_provider: InstrumentProviderConfig = InstrumentProviderConfig()
     routing: RoutingConfig = RoutingConfig()
 
 
@@ -129,14 +143,15 @@
 
     Parameters
     ----------
     instrument_provider : InstrumentProviderConfig
         The clients instrument provider configuration.
     routing : RoutingConfig
         The clients message routing config.
+
     """
 
     instrument_provider: InstrumentProviderConfig = InstrumentProviderConfig()
     routing: RoutingConfig = RoutingConfig()
 
 
 class TradingNodeConfig(NautilusKernelConfig, frozen=True):
@@ -159,16 +174,20 @@
         The live execution engine configuration.
     streaming : StreamingConfig, optional
         The configuration for streaming to feather files.
     data_clients : dict[str, ImportableConfig | LiveDataClientConfig], optional
         The data client configurations.
     exec_clients : dict[str, ImportableConfig | LiveExecClientConfig], optional
         The execution client configurations.
+    heartbeat_interval : PositiveFloat, optional
+        The heartbeat interval (seconds) to use for trading node health.
+
     """
 
     environment: Environment = Environment.LIVE
     trader_id: str = "TRADER-001"
     data_engine: LiveDataEngineConfig = LiveDataEngineConfig()
     risk_engine: LiveRiskEngineConfig = LiveRiskEngineConfig()
     exec_engine: LiveExecEngineConfig = LiveExecEngineConfig()
     data_clients: dict[str, LiveDataClientConfig] = {}
     exec_clients: dict[str, LiveExecClientConfig] = {}
+    heartbeat_interval: Optional[PositiveFloat] = None
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/config/validation.py` & `nautilus_trader-1.176.0/nautilus_trader/config/validation.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/core/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -8,18 +8,19 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `core` subpackage groups core constants, functions and low-level components used throughout the framework.
+The `core` subpackage groups core constants, functions and low-level components used
+throughout the framework.
 
 The main focus here is on efficiency and re-usability as this forms the base
 layer of the entire framework. Message passing is a core design philosophy and
 the base massage types are contained here.
 
 A generic `FiniteStateMachine` operates with C-level enums, ensuring correct
 state transitions for both domain entities and more complex components.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/asynchronous.py` & `nautilus_trader-1.176.0/nautilus_trader/core/asynchronous.py`

 * *Files 12% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 
 
 @types.coroutine
 def sleep0():
     """
     Skip one event loop run cycle.
 
-    This is equivalent to `asyncio.sleep(0)` however avoids the overhead
-    of the Python function call and integer comparison <= 0.
+    This is equivalent to `asyncio.sleep(0)` however avoids the overhead of the Python
+    function call and integer comparison <= 0.
 
-    Uses a bare 'yield' expression (which Task.__step knows how to handle)
-    instead of creating a Future object.
+    Uses a bare 'yield' expression (which Task.__step knows how to handle) instead of
+    creating a Future object.
 
     """
     yield
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/correctness.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/correctness.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/correctness.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/correctness.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/data.pxd` & `nautilus_trader-1.176.0/nautilus_trader/msgbus/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -8,11 +8,11 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-
-cdef class Data:
-    pass
+"""
+The `msgbus` subpackage provides a universal message bus for connecting system
+components in a loosely coupled way.
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/data.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/data.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/datetime.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/datetime.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/datetime.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/datetime.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/fsm.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/fsm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/fsm.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/fsm.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/includes/algorithms.h` & `nautilus_trader-1.176.0/nautilus_trader/core/includes/algorithms.h`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/includes/backtest.h` & `nautilus_trader-1.176.0/nautilus_trader/core/includes/backtest.h`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/includes/common.h` & `nautilus_trader-1.176.0/nautilus_trader/core/includes/common.h`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/includes/core.h` & `nautilus_trader-1.176.0/nautilus_trader/core/includes/core.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 /* Generated with cbindgen:0.24.5 */
 
 /* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */
 
 #include <stdint.h>
 #include <Python.h>
 
-typedef struct Arc_String Arc_String;
-
 /**
  * `CVec` is a C compatible struct that stores an opaque pointer to a block of
  * memory, it's length and the capacity of the vector it was allocated from.
  *
  * NOTE: Changing the values here may lead to undefined behaviour when the
  * memory is dropped.
  */
@@ -28,15 +26,15 @@
      * The capacity of vector from which it was allocated.
      * Used when deallocating the memory
      */
     uintptr_t cap;
 } CVec;
 
 typedef struct UUID4_t {
-    struct Arc_String *value;
+    uint8_t value[37];
 } UUID4_t;
 
 void cvec_drop(struct CVec cvec);
 
 struct CVec cvec_new(void);
 
 /**
@@ -118,18 +116,14 @@
 /**
  * Returns the current nanoseconds since the UNIX epoch.
  */
 uint64_t unix_timestamp_ns(void);
 
 struct UUID4_t uuid4_new(void);
 
-struct UUID4_t uuid4_clone(const struct UUID4_t *uuid4);
-
-void uuid4_drop(struct UUID4_t uuid4);
-
 /**
  * Returns a [`UUID4`] from C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  *
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/includes/model.h` & `nautilus_trader-1.176.0/nautilus_trader/core/includes/model.h`

 * *Files 9% similar despite different names*

```diff
@@ -614,125 +614,253 @@
     MARK_PRICE = 8,
     /**
      * Based on the index price for the instrument.
      */
     INDEX_PRICE = 9,
 } TriggerType;
 
-typedef struct Arc_String Arc_String;
+typedef struct Level Level;
 
 typedef struct OrderBook OrderBook;
 
 typedef struct String String;
 
 /**
  * Represents a synthetic instrument with prices derived from component instruments using a
  * formula.
  */
 typedef struct SyntheticInstrument SyntheticInstrument;
 
-typedef struct BarSpecification_t {
-    uint64_t step;
-    uint8_t aggregation;
-    enum PriceType price_type;
-} BarSpecification_t;
-
 typedef struct Symbol_t {
-    struct Arc_String *value;
+    char* value;
 } Symbol_t;
 
 typedef struct Venue_t {
-    struct Arc_String *value;
+    char* value;
 } Venue_t;
 
 typedef struct InstrumentId_t {
     struct Symbol_t symbol;
     struct Venue_t venue;
 } InstrumentId_t;
 
-typedef struct BarType_t {
-    struct InstrumentId_t instrument_id;
-    struct BarSpecification_t spec;
-    enum AggregationSource aggregation_source;
-} BarType_t;
-
 typedef struct Price_t {
     int64_t raw;
     uint8_t precision;
 } Price_t;
 
 typedef struct Quantity_t {
     uint64_t raw;
     uint8_t precision;
 } Quantity_t;
 
-typedef struct Bar_t {
-    struct BarType_t bar_type;
-    struct Price_t open;
-    struct Price_t high;
-    struct Price_t low;
-    struct Price_t close;
-    struct Quantity_t volume;
-    uint64_t ts_event;
-    uint64_t ts_init;
-} Bar_t;
-
 /**
  * Represents an order in a book.
  */
 typedef struct BookOrder_t {
+    /**
+     * The order side.
+     */
     enum OrderSide side;
+    /**
+     * The order price.
+     */
     struct Price_t price;
+    /**
+     * The order size.
+     */
     struct Quantity_t size;
+    /**
+     * The order ID.
+     */
     uint64_t order_id;
 } BookOrder_t;
 
 /**
  * Represents a single change/delta in an order book.
  */
 typedef struct OrderBookDelta_t {
+    /**
+     * The instrument ID for the book.
+     */
     struct InstrumentId_t instrument_id;
+    /**
+     * The order book delta action.
+     */
     enum BookAction action;
+    /**
+     * The order to apply.
+     */
     struct BookOrder_t order;
+    /**
+     * A combination of packet end with matching engine status.
+     */
     uint8_t flags;
+    /**
+     * The message sequence number assigned at the venue.
+     */
     uint64_t sequence;
+    /**
+     * The UNIX timestamp (nanoseconds) when the data event occurred.
+     */
     uint64_t ts_event;
+    /**
+     * The UNIX timestamp (nanoseconds) when the data object was initialized.
+     */
     uint64_t ts_init;
 } OrderBookDelta_t;
 
 /**
  * Represents a single quote tick in a financial market.
  */
 typedef struct QuoteTick_t {
+    /**
+     * The quotes instrument ID.
+     */
     struct InstrumentId_t instrument_id;
+    /**
+     * The top of book bid price.
+     */
     struct Price_t bid;
+    /**
+     * The top of book ask price.
+     */
     struct Price_t ask;
+    /**
+     * The top of book bid size.
+     */
     struct Quantity_t bid_size;
+    /**
+     * The top of book ask size.
+     */
     struct Quantity_t ask_size;
+    /**
+     * The UNIX timestamp (nanoseconds) when the tick event occurred.
+     */
     uint64_t ts_event;
+    /**
+     * The UNIX timestamp (nanoseconds) when the data object was initialized.
+     */
     uint64_t ts_init;
 } QuoteTick_t;
 
 typedef struct TradeId_t {
-    struct Arc_String *value;
+    char* value;
 } TradeId_t;
 
 /**
  * Represents a single trade tick in a financial market.
  */
 typedef struct TradeTick_t {
+    /**
+     * The trade instrument ID.
+     */
     struct InstrumentId_t instrument_id;
+    /**
+     * The traded price.
+     */
     struct Price_t price;
+    /**
+     * The traded size.
+     */
     struct Quantity_t size;
+    /**
+     * The trade aggressor side.
+     */
     enum AggressorSide aggressor_side;
+    /**
+     * The trade match ID (assigned by the venue).
+     */
     struct TradeId_t trade_id;
+    /**
+     * The UNIX timestamp (nanoseconds) when the tick event occurred.
+     */
     uint64_t ts_event;
+    /**
+     *  The UNIX timestamp (nanoseconds) when the data object was initialized.
+     */
     uint64_t ts_init;
 } TradeTick_t;
 
+/**
+ * Represents a bar aggregation specification including a step, aggregation
+ * method/rule and price type.
+ */
+typedef struct BarSpecification_t {
+    /**
+     * The step for binning samples for bar aggregation.
+     */
+    uint64_t step;
+    /**
+     * The type of bar aggregation.
+     */
+    uint8_t aggregation;
+    /**
+     * The price type to use for aggregation.
+     */
+    enum PriceType price_type;
+} BarSpecification_t;
+
+/**
+ * Represents a bar type including the instrument ID, bar specification and
+ * aggregation source.
+ */
+typedef struct BarType_t {
+    /**
+     * The bar types instrument ID.
+     */
+    struct InstrumentId_t instrument_id;
+    /**
+     * The bar types specification.
+     */
+    struct BarSpecification_t spec;
+    /**
+     * The bar types aggregation source.
+     */
+    enum AggregationSource aggregation_source;
+} BarType_t;
+
+/**
+ * Represents an aggregated bar.
+ */
+typedef struct Bar_t {
+    /**
+     * The bar type for this bar.
+     */
+    struct BarType_t bar_type;
+    /**
+     * The bars open price.
+     */
+    struct Price_t open;
+    /**
+     * The bars high price.
+     */
+    struct Price_t high;
+    /**
+     * The bars low price.
+     */
+    struct Price_t low;
+    /**
+     * The bars close price.
+     */
+    struct Price_t close;
+    /**
+     * The bars volume.
+     */
+    struct Quantity_t volume;
+    /**
+     * The UNIX timestamp (nanoseconds) when the data event occurred.
+     */
+    uint64_t ts_event;
+    /**
+     * The UNIX timestamp (nanoseconds) when the data object was initialized.
+     */
+    uint64_t ts_init;
+} Bar_t;
+
 typedef enum Data_t_Tag {
     DELTA,
     QUOTE,
     TRADE,
     BAR,
 } Data_t_Tag;
 
@@ -751,62 +879,62 @@
         struct {
             struct Bar_t bar;
         };
     };
 } Data_t;
 
 typedef struct TraderId_t {
-    struct Arc_String *value;
+    char* value;
 } TraderId_t;
 
 typedef struct StrategyId_t {
-    struct Arc_String *value;
+    char* value;
 } StrategyId_t;
 
 typedef struct ClientOrderId_t {
-    struct Arc_String *value;
+    char* value;
 } ClientOrderId_t;
 
 typedef struct OrderDenied_t {
     struct TraderId_t trader_id;
     struct StrategyId_t strategy_id;
     struct InstrumentId_t instrument_id;
     struct ClientOrderId_t client_order_id;
     struct String *reason;
     UUID4_t event_id;
     uint64_t ts_event;
     uint64_t ts_init;
 } OrderDenied_t;
 
 typedef struct AccountId_t {
-    struct Arc_String *value;
+    char* value;
 } AccountId_t;
 
 typedef struct ClientId_t {
-    struct Arc_String *value;
+    char* value;
 } ClientId_t;
 
 typedef struct ComponentId_t {
-    struct Arc_String *value;
+    char* value;
 } ComponentId_t;
 
 typedef struct ExecAlgorithmId_t {
-    struct Arc_String *value;
+    char* value;
 } ExecAlgorithmId_t;
 
 typedef struct OrderListId_t {
-    struct Arc_String *value;
+    char* value;
 } OrderListId_t;
 
 typedef struct PositionId_t {
-    struct Arc_String *value;
+    char* value;
 } PositionId_t;
 
 typedef struct VenueOrderId_t {
-    struct Arc_String *value;
+    char* value;
 } VenueOrderId_t;
 
 /**
  * Provides a C compatible Foreign Function Interface (FFI) for an underlying
  * [`SyntheticInstrument`].
  *
  * This struct wraps `SyntheticInstrument` in a way that makes it compatible with C function
@@ -830,27 +958,50 @@
  * dereferenced to `OrderBook`, providing access to `OrderBook`'s methods without
  * having to manually access the underlying `OrderBook` instance.
  */
 typedef struct OrderBook_API {
     struct OrderBook *_0;
 } OrderBook_API;
 
+/**
+ * Provides a C compatible Foreign Function Interface (FFI) for an underlying order book[`Level`].
+ *
+ * This struct wraps `Level` in a way that makes it compatible with C function
+ * calls, enabling interaction with `Level` in a C environment.
+ *
+ * It implements the `Deref` trait, allowing instances of `Level_API` to be
+ * dereferenced to `Level`, providing access to `Level`'s methods without
+ * having to manually acce wss the underlying `Level` instance.
+ */
+typedef struct Level_API {
+    struct Level *_0;
+} Level_API;
+
 typedef struct Currency_t {
-    struct Arc_String *code;
+    char* code;
     uint8_t precision;
     uint16_t iso4217;
-    struct Arc_String *name;
+    char* name;
     enum CurrencyType currency_type;
 } Currency_t;
 
 typedef struct Money_t {
     int64_t raw;
     struct Currency_t currency;
 } Money_t;
 
+#define NULL_ORDER (BookOrder_t){ .side = OrderSide_NoOrderSide, .price = (Price_t){ .raw = 0, .precision = 0 }, .size = (Quantity_t){ .raw = 0, .precision = 0 }, .order_id = 0 }
+
+/**
+ * Sentinel Price for errors.
+ */
+#define ERROR_PRICE (Price_t){ .raw = INT64_MAX, .precision = 0 }
+
+struct Data_t data_clone(const struct Data_t *data);
+
 struct BarSpecification_t bar_specification_new(uint64_t step,
                                                 uint8_t aggregation,
                                                 uint8_t price_type);
 
 /**
  * Returns a [`BarSpecification`] as a C string pointer.
  */
@@ -873,18 +1024,14 @@
 uint8_t bar_specification_ge(const struct BarSpecification_t *lhs,
                              const struct BarSpecification_t *rhs);
 
 struct BarType_t bar_type_new(struct InstrumentId_t instrument_id,
                               struct BarSpecification_t spec,
                               uint8_t aggregation_source);
 
-void bar_type_drop(struct BarType_t bar_type);
-
-struct BarType_t bar_type_clone(const struct BarType_t *bar_type);
-
 uint8_t bar_type_eq(const struct BarType_t *lhs, const struct BarType_t *rhs);
 
 uint8_t bar_type_lt(const struct BarType_t *lhs, const struct BarType_t *rhs);
 
 uint8_t bar_type_le(const struct BarType_t *lhs, const struct BarType_t *rhs);
 
 uint8_t bar_type_gt(const struct BarType_t *lhs, const struct BarType_t *rhs);
@@ -914,26 +1061,34 @@
                               int64_t close,
                               uint8_t price_prec,
                               uint64_t volume,
                               uint8_t size_prec,
                               uint64_t ts_event,
                               uint64_t ts_init);
 
-void bar_drop(struct Bar_t bar);
+uint8_t bar_eq(const struct Bar_t *lhs, const struct Bar_t *rhs);
 
-struct Bar_t bar_clone(const struct Bar_t *bar);
+uint64_t bar_hash(const struct Bar_t *bar);
 
 /**
  * Returns a [`Bar`] as a C string.
  */
 const char *bar_to_cstr(const struct Bar_t *bar);
 
-uint8_t bar_eq(const struct Bar_t *lhs, const struct Bar_t *rhs);
+struct OrderBookDelta_t orderbook_delta_new(struct InstrumentId_t instrument_id,
+                                            enum BookAction action,
+                                            struct BookOrder_t order,
+                                            uint8_t flags,
+                                            uint64_t sequence,
+                                            uint64_t ts_event,
+                                            uint64_t ts_init);
 
-uint64_t bar_hash(const struct Bar_t *bar);
+uint8_t orderbook_delta_eq(const struct OrderBookDelta_t *lhs, const struct OrderBookDelta_t *rhs);
+
+uint64_t orderbook_delta_hash(const struct OrderBookDelta_t *delta);
 
 struct BookOrder_t book_order_from_raw(enum OrderSide order_side,
                                        int64_t price_raw,
                                        uint8_t price_prec,
                                        uint64_t size_raw,
                                        uint8_t size_prec,
                                        uint64_t order_id);
@@ -952,45 +1107,29 @@
 const char *book_order_display_to_cstr(const struct BookOrder_t *order);
 
 /**
  * Returns a [`BookOrder`] debug string as a C string pointer.
  */
 const char *book_order_debug_to_cstr(const struct BookOrder_t *order);
 
-void orderbook_delta_drop(struct OrderBookDelta_t delta);
-
-struct OrderBookDelta_t orderbook_delta_clone(const struct OrderBookDelta_t *delta);
-
-struct OrderBookDelta_t orderbook_delta_new(struct InstrumentId_t instrument_id,
-                                            enum BookAction action,
-                                            struct BookOrder_t order,
-                                            uint8_t flags,
-                                            uint64_t sequence,
-                                            uint64_t ts_event,
-                                            uint64_t ts_init);
-
-uint8_t orderbook_delta_eq(const struct OrderBookDelta_t *lhs, const struct OrderBookDelta_t *rhs);
-
-uint64_t orderbook_delta_hash(const struct OrderBookDelta_t *delta);
-
 struct QuoteTick_t quote_tick_new(struct InstrumentId_t instrument_id,
                                   int64_t bid_price_raw,
                                   int64_t ask_price_raw,
                                   uint8_t bid_price_prec,
                                   uint8_t ask_price_prec,
                                   uint64_t bid_size_raw,
                                   uint64_t ask_size_raw,
                                   uint8_t bid_size_prec,
                                   uint8_t ask_size_prec,
                                   uint64_t ts_event,
                                   uint64_t ts_init);
 
-void quote_tick_drop(struct QuoteTick_t tick);
+uint8_t quote_tick_eq(const struct QuoteTick_t *lhs, const struct QuoteTick_t *rhs);
 
-struct QuoteTick_t quote_tick_clone(const struct QuoteTick_t *tick);
+uint64_t quote_tick_hash(const struct QuoteTick_t *delta);
 
 /**
  * Returns a [`QuoteTick`] as a C string pointer.
  */
 const char *quote_tick_to_cstr(const struct QuoteTick_t *tick);
 
 struct TradeTick_t trade_tick_new(struct InstrumentId_t instrument_id,
@@ -999,27 +1138,23 @@
                                   uint64_t size_raw,
                                   uint8_t size_prec,
                                   enum AggressorSide aggressor_side,
                                   struct TradeId_t trade_id,
                                   uint64_t ts_event,
                                   uint64_t ts_init);
 
-void trade_tick_drop(struct TradeTick_t tick);
+uint8_t trade_tick_eq(const struct TradeTick_t *lhs, const struct TradeTick_t *rhs);
 
-struct TradeTick_t trade_tick_clone(const struct TradeTick_t *tick);
+uint64_t trade_tick_hash(const struct TradeTick_t *delta);
 
 /**
  * Returns a [`TradeTick`] as a C string pointer.
  */
 const char *trade_tick_to_cstr(const struct TradeTick_t *tick);
 
-void data_drop(struct Data_t data);
-
-struct Data_t data_clone(const struct Data_t *data);
-
 const char *account_type_to_cstr(enum AccountType value);
 
 /**
  * Returns an enum from a Python string.
  *
  * # Safety
  * - Assumes `ptr` is a valid C string pointer.
@@ -1275,377 +1410,212 @@
  */
 void order_denied_drop(struct OrderDenied_t event);
 
 struct OrderDenied_t order_denied_clone(const struct OrderDenied_t *event);
 
 const char *order_denied_reason_to_cstr(const struct OrderDenied_t *event);
 
+void interned_string_stats(void);
+
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct AccountId_t account_id_new(const char *ptr);
 
-struct AccountId_t account_id_clone(const struct AccountId_t *account_id);
-
-/**
- * Frees the memory for the given `account_id` by dropping.
- */
-void account_id_drop(struct AccountId_t account_id);
-
-/**
- * Returns an [`AccountId`] as a C string pointer.
- */
-const char *account_id_to_cstr(const struct AccountId_t *account_id);
-
-uint8_t account_id_eq(const struct AccountId_t *lhs, const struct AccountId_t *rhs);
-
-uint64_t account_id_hash(const struct AccountId_t *account_id);
+uint64_t account_id_hash(const struct AccountId_t *id);
 
 /**
  * Returns a Nautilus identifier from C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct ClientId_t client_id_new(const char *ptr);
 
-struct ClientId_t client_id_clone(const struct ClientId_t *client_id);
-
-/**
- * Frees the memory for the given `client_id` by dropping.
- */
-void client_id_drop(struct ClientId_t client_id);
-
-/**
- * Returns a [`ClientId`] identifier as a C string pointer.
- */
-const char *client_id_to_cstr(const struct ClientId_t *client_id);
-
-uint8_t client_id_eq(const struct ClientId_t *lhs, const struct ClientId_t *rhs);
-
-uint64_t client_id_hash(const struct ClientId_t *client_id);
+uint64_t client_id_hash(const struct ClientId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct ClientOrderId_t client_order_id_new(const char *ptr);
 
-struct ClientOrderId_t client_order_id_clone(const struct ClientOrderId_t *client_order_id);
-
-/**
- * Frees the memory for the given `client_order_id` by dropping.
- */
-void client_order_id_drop(struct ClientOrderId_t client_order_id);
-
-/**
- * Returns a [`ClientOrderId`] as a C string pointer.
- */
-const char *client_order_id_to_cstr(const struct ClientOrderId_t *client_order_id);
-
-uint8_t client_order_id_eq(const struct ClientOrderId_t *lhs, const struct ClientOrderId_t *rhs);
-
-uint64_t client_order_id_hash(const struct ClientOrderId_t *client_order_id);
+uint64_t client_order_id_hash(const struct ClientOrderId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct ComponentId_t component_id_new(const char *ptr);
 
-struct ComponentId_t component_id_clone(const struct ComponentId_t *component_id);
-
-/**
- * Frees the memory for the given `component_id` by dropping.
- */
-void component_id_drop(struct ComponentId_t component_id);
-
-/**
- * Returns a [`ComponentId`] identifier as a C string pointer.
- */
-const char *component_id_to_cstr(const struct ComponentId_t *component_id);
-
-uint8_t component_id_eq(const struct ComponentId_t *lhs, const struct ComponentId_t *rhs);
-
-uint64_t component_id_hash(const struct ComponentId_t *component_id);
+uint64_t component_id_hash(const struct ComponentId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct ExecAlgorithmId_t exec_algorithm_id_new(const char *ptr);
 
-struct ExecAlgorithmId_t exec_algorithm_id_clone(const struct ExecAlgorithmId_t *exec_algorithm_id);
-
-/**
- * Frees the memory for the given `exec_algorithm_id` by dropping.
- */
-void exec_algorithm_id_drop(struct ExecAlgorithmId_t exec_algorithm_id);
-
-/**
- * Returns an [`ExecAlgorithmId`] identifier as a C string pointer.
- */
-const char *exec_algorithm_id_to_cstr(const struct ExecAlgorithmId_t *exec_algorithm_id);
-
-uint8_t exec_algorithm_id_eq(const struct ExecAlgorithmId_t *lhs,
-                             const struct ExecAlgorithmId_t *rhs);
-
-uint64_t exec_algorithm_id_hash(const struct ExecAlgorithmId_t *exec_algorithm_id);
+uint64_t exec_algorithm_id_hash(const struct ExecAlgorithmId_t *id);
 
-struct InstrumentId_t instrument_id_new(const struct Symbol_t *symbol, const struct Venue_t *venue);
+struct InstrumentId_t instrument_id_new(struct Symbol_t symbol, struct Venue_t venue);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct InstrumentId_t instrument_id_new_from_cstr(const char *ptr);
 
-struct InstrumentId_t instrument_id_clone(const struct InstrumentId_t *instrument_id);
-
-/**
- * Frees the memory for the given `instrument_id` by dropping.
- */
-void instrument_id_drop(struct InstrumentId_t instrument_id);
-
 /**
  * Returns an [`InstrumentId`] as a C string pointer.
  */
 const char *instrument_id_to_cstr(const struct InstrumentId_t *instrument_id);
 
-uint8_t instrument_id_eq(const struct InstrumentId_t *lhs, const struct InstrumentId_t *rhs);
-
 uint64_t instrument_id_hash(const struct InstrumentId_t *instrument_id);
 
+uint8_t instrument_id_is_synthetic(const struct InstrumentId_t *instrument_id);
+
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct OrderListId_t order_list_id_new(const char *ptr);
 
-struct OrderListId_t order_list_id_clone(const struct OrderListId_t *order_list_id);
-
-/**
- * Frees the memory for the given `order_list_id` by dropping.
- */
-void order_list_id_drop(struct OrderListId_t order_list_id);
-
-/**
- * Returns an [`OrderListId`] as a C string pointer.
- */
-const char *order_list_id_to_cstr(const struct OrderListId_t *order_list_id);
-
-uint8_t order_list_id_eq(const struct OrderListId_t *lhs, const struct OrderListId_t *rhs);
-
-uint64_t order_list_id_hash(const struct OrderListId_t *order_list_id);
+uint64_t order_list_id_hash(const struct OrderListId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct PositionId_t position_id_new(const char *ptr);
 
-struct PositionId_t position_id_clone(const struct PositionId_t *position_id);
-
-/**
- * Frees the memory for the given `position_id` by dropping.
- */
-void position_id_drop(struct PositionId_t position_id);
-
-/**
- * Returns a [`PositionId`] identifier as a C string pointer.
- */
-const char *position_id_to_cstr(const struct PositionId_t *position_id);
-
-uint8_t position_id_eq(const struct PositionId_t *lhs, const struct PositionId_t *rhs);
-
-uint64_t position_id_hash(const struct PositionId_t *position_id);
+uint64_t position_id_hash(const struct PositionId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct StrategyId_t strategy_id_new(const char *ptr);
 
-struct StrategyId_t strategy_id_clone(const struct StrategyId_t *strategy_id);
-
-/**
- * Frees the memory for the given `strategy_id` by dropping.
- */
-void strategy_id_drop(struct StrategyId_t strategy_id);
-
-/**
- * Returns a [`StrategyId`] as a C string pointer.
- */
-const char *strategy_id_to_cstr(const struct StrategyId_t *strategy_id);
+uint64_t strategy_id_hash(const struct StrategyId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct Symbol_t symbol_new(const char *ptr);
 
-struct Symbol_t symbol_clone(const struct Symbol_t *symbol);
-
-/**
- * Frees the memory for the given [Symbol] by dropping.
- */
-void symbol_drop(struct Symbol_t symbol);
-
-/**
- * Returns a [`Symbol`] as a C string pointer.
- */
-const char *symbol_to_cstr(const struct Symbol_t *symbol);
-
-uint8_t symbol_eq(const struct Symbol_t *lhs, const struct Symbol_t *rhs);
-
-uint64_t symbol_hash(const struct Symbol_t *symbol);
+uint64_t symbol_hash(const struct Symbol_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct TradeId_t trade_id_new(const char *ptr);
 
-struct TradeId_t trade_id_clone(const struct TradeId_t *trade_id);
-
-/**
- * Frees the memory for the given `trade_id` by dropping.
- */
-void trade_id_drop(struct TradeId_t trade_id);
-
-/**
- * Returns [`TradeId`] as a C string pointer.
- */
-const char *trade_id_to_cstr(const struct TradeId_t *trade_id);
-
-uint8_t trade_id_eq(const struct TradeId_t *lhs, const struct TradeId_t *rhs);
-
-uint64_t trade_id_hash(const struct TradeId_t *trade_id);
+uint64_t trade_id_hash(const struct TradeId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct TraderId_t trader_id_new(const char *ptr);
 
-struct TraderId_t trader_id_clone(const struct TraderId_t *trader_id);
-
-/**
- * Frees the memory for the given `trader_id` by dropping.
- */
-void trader_id_drop(struct TraderId_t trader_id);
-
-/**
- * Returns a [`TraderId`] as a C string pointer.
- */
-const char *trader_id_to_cstr(const struct TraderId_t *trader_id);
+uint64_t trader_id_hash(const struct TraderId_t *id);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct Venue_t venue_new(const char *ptr);
 
-struct Venue_t venue_clone(const struct Venue_t *venue);
+uint64_t venue_hash(const struct Venue_t *id);
 
-/**
- * Frees the memory for the given `venue` by dropping.
- */
-void venue_drop(struct Venue_t venue);
-
-/**
- * Returns a [`Venue`] identifier as a C string pointer.
- */
-const char *venue_to_cstr(const struct Venue_t *venue);
-
-uint8_t venue_eq(const struct Venue_t *lhs, const struct Venue_t *rhs);
-
-uint64_t venue_hash(const struct Venue_t *venue);
+uint8_t venue_is_synthetic(const struct Venue_t *venue);
 
 /**
  * Returns a Nautilus identifier from a C string pointer.
  *
  * # Safety
  *
  * - Assumes `ptr` is a valid C string pointer.
  */
 struct VenueOrderId_t venue_order_id_new(const char *ptr);
 
-struct VenueOrderId_t venue_order_id_clone(const struct VenueOrderId_t *venue_order_id);
-
-/**
- * Frees the memory for the given `venue_order_id` by dropping.
- */
-void venue_order_id_drop(struct VenueOrderId_t venue_order_id);
-
-const char *venue_order_id_to_cstr(const struct VenueOrderId_t *venue_order_id);
-
-uint8_t venue_order_id_eq(const struct VenueOrderId_t *lhs, const struct VenueOrderId_t *rhs);
-
-uint64_t venue_order_id_hash(const struct VenueOrderId_t *venue_order_id);
+uint64_t venue_order_id_hash(const struct VenueOrderId_t *id);
 
 /**
  * # Safety
  *
  * - Assumes `components_ptr` is a valid C string pointer of a JSON format list of strings.
  * - Assumes `formula_ptr` is a valid C string pointer.
  */
 struct SyntheticInstrument_API synthetic_instrument_new(struct Symbol_t symbol,
-                                                        uint8_t precision,
+                                                        uint8_t price_precision,
                                                         const char *components_ptr,
-                                                        const char *formula_ptr);
+                                                        const char *formula_ptr,
+                                                        uint64_t ts_event,
+                                                        uint64_t ts_init);
 
 void synthetic_instrument_drop(struct SyntheticInstrument_API synth);
 
 struct InstrumentId_t synthetic_instrument_id(const struct SyntheticInstrument_API *synth);
 
-uint8_t synthetic_instrument_precision(const struct SyntheticInstrument_API *synth);
+uint8_t synthetic_instrument_price_precision(const struct SyntheticInstrument_API *synth);
+
+struct Price_t synthetic_instrument_price_increment(const struct SyntheticInstrument_API *synth);
 
 const char *synthetic_instrument_formula_to_cstr(const struct SyntheticInstrument_API *synth);
 
 const char *synthetic_instrument_components_to_cstr(const struct SyntheticInstrument_API *synth);
 
+uintptr_t synthetic_instrument_components_count(const struct SyntheticInstrument_API *synth);
+
+uint64_t synthetic_instrument_ts_event(const struct SyntheticInstrument_API *synth);
+
+uint64_t synthetic_instrument_ts_init(const struct SyntheticInstrument_API *synth);
+
 /**
  * # Safety
  *
  * - Assumes `formula_ptr` is a valid C string pointer.
  */
 uint8_t synthetic_instrument_is_valid_formula(const struct SyntheticInstrument_API *synth,
                                               const char *formula_ptr);
@@ -1696,14 +1666,18 @@
 
 void orderbook_clear_bids(struct OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
 
 void orderbook_clear_asks(struct OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
 
 void orderbook_apply_delta(struct OrderBook_API *book, struct OrderBookDelta_t delta);
 
+CVec orderbook_bids(struct OrderBook_API *book);
+
+CVec orderbook_asks(struct OrderBook_API *book);
+
 uint8_t orderbook_has_bid(struct OrderBook_API *book);
 
 uint8_t orderbook_has_ask(struct OrderBook_API *book);
 
 struct Price_t orderbook_best_bid_price(struct OrderBook_API *book);
 
 struct Price_t orderbook_best_ask_price(struct OrderBook_API *book);
@@ -1712,14 +1686,18 @@
 
 struct Quantity_t orderbook_best_ask_size(struct OrderBook_API *book);
 
 double orderbook_spread(struct OrderBook_API *book);
 
 double orderbook_midpoint(struct OrderBook_API *book);
 
+double orderbook_get_avg_px_for_quantity(struct OrderBook_API *book,
+                                         struct Quantity_t qty,
+                                         enum OrderSide order_side);
+
 void orderbook_update_quote_tick(struct OrderBook_API *book, const struct QuoteTick_t *tick);
 
 void orderbook_update_trade_tick(struct OrderBook_API *book, const struct TradeTick_t *tick);
 
 CVec orderbook_simulate_fills(const struct OrderBook_API *book, struct BookOrder_t order);
 
 void orderbook_check_integrity(const struct OrderBook_API *book);
@@ -1727,40 +1705,52 @@
 void vec_fills_drop(CVec v);
 
 /**
  * Returns a pretty printed [`OrderBook`] number of levels per side, as a C string pointer.
  */
 const char *orderbook_pprint_to_cstr(const struct OrderBook_API *book, uintptr_t num_levels);
 
+struct Level_API level_new(enum OrderSide order_side, struct Price_t price, CVec orders);
+
+void level_drop(struct Level_API level);
+
+struct Level_API level_clone(const struct Level_API *level);
+
+struct Price_t level_price(const struct Level_API *level);
+
+CVec level_orders(const struct Level_API *level);
+
+double level_volume(const struct Level_API *level);
+
+double level_exposure(const struct Level_API *level);
+
+void vec_levels_drop(CVec v);
+
+void vec_orders_drop(CVec v);
+
 /**
  * Returns a [`Currency`] from pointers and primitives.
  *
  * # Safety
  *
  * - Assumes `code_ptr` is a valid C string pointer.
  * - Assumes `name_ptr` is a valid C string pointer.
  */
 struct Currency_t currency_from_py(const char *code_ptr,
                                    uint8_t precision,
                                    uint16_t iso4217,
                                    const char *name_ptr,
                                    enum CurrencyType currency_type);
 
-struct Currency_t currency_clone(const struct Currency_t *currency);
-
-void currency_drop(struct Currency_t currency);
-
 const char *currency_to_cstr(const struct Currency_t *currency);
 
 const char *currency_code_to_cstr(const struct Currency_t *currency);
 
 const char *currency_name_to_cstr(const struct Currency_t *currency);
 
-uint8_t currency_eq(const struct Currency_t *lhs, const struct Currency_t *rhs);
-
 uint64_t currency_hash(const struct Currency_t *currency);
 
 void currency_register(struct Currency_t currency);
 
 /**
  * # Safety
  *
@@ -1775,16 +1765,14 @@
  */
 struct Currency_t currency_from_cstr(const char *code_ptr);
 
 struct Money_t money_new(double amount, struct Currency_t currency);
 
 struct Money_t money_from_raw(int64_t raw, struct Currency_t currency);
 
-void money_drop(struct Money_t money);
-
 double money_as_f64(const struct Money_t *money);
 
 void money_add_assign(struct Money_t a, struct Money_t b);
 
 void money_sub_assign(struct Money_t a, struct Money_t b);
 
 struct Price_t price_new(double value, uint8_t precision);
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/inspect.py` & `nautilus_trader-1.176.0/nautilus_trader/core/inspect.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/message.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/message.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/message.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/message.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/examples/algorithms/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/algorithms.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/algorithms.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/backtest.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/backtest.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/common.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/common.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/common.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/common.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/core.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/core.pxd`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,13 @@
 # Warning, this file is autogenerated by cbindgen. Don't modify this manually. */
 
 from libc.stdint cimport uint8_t, uint64_t, uintptr_t
 
 cdef extern from "../includes/core.h":
 
-    cdef struct Arc_String:
-        pass
-
     # `CVec` is a C compatible struct that stores an opaque pointer to a block of
     # memory, it's length and the capacity of the vector it was allocated from.
     #
     # NOTE: Changing the values here may lead to undefined behaviour when the
     # memory is dropped.
     cdef struct CVec:
         # Opaque pointer to block of memory storing elements to access the
@@ -19,15 +16,15 @@
         # The number of elements in the block.
         uintptr_t len;
         # The capacity of vector from which it was allocated.
         # Used when deallocating the memory
         uintptr_t cap;
 
     cdef struct UUID4_t:
-        Arc_String *value;
+        uint8_t value[37];
 
     void cvec_drop(CVec cvec);
 
     CVec cvec_new();
 
     # Converts seconds to nanoseconds (ns).
     uint64_t secs_to_nanos(double secs);
@@ -82,18 +79,14 @@
     uint64_t unix_timestamp_us();
 
     # Returns the current nanoseconds since the UNIX epoch.
     uint64_t unix_timestamp_ns();
 
     UUID4_t uuid4_new();
 
-    UUID4_t uuid4_clone(const UUID4_t *uuid4);
-
-    void uuid4_drop(UUID4_t uuid4);
-
     # Returns a [`UUID4`] from C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     #
     # # Panics
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/model.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/model.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -327,104 +327,148 @@
         # Based on the mid-point of the [`TriggerType::BidAsk`].
         MID_POINT # = 7,
         # Based on the mark price for the instrument.
         MARK_PRICE # = 8,
         # Based on the index price for the instrument.
         INDEX_PRICE # = 9,
 
-    cdef struct Arc_String:
+    cdef struct Level:
         pass
 
     cdef struct OrderBook:
         pass
 
     cdef struct String:
         pass
 
     # Represents a synthetic instrument with prices derived from component instruments using a
     # formula.
     cdef struct SyntheticInstrument:
         pass
 
-    cdef struct BarSpecification_t:
-        uint64_t step;
-        uint8_t aggregation;
-        PriceType price_type;
-
     cdef struct Symbol_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct Venue_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct InstrumentId_t:
         Symbol_t symbol;
         Venue_t venue;
 
-    cdef struct BarType_t:
-        InstrumentId_t instrument_id;
-        BarSpecification_t spec;
-        AggregationSource aggregation_source;
-
     cdef struct Price_t:
         int64_t raw;
         uint8_t precision;
 
     cdef struct Quantity_t:
         uint64_t raw;
         uint8_t precision;
 
-    cdef struct Bar_t:
-        BarType_t bar_type;
-        Price_t open;
-        Price_t high;
-        Price_t low;
-        Price_t close;
-        Quantity_t volume;
-        uint64_t ts_event;
-        uint64_t ts_init;
-
     # Represents an order in a book.
     cdef struct BookOrder_t:
+        # The order side.
         OrderSide side;
+        # The order price.
         Price_t price;
+        # The order size.
         Quantity_t size;
+        # The order ID.
         uint64_t order_id;
 
     # Represents a single change/delta in an order book.
     cdef struct OrderBookDelta_t:
+        # The instrument ID for the book.
         InstrumentId_t instrument_id;
+        # The order book delta action.
         BookAction action;
+        # The order to apply.
         BookOrder_t order;
+        # A combination of packet end with matching engine status.
         uint8_t flags;
+        # The message sequence number assigned at the venue.
         uint64_t sequence;
+        # The UNIX timestamp (nanoseconds) when the data event occurred.
         uint64_t ts_event;
+        # The UNIX timestamp (nanoseconds) when the data object was initialized.
         uint64_t ts_init;
 
     # Represents a single quote tick in a financial market.
     cdef struct QuoteTick_t:
+        # The quotes instrument ID.
         InstrumentId_t instrument_id;
+        # The top of book bid price.
         Price_t bid;
+        # The top of book ask price.
         Price_t ask;
+        # The top of book bid size.
         Quantity_t bid_size;
+        # The top of book ask size.
         Quantity_t ask_size;
+        # The UNIX timestamp (nanoseconds) when the tick event occurred.
         uint64_t ts_event;
+        # The UNIX timestamp (nanoseconds) when the data object was initialized.
         uint64_t ts_init;
 
     cdef struct TradeId_t:
-        Arc_String *value;
+        char* value;
 
     # Represents a single trade tick in a financial market.
     cdef struct TradeTick_t:
+        # The trade instrument ID.
         InstrumentId_t instrument_id;
+        # The traded price.
         Price_t price;
+        # The traded size.
         Quantity_t size;
+        # The trade aggressor side.
         AggressorSide aggressor_side;
+        # The trade match ID (assigned by the venue).
         TradeId_t trade_id;
+        # The UNIX timestamp (nanoseconds) when the tick event occurred.
+        uint64_t ts_event;
+        #  The UNIX timestamp (nanoseconds) when the data object was initialized.
+        uint64_t ts_init;
+
+    # Represents a bar aggregation specification including a step, aggregation
+    # method/rule and price type.
+    cdef struct BarSpecification_t:
+        # The step for binning samples for bar aggregation.
+        uint64_t step;
+        # The type of bar aggregation.
+        uint8_t aggregation;
+        # The price type to use for aggregation.
+        PriceType price_type;
+
+    # Represents a bar type including the instrument ID, bar specification and
+    # aggregation source.
+    cdef struct BarType_t:
+        # The bar types instrument ID.
+        InstrumentId_t instrument_id;
+        # The bar types specification.
+        BarSpecification_t spec;
+        # The bar types aggregation source.
+        AggregationSource aggregation_source;
+
+    # Represents an aggregated bar.
+    cdef struct Bar_t:
+        # The bar type for this bar.
+        BarType_t bar_type;
+        # The bars open price.
+        Price_t open;
+        # The bars high price.
+        Price_t high;
+        # The bars low price.
+        Price_t low;
+        # The bars close price.
+        Price_t close;
+        # The bars volume.
+        Quantity_t volume;
+        # The UNIX timestamp (nanoseconds) when the data event occurred.
         uint64_t ts_event;
+        # The UNIX timestamp (nanoseconds) when the data object was initialized.
         uint64_t ts_init;
 
     cpdef enum Data_t_Tag:
         DELTA,
         QUOTE,
         TRADE,
         BAR,
@@ -433,52 +477,52 @@
         Data_t_Tag tag;
         OrderBookDelta_t delta;
         QuoteTick_t quote;
         TradeTick_t trade;
         Bar_t bar;
 
     cdef struct TraderId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct StrategyId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct ClientOrderId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct OrderDenied_t:
         TraderId_t trader_id;
         StrategyId_t strategy_id;
         InstrumentId_t instrument_id;
         ClientOrderId_t client_order_id;
         String *reason;
         UUID4_t event_id;
         uint64_t ts_event;
         uint64_t ts_init;
 
     cdef struct AccountId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct ClientId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct ComponentId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct ExecAlgorithmId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct OrderListId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct PositionId_t:
-        Arc_String *value;
+        char* value;
 
     cdef struct VenueOrderId_t:
-        Arc_String *value;
+        char* value;
 
     # Provides a C compatible Foreign Function Interface (FFI) for an underlying
     # [`SyntheticInstrument`].
     #
     # This struct wraps `SyntheticInstrument` in a way that makes it compatible with C function
     # calls, enabling interaction with `SyntheticInstrument` in a C environment.
     #
@@ -495,25 +539,43 @@
     #
     # It implements the `Deref` trait, allowing instances of `OrderBook_API` to be
     # dereferenced to `OrderBook`, providing access to `OrderBook`'s methods without
     # having to manually access the underlying `OrderBook` instance.
     cdef struct OrderBook_API:
         OrderBook *_0;
 
+    # Provides a C compatible Foreign Function Interface (FFI) for an underlying order book[`Level`].
+    #
+    # This struct wraps `Level` in a way that makes it compatible with C function
+    # calls, enabling interaction with `Level` in a C environment.
+    #
+    # It implements the `Deref` trait, allowing instances of `Level_API` to be
+    # dereferenced to `Level`, providing access to `Level`'s methods without
+    # having to manually acce wss the underlying `Level` instance.
+    cdef struct Level_API:
+        Level *_0;
+
     cdef struct Currency_t:
-        Arc_String *code;
+        char* code;
         uint8_t precision;
         uint16_t iso4217;
-        Arc_String *name;
+        char* name;
         CurrencyType currency_type;
 
     cdef struct Money_t:
         int64_t raw;
         Currency_t currency;
 
+    const BookOrder_t NULL_ORDER # = <BookOrder_t>{ OrderSide_NoOrderSide, <Price_t>{ 0, 0 }, <Quantity_t>{ 0, 0 }, 0 }
+
+    # Sentinel Price for errors.
+    const Price_t ERROR_PRICE # = <Price_t>{ INT64_MAX, 0 }
+
+    Data_t data_clone(const Data_t *data);
+
     BarSpecification_t bar_specification_new(uint64_t step,
                                              uint8_t aggregation,
                                              uint8_t price_type);
 
     # Returns a [`BarSpecification`] as a C string pointer.
     const char *bar_specification_to_cstr(const BarSpecification_t *bar_spec);
 
@@ -529,18 +591,14 @@
 
     uint8_t bar_specification_ge(const BarSpecification_t *lhs, const BarSpecification_t *rhs);
 
     BarType_t bar_type_new(InstrumentId_t instrument_id,
                            BarSpecification_t spec,
                            uint8_t aggregation_source);
 
-    void bar_type_drop(BarType_t bar_type);
-
-    BarType_t bar_type_clone(const BarType_t *bar_type);
-
     uint8_t bar_type_eq(const BarType_t *lhs, const BarType_t *rhs);
 
     uint8_t bar_type_lt(const BarType_t *lhs, const BarType_t *rhs);
 
     uint8_t bar_type_le(const BarType_t *lhs, const BarType_t *rhs);
 
     uint8_t bar_type_gt(const BarType_t *lhs, const BarType_t *rhs);
@@ -568,24 +626,32 @@
                            int64_t close,
                            uint8_t price_prec,
                            uint64_t volume,
                            uint8_t size_prec,
                            uint64_t ts_event,
                            uint64_t ts_init);
 
-    void bar_drop(Bar_t bar);
+    uint8_t bar_eq(const Bar_t *lhs, const Bar_t *rhs);
 
-    Bar_t bar_clone(const Bar_t *bar);
+    uint64_t bar_hash(const Bar_t *bar);
 
     # Returns a [`Bar`] as a C string.
     const char *bar_to_cstr(const Bar_t *bar);
 
-    uint8_t bar_eq(const Bar_t *lhs, const Bar_t *rhs);
+    OrderBookDelta_t orderbook_delta_new(InstrumentId_t instrument_id,
+                                         BookAction action,
+                                         BookOrder_t order,
+                                         uint8_t flags,
+                                         uint64_t sequence,
+                                         uint64_t ts_event,
+                                         uint64_t ts_init);
 
-    uint64_t bar_hash(const Bar_t *bar);
+    uint8_t orderbook_delta_eq(const OrderBookDelta_t *lhs, const OrderBookDelta_t *rhs);
+
+    uint64_t orderbook_delta_hash(const OrderBookDelta_t *delta);
 
     BookOrder_t book_order_from_raw(OrderSide order_side,
                                     int64_t price_raw,
                                     uint8_t price_prec,
                                     uint64_t size_raw,
                                     uint8_t size_prec,
                                     uint64_t order_id);
@@ -600,70 +666,50 @@
 
     # Returns a [`BookOrder`] display string as a C string pointer.
     const char *book_order_display_to_cstr(const BookOrder_t *order);
 
     # Returns a [`BookOrder`] debug string as a C string pointer.
     const char *book_order_debug_to_cstr(const BookOrder_t *order);
 
-    void orderbook_delta_drop(OrderBookDelta_t delta);
-
-    OrderBookDelta_t orderbook_delta_clone(const OrderBookDelta_t *delta);
-
-    OrderBookDelta_t orderbook_delta_new(InstrumentId_t instrument_id,
-                                         BookAction action,
-                                         BookOrder_t order,
-                                         uint8_t flags,
-                                         uint64_t sequence,
-                                         uint64_t ts_event,
-                                         uint64_t ts_init);
-
-    uint8_t orderbook_delta_eq(const OrderBookDelta_t *lhs, const OrderBookDelta_t *rhs);
-
-    uint64_t orderbook_delta_hash(const OrderBookDelta_t *delta);
-
     QuoteTick_t quote_tick_new(InstrumentId_t instrument_id,
                                int64_t bid_price_raw,
                                int64_t ask_price_raw,
                                uint8_t bid_price_prec,
                                uint8_t ask_price_prec,
                                uint64_t bid_size_raw,
                                uint64_t ask_size_raw,
                                uint8_t bid_size_prec,
                                uint8_t ask_size_prec,
                                uint64_t ts_event,
                                uint64_t ts_init);
 
-    void quote_tick_drop(QuoteTick_t tick);
+    uint8_t quote_tick_eq(const QuoteTick_t *lhs, const QuoteTick_t *rhs);
 
-    QuoteTick_t quote_tick_clone(const QuoteTick_t *tick);
+    uint64_t quote_tick_hash(const QuoteTick_t *delta);
 
     # Returns a [`QuoteTick`] as a C string pointer.
     const char *quote_tick_to_cstr(const QuoteTick_t *tick);
 
     TradeTick_t trade_tick_new(InstrumentId_t instrument_id,
                                int64_t price_raw,
                                uint8_t price_prec,
                                uint64_t size_raw,
                                uint8_t size_prec,
                                AggressorSide aggressor_side,
                                TradeId_t trade_id,
                                uint64_t ts_event,
                                uint64_t ts_init);
 
-    void trade_tick_drop(TradeTick_t tick);
+    uint8_t trade_tick_eq(const TradeTick_t *lhs, const TradeTick_t *rhs);
 
-    TradeTick_t trade_tick_clone(const TradeTick_t *tick);
+    uint64_t trade_tick_hash(const TradeTick_t *delta);
 
     # Returns a [`TradeTick`] as a C string pointer.
     const char *trade_tick_to_cstr(const TradeTick_t *tick);
 
-    void data_drop(Data_t data);
-
-    Data_t data_clone(const Data_t *data);
-
     const char *account_type_to_cstr(AccountType value);
 
     # Returns an enum from a Python string.
     #
     # # Safety
     # - Assumes `ptr` is a valid C string pointer.
     AccountType account_type_from_cstr(const char *ptr);
@@ -867,292 +913,180 @@
     # Frees the memory for the given `event` by dropping.
     void order_denied_drop(OrderDenied_t event);
 
     OrderDenied_t order_denied_clone(const OrderDenied_t *event);
 
     const char *order_denied_reason_to_cstr(const OrderDenied_t *event);
 
+    void interned_string_stats();
+
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     AccountId_t account_id_new(const char *ptr);
 
-    AccountId_t account_id_clone(const AccountId_t *account_id);
-
-    # Frees the memory for the given `account_id` by dropping.
-    void account_id_drop(AccountId_t account_id);
-
-    # Returns an [`AccountId`] as a C string pointer.
-    const char *account_id_to_cstr(const AccountId_t *account_id);
-
-    uint8_t account_id_eq(const AccountId_t *lhs, const AccountId_t *rhs);
-
-    uint64_t account_id_hash(const AccountId_t *account_id);
+    uint64_t account_id_hash(const AccountId_t *id);
 
     # Returns a Nautilus identifier from C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     ClientId_t client_id_new(const char *ptr);
 
-    ClientId_t client_id_clone(const ClientId_t *client_id);
-
-    # Frees the memory for the given `client_id` by dropping.
-    void client_id_drop(ClientId_t client_id);
-
-    # Returns a [`ClientId`] identifier as a C string pointer.
-    const char *client_id_to_cstr(const ClientId_t *client_id);
-
-    uint8_t client_id_eq(const ClientId_t *lhs, const ClientId_t *rhs);
-
-    uint64_t client_id_hash(const ClientId_t *client_id);
+    uint64_t client_id_hash(const ClientId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     ClientOrderId_t client_order_id_new(const char *ptr);
 
-    ClientOrderId_t client_order_id_clone(const ClientOrderId_t *client_order_id);
-
-    # Frees the memory for the given `client_order_id` by dropping.
-    void client_order_id_drop(ClientOrderId_t client_order_id);
-
-    # Returns a [`ClientOrderId`] as a C string pointer.
-    const char *client_order_id_to_cstr(const ClientOrderId_t *client_order_id);
-
-    uint8_t client_order_id_eq(const ClientOrderId_t *lhs, const ClientOrderId_t *rhs);
-
-    uint64_t client_order_id_hash(const ClientOrderId_t *client_order_id);
+    uint64_t client_order_id_hash(const ClientOrderId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     ComponentId_t component_id_new(const char *ptr);
 
-    ComponentId_t component_id_clone(const ComponentId_t *component_id);
-
-    # Frees the memory for the given `component_id` by dropping.
-    void component_id_drop(ComponentId_t component_id);
-
-    # Returns a [`ComponentId`] identifier as a C string pointer.
-    const char *component_id_to_cstr(const ComponentId_t *component_id);
-
-    uint8_t component_id_eq(const ComponentId_t *lhs, const ComponentId_t *rhs);
-
-    uint64_t component_id_hash(const ComponentId_t *component_id);
+    uint64_t component_id_hash(const ComponentId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     ExecAlgorithmId_t exec_algorithm_id_new(const char *ptr);
 
-    ExecAlgorithmId_t exec_algorithm_id_clone(const ExecAlgorithmId_t *exec_algorithm_id);
-
-    # Frees the memory for the given `exec_algorithm_id` by dropping.
-    void exec_algorithm_id_drop(ExecAlgorithmId_t exec_algorithm_id);
-
-    # Returns an [`ExecAlgorithmId`] identifier as a C string pointer.
-    const char *exec_algorithm_id_to_cstr(const ExecAlgorithmId_t *exec_algorithm_id);
-
-    uint8_t exec_algorithm_id_eq(const ExecAlgorithmId_t *lhs, const ExecAlgorithmId_t *rhs);
+    uint64_t exec_algorithm_id_hash(const ExecAlgorithmId_t *id);
 
-    uint64_t exec_algorithm_id_hash(const ExecAlgorithmId_t *exec_algorithm_id);
-
-    InstrumentId_t instrument_id_new(const Symbol_t *symbol, const Venue_t *venue);
+    InstrumentId_t instrument_id_new(Symbol_t symbol, Venue_t venue);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     InstrumentId_t instrument_id_new_from_cstr(const char *ptr);
 
-    InstrumentId_t instrument_id_clone(const InstrumentId_t *instrument_id);
-
-    # Frees the memory for the given `instrument_id` by dropping.
-    void instrument_id_drop(InstrumentId_t instrument_id);
-
     # Returns an [`InstrumentId`] as a C string pointer.
     const char *instrument_id_to_cstr(const InstrumentId_t *instrument_id);
 
-    uint8_t instrument_id_eq(const InstrumentId_t *lhs, const InstrumentId_t *rhs);
-
     uint64_t instrument_id_hash(const InstrumentId_t *instrument_id);
 
+    uint8_t instrument_id_is_synthetic(const InstrumentId_t *instrument_id);
+
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     OrderListId_t order_list_id_new(const char *ptr);
 
-    OrderListId_t order_list_id_clone(const OrderListId_t *order_list_id);
-
-    # Frees the memory for the given `order_list_id` by dropping.
-    void order_list_id_drop(OrderListId_t order_list_id);
-
-    # Returns an [`OrderListId`] as a C string pointer.
-    const char *order_list_id_to_cstr(const OrderListId_t *order_list_id);
-
-    uint8_t order_list_id_eq(const OrderListId_t *lhs, const OrderListId_t *rhs);
-
-    uint64_t order_list_id_hash(const OrderListId_t *order_list_id);
+    uint64_t order_list_id_hash(const OrderListId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     PositionId_t position_id_new(const char *ptr);
 
-    PositionId_t position_id_clone(const PositionId_t *position_id);
-
-    # Frees the memory for the given `position_id` by dropping.
-    void position_id_drop(PositionId_t position_id);
-
-    # Returns a [`PositionId`] identifier as a C string pointer.
-    const char *position_id_to_cstr(const PositionId_t *position_id);
-
-    uint8_t position_id_eq(const PositionId_t *lhs, const PositionId_t *rhs);
-
-    uint64_t position_id_hash(const PositionId_t *position_id);
+    uint64_t position_id_hash(const PositionId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     StrategyId_t strategy_id_new(const char *ptr);
 
-    StrategyId_t strategy_id_clone(const StrategyId_t *strategy_id);
-
-    # Frees the memory for the given `strategy_id` by dropping.
-    void strategy_id_drop(StrategyId_t strategy_id);
-
-    # Returns a [`StrategyId`] as a C string pointer.
-    const char *strategy_id_to_cstr(const StrategyId_t *strategy_id);
+    uint64_t strategy_id_hash(const StrategyId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     Symbol_t symbol_new(const char *ptr);
 
-    Symbol_t symbol_clone(const Symbol_t *symbol);
-
-    # Frees the memory for the given [Symbol] by dropping.
-    void symbol_drop(Symbol_t symbol);
-
-    # Returns a [`Symbol`] as a C string pointer.
-    const char *symbol_to_cstr(const Symbol_t *symbol);
-
-    uint8_t symbol_eq(const Symbol_t *lhs, const Symbol_t *rhs);
-
-    uint64_t symbol_hash(const Symbol_t *symbol);
+    uint64_t symbol_hash(const Symbol_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     TradeId_t trade_id_new(const char *ptr);
 
-    TradeId_t trade_id_clone(const TradeId_t *trade_id);
-
-    # Frees the memory for the given `trade_id` by dropping.
-    void trade_id_drop(TradeId_t trade_id);
-
-    # Returns [`TradeId`] as a C string pointer.
-    const char *trade_id_to_cstr(const TradeId_t *trade_id);
-
-    uint8_t trade_id_eq(const TradeId_t *lhs, const TradeId_t *rhs);
-
-    uint64_t trade_id_hash(const TradeId_t *trade_id);
+    uint64_t trade_id_hash(const TradeId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     TraderId_t trader_id_new(const char *ptr);
 
-    TraderId_t trader_id_clone(const TraderId_t *trader_id);
-
-    # Frees the memory for the given `trader_id` by dropping.
-    void trader_id_drop(TraderId_t trader_id);
-
-    # Returns a [`TraderId`] as a C string pointer.
-    const char *trader_id_to_cstr(const TraderId_t *trader_id);
+    uint64_t trader_id_hash(const TraderId_t *id);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     Venue_t venue_new(const char *ptr);
 
-    Venue_t venue_clone(const Venue_t *venue);
-
-    # Frees the memory for the given `venue` by dropping.
-    void venue_drop(Venue_t venue);
-
-    # Returns a [`Venue`] identifier as a C string pointer.
-    const char *venue_to_cstr(const Venue_t *venue);
+    uint64_t venue_hash(const Venue_t *id);
 
-    uint8_t venue_eq(const Venue_t *lhs, const Venue_t *rhs);
-
-    uint64_t venue_hash(const Venue_t *venue);
+    uint8_t venue_is_synthetic(const Venue_t *venue);
 
     # Returns a Nautilus identifier from a C string pointer.
     #
     # # Safety
     #
     # - Assumes `ptr` is a valid C string pointer.
     VenueOrderId_t venue_order_id_new(const char *ptr);
 
-    VenueOrderId_t venue_order_id_clone(const VenueOrderId_t *venue_order_id);
-
-    # Frees the memory for the given `venue_order_id` by dropping.
-    void venue_order_id_drop(VenueOrderId_t venue_order_id);
-
-    const char *venue_order_id_to_cstr(const VenueOrderId_t *venue_order_id);
-
-    uint8_t venue_order_id_eq(const VenueOrderId_t *lhs, const VenueOrderId_t *rhs);
-
-    uint64_t venue_order_id_hash(const VenueOrderId_t *venue_order_id);
+    uint64_t venue_order_id_hash(const VenueOrderId_t *id);
 
     # # Safety
     #
     # - Assumes `components_ptr` is a valid C string pointer of a JSON format list of strings.
     # - Assumes `formula_ptr` is a valid C string pointer.
     SyntheticInstrument_API synthetic_instrument_new(Symbol_t symbol,
-                                                     uint8_t precision,
+                                                     uint8_t price_precision,
                                                      const char *components_ptr,
-                                                     const char *formula_ptr);
+                                                     const char *formula_ptr,
+                                                     uint64_t ts_event,
+                                                     uint64_t ts_init);
 
     void synthetic_instrument_drop(SyntheticInstrument_API synth);
 
     InstrumentId_t synthetic_instrument_id(const SyntheticInstrument_API *synth);
 
-    uint8_t synthetic_instrument_precision(const SyntheticInstrument_API *synth);
+    uint8_t synthetic_instrument_price_precision(const SyntheticInstrument_API *synth);
+
+    Price_t synthetic_instrument_price_increment(const SyntheticInstrument_API *synth);
 
     const char *synthetic_instrument_formula_to_cstr(const SyntheticInstrument_API *synth);
 
     const char *synthetic_instrument_components_to_cstr(const SyntheticInstrument_API *synth);
 
+    uintptr_t synthetic_instrument_components_count(const SyntheticInstrument_API *synth);
+
+    uint64_t synthetic_instrument_ts_event(const SyntheticInstrument_API *synth);
+
+    uint64_t synthetic_instrument_ts_init(const SyntheticInstrument_API *synth);
+
     # # Safety
     #
     # - Assumes `formula_ptr` is a valid C string pointer.
     uint8_t synthetic_instrument_is_valid_formula(const SyntheticInstrument_API *synth,
                                                   const char *formula_ptr);
 
     # # Safety
@@ -1198,14 +1132,18 @@
 
     void orderbook_clear_bids(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
 
     void orderbook_clear_asks(OrderBook_API *book, uint64_t ts_event, uint64_t sequence);
 
     void orderbook_apply_delta(OrderBook_API *book, OrderBookDelta_t delta);
 
+    CVec orderbook_bids(OrderBook_API *book);
+
+    CVec orderbook_asks(OrderBook_API *book);
+
     uint8_t orderbook_has_bid(OrderBook_API *book);
 
     uint8_t orderbook_has_ask(OrderBook_API *book);
 
     Price_t orderbook_best_bid_price(OrderBook_API *book);
 
     Price_t orderbook_best_ask_price(OrderBook_API *book);
@@ -1214,51 +1152,67 @@
 
     Quantity_t orderbook_best_ask_size(OrderBook_API *book);
 
     double orderbook_spread(OrderBook_API *book);
 
     double orderbook_midpoint(OrderBook_API *book);
 
+    double orderbook_get_avg_px_for_quantity(OrderBook_API *book,
+                                             Quantity_t qty,
+                                             OrderSide order_side);
+
     void orderbook_update_quote_tick(OrderBook_API *book, const QuoteTick_t *tick);
 
     void orderbook_update_trade_tick(OrderBook_API *book, const TradeTick_t *tick);
 
     CVec orderbook_simulate_fills(const OrderBook_API *book, BookOrder_t order);
 
     void orderbook_check_integrity(const OrderBook_API *book);
 
     void vec_fills_drop(CVec v);
 
     # Returns a pretty printed [`OrderBook`] number of levels per side, as a C string pointer.
     const char *orderbook_pprint_to_cstr(const OrderBook_API *book, uintptr_t num_levels);
 
+    Level_API level_new(OrderSide order_side, Price_t price, CVec orders);
+
+    void level_drop(Level_API level);
+
+    Level_API level_clone(const Level_API *level);
+
+    Price_t level_price(const Level_API *level);
+
+    CVec level_orders(const Level_API *level);
+
+    double level_volume(const Level_API *level);
+
+    double level_exposure(const Level_API *level);
+
+    void vec_levels_drop(CVec v);
+
+    void vec_orders_drop(CVec v);
+
     # Returns a [`Currency`] from pointers and primitives.
     #
     # # Safety
     #
     # - Assumes `code_ptr` is a valid C string pointer.
     # - Assumes `name_ptr` is a valid C string pointer.
     Currency_t currency_from_py(const char *code_ptr,
                                 uint8_t precision,
                                 uint16_t iso4217,
                                 const char *name_ptr,
                                 CurrencyType currency_type);
 
-    Currency_t currency_clone(const Currency_t *currency);
-
-    void currency_drop(Currency_t currency);
-
     const char *currency_to_cstr(const Currency_t *currency);
 
     const char *currency_code_to_cstr(const Currency_t *currency);
 
     const char *currency_name_to_cstr(const Currency_t *currency);
 
-    uint8_t currency_eq(const Currency_t *lhs, const Currency_t *rhs);
-
     uint64_t currency_hash(const Currency_t *currency);
 
     void currency_register(Currency_t currency);
 
     # # Safety
     #
     # - Assumes `code_ptr` is borrowed from a valid Python UTF-8 `str`.
@@ -1269,16 +1223,14 @@
     # - Assumes `code_ptr` is borrowed from a valid Python UTF-8 `str`.
     Currency_t currency_from_cstr(const char *code_ptr);
 
     Money_t money_new(double amount, Currency_t currency);
 
     Money_t money_from_raw(int64_t raw, Currency_t currency);
 
-    void money_drop(Money_t money);
-
     double money_as_f64(const Money_t *money);
 
     void money_add_assign(Money_t a, Money_t b);
 
     void money_sub_assign(Money_t a, Money_t b);
 
     Price_t price_new(double value, uint8_t precision);
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/rust/model.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/rust/model.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/stats.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/stats.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/stats.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/stats.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/string.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/string.pxd`

 * *Files 4% similar despite different names*

```diff
@@ -53,23 +53,29 @@
     # size). It must not be deallocated. If string is a Unicode
     # object, this function computes the default encoding of string
     # and operates on that. If string is not a string object at all,
     # PyBytes_AsString() returns NULL and raises TypeError.
     char* PyBytes_AsString(object string) except NULL
 
 
-cdef inline str cstr_to_pystr(const char* ptr):
+cdef inline str cstr_to_pystr(const char* ptr, bint drop = True):
     cdef str obj = PyUnicode_FromString(ptr)
 
     # Assumes `ptr` was created from Rust `CString::from_raw`,
     # otherwise will lead to undefined behaviour when passed to `cstr_drop`.
-    cstr_drop(ptr)
+    if drop:
+        cstr_drop(ptr)
     return obj
 
 
+# Convert a Rust interned string to a Python string
+cdef inline str ustr_to_pystr(const char* ptr):
+    return PyUnicode_FromString(ptr)
+
+
 cdef inline bytes cstr_to_pybytes(const char* ptr):
     cdef bytes obj = PyBytes_FromString(ptr)
 
     # Assumes `ptr` was created from Rust `CString::from_raw`,
     # otherwise will lead to undefined behaviour when passed to `cstr_drop`.
     cstr_drop(ptr)
     return obj
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/uuid.pxd` & `nautilus_trader-1.176.0/nautilus_trader/core/uuid.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/core/uuid.pyx` & `nautilus_trader-1.176.0/nautilus_trader/core/uuid.pyx`

 * *Files 8% similar despite different names*

```diff
@@ -10,16 +10,14 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.core.rust.core cimport UUID4_t
-from nautilus_trader.core.rust.core cimport uuid4_clone
-from nautilus_trader.core.rust.core cimport uuid4_drop
 from nautilus_trader.core.rust.core cimport uuid4_eq
 from nautilus_trader.core.rust.core cimport uuid4_from_cstr
 from nautilus_trader.core.rust.core cimport uuid4_hash
 from nautilus_trader.core.rust.core cimport uuid4_new
 from nautilus_trader.core.rust.core cimport uuid4_to_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
@@ -48,18 +46,14 @@
         if value is None:
             # Create a new UUID4 from Rust
             self._mem = uuid4_new()  # `UUID4_t` owned from Rust
         else:
             # `value` borrowed by Rust, `UUID4_t` owned from Rust
             self._mem = uuid4_from_cstr(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            uuid4_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = uuid4_from_cstr(pystr_to_cstr(state))
 
     def __eq__(self, UUID4 other) -> bool:
@@ -71,18 +65,18 @@
     def __str__(self) -> str:
         return self.to_str()
 
     def __repr__(self) -> str:
         return f"{type(self).__name__}('{self}')"
 
     cdef str to_str(self):
-        return cstr_to_pystr(uuid4_to_cstr(&self._mem))
+        return cstr_to_pystr(uuid4_to_cstr(&self._mem), False)
 
     @property
     def value(self) -> str:
         return self.to_str()
 
     @staticmethod
     cdef UUID4 from_mem_c(UUID4_t mem):
         cdef UUID4 uuid4 = UUID4.__new__(UUID4)
-        uuid4._mem = uuid4_clone(&mem)
+        uuid4._mem = mem
         return uuid4
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/data/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,19 +8,20 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `data` subpackage groups components relating to the data stack and data tooling for the platform.
+The `data` subpackage groups components relating to the data stack and data tooling for
+the platform.
 
 The layered architecture of the data stack somewhat mirrors the
 execution stack with a central engine, cache layer beneath, database layer
 beneath, with alternative implementations able to be written on top.
 
 Due to the high-performance, the core components are reusable between both
 backtest and live implementations - helping to ensure consistent logic for
 trading operations.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pxd` & `nautilus_trader-1.176.0/nautilus_trader/data/aggregation.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pyx` & `nautilus_trader-1.176.0/nautilus_trader/data/aggregation.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/client.pxd` & `nautilus_trader-1.176.0/nautilus_trader/data/client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/client.pyx` & `nautilus_trader-1.176.0/nautilus_trader/data/client.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/engine.pxd` & `nautilus_trader-1.176.0/nautilus_trader/data/engine.pxd`

 * *Files 14% similar despite different names*

```diff
@@ -35,26 +35,33 @@
 from nautilus_trader.model.data.ticker cimport Ticker
 from nautilus_trader.model.data.venue cimport InstrumentClose
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
 
 
 cdef class DataEngine(Component):
     cdef readonly Cache _cache
     cdef readonly DataClient _default_client
     cdef readonly object _catalog
     cdef readonly bint _use_rust
 
     cdef readonly dict _clients
     cdef readonly dict _routing_map
     cdef readonly dict _order_book_intervals
     cdef readonly dict _bar_aggregators
+    cdef readonly dict _synthetic_quote_feeds
+    cdef readonly dict _synthetic_trade_feeds
+    cdef readonly list _subscribed_synthetic_quotes
+    cdef readonly list _subscribed_synthetic_trades
     cdef readonly bint _time_bars_build_with_no_updates
     cdef readonly bint _time_bars_timestamp_on_close
     cdef readonly bint _validate_data_sequence
 
     cdef readonly bint debug
     """If debug mode is active (will provide extra debug logging).\n\n:returns: `bool`"""
     cdef readonly int command_count
@@ -89,14 +96,16 @@
     cpdef list subscribed_order_book_snapshots(self)
     cpdef list subscribed_tickers(self)
     cpdef list subscribed_quote_ticks(self)
     cpdef list subscribed_trade_ticks(self)
     cpdef list subscribed_bars(self)
     cpdef list subscribed_instrument_status_updates(self)
     cpdef list subscribed_instrument_close(self)
+    cpdef list subscribed_synthetic_quotes(self)
+    cpdef list subscribed_synthetic_trades(self)
 
 # -- COMMANDS -------------------------------------------------------------------------------------
 
     cpdef void execute(self, DataCommand command)
     cpdef void process(self, Data data)
     cpdef void request(self, DataRequest request)
     cpdef void response(self, DataResponse response)
@@ -108,15 +117,17 @@
     cpdef void _handle_unsubscribe(self, DataClient client, Unsubscribe command)
     cpdef void _handle_subscribe_instrument(self, MarketDataClient client, InstrumentId instrument_id)
     cpdef void _handle_subscribe_order_book_deltas(self, MarketDataClient client, InstrumentId instrument_id, dict metadata)  # noqa
     cpdef void _handle_subscribe_order_book_snapshots(self, MarketDataClient client, InstrumentId instrument_id, dict metadata)  # noqa
     cpdef void _setup_order_book(self, MarketDataClient client, InstrumentId instrument_id, dict metadata, bint only_deltas)  # noqa
     cpdef void _handle_subscribe_ticker(self, MarketDataClient client, InstrumentId instrument_id)
     cpdef void _handle_subscribe_quote_ticks(self, MarketDataClient client, InstrumentId instrument_id)
+    cpdef void _handle_subscribe_synthetic_quote_ticks(self, InstrumentId instrument_id)
     cpdef void _handle_subscribe_trade_ticks(self, MarketDataClient client, InstrumentId instrument_id)
+    cpdef void _handle_subscribe_synthetic_trade_ticks(self, InstrumentId instrument_id)
     cpdef void _handle_subscribe_bars(self, MarketDataClient client, BarType bar_type)
     cpdef void _handle_subscribe_data(self, DataClient client, DataType data_type)
     cpdef void _handle_subscribe_venue_status_updates(self, MarketDataClient client, Venue venue)
     cpdef void _handle_subscribe_instrument_status_updates(self, MarketDataClient client, InstrumentId instrument_id)
     cpdef void _handle_subscribe_instrument_close(self, MarketDataClient client, InstrumentId instrument_id)
     cpdef void _handle_unsubscribe_instrument(self, MarketDataClient client, InstrumentId instrument_id)
     cpdef void _handle_unsubscribe_order_book_deltas(self, MarketDataClient client, InstrumentId instrument_id, dict metadata)  # noqa
@@ -155,7 +166,11 @@
 # -- INTERNAL -------------------------------------------------------------------------------------
 
     cpdef void _internal_update_instruments(self, list instruments)
     cpdef void _update_order_book(self, Data data)
     cpdef void _snapshot_order_book(self, TimeEvent snap_event)
     cpdef void _start_bar_aggregator(self, MarketDataClient client, BarType bar_type)
     cpdef void _stop_bar_aggregator(self, MarketDataClient client, BarType bar_type)
+    cpdef void _update_synthetics_with_quote(self, list synthetics, QuoteTick update)
+    cpdef void _update_synthetic_with_quote(self, SyntheticInstrument synthetic, QuoteTick update)
+    cpdef void _update_synthetics_with_trade(self, list synthetics, TradeTick update)
+    cpdef void _update_synthetic_with_trade(self, SyntheticInstrument synthetic, TradeTick update)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/engine.pyx` & `nautilus_trader-1.176.0/nautilus_trader/data/engine.pyx`

 * *Files 11% similar despite different names*

```diff
@@ -76,14 +76,17 @@
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport BarAggregation
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ComponentId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orderbook.book cimport OrderBook
 from nautilus_trader.msgbus.bus cimport MessageBus
 
 
 cdef class DataEngine(Component):
     """
     Provides a high-performance data engine for managing many `DataClient`
@@ -127,14 +130,18 @@
         self._clients: dict[ClientId, DataClient] = {}
         self._routing_map: dict[Venue, DataClient] = {}
         self._default_client: Optional[DataClient] = None
         self._catalog: Optional[ParquetDataCatalog] = None
         self._use_rust: bool = False
         self._order_book_intervals: dict[(InstrumentId, int), list[Callable[[Bar], None]]] = {}
         self._bar_aggregators: dict[BarType, BarAggregator] = {}
+        self._synthetic_quote_feeds: dict[InstrumentId, list[SyntheticInstrument]] = {}
+        self._synthetic_trade_feeds: dict[InstrumentId, list[SyntheticInstrument]] = {}
+        self._subscribed_synthetic_quotes: list[InstrumentId] = []
+        self._subscribed_synthetic_trades: list[InstrumentId] = []
 
         # Settings
         self.debug = config.debug
         self._time_bars_build_with_no_updates = config.time_bars_build_with_no_updates
         self._time_bars_timestamp_on_close = config.time_bars_timestamp_on_close
         self._validate_data_sequence = config.validate_data_sequence
 
@@ -184,14 +191,46 @@
     def disconnect(self) -> None:
         """
         Disconnect the engine by calling disconnect on all registered clients.
         """
         self._log.info("Disconnecting all clients...")
         # Implement actual client connections for a live/sandbox context
 
+    cpdef bint check_connected(self):
+        """
+        Check all of the engines clients are connected.
+
+        Returns
+        -------
+        bool
+            True if all clients connected, else False.
+
+        """
+        cdef DataClient client
+        for client in self._clients.values():
+            if not client.is_connected:
+                return False
+        return True
+
+    cpdef bint check_disconnected(self):
+        """
+        Check all of the engines clients are disconnected.
+
+        Returns
+        -------
+        bool
+            True if all clients disconnected, else False.
+
+        """
+        cdef DataClient client
+        for client in self._clients.values():
+            if client.is_connected:
+                return False
+        return True
+
 # --REGISTRATION ----------------------------------------------------------------------------------
 
     def register_catalog(self, catalog: ParquetDataCatalog, bint use_rust=False) -> None:
         """
         Register the given data catalog with the engine.
 
         Parameters
@@ -443,45 +482,35 @@
         """
         cdef list subscriptions = []
         cdef MarketDataClient client
         for client in [c for c in self._clients.values() if isinstance(c, MarketDataClient)]:
             subscriptions += client.subscribed_instrument_close()
         return subscriptions
 
-    cpdef bint check_connected(self):
+    cpdef list subscribed_synthetic_quotes(self):
         """
-        Check all of the engines clients are connected.
+        Return the synthetic instrument quote ticks subscribed to.
 
         Returns
         -------
-        bool
-            True if all clients connected, else False.
+        list[InstrumentId]
 
         """
-        cdef DataClient client
-        for client in self._clients.values():
-            if not client.is_connected:
-                return False
-        return True
+        return self._subscribed_synthetic_quotes.copy()
 
-    cpdef bint check_disconnected(self):
+    cpdef list subscribed_synthetic_trades(self):
         """
-        Check all of the engines clients are disconnected.
+        Return the synthetic instrument trade ticks subscribed to.
 
         Returns
         -------
-        bool
-            True if all clients disconnected, else False.
+        list[InstrumentId]
 
         """
-        cdef DataClient client
-        for client in self._clients.values():
-            if client.is_connected:
-                return False
-        return True
+        return self._subscribed_synthetic_trades.copy()
 
 # -- ABSTRACT METHODS -----------------------------------------------------------------------------
 
     cpdef void _on_start(self):
         pass  # Optionally override in subclass
 
     cpdef void _on_stop(self):
@@ -510,14 +539,18 @@
     cpdef void _reset(self):
         cdef DataClient client
         for client in self._clients.values():
             client.reset()
 
         self._order_book_intervals.clear()
         self._bar_aggregators.clear()
+        self._synthetic_quote_feeds.clear()
+        self._synthetic_trade_feeds.clear()
+        self._subscribed_synthetic_quotes.clear()
+        self._subscribed_synthetic_trades.clear()
 
         self._clock.cancel_timers()
         self.command_count = 0
         self.data_count = 0
         self.request_count = 0
         self.response_count = 0
 
@@ -589,16 +622,20 @@
 # -- COMMAND HANDLERS -----------------------------------------------------------------------------
 
     cpdef void _execute_command(self, DataCommand command):
         if self.debug:
             self._log.debug(f"{RECV}{CMD} {command}.")
         self.command_count += 1
 
+        cdef Venue venue = command.venue
         cdef DataClient client = self._clients.get(command.client_id)
-        if client is None:
+        if venue is not None and venue.is_synthetic():
+            # No further check as no client needed
+            pass
+        elif client is None:
             client = self._routing_map.get(command.venue, self._default_client)
             if client is None:
                 self._log.error(
                     f"Cannot execute command: "
                     f"no data client configured for {command.venue} or `client_id` {command.client_id}, "
                     f"{command}."
                 )
@@ -715,27 +752,35 @@
     ):
         Condition.not_none(client, "client")
 
         if instrument_id is None:
             client.subscribe_instruments()
             return
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot subscribe for synthetic instrument `Instrument` data.")
+            return
+
         if instrument_id not in client.subscribed_instruments():
             client.subscribe_instrument(instrument_id)
 
     cpdef void _handle_subscribe_order_book_deltas(
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot subscribe for synthetic instrument `OrderBookDelta` data.")
+            return
+
         self._setup_order_book(
             client,
             instrument_id,
             metadata,
             only_deltas=True,
         )
 
@@ -745,14 +790,18 @@
         InstrumentId instrument_id,
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot subscribe for synthetic instrument `OrderBook` data.")
+            return
+
         cdef int interval_ms = metadata["interval_ms"]
         key = (instrument_id, interval_ms)
         if key not in self._order_book_intervals:
             self._order_book_intervals[key] = []
             now = self._clock.utc_now()
             start_time = now - timedelta(milliseconds=int((now.second * 1000) % interval_ms), microseconds=now.microsecond)
             timer_name = f"OrderBook_{instrument_id}_{interval_ms}"
@@ -805,15 +854,15 @@
             if instrument_id not in client.subscribed_order_book_deltas():
                 client.subscribe_order_book_deltas(
                     instrument_id=instrument_id,
                     book_type=metadata["book_type"],
                     depth=metadata["depth"],
                     kwargs=metadata.get("kwargs"),
                 )
-        except NotImplementedError as ex:
+        except NotImplementedError:
             if only_deltas:
                 raise
             if instrument_id not in client.subscribed_order_book_snapshots():
                 client.subscribe_order_book_snapshots(
                     instrument_id=instrument_id,
                     book_type=metadata["book_type"],
                     depth=metadata["depth"],
@@ -837,53 +886,121 @@
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot subscribe for synthetic instrument `Ticker` data.")
+            return
+
         if instrument_id not in client.subscribed_tickers():
             client.subscribe_ticker(instrument_id)
 
     cpdef void _handle_subscribe_quote_ticks(
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
     ):
-        Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
+        if instrument_id.is_synthetic():
+            self._handle_subscribe_synthetic_quote_ticks(instrument_id)
+            return
+        Condition.not_none(client, "client")
 
         if instrument_id not in client.subscribed_quote_ticks():
             client.subscribe_quote_ticks(instrument_id)
 
+    cpdef void _handle_subscribe_synthetic_quote_ticks(self, InstrumentId instrument_id):
+        cdef SyntheticInstrument synthetic = self._cache.synthetic(instrument_id)
+        if synthetic is None:
+            self._log.error(
+                f"Cannot subscribe to `QuoteTick` data for synthetic instrument {instrument_id}, "
+                " not found."
+            )
+            return
+
+        if instrument_id in self._subscribed_synthetic_quotes:
+            return  # Already setup
+
+        cdef:
+            InstrumentId component_instrument_id
+            list synthetics_for_feed
+        for component_instrument_id in synthetic.components:
+            synthetics_for_feed = self._synthetic_quote_feeds.get(component_instrument_id)
+            if synthetics_for_feed is None:
+                synthetics_for_feed = []
+            if synthetic in synthetics_for_feed:
+                continue
+            synthetics_for_feed.append(synthetic)
+            self._synthetic_quote_feeds[component_instrument_id] = synthetics_for_feed
+
+        self._subscribed_synthetic_quotes.append(instrument_id)
+
     cpdef void _handle_subscribe_trade_ticks(
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
     ):
-        Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
+        if instrument_id.is_synthetic():
+            self._handle_subscribe_synthetic_trade_ticks(instrument_id)
+            return
+        Condition.not_none(client, "client")
 
         if instrument_id not in client.subscribed_trade_ticks():
             client.subscribe_trade_ticks(instrument_id)
 
+    cpdef void _handle_subscribe_synthetic_trade_ticks(self, InstrumentId instrument_id):
+        cdef SyntheticInstrument synthetic = self._cache.synthetic(instrument_id)
+        if synthetic is None:
+            self._log.error(
+                f"Cannot subscribe to `TradeTick` data for synthetic instrument {instrument_id}, "
+                " not found."
+            )
+            return
+
+        if instrument_id in self._subscribed_synthetic_trades:
+            return  # Already setup
+
+        cdef:
+            InstrumentId component_instrument_id
+            list synthetics_for_feed
+        for component_instrument_id in synthetic.components:
+            synthetics_for_feed = self._synthetic_trade_feeds.get(component_instrument_id)
+            if synthetics_for_feed is None:
+                synthetics_for_feed = []
+            if synthetic in synthetics_for_feed:
+                continue
+            synthetics_for_feed.append(synthetic)
+            self._synthetic_trade_feeds[component_instrument_id] = synthetics_for_feed
+
+        self._subscribed_synthetic_trades.append(instrument_id)
+
     cpdef void _handle_subscribe_bars(
         self,
         MarketDataClient client,
         BarType bar_type,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(bar_type, "bar_type")
 
         if bar_type.is_internally_aggregated():
             # Internal aggregation
             if bar_type not in self._bar_aggregators:
                 self._start_bar_aggregator(client, bar_type)
         else:
             # External aggregation
+            if bar_type.instrument_id.is_synthetic():
+                self._log.error(
+                    "Cannot subscribe for externally aggregated synthetic instrument bar data.",
+                )
+                return
+
             if bar_type not in client.subscribed_bars():
                 client.subscribe_bars(bar_type)
 
     cpdef void _handle_subscribe_data(
         self,
         DataClient client,
         DataType data_type,
@@ -916,25 +1033,35 @@
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
 
+        if instrument_id.is_synthetic():
+            self._log.error(
+                "Cannot subscribe for synthetic instrument `InstrumentStatusUpdate` data.",
+            )
+            return
+
         if instrument_id not in client.subscribed_instrument_status_updates():
             client.subscribe_instrument_status_updates(instrument_id)
 
     cpdef void _handle_subscribe_instrument_close(
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot subscribe for synthetic instrument `InstrumentClose` data.")
+            return
+
         if instrument_id not in client.subscribed_instrument_close():
             client.subscribe_instrument_close(instrument_id)
 
     cpdef void _handle_unsubscribe_instrument(
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
@@ -942,14 +1069,18 @@
         Condition.not_none(client, "client")
 
         if instrument_id is None:
             if not self._msgbus.has_subscribers(f"data.instrument.{client.id.value}.*"):
                 client.unsubscribe_instruments()
             return
         else:
+            if instrument_id.is_synthetic():
+                self._log.error("Cannot unsubscribe from synthetic instrument `Instrument` data.")
+                return
+
             if not self._msgbus.has_subscribers(
                 f"data.instrument"
                 f".{instrument_id.venue}"
                 f".{instrument_id.symbol}",
             ):
                 client.unsubscribe_instrument(instrument_id)
 
@@ -959,14 +1090,18 @@
         InstrumentId instrument_id,
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot unsubscribe from synthetic instrument `OrderBookDelta` data.")
+            return
+
         if not self._msgbus.has_subscribers(
             f"data.book.deltas"
             f".{instrument_id.venue}"
             f".{instrument_id.symbol}",
         ):
             client.unsubscribe_order_book_deltas(instrument_id)
 
@@ -976,14 +1111,18 @@
         InstrumentId instrument_id,
         dict metadata,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(metadata, "metadata")
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot unsubscribe from synthetic instrument `OrderBook` data.")
+            return
+
         if not self._msgbus.has_subscribers(
             f"data.book.snapshots"
             f".{instrument_id.venue}"
             f".{instrument_id.symbol}",
         ):
             client.unsubscribe_order_book_snapshots(instrument_id)
 
@@ -991,14 +1130,18 @@
         self,
         MarketDataClient client,
         InstrumentId instrument_id,
     ):
         Condition.not_none(client, "client")
         Condition.not_none(instrument_id, "instrument_id")
 
+        if instrument_id.is_synthetic():
+            self._log.error("Cannot unsubscribe from synthetic instrument `Ticker` data.")
+            return
+
         if not self._msgbus.has_subscribers(
             f"data.tickers"
             f".{instrument_id.venue}"
             f".{instrument_id.symbol}",
         ):
             client.unsubscribe_ticker(instrument_id)
 
@@ -1293,23 +1436,35 @@
                   f".{ticker.instrument_id.venue}"
                   f".{ticker.instrument_id.symbol}",
             msg=ticker,
         )
 
     cpdef void _handle_quote_tick(self, QuoteTick tick):
         self._cache.add_quote_tick(tick)
+
+        # Handle synthetics update
+        cdef list synthetics = self._synthetic_quote_feeds.get(tick.instrument_id)
+        if synthetics is not None:
+            self._update_synthetics_with_quote(synthetics, tick)
+
         self._msgbus.publish_c(
             topic=f"data.quotes"
                   f".{tick.instrument_id.venue}"
                   f".{tick.instrument_id.symbol}",
             msg=tick,
         )
 
     cpdef void _handle_trade_tick(self, TradeTick tick):
         self._cache.add_trade_tick(tick)
+
+        # Handle synthetics update
+        cdef list synthetics = self._synthetic_trade_feeds.get(tick.instrument_id)
+        if synthetics is not None:
+            self._update_synthetics_with_trade(synthetics, tick)
+
         self._msgbus.publish_c(
             topic=f"data.trades"
                   f".{tick.instrument_id.venue}"
                   f".{tick.instrument_id.symbol}",
             msg=tick,
         )
 
@@ -1557,7 +1712,112 @@
                       f".{bar_type.instrument_id.symbol}",
                 handler=aggregator.handle_quote_tick,
             )
             self._handle_unsubscribe_quote_ticks(client, bar_type.instrument_id)
 
         # Remove from aggregators
         del self._bar_aggregators[bar_type]
+
+    cpdef void _update_synthetics_with_quote(self, list synthetics, QuoteTick update):
+        cdef SyntheticInstrument synthetic
+        for synthetic in synthetics:
+            self._update_synthetic_with_quote(synthetic, update)
+
+    cpdef void _update_synthetic_with_quote(self, SyntheticInstrument synthetic, QuoteTick update):
+        cdef list components = synthetic.components
+        cdef list[double] inputs_bid = []
+        cdef list[double] inputs_ask = []
+
+        cdef:
+            InstrumentId instrument_id
+            QuoteTick component_quote
+            Price update_bid
+            Price update_ask
+        for instrument_id in components:
+            if instrument_id == update.instrument_id:
+                update_bid = update.bid
+                update_ask = update.ask
+                inputs_bid.append(update_bid.as_f64_c())
+                inputs_ask.append(update_ask.as_f64_c())
+                continue
+            component_quote = self._cache.quote_tick(instrument_id)
+            if component_quote is None:
+                self._log.warning(
+                    f"Cannot calculate synthetic instrument {synthetic.id} price, "
+                    f"no quotes for {instrument_id} yet...",
+                )
+                return
+            update_bid = component_quote.bid
+            update_ask = component_quote.ask
+            inputs_bid.append(update_bid.as_f64_c())
+            inputs_ask.append(update_ask.as_f64_c())
+
+        cdef Price bid = synthetic.calculate(inputs_bid)
+        cdef Price ask = synthetic.calculate(inputs_ask)
+        cdef Quantity size_one = Quantity(1, 0)  # Placeholder for now
+
+        cdef InstrumentId synthetic_instrument_id = synthetic.id
+        cdef QuoteTick synthetic_quote = QuoteTick(
+            synthetic_instrument_id,
+            bid,
+            ask,
+            size_one,
+            size_one,
+            update.ts_event,
+            self._clock.timestamp_ns(),
+        )
+
+        self._msgbus.publish_c(
+            topic=f"data.quotes"
+                  f".{synthetic_instrument_id.venue}"
+                  f".{synthetic_instrument_id.symbol}",
+            msg=synthetic_quote,
+        )
+
+    cpdef void _update_synthetics_with_trade(self, list synthetics, TradeTick update):
+        cdef SyntheticInstrument synthetic
+        for synthetic in synthetics:
+            self._update_synthetic_with_trade(synthetic, update)
+
+    cpdef void _update_synthetic_with_trade(self, SyntheticInstrument synthetic, TradeTick update):
+        cdef list components = synthetic.components
+        cdef list[double] inputs = []
+
+        cdef:
+            InstrumentId instrument_id
+            TradeTick component_quote
+            Price update_price
+        for instrument_id in components:
+            if instrument_id == update.instrument_id:
+                update_price = update.price
+                inputs.append(update_price.as_f64_c())
+                continue
+            component_trade = self._cache.trade_tick(instrument_id)
+            if component_trade is None:
+                self._log.warning(
+                    f"Cannot calculate synthetic instrument {synthetic.id} price, "
+                    f"no trades for {instrument_id} yet...",
+                )
+                return
+            update_price = component_trade.price
+            inputs.append(update_price.as_f64_c())
+
+        cdef Price price = synthetic.calculate(inputs)
+        cdef Quantity size_one = Quantity(1, 0)  # Placeholder for now
+
+        cdef InstrumentId synthetic_instrument_id = synthetic.id
+        cdef TradeTick synthetic_trade = TradeTick(
+            synthetic_instrument_id,
+            price,
+            size_one,
+            update.aggressor_side,
+            update.trade_id,
+            update.ts_event,
+            self._clock.timestamp_ns(),
+        )
+
+        self._msgbus.publish_c(
+            topic=f"data.trades"
+                  f".{synthetic_instrument_id.venue}"
+                  f".{synthetic_instrument_id.symbol}",
+            msg=synthetic_trade,
+        )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/messages.pxd` & `nautilus_trader-1.176.0/nautilus_trader/data/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/data/messages.pyx` & `nautilus_trader-1.176.0/nautilus_trader/data/messages.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/execution/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/blank.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/algorithms/blank.py`

 * *Files 2% similar despite different names*

```diff
@@ -26,43 +26,51 @@
     """
     Configuration for ``MyExecAlgorithm`` instances.
 
     Parameters
     ----------
     exec_algorithm_id : str | ExecAlgorithmId, optional
         The execution algorithm ID (will override default which is the class name).
+
     """
 
     exec_algorithm_id: Optional[str] = None
 
 
 class MyExecAlgorithm(ExecAlgorithm):
     """
     A blank template execution algorithm.
 
     Parameters
     ----------
     config : MyExecAlgorithmConfig
         The configuration for the instance.
+
     """
 
     def __init__(self, config: MyExecAlgorithmConfig) -> None:
         super().__init__(config)
         # Optionally implement further initialization
 
     def on_start(self) -> None:
-        """Actions to be performed when the algorithm component is started."""
+        """
+        Actions to be performed when the algorithm component is started.
+        """
         # Optionally implement
 
     def on_stop(self) -> None:
-        """Actions to be performed when the algorithm component is stopped."""
+        """
+        Actions to be performed when the algorithm component is stopped.
+        """
         # Optionally implement
 
     def on_reset(self) -> None:
-        """Actions to be performed when the algorithm component is reset."""
+        """
+        Actions to be performed when the algorithm component is reset.
+        """
         # Optionally implement
 
     def on_dispose(self) -> None:
         """
         Actions to be performed when the algorithm component is disposed.
 
         Cleanup any resources used by the strategy here.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/twap.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/algorithms/twap.py`

 * *Files 1% similar despite different names*

```diff
@@ -40,14 +40,15 @@
     (TWAP) execution algorithm, which aims to execute orders evenly spread over a specified
     time horizon, at regular intervals.
 
     Parameters
     ----------
     exec_algorithm_id : InstrumentId
         The execution algorithm ID (will override default which is the class name).
+
     """
 
     exec_algorithm_id: Optional[str] = "TWAP"
 
 
 class TWAPExecAlgorithm(ExecAlgorithm):
     """
@@ -64,33 +65,40 @@
     The algorithm will immediately submit the first order, with the final order submitted being the
     primary order at the end of the horizon period.
 
     Parameters
     ----------
     config : TWAPExecAlgorithmConfig, optional
         The configuration for the instance.
+
     """
 
     def __init__(self, config: Optional[TWAPExecAlgorithmConfig] = None) -> None:
         if config is None:
             config = TWAPExecAlgorithmConfig()
         super().__init__(config)
 
         self._scheduled_sizes: dict[ClientOrderId, list[Quantity]] = {}
 
     def on_start(self) -> None:
-        """Actions to be performed when the algorithm component is started."""
+        """
+        Actions to be performed when the algorithm component is started.
+        """
         # Optionally implement
 
     def on_stop(self) -> None:
-        """Actions to be performed when the algorithm component is stopped."""
+        """
+        Actions to be performed when the algorithm component is stopped.
+        """
         self.clock.cancel_timers()
 
     def on_reset(self) -> None:
-        """Actions to be performed when the algorithm component is reset."""
+        """
+        Actions to be performed when the algorithm component is reset.
+        """
         self._scheduled_sizes.clear()
 
     def on_save(self) -> dict[str, bytes]:
         """
         Actions to be performed when the algorithm component is saved.
 
         Create and return a state dictionary of values to be saved.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/blank.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/blank.py`

 * *Files 1% similar despite different names*

```diff
@@ -34,45 +34,53 @@
         The instrument ID for the strategy.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
 
 
 class MyStrategy(Strategy):
     """
     A blank template strategy.
 
     Parameters
     ----------
     config : MyStrategyConfig
         The configuration for the instance.
+
     """
 
     def __init__(self, config: MyStrategyConfig) -> None:
         super().__init__(config)
 
         # Configuration
         self.instrument_id = InstrumentId.from_str(config.instrument_id)
 
     def on_start(self) -> None:
-        """Actions to be performed when the strategy is started."""
+        """
+        Actions to be performed when the strategy is started.
+        """
         # Optionally implement
 
     def on_stop(self) -> None:
-        """Actions to be performed when the strategy is stopped."""
+        """
+        Actions to be performed when the strategy is stopped.
+        """
         # Optionally implement
 
     def on_reset(self) -> None:
-        """Actions to be performed when the strategy is reset."""
+        """
+        Actions to be performed when the strategy is reset.
+        """
         # Optionally implement
 
     def on_dispose(self) -> None:
         """
         Actions to be performed when the strategy is disposed.
 
         Cleanup any resources used by the strategy here.
@@ -106,16 +114,15 @@
             The strategy state dictionary.
 
         """
         # Optionally implement
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
-        Actions to be performed when the strategy is running and receives an
-        instrument.
+        Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
         instrument : Instrument
             The instrument received.
 
         """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross.py`

 * *Files 0% similar despite different names*

```diff
@@ -59,14 +59,15 @@
         If all open positions should be closed on strategy stop.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     bar_type: str
     trade_size: Decimal
     fast_ema_period: int = 10
     slow_ema_period: int = 20
@@ -87,14 +88,15 @@
     config : EMACrossConfig
         The configuration for the instance.
 
     Raises
     ------
     ValueError
         If `config.fast_ema_period` is not less than `config.slow_ema_period`.
+
     """
 
     def __init__(self, config: EMACrossConfig) -> None:
         PyCondition.true(
             config.fast_ema_period < config.slow_ema_period,
             "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
         )
@@ -109,15 +111,17 @@
         self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
         self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
 
         self.close_positions_on_stop = config.close_positions_on_stop
         self.instrument: Instrument = None
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         # Register the indicators for updating
@@ -135,29 +139,29 @@
         # self.subscribe_trade_ticks(self.instrument_id)
         # self.subscribe_ticker(self.instrument_id)  # For debugging
         # self.subscribe_order_book_deltas(self.instrument_id, depth=20)  # For debugging
         # self.subscribe_order_book_snapshots(self.instrument_id, depth=20)  # For debugging
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
-        Actions to be performed when the strategy is running and receives an
-        instrument.
+        Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
         instrument : Instrument
             The instrument received.
 
         """
         # For debugging (must add a subscription)
         # self.log.info(repr(instrument), LogColor.CYAN)
 
     def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         """
-        Actions to be performed when the strategy is running and receives order book deltas.
+        Actions to be performed when the strategy is running and receives order book
+        deltas.
 
         Parameters
         ----------
         deltas : OrderBookDeltas
             The order book deltas received.
 
         """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_bracket.py`

 * *Files 1% similar despite different names*

```diff
@@ -68,14 +68,15 @@
         If the expiry for orders with a time in force of 'GTD' will be managed by the strategy.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     bar_type: str
     trade_size: Decimal
     atr_period: int = 20
     fast_ema_period: int = 10
@@ -99,14 +100,15 @@
     config : EMACrossConfig
         The configuration for the instance.
 
     Raises
     ------
     ValueError
         If `config.fast_ema_period` is not less than `config.slow_ema_period`.
+
     """
 
     def __init__(self, config: EMACrossBracketConfig) -> None:
         PyCondition.true(
             config.fast_ema_period < config.slow_ema_period,
             "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
         )
@@ -123,15 +125,17 @@
         self.atr = AverageTrueRange(config.atr_period)
         self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
         self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
 
         self.instrument: Optional[Instrument] = None  # Initialized in on_start
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         # Register the indicators for updating
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py`

 * *Files 0% similar despite different names*

```diff
@@ -84,14 +84,15 @@
         If all open positions should be closed on strategy stop.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     bar_type: str
     trade_size: Decimal
     atr_period: int = 20
     fast_ema_period: int = 10
@@ -122,14 +123,15 @@
     config : EMACrossConfig
         The configuration for the instance.
 
     Raises
     ------
     ValueError
         If `config.fast_ema_period` is not less than `config.slow_ema_period`.
+
     """
 
     def __init__(self, config: EMACrossBracketAlgoConfig) -> None:
         PyCondition.true(
             config.fast_ema_period < config.slow_ema_period,
             "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
         )
@@ -169,15 +171,17 @@
         )
         self.tp_exec_algorithm_params = config.tp_exec_algorithm_params
 
         self.close_positions_on_stop = config.close_positions_on_stop
         self.instrument: Optional[Instrument] = None  # Initialized in on_start
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         # Register the indicators for updating
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -116,15 +116,17 @@
         # Create the indicators for the strategy
         self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
         self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
 
         self.instrument: Optional[Instrument] = None  # Initialized in on_start
 
     cpdef void on_start(self):
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         # Register the indicators for updating
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py`

 * *Files 0% similar despite different names*

```diff
@@ -75,14 +75,15 @@
         If 'NONE' then orders will not be emulated.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     bar_type: str
     atr_period: int
     trailing_atr_multiple: float
     trailing_offset_type: str
@@ -92,16 +93,16 @@
     fast_ema_period: int = 10
     slow_ema_period: int = 20
     emulation_trigger: str = "NO_TRIGGER"
 
 
 class EMACrossStopEntry(Strategy):
     """
-    A simple moving average cross example strategy with a `MARKET_IF_TOUCHED`
-    entry and `TRAILING_STOP_MARKET` stop.
+    A simple moving average cross example strategy with a `MARKET_IF_TOUCHED` entry and
+    `TRAILING_STOP_MARKET` stop.
 
     When the fast EMA crosses the slow EMA then submits a `MARKET_IF_TOUCHED` order
     one tick above the current bar for BUY, or one tick below the current bar
     for SELL.
 
     If the entry order is filled then a `TRAILING_STOP_MARKET` at a specified
     ATR distance is submitted and managed.
@@ -113,14 +114,15 @@
     config : EMACrossStopEntryConfig
         The configuration for the instance.
 
     Raises
     ------
     ValueError
         If `config.fast_ema_period` is not less than `config.slow_ema_period`.
+
     """
 
     def __init__(self, config: EMACrossStopEntryConfig) -> None:
         PyCondition.true(
             config.fast_ema_period < config.slow_ema_period,
             "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
         )
@@ -145,15 +147,17 @@
         self.tick_size = None  # Initialized in `on_start()`
 
         # Users order management variables
         self.entry = None
         self.trailing_stop = None
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         self.tick_size = self.instrument.price_increment
@@ -169,16 +173,15 @@
         # Subscribe to live data
         self.subscribe_bars(self.bar_type)
         self.subscribe_quote_ticks(self.instrument_id)
         self.subscribe_trade_ticks(self.instrument_id)
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
-        Actions to be performed when the strategy is running and receives an
-        instrument.
+        Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
         instrument : Instrument
             The instrument received.
 
         """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py`

 * *Files 1% similar despite different names*

```diff
@@ -75,14 +75,15 @@
         If 'NONE' then orders will not be emulated.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     bar_type: str
     atr_period: int
     trailing_atr_multiple: float
     trailing_offset_type: str
@@ -91,16 +92,16 @@
     fast_ema_period: int = 10
     slow_ema_period: int = 20
     emulation_trigger: str = "NO_TRIGGER"
 
 
 class EMACrossTrailingStop(Strategy):
     """
-    A simple moving average cross example strategy with a stop-market entry and
-    trailing stop.
+    A simple moving average cross example strategy with a stop-market entry and trailing
+    stop.
 
     When the fast EMA crosses the slow EMA then submits a stop-market order one
     tick above the current bar for BUY, or one tick below the current bar
     for SELL.
 
     If the entry order is filled then a trailing stop at a specified ATR
     distance is submitted and managed.
@@ -112,14 +113,15 @@
     config : EMACrossTrailingStopConfig
         The configuration for the instance.
 
     Raises
     ------
     ValueError
         If `config.fast_ema_period` is not less than `config.slow_ema_period`.
+
     """
 
     def __init__(self, config: EMACrossTrailingStopConfig) -> None:
         PyCondition.true(
             config.fast_ema_period < config.slow_ema_period,
             "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
         )
@@ -144,15 +146,17 @@
 
         # Users order management variables
         self.entry = None
         self.trailing_stop = None
         self.position_id = None
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         self.tick_size = self.instrument.price_increment
@@ -187,16 +191,15 @@
         # Reset indicators here
         self.fast_ema.reset()
         self.slow_ema.reset()
         self.atr.reset()
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
-        Actions to be performed when the strategy is running and receives an
-        instrument.
+        Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
         instrument : Instrument
             The instrument received.
 
         """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_twap.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/ema_cross_twap.py`

 * *Files 1% similar despite different names*

```diff
@@ -67,14 +67,15 @@
         If all open positions should be closed on strategy stop.
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     bar_type: str
     trade_size: Decimal
     fast_ema_period: int = 10
     slow_ema_period: int = 20
@@ -99,14 +100,15 @@
 
     Raises
     ------
     ValueError
         If `config.fast_ema_period` is not less than `config.slow_ema_period`.
     ValueError
         If `config.twap_interval_secs` is not less than or equal to `config.twap_horizon_secs`.
+
     """
 
     def __init__(self, config: EMACrossTWAPConfig) -> None:
         PyCondition.true(
             config.fast_ema_period < config.slow_ema_period,
             "{config.fast_ema_period=} must be less than {config.slow_ema_period=}",
         )
@@ -132,15 +134,17 @@
             "interval_secs": config.twap_interval_secs,
         }
         self.close_positions_on_stop = config.close_positions_on_stop
 
         self.instrument: Instrument = None
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         # Register the indicators for updating
@@ -152,29 +156,29 @@
 
         # Subscribe to live data
         self.subscribe_bars(self.bar_type)
         self.subscribe_quote_ticks(self.instrument_id)
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
-        Actions to be performed when the strategy is running and receives an
-        instrument.
+        Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
         instrument : Instrument
             The instrument received.
 
         """
         # For debugging (must add a subscription)
         # self.log.info(repr(instrument), LogColor.CYAN)
 
     def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         """
-        Actions to be performed when the strategy is running and receives order book deltas.
+        Actions to be performed when the strategy is running and receives order book
+        deltas.
 
         Parameters
         ----------
         deltas : OrderBookDeltas
             The order book deltas received.
 
         """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/market_maker.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/market_maker.py`

 * *Files 0% similar despite different names*

```diff
@@ -39,14 +39,15 @@
     ----------
     instrument_id : InstrumentId
         The instrument ID for the strategy.
     trade_size : Decimal
         The position size per trade.
     max_size : Decimal
         The maximum inventory size allowed.
+
     """
 
     def __init__(
         self,
         instrument_id: InstrumentId,
         trade_size: Decimal,
         max_size: Decimal,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/orderbook_imbalance.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/orderbook_imbalance.py`

 * *Files 6% similar despite different names*

```diff
@@ -53,36 +53,38 @@
         20).
     order_id_tag : str
         The unique order ID tag for the strategy. Must be unique
         amongst all running strategies for a particular trader ID.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     max_trade_size: Decimal
     trigger_min_size: float = 100.0
     trigger_imbalance_ratio: float = 0.20
     book_type: str = "L2_MBP"
     use_quote_ticks: bool = False
     subscribe_ticker: bool = False
 
 
 class OrderBookImbalance(Strategy):
     """
-    A simple strategy that sends FOK limit orders when there is a bid/ask
-    imbalance in the order book.
+    A simple strategy that sends FOK limit orders when there is a bid/ask imbalance in
+    the order book.
 
     Cancels all orders and closes all positions on stop.
 
     Parameters
     ----------
     config : OrderbookImbalanceConfig
         The configuration for the instance.
+
     """
 
     def __init__(self, config: OrderBookImbalanceConfig) -> None:
         assert 0 < config.trigger_imbalance_ratio < 1
         super().__init__(config)
 
         # Configuration
@@ -93,15 +95,17 @@
         self.instrument: Optional[Instrument] = None
         if self.config.use_quote_ticks:
             assert self.config.book_type == "L1_TBBO"
         self.book_type: BookType = book_type_from_str(self.config.book_type)
         self._book = None  # type: Optional[OrderBook]
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         if self.config.use_quote_ticks:
@@ -114,25 +118,29 @@
             self.subscribe_ticker(self.instrument.id)
         self._book = OrderBook(
             instrument_id=self.instrument.id,
             book_type=book_type,
         )
 
     def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
-        """Actions to be performed when order book deltas are received."""
+        """
+        Actions to be performed when order book deltas are received.
+        """
         if not self._book:
             self.log.error("No book being maintained.")
             return
 
         self._book.apply_deltas(deltas)
         if self._book.spread():
             self.check_trigger()
 
     def on_quote_tick(self, tick: QuoteTick) -> None:
-        """Actions to be performed when a delta is received."""
+        """
+        Actions to be performed when a delta is received.
+        """
         bid = BookOrder(
             price=tick.bid.as_double(),
             size=tick.bid_size.as_double(),
             side=OrderSide.BUY,
         )
         ask = BookOrder(
             price=tick.ask.as_double(),
@@ -143,21 +151,25 @@
         self._book.clear()
         self._book.update(bid)
         self._book.update(ask)
         if self._book.spread():
             self.check_trigger()
 
     def on_order_book(self, order_book: OrderBook) -> None:
-        """Actions to be performed when an order book update is received."""
+        """
+        Actions to be performed when an order book update is received.
+        """
         self._book = order_book
         if self._book.spread():
             self.check_trigger()
 
     def check_trigger(self) -> None:
-        """Check for trigger conditions."""
+        """
+        Check for trigger conditions.
+        """
         if not self._book:
             self.log.error("No book being maintained.")
             return
 
         if not self.instrument:
             self.log.error("No instrument loaded.")
             return
@@ -194,12 +206,14 @@
                     quantity=self.instrument.make_qty(bid_size),
                     post_only=False,
                     time_in_force=TimeInForce.FOK,
                 )
                 self.submit_order(order)
 
     def on_stop(self) -> None:
-        """Actions to be performed when the strategy is stopped."""
+        """
+        Actions to be performed when the strategy is stopped.
+        """
         if self.instrument is None:
             return
         self.cancel_all_orders(self.instrument.id)
         self.close_all_positions(self.instrument.id)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/signal_strategy.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/signal_strategy.py`

 * *Files 4% similar despite different names*

```diff
@@ -38,30 +38,37 @@
     """
     A strategy that simply emits a signal counter (FOR TESTING PURPOSES ONLY).
 
     Parameters
     ----------
     config : OrderbookImbalanceConfig
         The configuration for the instance.
+
     """
 
     def __init__(self, config: SignalStrategyConfig) -> None:
         super().__init__(config)
         self.instrument_id = InstrumentId.from_str(self.config.instrument_id)
         self.instrument: Optional[Instrument] = None
         self.counter = 0
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         self.subscribe_trade_ticks(instrument_id=self.instrument_id)
         self.subscribe_quote_ticks(instrument_id=self.instrument_id)
 
     def on_quote_tick(self, tick: QuoteTick) -> None:
-        """Actions to be performed when the strategy is running and receives a quote tick."""
+        """
+        Actions to be performed when the strategy is running and receives a quote tick.
+        """
         self.counter += 1
         self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)
 
     def on_trade_tick(self, tick: TradeTick) -> None:
-        """Actions to be performed when the strategy is running and receives a trade tick."""
+        """
+        Actions to be performed when the strategy is running and receives a trade tick.
+        """
         self.counter += 1
         self.publish_signal(name="counter", value=self.counter, ts_event=tick.ts_event)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/subscribe.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/subscribe.py`

 * *Files 1% similar despite different names*

```diff
@@ -45,29 +45,33 @@
     trade_ticks: bool = False
     quote_ticks: bool = False
     bars: bool = False
 
 
 class SubscribeStrategy(Strategy):
     """
-    A strategy that simply subscribes to data and logs it (typically for testing adapters)
+    A strategy that simply subscribes to data and logs it (typically for testing
+    adapters)
 
     Parameters
     ----------
     config : OrderbookImbalanceConfig
         The configuration for the instance.
+
     """
 
     def __init__(self, config: SubscribeStrategyConfig) -> None:
         super().__init__(config)
         self.instrument_id = InstrumentId.from_str(self.config.instrument_id)
         self.book: Optional[OrderBook] = None
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         if self.config.book_type:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/volatility_market_maker.py` & `nautilus_trader-1.176.0/nautilus_trader/examples/strategies/volatility_market_maker.py`

 * *Files 1% similar despite different names*

```diff
@@ -63,35 +63,37 @@
         amongst all running strategies for a particular trader ID.
     emulation_trigger : str, default 'NO_TRIGGER'
         The emulation trigger for submitting emulated orders.
         If ``None`` then orders will not be emulated.
     oms_type : OmsType
         The order management system type for the strategy. This will determine
         how the `ExecutionEngine` handles position IDs (see docs).
+
     """
 
     instrument_id: str
     bar_type: str
     atr_period: int
     atr_multiple: float
     trade_size: Decimal
     emulation_trigger: str = "NO_TRIGGER"
 
 
 class VolatilityMarketMaker(Strategy):
     """
-    A very dumb market maker which brackets the current market based on
-    volatility measured by an ATR indicator.
+    A very dumb market maker which brackets the current market based on volatility
+    measured by an ATR indicator.
 
     Cancels all orders and closes all positions on stop.
 
     Parameters
     ----------
     config : VolatilityMarketMakerConfig
         The configuration for the instance.
+
     """
 
     def __init__(self, config: VolatilityMarketMakerConfig) -> None:
         super().__init__(config)
 
         # Configuration
         self.instrument_id = InstrumentId.from_str(config.instrument_id)
@@ -106,15 +108,17 @@
         self.instrument: Optional[Instrument] = None  # Initialized in on_start
 
         # Users order management variables
         self.buy_order: Union[LimitOrder, None] = None
         self.sell_order: Union[LimitOrder, None] = None
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         # Register the indicators for updating
@@ -140,30 +144,28 @@
         #         metadata={"instrument_id": self.instrument.id},
         #     ),
         #     client_id=ClientId("BINANCE"),
         # )
 
     def on_data(self, data: Data) -> None:
         """
-        Actions to be performed when the strategy is running and receives generic
-        data.
+        Actions to be performed when the strategy is running and receives generic data.
 
         Parameters
         ----------
         data : Data
             The data received.
 
         """
         # For debugging (must add a subscription)
         # self.log.info(repr(data), LogColor.CYAN)
 
     def on_instrument(self, instrument: Instrument) -> None:
         """
-        Actions to be performed when the strategy is running and receives an
-        instrument.
+        Actions to be performed when the strategy is running and receives an instrument.
 
         Parameters
         ----------
         instrument : Instrument
             The instrument received.
 
         """
@@ -181,15 +183,16 @@
 
         """
         # For debugging (must add a subscription)
         self.log.info(repr(order_book), LogColor.CYAN)
 
     def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         """
-        Actions to be performed when the strategy is running and receives order book deltas.
+        Actions to be performed when the strategy is running and receives order book
+        deltas.
 
         Parameters
         ----------
         deltas : OrderBookDeltas
             The order book deltas received.
 
         """
@@ -216,15 +219,15 @@
         Parameters
         ----------
         tick : QuoteTick
             The tick received.
 
         """
         # For debugging (must add a subscription)
-        # self.log.info(repr(tick), LogColor.CYAN)
+        self.log.info(repr(tick), LogColor.CYAN)
 
     def on_trade_tick(self, tick: TradeTick) -> None:
         """
         Actions to be performed when the strategy is running and receives a trade tick.
 
         Parameters
         ----------
@@ -243,14 +246,18 @@
         ----------
         bar : Bar
             The bar received.
 
         """
         self.log.info(repr(bar), LogColor.CYAN)
 
+        if not self.instrument:
+            self.log.error("No instrument loaded.")
+            return
+
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
                 f"Waiting for indicators to warm up " f"[{self.cache.bar_count(self.bar_type)}]...",
                 color=LogColor.BLUE,
             )
             return  # Wait for indicators to warm up...
@@ -258,19 +265,29 @@
         last: QuoteTick = self.cache.quote_tick(self.instrument_id)
         if last is None:
             self.log.info("No quotes yet...")
             return
 
         # Maintain buy orders
         if self.buy_order and (self.buy_order.is_emulated or self.buy_order.is_open):
+            # price: Decimal = last.bid - (self.atr.value * self.atr_multiple)
+            # self.modify_order(
+            #     order=self.buy_order,
+            #     price=self.instrument.make_price(price),
+            # )
             self.cancel_order(self.buy_order)
         self.create_buy_order(last)
 
         # Maintain sell orders
         if self.sell_order and (self.sell_order.is_emulated or self.sell_order.is_open):
+            # price = last.ask + (self.atr.value * self.atr_multiple)
+            # self.modify_order(
+            #     order=self.sell_order,
+            #     price=self.instrument.make_price(price),
+            # )
             self.cancel_order(self.sell_order)
         self.create_sell_order(last)
 
     def create_buy_order(self, last: QuoteTick) -> None:
         """
         Market maker simple buy limit method (example).
         """
@@ -327,15 +344,15 @@
 
         """
         last: QuoteTick = self.cache.quote_tick(self.instrument_id)
         if last is None:
             self.log.info("No quotes yet...")
             return
 
-        # If order filled then replace order at atr multiple distance from the market
+        # If order filled then replace order at ATR multiple distance from the market
         if isinstance(event, OrderFilled):
             if self.buy_order and event.order_side == OrderSide.BUY:
                 if self.buy_order.is_closed:
                     self.create_buy_order(last)
             elif (
                 self.sell_order and event.order_side == OrderSide.SELL and self.sell_order.is_closed
             ):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/execution/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,19 +8,20 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `execution` subpackage groups components relating to the execution stack for the platform.
+The `execution` subpackage groups components relating to the execution stack for the
+platform.
 
 The layered architecture of the execution stack somewhat mirrors the
 data stack with a central engine, cache layer beneath, database layer
 beneath, with alternative implementations able to be written on top.
 
 Due to the high-performance, the core components are reusable between both
 backtest and live implementations - helping to ensure consistent logic for
 trading operations.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pxd` & `nautilus_trader-1.176.0/nautilus_trader/execution/algorithm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/algorithm.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -622,73 +622,76 @@
 
         """
         Condition.true(self.trader_id is not None, "The execution algorithm has not been registered")
         Condition.not_none(order, "order")
         Condition.equal(order.status, OrderStatus.INITIALIZED, "order", "order_status")
         Condition.equal(order.emulation_trigger, TriggerType.NO_TRIGGER, "order.emulation_trigger", "NO_TRIGGER")
 
-        cdef SubmitOrder primary_command = None
-        cdef SubmitOrder spawned_command = None
+        cdef Order primary = None
+        cdef PositionId position_id = None
+        cdef ClientId client_id = None
+        cdef SubmitOrder command = None
 
         if order.exec_spawn_id is not None:
             # Handle new spawned order
-            primary_command = self.cache.load_submit_order_command(order.exec_spawn_id)
-            Condition.equal(order.strategy_id, primary_command.strategy_id, "order.strategy_id", "primary_command.strategy_id")
-            if primary_command is None:
+            primary = self.cache.order(order.exec_spawn_id)
+            Condition.equal(order.strategy_id, primary.strategy_id, "order.strategy_id", "primary.strategy_id")
+            if primary is None:
                 self._log.error(
-                    "Cannot submit order: cannot find primary "
-                    f"`SubmitOrder` command for {repr(order.exec_spawn_id)}."
+                    "Cannot submit order: cannot find primary order for {repr(order.exec_spawn_id)}."
                 )
                 return
 
+            position_id = self.cache.position_id(primary.client_order_id)
+            client_id = self.cache.client_id(primary.client_order_id)
+
             if self.cache.order_exists(order.client_order_id):
                 self._log.error(
                     f"Cannot submit order: order already exists for {repr(order.client_order_id)}.",
                 )
                 return
 
             # Publish initialized event
             self._msgbus.publish_c(
                 topic=f"events.order.{order.strategy_id.to_str()}",
                 msg=order.init_event_c(),
             )
 
-            self.cache.add_order(order, primary_command.position_id)
+            self.cache.add_order(order, position_id)
 
-            spawned_command = SubmitOrder(
+            command = SubmitOrder(
                 trader_id=self.trader_id,
-                strategy_id=primary_command.strategy_id,
+                strategy_id=primary.strategy_id,
                 order=order,
                 command_id=UUID4(),
                 ts_init=self.clock.timestamp_ns(),
-                position_id=primary_command.position_id,
-                client_id=primary_command.client_id,
+                position_id=primary.position_id,
+                client_id=client_id,
             )
-            self.cache.add_submit_order_command(spawned_command)
 
-            self._send_risk_command(spawned_command)
+            self._send_risk_command(command)
             return
 
         # Handle primary (original) order
-        primary_command = self.cache.load_submit_order_command(order.client_order_id)
+        position_id = self.cache.position_id(order.client_order_id)
         cdef Order cached_order = self.cache.order(order.client_order_id)
         if cached_order.order_type != order.order_type:
-            self.cache.add_order(order, primary_command.position_id, override=True)
+            self.cache.add_order(order, position_id, client_id, override=True)
 
-        # Replace commands order with transformed order
-        primary_command.order = order
+        command = SubmitOrder(
+            trader_id=self.trader_id,
+            strategy_id=order.strategy_id,
+            order=order,
+            command_id=UUID4(),
+            ts_init=self.clock.timestamp_ns(),
+            position_id=position_id,
+            client_id=None,  # Not yet supported
+        )
 
-        Condition.equal(order.strategy_id, primary_command.strategy_id, "order.strategy_id", "primary_command.strategy_id")
-        if primary_command is None:
-            self._log.error(
-                "Cannot submit order: cannot find primary "
-                f"`SubmitOrder` command for {repr(order.client_order_id)}."
-            )
-            return
-        self._send_risk_command(primary_command)
+        self._send_risk_command(command)
 
     cpdef void modify_order(
         self,
         Order order,
         Quantity quantity = None,
         Price price = None,
         Price trigger_price = None,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/client.pxd` & `nautilus_trader-1.176.0/nautilus_trader/execution/client.pxd`

 * *Files 8% similar despite different names*

```diff
@@ -20,17 +20,14 @@
 from nautilus_trader.common.component cimport Component
 from nautilus_trader.execution.messages cimport CancelAllOrders
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
 from nautilus_trader.execution.messages cimport QueryOrder
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
-from nautilus_trader.execution.reports cimport ExecutionMassStatus
-from nautilus_trader.execution.reports cimport OrderStatusReport
-from nautilus_trader.execution.reports cimport TradeReport
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport AccountType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.events.account cimport AccountState
@@ -183,10 +180,10 @@
         uint64_t ts_event,
     )
 
 # --------------------------------------------------------------------------------------------------
 
     cpdef void _send_account_state(self, AccountState account_state)
     cpdef void _send_order_event(self, OrderEvent event)
-    cpdef void _send_mass_status_report(self, ExecutionMassStatus report)
-    cpdef void _send_order_status_report(self, OrderStatusReport report)
-    cpdef void _send_trade_report(self, TradeReport report)
+    cpdef void _send_mass_status_report(self, report)
+    cpdef void _send_order_status_report(self, report)
+    cpdef void _send_trade_report(self, report)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/client.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/client.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -11,30 +11,31 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from typing import Optional
 
+from nautilus_trader.execution.reports import ExecutionMassStatus
+from nautilus_trader.execution.reports import OrderStatusReport
+from nautilus_trader.execution.reports import TradeReport
+
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.cache.cache cimport Cache
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.component cimport Component
 from nautilus_trader.common.logging cimport Logger
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.execution.messages cimport CancelAllOrders
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
-from nautilus_trader.execution.reports cimport ExecutionMassStatus
-from nautilus_trader.execution.reports cimport OrderStatusReport
-from nautilus_trader.execution.reports cimport TradeReport
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport AccountType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.events.account cimport AccountState
 from nautilus_trader.model.events.order cimport OrderAccepted
@@ -773,36 +774,36 @@
             ts_init=self._clock.timestamp_ns(),
         )
 
         self._send_order_event(fill)
 
 # --------------------------------------------------------------------------------------------------
 
-    cpdef void _send_account_state(self, AccountState account_state):
+    cpdef void _send_account_state(self, account_state: AccountState):
         self._msgbus.send(
             endpoint=f"Portfolio.update_account",
             msg=account_state,
         )
 
-    cpdef void _send_order_event(self, OrderEvent event):
+    cpdef void _send_order_event(self, event: OrderEvent):
         self._msgbus.send(
             endpoint="ExecEngine.process",
             msg=event,
         )
 
-    cpdef void _send_mass_status_report(self, ExecutionMassStatus report):
+    cpdef void _send_mass_status_report(self, report: ExecutionMassStatus):
         self._msgbus.send(
             endpoint="ExecEngine.reconcile_mass_status",
             msg=report,
         )
 
-    cpdef void _send_order_status_report(self, OrderStatusReport report):
+    cpdef void _send_order_status_report(self, report: OrderStatusReport):
         self._msgbus.send(
             endpoint="ExecEngine.reconcile_report",
             msg=report,
         )
 
-    cpdef void _send_trade_report(self, TradeReport report):
+    cpdef void _send_trade_report(self, report: TradeReport):
         self._msgbus.send(
             endpoint="ExecEngine.reconcile_report",
             msg=report,
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pxd` & `nautilus_trader-1.176.0/nautilus_trader/execution/emulator.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -25,38 +25,40 @@
 from nautilus_trader.model.events.order cimport OrderEvent
 from nautilus_trader.model.events.order cimport OrderExpired
 from nautilus_trader.model.events.order cimport OrderFilled
 from nautilus_trader.model.events.order cimport OrderRejected
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.events.position cimport PositionEvent
 from nautilus_trader.model.identifiers cimport ClientId
+from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport PositionId
-from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.identifiers cimport StrategyId
+from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
 cdef class OrderEmulator(Actor):
     cdef dict _matching_cores
     cdef dict _commands_submit_order
-    cdef dict _commands_submit_order_list
 
     cdef set _subscribed_quotes
     cdef set _subscribed_trades
     cdef set _subscribed_strategies
     cdef set _monitored_positions
 
     cpdef void execute(self, TradingCommand command)
-    cpdef MatchingCore create_matching_core(self, Instrument instrument)
+    cpdef MatchingCore create_matching_core(self, InstrumentId instrument_id, Price price_increment)
     cdef void _handle_submit_order(self, SubmitOrder command)
     cdef void _handle_submit_order_list(self, SubmitOrderList command)
     cdef void _handle_modify_order(self, ModifyOrder command)
     cdef void _handle_cancel_order(self, CancelOrder command)
     cdef void _handle_cancel_all_orders(self, CancelAllOrders command)
 
+    cdef void _check_monitoring(self, StrategyId strategy_id, PositionId position_id)
     cdef void _create_new_submit_order(self, Order order, PositionId position_id, ClientId client_id)
     cdef void _cancel_order(self, MatchingCore matching_core, Order order)
 
 # -- EVENT HANDLERS -------------------------------------------------------------------------------
 
     cdef void _handle_order_rejected(self, OrderRejected rejected)
     cdef void _handle_order_canceled(self, OrderCanceled canceled)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/emulator.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -94,15 +94,14 @@
             cache=cache,
             clock=clock,
             logger=logger,
         )
 
         self._matching_cores: dict[InstrumentId, MatchingCore]  = {}
         self._commands_submit_order: dict[ClientOrderId, SubmitOrder] = {}
-        self._commands_submit_order_list: dict[OrderListId, SubmitOrderList] = {}
 
         self._subscribed_quotes: set[InstrumentId] = set()
         self._subscribed_trades: set[InstrumentId] = set()
         self._subscribed_strategies: set[StrategyId] = set()
         self._monitored_positions: set[PositionId] = set()
 
         # Register endpoints
@@ -139,25 +138,14 @@
         Returns
         -------
         dict[ClientOrderId, SubmitOrder]
 
         """
         return self._commands_submit_order.copy()
 
-    def get_submit_order_list_commands(self) -> dict[OrderListId, SubmitOrderList]:
-        """
-        Return the emulators cached submit order list commands.
-
-        Returns
-        -------
-        dict[OrderListId, SubmitOrderList]
-
-        """
-        return self._commands_submit_order_list.copy()
-
     def get_matching_core(self, InstrumentId instrument_id) -> Optional[MatchingCore]:
         """
         Return the emulators matching core for the given instrument ID.
 
         Returns
         -------
         MatchingCore or ``None``
@@ -169,39 +157,36 @@
 
     cpdef void on_start(self):
         cdef list emulated_orders = self.cache.orders_emulated()
         if not emulated_orders:
             self._log.info("No emulated orders to reactivate.")
             return
 
-        cdef int emulated_count = len(emulated_orders)
-        self._log.info(f"Reactivating {emulated_count} emulated order{'' if emulated_count == 1 else 's'}...")
-
         cdef:
             Order order
-            TradingCommand command
+            SubmitOrder command
+            PositionId position_id
+            ClientId client_id
         for order in emulated_orders:
-            if order.order_list_id is not None and order.order_list_id not in self._commands_submit_order_list:
-                command = self.cache.load_submit_order_list_command(order.order_list_id)
-                if command is None:
-                    self._log.error(
-                        f"Cannot load `SubmitOrderList` command for {repr(order.order_list_id)}: not found in cache."
-                    )
-                    continue
-                self._log.info(f"Loaded {command}.", LogColor.BLUE)
-                self._handle_submit_order_list(command)
-            else:
-                command = self.cache.load_submit_order_command(order.client_order_id)
-                if command is None:
-                    self._log.error(
-                        f"Cannot load `SubmitOrder` command for {repr(order.client_order_id)}: not found in cache."
-                    )
-                    continue
-                self._log.info(f"Loaded {command}.", LogColor.BLUE)
-                self._handle_submit_order(command)
+            if order.status != OrderStatus.INITIALIZED:
+                continue  # No longer emulated
+
+            position_id = self.cache.position_id(order.client_order_id)
+            client_id = self.cache.client_id(order.client_order_id)
+            command = SubmitOrder(
+                trader_id=self.trader_id,
+                strategy_id=order.strategy_id,
+                order=order,
+                command_id=UUID4(),
+                ts_init=self.clock.timestamp_ns(),
+                position_id=position_id,
+                client_id=client_id,
+            )
+
+            self._handle_submit_order(command)
 
     cpdef void on_event(self, Event event):
         self._log.info(f"Received {event}.", LogColor.MAGENTA)
         if isinstance(event, OrderRejected):
             self._handle_order_rejected(event)
         elif isinstance(event, OrderCanceled):
             self._handle_order_canceled(event)
@@ -215,15 +200,14 @@
             self._handle_position_event(event)
 
     cpdef void on_stop(self):
         pass
 
     cpdef void on_reset(self):
         self._commands_submit_order.clear()
-        self._commands_submit_order_list.clear()
         self._matching_cores.clear()
 
     cpdef void on_dispose(self):
         pass
 
 # -------------------------------------------------------------------------------------------------
 
@@ -250,73 +234,90 @@
         elif isinstance(command, CancelOrder):
             self._handle_cancel_order(command)
         elif isinstance(command, CancelAllOrders):
             self._handle_cancel_all_orders(command)
         else:
             self._log.error(f"Cannot handle command: unrecognized {command}.")
 
-    cpdef MatchingCore create_matching_core(self, Instrument instrument):
+    cpdef MatchingCore create_matching_core(
+        self,
+        InstrumentId instrument_id,
+        Price price_increment,
+    ):
         """
         Create an internal matching core for the given `instrument`.
 
         Parameters
         ----------
-        instrument : Instrument
-            The instrument for the matching core.
+        instrument_id : InstrumentId
+            The instrument ID for the matching core.
+        price_increment : Price
+            The minimum price increment (tick size) for the matching core.
 
         Returns
         -------
         MatchingCore
 
         Raises
         ------
         RuntimeError
-            If a matching core for the given `instrument` already exists.
+            If a matching core for the given `instrument_id` already exists.
 
         """
-        if instrument.id in self._matching_cores:
-            raise RuntimeError(f"A matching core already exists for {instrument.id}.")
+        if instrument_id in self._matching_cores:
+            raise RuntimeError(f"A matching core already exists for {instrument_id}.")
 
         matching_core = MatchingCore(
-            instrument=instrument,
+            instrument_id=instrument_id,
+            price_increment=price_increment,
             trigger_stop_order=self._trigger_stop_order,
             fill_market_order=self._fill_market_order,
             fill_limit_order=self._fill_limit_order,
         )
 
-        self._matching_cores[instrument.id] = matching_core
-        self._log.debug(f"Created matching core for {instrument.id.to_str()}.")
+        self._matching_cores[instrument_id] = matching_core
+        self._log.debug(f"Created matching core for {instrument_id}.")
 
         return matching_core
 
     cdef void _handle_submit_order(self, SubmitOrder command):
         cdef Order order = command.order
         cdef TriggerType emulation_trigger = command.order.emulation_trigger
         Condition.not_equal(emulation_trigger, TriggerType.NO_TRIGGER, "command.order.emulation_trigger", "TriggerType.NO_TRIGGER")
         Condition.not_in(command.order.client_order_id, self._commands_submit_order, "command.order.client_order_id", "self._commands_submit_order")
 
         if emulation_trigger not in SUPPORTED_TRIGGERS:
             self._log.error(
-                f"Cannot emulate order: `TriggerType` {trigger_type_to_str(emulation_trigger)} "
-                f"not supported.",
-            )
+                f"Cannot emulate order: `TriggerType` {trigger_type_to_str(emulation_trigger)} not supported.")
             self._cancel_order(matching_core=None, order=order)
             return
 
+        self._check_monitoring(command.strategy_id, command.position_id)
+
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
-            instrument = self.cache.instrument(trigger_instrument_id)
-            if instrument is None:
-                self._log.error(
-                    f"Cannot emulate order: no trigger instrument for {trigger_instrument_id}.",
-                )
-                self._cancel_order(matching_core=None, order=order)
-                return
-            matching_core = self.create_matching_core(instrument)
+            if trigger_instrument_id.is_synthetic():
+                synthetic = self.cache.synthetic(trigger_instrument_id)
+                if synthetic is None:
+                    self._log.error(
+                        f"Cannot emulate order: no synthetic instrument {trigger_instrument_id} for trigger.",
+                    )
+                    self._cancel_order(matching_core=None, order=order)
+                    return
+                matching_core = self.create_matching_core(synthetic.id, synthetic.price_increment)
+            else:
+                instrument = self.cache.instrument(trigger_instrument_id)
+                if instrument is None:
+                    self._log.error(
+                        f"Cannot emulate order: no instrument {trigger_instrument_id} for trigger.",
+                    )
+                    self._cancel_order(matching_core=None, order=order)
+                    return
+                matching_core = self.create_matching_core(instrument.id, instrument.price_increment)
 
         # Update trailing stop
         if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
             self._update_trailing_stop_order(matching_core, order)
             if order.trigger_price is None:
                 self.log.error(
                     "Cannot handle trailing stop order with no `trigger_price` and no market updates.",
@@ -349,29 +350,15 @@
 
         # Hold in matching core
         matching_core.add_order(order)
 
         self.log.info(f"Emulating {command.order}.", LogColor.MAGENTA)
 
     cdef void _handle_submit_order_list(self, SubmitOrderList command):
-        Condition.not_in(command.order_list.id, self._commands_submit_order_list, "command.order_list.id", "self._commands_submit_order_list")
-
-        # Cache command
-        self._commands_submit_order_list[command.order_list.id] = command
-
-        # Setup event monitoring
-        if command.strategy_id not in self._subscribed_strategies:
-            # Subscribe to all strategy events
-            self._log.info(f"Subscribing to strategy {command.strategy_id.to_str()} order and position events.", LogColor.BLUE)
-            self._msgbus.subscribe(topic=f"events.order.{command.strategy_id.to_str()}", handler=self.on_event)
-            self._msgbus.subscribe(topic=f"events.position.{command.strategy_id.to_str()}", handler=self.on_event)
-            self._subscribed_strategies.add(command.strategy_id)
-
-        if command.position_id is not None:
-            self._monitored_positions.add(command.position_id)
+        self._check_monitoring(command.strategy_id, command.position_id)
 
         cdef Order order
         for order in command.order_list.orders:
             if order.parent_order_id is not None:
                 parent_order = self.cache.order(order.parent_order_id)
                 assert parent_order, f"Parent order for {repr(order.client_order_id)} not found"
                 if parent_order.contingency_type == ContingencyType.OTO:
@@ -436,15 +423,15 @@
             return
 
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
             raise RuntimeError(f"Cannot handle `CancelOrder`: no matching core for trigger instrument {trigger_instrument_id}.")  # pragma: no cover (design-time error)
 
-        if not matching_core.order_exists(order.client_order_id):
+        if not matching_core.order_exists(order.client_order_id) and order.is_open_c() and not order.is_pending_cancel_c():
             # Order not held in the emulator
             self._send_exec_command(command)
         else:
             self._cancel_order(matching_core, order)
 
     cdef void _handle_cancel_all_orders(self, CancelAllOrders command):
         cdef MatchingCore matching_core = self._matching_cores.get(command.instrument_id)
@@ -464,34 +451,45 @@
                 f"invalid `OrderSide`, was {command.order_side}",  # pragma: no cover (design-time error)
             )
 
         cdef Order order
         for order in orders:
             self._cancel_order(matching_core, order)
 
+    cdef void _check_monitoring(self, StrategyId strategy_id, PositionId position_id):
+        if strategy_id not in self._subscribed_strategies:
+            # Subscribe to all strategy events
+            self._msgbus.subscribe(topic=f"events.order.{strategy_id.to_str()}", handler=self.on_event)
+            self._msgbus.subscribe(topic=f"events.position.{strategy_id.to_str()}", handler=self.on_event)
+            self._subscribed_strategies.add(strategy_id)
+            self._log.info(f"Subscribed to strategy {strategy_id.to_str()} order and position events.", LogColor.BLUE)
+
+        if position_id is not None and position_id not in self._monitored_positions:
+            self._monitored_positions.add(position_id)
+
     cdef void _create_new_submit_order(
         self,
         Order order,
         PositionId position_id,
         ClientId client_id,
     ):
-        cdef SubmitOrder submit = self.cache.load_submit_order_command(order.client_order_id)
-        if submit is None:
-            submit = SubmitOrder(
-                trader_id=order.trader_id,
-                strategy_id=order.strategy_id,
-                order=order,
-                position_id=position_id,
-                client_id=client_id,
-                command_id=UUID4(),
-                ts_init=self.clock.timestamp_ns(),
-            )
-            self.cache.add_submit_order_command(submit)
+        cdef SubmitOrder submit = SubmitOrder(
+            trader_id=order.trader_id,
+            strategy_id=order.strategy_id,
+            order=order,
+            position_id=position_id,
+            client_id=client_id,
+            command_id=UUID4(),
+            ts_init=self.clock.timestamp_ns(),
+        )
 
         if order.emulation_trigger == TriggerType.NO_TRIGGER:
+            # Cache command
+            self._commands_submit_order[order.client_order_id] = submit
+
             if order.exec_algorithm_id is not None:
                 self._send_algo_command(submit)
             else:
                 self._send_risk_command(submit)
         else:
             # Emulate
             self._handle_submit_order(submit)
@@ -594,36 +592,38 @@
         if order.is_closed_c():
             matching_core = self._matching_cores.get(order.instrument_id)
             if matching_core is not None:
                 matching_core.delete_order(order)
 
         cdef dict exec_algorithm_index = {}
         cdef:
+            PositionId position_id
+            ClientId client_id
             ClientOrderId client_order_id
             SubmitOrderList submit_order_list
-            Order contingent_order
+            Order child_order
             Order spawned_order
             Order primary_order
             list exec_spawn_orders
             uint64_t raw_filled_qty
             Quantity filled_qty
         if order.contingency_type == ContingencyType.OTO:
             assert order.linked_order_ids
-            submit_order_list = self._commands_submit_order_list.get(order.order_list_id)
-            assert submit_order_list
+            position_id = self.cache.position_id(order.client_order_id)
+            client_id = self.cache.client_id(order.client_order_id)
             for client_order_id in order.linked_order_ids:
                 child_order = self.cache.order(client_order_id)
                 assert child_order, f"Cannot find child order for {repr(client_order_id)}"
                 if child_order.is_closed_c():
                     continue
-                if not self.cache.load_submit_order_command(child_order.client_order_id):
+                if not child_order.client_order_id in self._commands_submit_order:
                     self._create_new_submit_order(
                         order=child_order,
-                        position_id=submit_order_list.position_id,
-                        client_id=submit_order_list.client_id,
+                        position_id=position_id,
+                        client_id=client_id,
                     )
                     continue
 
                 # Check if execution algorithm spawned order (only update based on primary)
                 if order.exec_spawn_id is None:
                     return
 
@@ -764,19 +764,25 @@
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
             raise RuntimeError(f"No matching core for trigger instrument {trigger_instrument_id}")
 
         matching_core.delete_order(order)
 
+        order.emulation_trigger = TriggerType.NO_TRIGGER
         cdef MarketOrder transformed = MarketOrder.transform(order, self.clock.timestamp_ns())
 
         # Cast to writable cache
         cdef Cache cache = <Cache>self.cache
-        cache.add_order(transformed, command.position_id, override=True)
+        cache.add_order(
+            transformed,
+            command.position_id,
+            command.client_id,
+            override=True,
+        )
 
         # Replace commands order with transformed order
         command.order = transformed
 
         # Publish initialized event
         self._msgbus.publish_c(
             topic=f"events.order.{order.strategy_id.to_str()}",
@@ -806,19 +812,25 @@
         cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
             raise RuntimeError(f"No matching core for trigger instrument {trigger_instrument_id}")
 
         matching_core.delete_order(order)
 
+        order.emulation_trigger = TriggerType.NO_TRIGGER
         cdef LimitOrder transformed = LimitOrder.transform(order, self.clock.timestamp_ns())
 
         # Cast to writable cache
         cdef Cache cache = <Cache>self.cache
-        cache.add_order(transformed, command.position_id, override=True)
+        cache.add_order(
+            transformed,
+            command.position_id,
+            command.client_id,
+            override=True,
+        )
 
         # Replace commands order with transformed order
         command.order = transformed
 
         # Publish initialized event
         self._msgbus.publish_c(
             topic=f"events.order.{order.strategy_id.to_str()}",
@@ -870,46 +882,39 @@
                 continue
 
             # Manage trailing stop
             if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
                 self._update_trailing_stop_order(matching_core, order)
 
     cdef void _update_trailing_stop_order(self, MatchingCore matching_core, Order order):
-        cdef Instrument instrument = self.cache.instrument(order.instrument_id)
-        if instrument is None:
-            self._log.error(
-                f"Cannot update order: no instrument for {order.instrument_id}.",
-            )
-            return
-
         # TODO(cs): Improve efficiency of this ---------------------------------
         cdef Price bid = None
         cdef Price ask = None
         cdef Price last = None
         if matching_core.is_bid_initialized:
-            bid = Price.from_raw_c(matching_core.bid_raw, instrument.price_precision)
+            bid = Price.from_raw_c(matching_core.bid_raw, matching_core.price_precision)
         if matching_core.is_ask_initialized:
-            ask = Price.from_raw_c(matching_core.ask_raw, instrument.price_precision)
+            ask = Price.from_raw_c(matching_core.ask_raw, matching_core.price_precision)
         if matching_core.is_last_initialized:
-            last = Price.from_raw_c(matching_core.last_raw, instrument.price_precision)
+            last = Price.from_raw_c(matching_core.last_raw, matching_core.price_precision)
 
-        cdef QuoteTick quote_tick = self.cache.quote_tick(instrument.id)
-        cdef TradeTick trade_tick = self.cache.trade_tick(instrument.id)
+        cdef QuoteTick quote_tick = self.cache.quote_tick(matching_core.instrument_id)
+        cdef TradeTick trade_tick = self.cache.trade_tick(matching_core.instrument_id)
         if bid is None and quote_tick is not None:
             bid = quote_tick.bid
         if ask is None and quote_tick is not None:
             ask = quote_tick.ask
         if last is None and trade_tick is not None:
             last = trade_tick.price
         # TODO(cs): ------------------------------------------------------------
 
         cdef tuple output
         try:
             output = TrailingStopCalculator.calculate(
-                instrument=instrument,
+                price_increment=matching_core.price_increment,
                 order=order,
                 bid=bid,
                 ask=ask,
                 last=last,
             )
         except RuntimeError as e:
             self._log.warning(f"Cannot calculate trailing stop order: {e}")
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/engine.pxd` & `nautilus_trader-1.176.0/nautilus_trader/execution/engine.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -49,29 +49,28 @@
     cdef readonly dict _oms_overrides
     cdef readonly dict _external_order_claims
 
     cdef readonly bint debug
     """If debug mode is active (will provide extra debug logging).\n\n:returns: `bool`"""
     cdef readonly bint allow_cash_positions
     """If unleveraged spot/cash assets should generate positions.\n\n:returns: `bool`"""
-    cdef readonly bint filter_unclaimed_external_orders
-    """If unclaimed order events with an EXTERNAL strategy ID should be filtered/dropped.\n\n:returns `bool`"""
     cdef readonly int command_count
     """The total count of commands received by the engine.\n\n:returns: `int`"""
     cdef readonly int event_count
     """The total count of events received by the engine.\n\n:returns: `int`"""
     cdef public int report_count
     """The total count of reports received by the engine.\n\n:returns: `int`"""
 
     cpdef int position_id_count(self, StrategyId strategy_id)
     cpdef bint check_integrity(self)
     cpdef bint check_connected(self)
     cpdef bint check_disconnected(self)
     cpdef bint check_residuals(self)
     cpdef StrategyId get_external_order_claim(self, InstrumentId instrument_id)
+    cpdef set get_external_order_claims_instruments(self)
 
 # -- REGISTRATION ---------------------------------------------------------------------------------
 
     cpdef void register_client(self, ExecutionClient client)
     cpdef void register_default_client(self, ExecutionClient client)
     cpdef void register_venue_routing(self, ExecutionClient client, Venue venue)
     cpdef void register_oms_type(self, Strategy strategy)
@@ -109,12 +108,12 @@
 
 # -- EVENT HANDLERS -------------------------------------------------------------------------------
 
     cpdef void _handle_event(self, OrderEvent event)
     cpdef OmsType _determine_oms_type(self, OrderFilled fill)
     cpdef void _determine_position_id(self, OrderFilled fill, OmsType oms_type)
     cpdef void _apply_event_to_order(self, Order order, OrderEvent event)
-    cpdef void _handle_order_fill(self, OrderFilled fill, OmsType oms_type)
-    cpdef void _open_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type)
+    cpdef void _handle_order_fill(self, Order order, OrderFilled fill, OmsType oms_type)
+    cpdef Position _open_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type)
     cpdef void _update_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type)
     cpdef bint _will_flip_position(self, Position position, OrderFilled fill)
     cpdef void _flip_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/engine.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/engine.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -30,14 +30,16 @@
 """
 
 from decimal import Decimal
 from typing import Optional
 
 from nautilus_trader.config import ExecEngineConfig
 from nautilus_trader.config.error import InvalidConfiguration
+from nautilus_trader.execution.reports import ExecutionMassStatus
+from nautilus_trader.execution.reports import ExecutionReport
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.cache.cache cimport Cache
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.component cimport Component
@@ -55,19 +57,14 @@
 from nautilus_trader.execution.client cimport ExecutionClient
 from nautilus_trader.execution.messages cimport CancelAllOrders
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
 from nautilus_trader.execution.messages cimport TradingCommand
-from nautilus_trader.execution.reports cimport ExecutionMassStatus
-from nautilus_trader.execution.reports cimport ExecutionReport
-from nautilus_trader.execution.reports cimport OrderStatusReport
-from nautilus_trader.execution.reports cimport PositionStatusReport
-from nautilus_trader.execution.reports cimport TradeReport
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport oms_type_to_str
 from nautilus_trader.model.events.order cimport OrderDenied
@@ -149,15 +146,14 @@
             trader_id=msgbus.trader_id,
             clock=clock,
         )
 
         # Settings
         self.debug: bool = config.debug
         self.allow_cash_positions: bool = config.allow_cash_positions
-        self.filter_unclaimed_external_orders: bool = config.filter_unclaimed_external_orders
 
         # Counters
         self.command_count: int = 0
         self.event_count: int = 0
         self.report_count: int = 0
 
         # Register endpoints
@@ -302,14 +298,25 @@
         StrategyId or ``None``
 
         """
         Condition.not_none(instrument_id, "instrument_id")
 
         return self._external_order_claims.get(instrument_id)
 
+    cpdef set get_external_order_claims_instruments(self):
+        """
+        Get all external order claims instrument IDs.
+
+        Returns
+        -------
+        set[InstrumentId]
+
+        """
+        return set(self._external_order_claims.keys())
+
 # -- REGISTRATION ---------------------------------------------------------------------------------
 
     cpdef void register_client(self, ExecutionClient client):
         """
         Register the given execution client with the execution engine.
 
         If the `client.venue` is ``None`` and a default routing client has not
@@ -563,25 +570,22 @@
 
     cpdef void load_cache(self):
         """
         Load the cache up from the execution database.
         """
         cdef uint64_t ts = unix_timestamp_ms()
 
-        # ***** WARNING *****
-        # Cache commands early so that `SubmitOrder` commands don't revert
-        # orders back to their initialized state.
         self._cache.cache_general()
-        self._cache.cache_commands()
         self._cache.cache_currencies()
         self._cache.cache_instruments()
         self._cache.cache_accounts()
         self._cache.cache_orders()
         self._cache.cache_order_lists()
         self._cache.cache_positions()
+
         self._cache.build_index()
         self._cache.check_integrity()
         self._set_position_id_counts()
 
         self._log.info(f"Loaded cache in {(unix_timestamp_ms() - ts)}ms.")
 
     cpdef void execute(self, TradingCommand command):
@@ -752,15 +756,15 @@
                 f"Cannot handle command: unrecognized {command}.",  # pragma: no cover (design-time error)
             )
 
     cpdef void _handle_submit_order(self, ExecutionClient client, SubmitOrder command):
         cdef Order order = command.order
         if not self._cache.order_exists(order.client_order_id):
             # Cache order
-            self._cache.add_order(order, command.position_id)
+            self._cache.add_order(order, command.position_id, command.client_id)
 
         cdef Instrument instrument = self._cache.instrument(order.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot handle submit order: "
                 f"no instrument found for {order.instrument_id}, {command}."
             )
@@ -781,15 +785,15 @@
         client.submit_order(command)
 
     cpdef void _handle_submit_order_list(self, ExecutionClient client, SubmitOrderList command):
         cdef Order order
         for order in command.order_list.orders:
             if not self._cache.order_exists(order.client_order_id):
                 # Cache order
-                self._cache.add_order(order, position_id=None)
+                self._cache.add_order(order, command.position_id, command.client_id)
 
         cdef Instrument instrument = self._cache.instrument(command.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot handle submit order list: "
                 f"no instrument found for {command.instrument_id}, {command}."
             )
@@ -880,15 +884,15 @@
             )
 
         cdef OmsType oms_type
         if isinstance(event, OrderFilled):
             oms_type = self._determine_oms_type(event)
             self._determine_position_id(event, oms_type)
             self._apply_event_to_order(order, event)
-            self._handle_order_fill(event, oms_type)
+            self._handle_order_fill(order, event, oms_type)
         else:
             self._apply_event_to_order(order, event)
 
     cpdef OmsType _determine_oms_type(self, OrderFilled fill):
         cdef ExecutionClient client
         # Check for strategy OMS override
         cdef OmsType oms_type = self._oms_overrides.get(fill.strategy_id, OmsType.UNSPECIFIED)
@@ -903,34 +907,40 @@
         return oms_type
 
     cpdef void _determine_position_id(self, OrderFilled fill, OmsType oms_type):
         # Fetch ID from cache
         cdef PositionId position_id = self._cache.position_id(fill.client_order_id)
         if self.debug:
             self._log.debug(
-                f"Determining position ID for {repr(fill.client_order_id)} = {repr(position_id)}.",
+                f"Determining position ID for {repr(fill.client_order_id)}, "
+                f"position_id={repr(position_id)}.",
                 LogColor.MAGENTA,
             )
         if position_id is not None:
             if fill.position_id is not None and fill.position_id != position_id:
                 self._log.error(
                     "Incorrect position ID assigned to fill: "
                     f"cached={repr(position_id)}, assigned={repr(fill.position_id)}. "
                     "re-assigning from cache.",
                 )
             # Assign position ID to fill
             fill.position_id = position_id
+            if self.debug:
+                self._log.debug(f"Assigned {repr(position_id)} to {fill}.", LogColor.MAGENTA)
             return
 
         if oms_type == OmsType.HEDGING:
             if fill.position_id is not None:
                 # Already assigned
                 return
             # Assign new position ID
-            fill.position_id = self._pos_id_generator.generate(fill.strategy_id)
+            position_id = self._pos_id_generator.generate(fill.strategy_id)
+            fill.position_id = position_id
+            if self.debug:
+                self._log.debug(f"Generated {repr(position_id)} for {fill}.", LogColor.MAGENTA)
         elif oms_type == OmsType.NETTING:
             # Assign netted position ID
             fill.position_id = PositionId(f"{fill.instrument_id.to_str()}-{fill.strategy_id.to_str()}")
         else:
             raise ValueError(  # pragma: no cover (design-time error)
                 f"invalid `OmsType`, was {oms_type}",  # pragma: no cover (design-time error)
             )
@@ -949,15 +959,15 @@
 
         self._cache.update_order(order)
         self._msgbus.publish_c(
             topic=f"events.order.{event.strategy_id.to_str()}",
             msg=event,
         )
 
-    cpdef void _handle_order_fill(self, OrderFilled fill, OmsType oms_type):
+    cpdef void _handle_order_fill(self, Order order, OrderFilled fill, OmsType oms_type):
         cdef Instrument instrument = self._cache.load_instrument(fill.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot handle order fill: "
                 f"no instrument found for {fill.instrument_id}, {fill}."
             )
             return
@@ -972,21 +982,38 @@
 
         if not self.allow_cash_positions and isinstance(instrument, CurrencyPair):
             if account.is_unleveraged(instrument.id):
                 return  # No spot cash positions
 
         cdef Position position = self._cache.position(fill.position_id)
         if position is None or position.is_closed_c():
-            self._open_position(instrument, position, fill, oms_type)
+            position = self._open_position(instrument, position, fill, oms_type)
         elif self._will_flip_position(position, fill):
             self._flip_position(instrument, position, fill, oms_type)
         else:
             self._update_position(instrument, position, fill, oms_type)
 
-    cpdef void _open_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type):
+        cdef:
+            ClientOrderId client_order_id
+            Order contingent_order
+        if order.contingency_type == ContingencyType.OTO and position is not None and position.is_open_c():
+            for client_order_id in order.linked_order_ids or []:
+                contingent_order = self._cache.order(client_order_id)
+                if contingent_order is not None and contingent_order.position_id is None:
+                    if contingent_order.is_reduce_only and contingent_order.quantity._mem.raw > position.quantity._mem.raw:
+                        return  # Cannot yet assign position ID as will reject `reduce_only` orders
+                    contingent_order.position_id = position.id
+                    self._cache.add_position_id(
+                        order.position_id,
+                        contingent_order.instrument_id.venue,
+                        contingent_order.client_order_id,
+                        contingent_order.strategy_id,
+                    )
+
+    cpdef Position _open_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type):
         if position is None:
             position = Position(instrument, fill)
             self._cache.add_position(position, oms_type)
         else:
             try:
                 self._cache.snapshot_position(position)
                 position.apply(fill)
@@ -1004,14 +1031,16 @@
         )
 
         self._msgbus.publish_c(
             topic=f"events.position.{event.strategy_id.to_str()}",
             msg=event,
         )
 
+        return position
+
     cpdef void _update_position(self, Instrument instrument, Position position, OrderFilled fill, OmsType oms_type):
         try:
             position.apply(fill)
         except KeyError as e:
             # Protected against duplicate OrderFilled
             self._log.exception(f"Error on applying {repr(fill)} to {repr(position)}", e)
             return  # Not re-raising to avoid crashing engine
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pxd` & `nautilus_trader-1.176.0/nautilus_trader/execution/matching_core.pxd`

 * *Files 8% similar despite different names*

```diff
@@ -10,26 +10,29 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport int64_t
+from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.identifiers cimport ClientOrderId
-from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orders.base cimport Order
 
 
 cdef class MatchingCore:
-    cdef Instrument _instrument
+    cdef InstrumentId _instrument_id
+    cdef Price _price_increment
+    cdef uint8_t _price_precision
     cdef readonly int64_t bid_raw
     cdef readonly int64_t ask_raw
     cdef readonly int64_t last_raw
     cdef readonly bint is_bid_initialized
     cdef readonly bint is_ask_initialized
     cdef readonly bint is_last_initialized
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/matching_core.pyx`

 * *Files 12% similar despite different names*

```diff
@@ -28,32 +28,37 @@
 
 cdef class MatchingCore:
     """
     Provides a generic order matching core.
 
     Parameters
     ----------
-    instrument : Instrument
-        The instrument for the matching core.
+    instrument_id : InstrumentId
+        The instrument ID for the matching core.
+    price_increment : Price
+        The minimum price increment (tick size) for the matching core.
     trigger_stop_order : Callable[[Order], None]
         The callable when a stop order is triggered.
     fill_market_order : Callable[[Order], None]
         The callable when a market order is filled.
     fill_limit_order : Callable[[Order], None]
         The callable when a limit order is filled.
     """
 
     def __init__(
         self,
-        Instrument instrument not None,
+        InstrumentId instrument_id not None,
+        Price price_increment not None,
         trigger_stop_order not None: Callable,
         fill_market_order not None: Callable,
         fill_limit_order not None: Callable,
     ):
-        self._instrument = instrument
+        self._instrument_id = instrument_id
+        self._price_increment = price_increment
+        self._price_precision = price_increment.precision
 
         # Market
         self.bid_raw = 0
         self.ask_raw = 0
         self.last_raw = 0
         self.is_bid_initialized = False
         self.is_ask_initialized = False
@@ -66,57 +71,93 @@
 
         # Orders
         self._orders: dict[ClientOrderId, Order] = {}
         self._orders_bid: list[Order] = []
         self._orders_ask: list[Order] = []
 
     @property
+    def instrument_id(self) -> InstrumentId:
+        """
+        Return the instrument ID for the matching core.
+
+        Returns
+        -------
+        InstrumentId
+
+        """
+        return self._instrument_id
+
+    @property
+    def price_precision(self) -> int:
+        """
+        Return the instruments price precision for the matching core.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._price_increment.precision
+
+    @property
+    def price_increment(self) -> Price:
+        """
+        Return the instruments minimum price increment (tick size) for the matching core.
+
+        Returns
+        -------
+        Price
+
+        """
+        return self._price_increment
+
+    @property
     def bid(self) -> Optional[Price]:
         """
         Return the current bid price for the matching core.
 
         Returns
         -------
         Price or ``None``
 
         """
         if not self.is_bid_initialized:
             return None
         else:
-            return Price.from_raw_c(self.bid_raw, self._instrument.price_precision)
+            return Price.from_raw_c(self.bid_raw, self._price_precision)
 
     @property
     def ask(self) -> Optional[Price]:
         """
         Return the current ask price for the matching core.
 
         Returns
         -------
         Price or ``None``
 
         """
         if not self.is_ask_initialized:
             return None
         else:
-            return Price.from_raw_c(self.ask_raw, self._instrument.price_precision)
+            return Price.from_raw_c(self.ask_raw, self._price_precision)
 
     @property
     def last(self) -> Optional[Price]:
         """
         Return the current last price for the matching core.
 
         Returns
         -------
         Price or ``None``
 
         """
         if not self.is_last_initialized:
             return None
         else:
-            return Price.from_raw_c(self.last_raw, self._instrument.price_precision)
+            return Price.from_raw_c(self.last_raw, self._price_precision)
 
 # -- QUERIES --------------------------------------------------------------------------------------
 
     cpdef Order get_order(self, ClientOrderId client_order_id):
         return self._orders.get(client_order_id)
 
     cpdef bint order_exists(self, ClientOrderId client_order_id):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/messages.pxd` & `nautilus_trader-1.176.0/nautilus_trader/execution/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/messages.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/messages.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/reports.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/events/order.pxd`

 * *Files 18% similar despite different names*

```diff
@@ -9,151 +9,244 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from cpython.datetime cimport datetime
-from libc.stdint cimport uint64_t
-
-from nautilus_trader.core.message cimport Document
+from nautilus_trader.core.message cimport Event
+from nautilus_trader.core.rust.model cimport OrderDenied_t
+from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OrderSide
-from nautilus_trader.model.enums_c cimport OrderStatus
 from nautilus_trader.model.enums_c cimport OrderType
-from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport TimeInForce
-from nautilus_trader.model.enums_c cimport TrailingOffsetType
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.identifiers cimport AccountId
-from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
+from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
+from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TradeId
-from nautilus_trader.model.identifiers cimport Venue
+from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.identifiers cimport VenueOrderId
 from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
-cdef class ExecutionReport(Document):
-    cdef readonly AccountId account_id
-    """The account ID for the report.\n\n:returns: `AccountId`"""
+cdef class OrderEvent(Event):
+    cdef readonly TraderId trader_id
+    """The trader ID associated with the event.\n\n:returns: `TraderId`"""
+    cdef readonly StrategyId strategy_id
+    """The strategy ID associated with the event.\n\n:returns: `StrategyId`"""
     cdef readonly InstrumentId instrument_id
-    """The instrument ID for the report.\n\n:returns: `InstrumentId`"""
-
-
-cdef class OrderStatusReport(ExecutionReport):
+    """The instrument ID associated with the event.\n\n:returns: `InstrumentId`"""
     cdef readonly ClientOrderId client_order_id
-    """The client order ID for the report.\n\n:returns: `ClientOrderId` or ``None``"""
-    cdef readonly OrderListId order_list_id
-    """The reported order list ID.\n\n:returns: `OrderListId` or ``None``"""
+    """The client order ID associated with the event.\n\n:returns: `ClientOrderId`"""
     cdef readonly VenueOrderId venue_order_id
-    """The reported venue order ID (assigned by the venue).\n\n:returns: `VenueOrderId`"""
-    cdef readonly OrderSide order_side
-    """The reported order side.\n\n:returns: `OrderSide`"""
+    """The venue order ID associated with the event.\n\n:returns: `VenueOrderId` or ``None``"""
+    cdef readonly AccountId account_id
+    """The account ID associated with the event.\n\n:returns: `AccountId` or ``None``"""
+    cdef readonly bint reconciliation
+    """If the event was generated during reconciliation.\n\n:returns: `bool`"""
+
+
+cdef class OrderInitialized(OrderEvent):
+    cdef readonly OrderSide side
+    """The order side.\n\n:returns: `OrderSide`"""
     cdef readonly OrderType order_type
-    """The reported order type.\n\n:returns: `OrderType`"""
-    cdef readonly ContingencyType contingency_type
-    """The reported orders contingency type.\n\n:returns: `ContingencyType`"""
-    cdef readonly TimeInForce time_in_force
-    """The reported order time in force.\n\n:returns: `TimeInForce`"""
-    cdef readonly datetime expire_time
-    """The order expiration.\n\n:returns: `datetime` or ``None``"""
-    cdef readonly OrderStatus order_status
-    """The reported order status at the exchange.\n\n:returns: `OrderStatus`"""
-    cdef readonly Price price
-    """The reported order price (LIMIT).\n\n:returns: `Price` or ``None``"""
-    cdef readonly Price trigger_price
-    """The reported order trigger price (STOP).\n\n:returns: `Price` or ``None``"""
-    cdef readonly TriggerType trigger_type
-    """The trigger type for the order.\n\n:returns: `TriggerType`"""
-    cdef readonly object limit_offset
-    """The trailing offset for the orders limit price.\n\n:returns: `Decimal`"""
-    cdef readonly object trailing_offset
-    """The trailing offset for the orders trigger price (STOP).\n\n:returns: `Decimal`"""
-    cdef readonly TrailingOffsetType trailing_offset_type
-    """The trailing offset type.\n\n:returns: `TrailingOffsetType`"""
+    """The order type.\n\n:returns: `OrderType`"""
     cdef readonly Quantity quantity
-    """The reported order original quantity.\n\n:returns: `Quantity`"""
-    cdef readonly Quantity filled_qty
-    """The reported filled quantity.\n\n:returns: `Quantity`"""
-    cdef readonly Quantity leaves_qty
-    """The reported order total leaves quantity.\n\n:returns: `Quantity`"""
-    cdef readonly Quantity display_qty
-    """The reported order quantity displayed on the public book (iceberg).\n\n:returns: `Quantity` or ``None``"""
-    cdef readonly object avg_px
-    """The reported order average fill price.\n\n:returns: `Decimal` or ``None``"""
+    """The order quantity.\n\n:returns: `Quantity`"""
+    cdef readonly TimeInForce time_in_force
+    """The order time in force.\n\n:returns: `TimeInForce`"""
     cdef readonly bint post_only
-    """If the reported order will only provide liquidity (make a market).\n\n:returns: `bool`"""
+    """If the order will only provide liquidity (make a market).\n\n:returns: `bool`"""
     cdef readonly bint reduce_only
-    """If the reported order carries the 'reduce-only' execution instruction.\n\n:returns: `bool`"""
-    cdef readonly str cancel_reason
-    """The reported reason for order cancellation.\n\n:returns: `str` or ``None``"""
-    cdef readonly uint64_t ts_accepted
-    """The UNIX timestamp (nanoseconds) when the reported order was accepted.\n\n:returns: `uint64_t`"""
-    cdef readonly uint64_t ts_triggered
-    """The UNIX timestamp (nanoseconds) when the order was triggered (0 if not triggered).\n\n:returns: `uint64_t`"""
-    cdef readonly uint64_t ts_last
-    """The UNIX timestamp (nanoseconds) of the last order status change.\n\n:returns: `uint64_t`"""
+    """If the order carries the 'reduce-only' execution instruction.\n\n:returns: `bool`"""
+    cdef readonly bint quote_quantity
+    """If the order quantity is denominated in the quote currency.\n\n:returns: `bool`"""
+    cdef readonly dict options
+    """The order initialization options.\n\n:returns: `dict`"""
+    cdef readonly TriggerType emulation_trigger
+    """The order emulation trigger type.\n\n:returns: `TriggerType`"""
+    cdef readonly InstrumentId trigger_instrument_id
+    """The order emulation trigger instrument ID (will be `instrument_id` if ``None``).\n\n:returns: `InstrumentId` or ``None``"""
+    cdef readonly ContingencyType contingency_type
+    """The orders contingency type.\n\n:returns: `ContingencyType`"""
+    cdef readonly OrderListId order_list_id
+    """The order list ID associated with the order.\n\n:returns: `OrderListId` or ``None``"""
+    cdef readonly list linked_order_ids
+    """The orders linked client order ID(s).\n\n:returns: `list[ClientOrderId]` or ``None``"""
+    cdef readonly ClientOrderId parent_order_id
+    """The orders parent client order ID.\n\n:returns: `ClientOrderId` or ``None``"""
+    cdef readonly ExecAlgorithmId exec_algorithm_id
+    """The execution algorithm ID for the order.\n\n:returns: `ExecAlgorithmId` or ``None``"""
+    cdef readonly dict exec_algorithm_params
+    """The execution algorithm parameters for the order.\n\n:returns: `dict[str, Any]` or ``None``"""
+    cdef readonly ClientOrderId exec_spawn_id
+    """The execution algorithm spawning client order ID.\n\n:returns: `ClientOrderId` or ``None``"""
+    cdef readonly str tags
+    """The order custom user tags.\n\n:returns: `str` or ``None``"""
 
+    @staticmethod
+    cdef OrderInitialized from_dict_c(dict values)
 
-cdef class TradeReport(ExecutionReport):
-    cdef readonly ClientOrderId client_order_id
-    """The client order ID for the report.\n\n:returns: `ClientOrderId` or ``None``"""
-    cdef readonly VenueOrderId venue_order_id
-    """The reported venue order ID (assigned by the venue).\n\n:returns: `VenueOrderId`"""
-    cdef readonly PositionId venue_position_id
-    """The reported venue position ID (assigned by the venue).\n\n:returns: `PositionId` or ``None``"""
-    cdef readonly TradeId trade_id
-    """The reported trade match ID (assigned by the venue).\n\n:returns: `TradeId`"""
-    cdef readonly OrderSide order_side
-    """The reported trades side.\n\n:returns: `OrderSide`"""
-    cdef readonly Quantity last_qty
-    """The reported quantity of the last fill.\n\n:returns: `Quantity`"""
-    cdef readonly Price last_px
-    """The reported price of the last fill.\n\n:returns: `Price`"""
-    cdef readonly Money commission
-    """The reported commission.\n\n:returns: `Money`"""
-    cdef readonly LiquiditySide liquidity_side
-    """The reported liquidity side.\n\n:returns: `LiquiditySide`"""
-    cdef readonly uint64_t ts_event
-    """The UNIX timestamp (nanoseconds) when the execution event occurred.\n\n:returns: `LiquiditySide`"""
+    @staticmethod
+    cdef dict to_dict_c(OrderInitialized obj)
+
+
+cdef class OrderDenied(OrderEvent):
+    cdef OrderDenied_t _mem
+
+    @staticmethod
+    cdef OrderDenied from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderDenied obj)
+
+
+
+cdef class OrderSubmitted(OrderEvent):
+
+    @staticmethod
+    cdef OrderSubmitted from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderSubmitted obj)
+
+
+cdef class OrderAccepted(OrderEvent):
+
+    @staticmethod
+    cdef OrderAccepted from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderAccepted obj)
+
+
+cdef class OrderRejected(OrderEvent):
+    cdef readonly str reason
+    """The reason the order was rejected.\n\n:returns: `str`"""
+
+    @staticmethod
+    cdef OrderRejected from_dict_c(dict values)
 
+    @staticmethod
+    cdef dict to_dict_c(OrderRejected obj)
 
-cdef class PositionStatusReport(ExecutionReport):
-    cdef readonly PositionId venue_position_id
-    """The reported venue position ID (assigned by the venue).\n\n:returns: `PositionId` or ``None``"""
-    cdef readonly PositionSide position_side
-    """The reported position side at the exchange.\n\n:returns: `PositionSide`"""
+
+cdef class OrderCanceled(OrderEvent):
+
+    @staticmethod
+    cdef OrderCanceled from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderCanceled obj)
+
+
+cdef class OrderExpired(OrderEvent):
+
+    @staticmethod
+    cdef OrderExpired from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderExpired obj)
+
+
+cdef class OrderTriggered(OrderEvent):
+
+    @staticmethod
+    cdef OrderTriggered from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderTriggered obj)
+
+
+cdef class OrderPendingUpdate(OrderEvent):
+
+    @staticmethod
+    cdef OrderPendingUpdate from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderPendingUpdate obj)
+
+
+cdef class OrderPendingCancel(OrderEvent):
+
+    @staticmethod
+    cdef OrderPendingCancel from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderPendingCancel obj)
+
+
+cdef class OrderModifyRejected(OrderEvent):
+    cdef readonly str reason
+    """The reason for modify order rejection.\n\n:returns: `str`"""
+
+    @staticmethod
+    cdef OrderModifyRejected from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderModifyRejected obj)
+
+
+cdef class OrderCancelRejected(OrderEvent):
+    cdef readonly str reason
+    """The reason for order cancel rejection.\n\n:returns: `str`"""
+
+    @staticmethod
+    cdef OrderCancelRejected from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderCancelRejected obj)
+
+
+cdef class OrderUpdated(OrderEvent):
     cdef readonly Quantity quantity
-    """The reported position quantity at the exchange.\n\n:returns: `Quantity`"""
-    cdef readonly object signed_decimal_qty
-    """The reported signed decimal quantity (positive for ``LONG``, negative for ``SHORT``).\n\n:returns: `Decimal`"""
-    cdef readonly uint64_t ts_last
-    """The UNIX timestamp (nanoseconds) of the last position change.\n\n:returns: `uint64_t`"""
+    """The orders current quantity.\n\n:returns: `Quantity`"""
+    cdef readonly Price price
+    """The orders current price.\n\n:returns: `Price`"""
+    cdef readonly Price trigger_price
+    """The orders current trigger price.\n\n:returns: `Price` or ``None``"""
 
+    @staticmethod
+    cdef OrderUpdated from_dict_c(dict values)
 
-cdef class ExecutionMassStatus(Document):
-    cdef dict _order_reports
-    cdef dict _trade_reports
-    cdef dict _position_reports
+    @staticmethod
+    cdef dict to_dict_c(OrderUpdated obj)
 
-    cdef readonly ClientId client_id
-    """The client ID for the report.\n\n:returns: `ClientId`"""
-    cdef readonly AccountId account_id
-    """The account ID for the report.\n\n:returns: `AccountId`"""
-    cdef readonly Venue venue
-    """The venue for the report.\n\n:returns: `Venue`"""
-
-    cpdef dict order_reports(self)
-    cpdef dict trade_reports(self)
-    cpdef dict position_reports(self)
-
-    cpdef void add_order_reports(self, list reports)
-    cpdef void add_trade_reports(self, list reports)
-    cpdef void add_position_reports(self, list reports)
+
+cdef class OrderFilled(OrderEvent):
+    cdef readonly TradeId trade_id
+    """The trade match ID (assigned by the venue).\n\n:returns: `TradeId`"""
+    cdef readonly PositionId position_id
+    """The position ID (assigned by the venue).\n\n:returns: `PositionId` or ``None``"""
+    cdef readonly OrderSide order_side
+    """The order side.\n\n:returns: `OrderSide`"""
+    cdef readonly OrderType order_type
+    """The order type.\n\n:returns: `OrderType`"""
+    cdef readonly Quantity last_qty
+    """The fill quantity.\n\n:returns: `Quantity`"""
+    cdef readonly Price last_px
+    """The fill price for this execution.\n\n:returns: `Price`"""
+    cdef readonly Currency currency
+    """The currency of the price.\n\n:returns: `Currency`"""
+    cdef readonly Money commission
+    """The commission generated from the fill.\n\n:returns: `Money`"""
+    cdef readonly LiquiditySide liquidity_side
+    """The liquidity side of the event {``MAKER``, ``TAKER``}.\n\n:returns: `LiquiditySide`"""
+    cdef readonly dict info
+    """The additional fill information.\n\n:returns: `dict[str, object]`"""
+
+    @staticmethod
+    cdef OrderFilled from_dict_c(dict values)
+
+    @staticmethod
+    cdef dict to_dict_c(OrderFilled obj)
+    cdef bint is_buy_c(self)
+    cdef bint is_sell_c(self)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/reports.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/reports.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,68 +9,75 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from decimal import Decimal
-from typing import Optional
+from __future__ import annotations
 
-from cpython.datetime cimport datetime
-from libc.stdint cimport uint64_t
+from datetime import datetime
+from decimal import Decimal
 
-from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.message cimport Document
-from nautilus_trader.core.uuid cimport UUID4
-from nautilus_trader.model.enums_c cimport ContingencyType
-from nautilus_trader.model.enums_c cimport LiquiditySide
-from nautilus_trader.model.enums_c cimport OrderStatus
-from nautilus_trader.model.enums_c cimport PositionSide
-from nautilus_trader.model.enums_c cimport TrailingOffsetType
-from nautilus_trader.model.enums_c cimport TriggerType
-from nautilus_trader.model.enums_c cimport contingency_type_to_str
-from nautilus_trader.model.enums_c cimport liquidity_side_to_str
-from nautilus_trader.model.enums_c cimport order_side_to_str
-from nautilus_trader.model.enums_c cimport order_status_to_str
-from nautilus_trader.model.enums_c cimport order_type_to_str
-from nautilus_trader.model.enums_c cimport position_side_to_str
-from nautilus_trader.model.enums_c cimport time_in_force_to_str
-from nautilus_trader.model.enums_c cimport trailing_offset_type_to_str
-from nautilus_trader.model.enums_c cimport trigger_type_to_str
-from nautilus_trader.model.identifiers cimport AccountId
-from nautilus_trader.model.identifiers cimport ClientOrderId
-from nautilus_trader.model.identifiers cimport InstrumentId
-from nautilus_trader.model.identifiers cimport TradeId
-from nautilus_trader.model.identifiers cimport Venue
-from nautilus_trader.model.identifiers cimport VenueOrderId
-from nautilus_trader.model.objects cimport Quantity
+from nautilus_trader.core.correctness import PyCondition
+from nautilus_trader.core.message import Document
+from nautilus_trader.core.uuid import UUID4
+from nautilus_trader.model.enums import ContingencyType
+from nautilus_trader.model.enums import LiquiditySide
+from nautilus_trader.model.enums import OrderSide
+from nautilus_trader.model.enums import OrderStatus
+from nautilus_trader.model.enums import OrderType
+from nautilus_trader.model.enums import PositionSide
+from nautilus_trader.model.enums import TimeInForce
+from nautilus_trader.model.enums import TrailingOffsetType
+from nautilus_trader.model.enums import TriggerType
+from nautilus_trader.model.enums import contingency_type_to_str
+from nautilus_trader.model.enums import liquidity_side_to_str
+from nautilus_trader.model.enums import order_side_to_str
+from nautilus_trader.model.enums import order_status_to_str
+from nautilus_trader.model.enums import order_type_to_str
+from nautilus_trader.model.enums import position_side_to_str
+from nautilus_trader.model.enums import time_in_force_to_str
+from nautilus_trader.model.enums import trailing_offset_type_to_str
+from nautilus_trader.model.enums import trigger_type_to_str
+from nautilus_trader.model.identifiers import AccountId
+from nautilus_trader.model.identifiers import ClientId
+from nautilus_trader.model.identifiers import ClientOrderId
+from nautilus_trader.model.identifiers import InstrumentId
+from nautilus_trader.model.identifiers import OrderListId
+from nautilus_trader.model.identifiers import PositionId
+from nautilus_trader.model.identifiers import TradeId
+from nautilus_trader.model.identifiers import Venue
+from nautilus_trader.model.identifiers import VenueOrderId
+from nautilus_trader.model.objects import Money
+from nautilus_trader.model.objects import Price
+from nautilus_trader.model.objects import Quantity
 
 
-cdef class ExecutionReport(Document):
+class ExecutionReport(Document):
     """
     The base class for all execution reports.
     """
 
     def __init__(
         self,
-        AccountId account_id not None,
-        InstrumentId instrument_id not None,
-        UUID4 report_id not None,
-        uint64_t ts_init,
-    ):
+        account_id: AccountId,
+        instrument_id: InstrumentId,
+        report_id: UUID4,
+        ts_init: int,
+    ) -> None:
         super().__init__(
             report_id,
             ts_init,
         )
         self.account_id = account_id
         self.instrument_id = instrument_id
 
 
-cdef class OrderStatusReport(ExecutionReport):
+class OrderStatusReport(ExecutionReport):
     """
     Represents an order status at a point in time.
 
     Parameters
     ----------
     account_id : AccountId
         The account ID for the report.
@@ -88,19 +95,19 @@
         The reported order status at the exchange.
     quantity : Quantity
         The reported order original quantity.
     filled_qty : Quantity
         The reported filled quantity at the exchange.
     report_id : UUID4
         The report ID.
-    ts_accepted : uint64_t
+    ts_accepted : int
         The UNIX timestamp (nanoseconds) when the reported order was accepted.
-    ts_last : uint64_t
+    ts_last : int
         The UNIX timestamp (nanoseconds) of the last order status change.
-    ts_init : uint64_t
+    ts_init : int
         The UNIX timestamp (nanoseconds) when the object was initialized.
     client_order_id : ClientOrderId, optional
         The reported client order ID.
     order_list_id : OrderListId, optional
         The reported order list ID associated with the order.
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The reported order contingency type.
@@ -124,67 +131,73 @@
         The reported order quantity displayed on the public book (iceberg).
     post_only : bool, default False
         If the reported order will only provide liquidity (make a market).
     reduce_only : bool, default False
         If the reported order carries the 'reduce-only' execution instruction.
     cancel_reason : str, optional
         The reported reason for order cancellation.
-    ts_triggered : uint64_t, optional
+    ts_triggered : int, optional
         The UNIX timestamp (nanoseconds) when the object was initialized.
 
     Raises
     ------
     ValueError
         If `quantity` is not positive (> 0).
     ValueError
         If `filled_qty` is negative (< 0).
     ValueError
         If `trigger_price` is not ``None`` and `trigger_price` is equal to ``NO_TRIGGER``.
     ValueError
         If `limit_offset` or `trailing_offset` is not ``None`` and trailing_offset_type is equal to ``NO_TRAILING_OFFSET``.
+
     """
 
     def __init__(
         self,
-        AccountId account_id not None,
-        InstrumentId instrument_id not None,
-        VenueOrderId venue_order_id not None,
-        OrderSide order_side,
-        OrderType order_type,
-        TimeInForce time_in_force,
-        OrderStatus order_status,
-        Quantity quantity not None,
-        Quantity filled_qty not None,
-        UUID4 report_id not None,
-        uint64_t ts_accepted,
-        uint64_t ts_last,
-        uint64_t ts_init,
-        ClientOrderId client_order_id: Optional[ClientOrderId] = None,  # (None if external order)
-        OrderListId order_list_id: Optional[OrderListId] = None,
-        ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
-        datetime expire_time: Optional[datetime] = None,
-        Price price: Optional[Price] = None,
-        Price trigger_price: Optional[Price] = None,
-        TriggerType trigger_type = TriggerType.NO_TRIGGER,
-        limit_offset: Optional[Decimal] = None,
-        trailing_offset: Optional[Decimal] = None,
-        TrailingOffsetType trailing_offset_type = TrailingOffsetType.NO_TRAILING_OFFSET,
-        avg_px: Optional[Decimal] = None,
-        Quantity display_qty: Optional[Quantity] = None,
-        bint post_only = False,
-        bint reduce_only = False,
-        str cancel_reason: Optional[str] = None,
-        ts_triggered: Optional[int] = None,
-    ):
-        Condition.positive(quantity, "quantity")
-        Condition.not_negative(filled_qty, "filled_qty")
-        if trigger_price is not None:
-            Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NONE")
+        account_id: AccountId,
+        instrument_id: InstrumentId,
+        venue_order_id: VenueOrderId,
+        order_side: OrderSide,
+        order_type: OrderType,
+        time_in_force: TimeInForce,
+        order_status: OrderStatus,
+        quantity: Quantity,
+        filled_qty: Quantity,
+        report_id: UUID4,
+        ts_accepted: int,
+        ts_last: int,
+        ts_init: int,
+        client_order_id: ClientOrderId | None = None,  # (None if external order)
+        order_list_id: OrderListId | None = None,
+        contingency_type: ContingencyType = ContingencyType.NO_CONTINGENCY,
+        expire_time: datetime | None = None,
+        price: Price | None = None,
+        trigger_price: Price | None = None,
+        trigger_type: TriggerType = TriggerType.NO_TRIGGER,
+        limit_offset: Decimal | None = None,
+        trailing_offset: Decimal | None = None,
+        trailing_offset_type: TrailingOffsetType = TrailingOffsetType.NO_TRAILING_OFFSET,
+        avg_px: Decimal | None = None,
+        display_qty: Quantity | None = None,
+        post_only: bool = False,
+        reduce_only: bool = False,
+        cancel_reason: str | None = None,
+        ts_triggered: int | None = None,
+    ) -> None:
+        PyCondition.positive(quantity, "quantity")
+        PyCondition.not_negative(filled_qty, "filled_qty")
+        if trigger_price is not None and trigger_price > 0:
+            PyCondition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NONE")
         if limit_offset is not None or trailing_offset is not None:
-            Condition.not_equal(trailing_offset_type, TrailingOffsetType.NO_TRAILING_OFFSET, "trailing_offset_type", "NO_TRAILING_OFFSET")
+            PyCondition.not_equal(
+                trailing_offset_type,
+                TrailingOffsetType.NO_TRAILING_OFFSET,
+                "trailing_offset_type",
+                "NO_TRAILING_OFFSET",
+            )
 
         super().__init__(
             account_id,
             instrument_id,
             report_id,
             ts_init,
         )
@@ -201,40 +214,45 @@
         self.trigger_price = trigger_price
         self.trigger_type = trigger_type
         self.limit_offset = limit_offset
         self.trailing_offset = trailing_offset
         self.trailing_offset_type = trailing_offset_type
         self.quantity = quantity
         self.filled_qty = filled_qty
-        self.leaves_qty = Quantity(self.quantity.as_f64_c() - self.filled_qty.as_f64_c(), self.quantity._mem.precision)
+        self.leaves_qty = Quantity(
+            self.quantity - self.filled_qty,
+            self.quantity.precision,
+        )
         self.display_qty = display_qty
         self.avg_px = avg_px
         self.post_only = post_only
         self.reduce_only = reduce_only
         self.cancel_reason = cancel_reason
         self.ts_accepted = ts_accepted
         self.ts_triggered = ts_triggered or 0
         self.ts_last = ts_last
 
-    def __eq__(self, OrderStatusReport other) -> bool:
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, OrderStatusReport):
+            return False
         return (
             self.account_id == other.account_id
             and self.instrument_id == other.instrument_id
             and self.venue_order_id == other.venue_order_id
             and self.ts_accepted == other.ts_accepted
         )
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
-            f"account_id={self.account_id.to_str()}, "
-            f"instrument_id={self.instrument_id.to_str()}, "
+            f"account_id={self.account_id}, "
+            f"instrument_id={self.instrument_id}, "
             f"client_order_id={self.client_order_id}, "
             f"order_list_id={self.order_list_id}, "  # Can be None
-            f"venue_order_id={self.venue_order_id.to_str()}, "  # Can be None
+            f"venue_order_id={self.venue_order_id}, "  # Can be None
             f"order_side={order_side_to_str(self.order_side)}, "
             f"order_type={order_type_to_str(self.order_type)}, "
             f"contingency_type={contingency_type_to_str(self.contingency_type)}, "
             f"time_in_force={time_in_force_to_str(self.time_in_force)}, "
             f"expire_time={self.expire_time}, "
             f"order_status={order_status_to_str(self.order_status)}, "
             f"price={self.price}, "
@@ -242,28 +260,28 @@
             f"trigger_type={trigger_type_to_str(self.trigger_type)}, "
             f"limit_offset={self.limit_offset}, "
             f"trailing_offset={self.trailing_offset}, "
             f"trailing_offset_type={trailing_offset_type_to_str(self.trailing_offset_type)}, "
             f"quantity={self.quantity.to_str()}, "
             f"filled_qty={self.filled_qty.to_str()}, "
             f"leaves_qty={self.leaves_qty.to_str()}, "
-            f"display_qty={self.display_qty.to_str() if self.display_qty is not None else None}, "
+            f"display_qty={self.display_qty}, "
             f"avg_px={self.avg_px}, "
             f"post_only={self.post_only}, "
             f"reduce_only={self.reduce_only}, "
             f"cancel_reason={self.cancel_reason}, "
             f"report_id={self.id}, "
             f"ts_accepted={self.ts_accepted}, "
             f"ts_triggered={self.ts_triggered}, "
             f"ts_last={self.ts_last}, "
             f"ts_init={self.ts_init})"
         )
 
 
-cdef class TradeReport(ExecutionReport):
+class TradeReport(ExecutionReport):
     """
     Represents a report of a single trade.
 
     Parameters
     ----------
     account_id : AccountId
         The account ID for the report.
@@ -279,17 +297,17 @@
         The reported quantity of the trade.
     last_px : Price
         The reported price of the trade.
     liquidity_side : LiquiditySide {``NO_LIQUIDITY_SIDE``, ``MAKER``, ``TAKER``}
         The reported liquidity side for the trade.
     report_id : UUID4
         The report ID.
-    ts_event : uint64_t
+    ts_event : int
         The UNIX timestamp (nanoseconds) when the trade occurred.
-    ts_init : uint64_t
+    ts_init : int
         The UNIX timestamp (nanoseconds) when the object was initialized.
     client_order_id : ClientOrderId, optional
         The reported client order ID for the trade.
     venue_position_id : PositionId, optional
         The reported venue position ID for the trade. If the trading venue has
         assigned a position ID / ticket for the trade then pass that here,
         otherwise pass ``None`` and the execution engine OMS will handle
@@ -297,34 +315,35 @@
     commission : Money, optional
         The reported commission for the trade (can be ``None``).
 
     Raises
     ------
     ValueError
         If `last_qty` is not positive (> 0).
+
     """
 
     def __init__(
         self,
-        AccountId account_id not None,
-        InstrumentId instrument_id not None,
-        VenueOrderId venue_order_id not None,
-        TradeId trade_id not None,
-        OrderSide order_side,
-        Quantity last_qty not None,
-        Price last_px not None,
-        LiquiditySide liquidity_side,
-        UUID4 report_id not None,
-        uint64_t ts_event,
-        uint64_t ts_init,
-        ClientOrderId client_order_id: Optional[ClientOrderId] = None,  # (None if external order)
-        PositionId venue_position_id: Optional[PositionId] = None,
-        Money commission: Optional[Money] = None,
-    ):
-        Condition.positive(last_qty, "last_qty")
+        account_id: AccountId,
+        instrument_id: InstrumentId,
+        venue_order_id: VenueOrderId,
+        trade_id: TradeId,
+        order_side: OrderSide,
+        last_qty: Quantity,
+        last_px: Price,
+        liquidity_side: LiquiditySide,
+        report_id: UUID4,
+        ts_event: int,
+        ts_init: int,
+        client_order_id: ClientOrderId | None = None,  # (None if external order)
+        venue_position_id: PositionId | None = None,
+        commission: Money | None = None,
+    ) -> None:
+        PyCondition.positive(last_qty, "last_qty")
 
         super().__init__(
             account_id,
             instrument_id,
             report_id,
             ts_init,
         )
@@ -335,44 +354,46 @@
         self.order_side = order_side
         self.last_qty = last_qty
         self.last_px = last_px
         self.commission = commission
         self.liquidity_side = liquidity_side
         self.ts_event = ts_event
 
-    def __eq__(self, TradeReport other) -> bool:
+    def __eq__(self, other: object) -> bool:
+        if not isinstance(other, TradeReport):
+            return False
         return (
             self.account_id == other.account_id
             and self.instrument_id == other.instrument_id
             and self.venue_order_id == other.venue_order_id
             and self.trade_id == other.trade_id
             and self.ts_event == other.ts_event
         )
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
-            f"account_id={self.account_id.to_str()}, "
-            f"instrument_id={self.instrument_id.to_str()}, "
-            f"client_order_id={self.client_order_id}, "  # Can be None
-            f"venue_order_id={self.venue_order_id.to_str()}, "
-            f"venue_position_id={self.venue_position_id}, "  # Can be None
-            f"trade_id={self.trade_id.to_str()}, "
+            f"account_id={self.account_id}, "
+            f"instrument_id={self.instrument_id}, "
+            f"client_order_id={self.client_order_id}, "
+            f"venue_order_id={self.venue_order_id}, "
+            f"venue_position_id={self.venue_position_id}, "
+            f"trade_id={self.trade_id}, "
             f"order_side={order_side_to_str(self.order_side)}, "
             f"last_qty={self.last_qty.to_str()}, "
             f"last_px={self.last_px}, "
-            f"commission={self.commission.to_str() if self.commission is not None else None}, "  # Can be None
+            f"commission={self.commission.to_str() if self.commission is not None else None}, "
             f"liquidity_side={liquidity_side_to_str(self.liquidity_side)}, "
             f"report_id={self.id}, "
             f"ts_event={self.ts_event}, "
             f"ts_init={self.ts_init})"
         )
 
 
-cdef class PositionStatusReport(ExecutionReport):
+class PositionStatusReport(ExecutionReport):
     """
     Represents a position status at a point in time.
 
     Parameters
     ----------
     account_id : AccountId
         The account ID for the report.
@@ -380,90 +401,96 @@
         The reported instrument ID for the position.
     position_side : PositionSide {``FLAT``, ``LONG``, ``SHORT``}
         The reported position side at the exchange.
     quantity : Quantity
         The reported position quantity at the exchange.
     report_id : UUID4
         The report ID.
-    ts_last : uint64_t
+    ts_last : int
         The UNIX timestamp (nanoseconds) of the last position change.
-    ts_init : uint64_t
+    ts_init : int
         The UNIX timestamp (nanoseconds) when the object was initialized.
     venue_position_id : PositionId, optional
         The reported venue position ID (assigned by the venue). If the trading
         venue has assigned a position ID / ticket for the trade then pass that
         here, otherwise pass ``None`` and the execution engine OMS will handle
         position ID resolution.
+
     """
 
     def __init__(
         self,
-        AccountId account_id not None,
-        InstrumentId instrument_id not None,
-        PositionSide position_side,
-        Quantity quantity not None,
-        UUID4 report_id not None,
-        uint64_t ts_last,
-        uint64_t ts_init,
-        PositionId venue_position_id: Optional[PositionId] = None,
-    ):
+        account_id: AccountId,
+        instrument_id: InstrumentId,
+        position_side: PositionSide,
+        quantity: Quantity,
+        report_id: UUID4,
+        ts_last: int,
+        ts_init: int,
+        venue_position_id: PositionId | None = None,
+    ) -> None:
         super().__init__(
             account_id,
             instrument_id,
             report_id,
             ts_init,
         )
         self.venue_position_id = venue_position_id
         self.position_side = position_side
         self.quantity = quantity
-        self.signed_decimal_qty = -self.quantity.as_decimal() if position_side == PositionSide.SHORT else self.quantity.as_decimal()
+        self.signed_decimal_qty = (
+            -self.quantity.as_decimal()
+            if position_side == PositionSide.SHORT
+            else self.quantity.as_decimal()
+        )
         self.ts_last = ts_last
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
-            f"account_id={self.account_id.to_str()}, "
-            f"instrument_id={self.instrument_id.to_str()}, "
-            f"venue_position_id={self.venue_position_id}, "  # Can be None
+            f"account_id={self.account_id}, "
+            f"instrument_id={self.instrument_id}, "
+            f"venue_position_id={self.venue_position_id}, "
             f"position_side={position_side_to_str(self.position_side)}, "
             f"quantity={self.quantity.to_str()}, "
             f"signed_decimal_qty={self.signed_decimal_qty}, "
             f"report_id={self.id}, "
             f"ts_last={self.ts_last}, "
             f"ts_init={self.ts_init})"
         )
 
 
-cdef class ExecutionMassStatus(Document):
+class ExecutionMassStatus(Document):
     """
-    Represents an execution mass status report for an execution client -
-    including status of all orders, trades for those orders and open positions.
+    Represents an execution mass status report for an execution client - including
+    status of all orders, trades for those orders and open positions.
 
     Parameters
     ----------
     venue : Venue
         The venue for the report.
     client_id : ClientId
         The client ID for the report.
     account_id : AccountId
         The account ID for the report.
     report_id : UUID4
         The report ID.
-    ts_init : uint64_t
+    ts_init : int
         The UNIX timestamp (nanoseconds) when the object was initialized.
+
     """
 
     def __init__(
         self,
-        ClientId client_id not None,
-        AccountId account_id not None,
-        Venue venue not None,
-        UUID4 report_id not None,
-        uint64_t ts_init,
-    ):
+        client_id: ClientId,
+        account_id: AccountId,
+        venue: Venue,
+        report_id: UUID4,
+        ts_init: int,
+    ) -> None:
         super().__init__(
             report_id,
             ts_init,
         )
         self.client_id = client_id
         self.account_id = account_id
         self.venue = venue
@@ -472,111 +499,109 @@
         self._trade_reports: dict[VenueOrderId, list[TradeReport]] = {}
         self._position_reports: dict[InstrumentId, list[PositionStatusReport]] = {}
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
             f"client_id={self.client_id}, "
-            f"account_id={self.account_id.to_str()}, "
-            f"venue={self.venue.to_str()}, "
+            f"account_id={self.account_id}, "
+            f"venue={self.venue}, "
             f"order_reports={self._order_reports}, "
             f"trade_reports={self._trade_reports}, "
             f"position_reports={self._position_reports}, "
             f"report_id={self.id}, "
             f"ts_init={self.ts_init})"
         )
 
-    cpdef dict order_reports(self):
+    def order_reports(self) -> dict[VenueOrderId, OrderStatusReport]:
         """
         Return the order status reports.
 
         Returns
         -------
         dict[VenueOrderId, OrderStatusReport]
 
         """
         return self._order_reports.copy()
 
-    cpdef dict trade_reports(self):
+    def trade_reports(self) -> dict[VenueOrderId, list[TradeReport]]:
         """
         Return the trade reports.
 
         Returns
         -------
         dict[VenueOrderId, list[TradeReport]
 
         """
         return self._trade_reports.copy()
 
-    cpdef dict position_reports(self):
+    def position_reports(self) -> dict[InstrumentId, list[PositionStatusReport]]:
         """
         Return the position status reports.
 
         Returns
         -------
         dict[InstrumentId, list[PositionStatusReport]]
 
         """
         return self._position_reports.copy()
 
-    cpdef void add_order_reports(self, list reports):
+    def add_order_reports(self, reports: list[OrderStatusReport]) -> None:
         """
         Add the order reports to the mass status.
 
         Parameters
         ----------
         reports : list[OrderStatusReport]
             The list of reports to add.
 
         Raises
-        -------
+        ------
         TypeError
             If `reports` contains a type other than `TradeReport`.
 
         """
-        Condition.not_none(reports, "reports")
+        PyCondition.not_none(reports, "reports")
 
-        cdef OrderStatusReport report
         for report in reports:
             self._order_reports[report.venue_order_id] = report
 
-    cpdef void add_trade_reports(self, list reports):
+    def add_trade_reports(self, reports: list[TradeReport]) -> None:
         """
         Add the trade reports to the mass status.
 
         Parameters
         ----------
         reports : list[TradeReport]
             The list of reports to add.
 
         Raises
-        -------
+        ------
         TypeError
             If `reports` contains a type other than `TradeReport`.
 
         """
-        Condition.not_none(reports, "reports")
+        PyCondition.not_none(reports, "reports")
 
         # Sort reports by venue order ID
-        cdef TradeReport report
         for report in reports:
             if report.venue_order_id not in self._trade_reports:
                 self._trade_reports[report.venue_order_id] = []
             self._trade_reports[report.venue_order_id].append(report)
 
-    cpdef void add_position_reports(self, list reports):
+    def add_position_reports(self, reports: list[PositionStatusReport]) -> None:
         """
         Add the position status reports to the mass status.
 
         Parameters
         ----------
         reports : list[PositionStatusReport]
             The reports to add.
 
         """
-        Condition.not_none(reports, "reports")
+        PyCondition.not_none(reports, "reports")
 
         # Sort reports by instrument ID
         for report in reports:
             if report.instrument_id not in self._position_reports:
                 self._position_reports[report.instrument_id] = []
             self._position_reports[report.instrument_id].append(report)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pxd` & `nautilus_trader-1.176.0/nautilus_trader/execution/trailing.pxd`

 * *Files 20% similar despite different names*

```diff
@@ -11,41 +11,40 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport TrailingOffsetType
-from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orders.base cimport Order
 
 
 cdef class TrailingStopCalculator:
 
     @staticmethod
     cdef tuple calculate(
-        Instrument instrument,
+        Price price_increment,
         Order order,
         Price bid,
         Price ask,
         Price last,
     )
 
     @staticmethod
     cdef Price calculate_with_last(
-        Instrument instrument,
+        Price price_increment,
         TrailingOffsetType trailing_offset_type,
         OrderSide side,
         double offset,
         Price last,
     )
 
     @staticmethod
     cdef Price calculate_with_bid_ask(
-        Instrument instrument,
+        Price price_increment,
         TrailingOffsetType trailing_offset_type,
         OrderSide side,
         double offset,
         Price bid,
         Price ask,
     )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pyx` & `nautilus_trader-1.176.0/nautilus_trader/execution/trailing.pyx`

 * *Files 16% similar despite different names*

```diff
@@ -19,33 +19,32 @@
 from nautilus_trader.core.rust.model cimport FIXED_SCALAR
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport TrailingOffsetType
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.enums_c cimport trailing_offset_type_to_str
 from nautilus_trader.model.enums_c cimport trigger_type_to_str
-from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orders.base cimport Order
 
 
 cdef class TrailingStopCalculator:
     """
     Provides trailing stop calculation functionality
     """
 
     @staticmethod
     cdef tuple calculate(
-        Instrument instrument,
+        Price price_increment,
         Order order,
         Price bid,
         Price ask,
         Price last,
     ):
-        Condition.not_none(instrument, "instrument")
+        Condition.not_none(price_increment, "price_increment")
         if order.order_type not in (OrderType.TRAILING_STOP_MARKET, OrderType.TRAILING_STOP_LIMIT):
             raise TypeError(f"invalid `OrderType` for calculation, was {order.type_string_c()}")
 
         cdef int64_t trailing_offset_raw = int(order.trailing_offset * int(FIXED_SCALAR))
         cdef int64_t limit_offset_raw = 0
 
         cdef Price trigger_price = order.trigger_price
@@ -69,45 +68,45 @@
                 raise RuntimeError(
                     f"cannot process trailing stop, "
                     f"no LAST price for {order.instrument_id} "
                     f"(add trade ticks or use bars)",
                 )
             if order.side == OrderSide.BUY:
                 temp_trigger_price = TrailingStopCalculator.calculate_with_last(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     last=last,
                 )
                 if trigger_price is None or trigger_price._mem.raw > temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_last(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         last=last,
                     )
                     if price is None or price._mem.raw > temp_price._mem.raw:
                         new_price = temp_price
             elif order.side == OrderSide.SELL:
                 temp_trigger_price = TrailingStopCalculator.calculate_with_last(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     last=last,
                 )
                 if trigger_price is None or trigger_price._mem.raw < temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_last(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         last=last,
                     )
                     if price is None or price._mem.raw < temp_price._mem.raw:
                         new_price = temp_price
@@ -123,48 +122,48 @@
                     f"cannot process trailing stop, "
                     f"no ASK price for {order.instrument_id} "
                     f"(add quote ticks or use bars)",
                 )
 
             if order.side == OrderSide.BUY:
                 temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     bid=bid,
                     ask=ask,
                 )
                 if trigger_price is None or trigger_price._mem.raw > temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_bid_ask(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         bid=bid,
                         ask=ask,
                     )
                     if price is None or price._mem.raw > temp_price._mem.raw:
                         new_price = temp_price
             elif order.side == OrderSide.SELL:
                 temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     bid=bid,
                     ask=ask,
                 )
                 if trigger_price is None or trigger_price._mem.raw < temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_bid_ask(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         bid=bid,
                         ask=ask,
                     )
                     if price is None or price._mem.raw < temp_price._mem.raw:
@@ -187,92 +186,92 @@
                     f"cannot process trailing stop, "
                     f"no ASK price for {order.instrument_id} "
                     f"(add quote ticks or use bars)",
                 )
 
             if order.side == OrderSide.BUY:
                 temp_trigger_price = TrailingStopCalculator.calculate_with_last(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     last=last,
                 )
                 if trigger_price is None or trigger_price._mem.raw > temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                     trigger_price = new_trigger_price  # Set trigger to new trigger
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_last(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         last=last,
                     )
                     if price is None or price._mem.raw > temp_price._mem.raw:
                         new_price = temp_price
                         price = new_price  # Set price to new price
 
                 temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     bid=bid,
                     ask=ask,
                 )
                 if trigger_price._mem.raw > temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_bid_ask(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         bid=bid,
                         ask=ask,
                     )
                     if price is None or price._mem.raw > temp_price._mem.raw:
                         new_price = temp_price
             elif order.side == OrderSide.SELL:
                 temp_trigger_price = TrailingStopCalculator.calculate_with_last(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     last=last,
                 )
                 if trigger_price is None or trigger_price._mem.raw < temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                     trigger_price = new_trigger_price  # Set trigger to new trigger
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_last(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         last=last,
                     )
                     if price is None or price._mem.raw < temp_price._mem.raw:
                         new_price = temp_price
                         price = new_price  # Set price to new price
 
                 temp_trigger_price = TrailingStopCalculator.calculate_with_bid_ask(
-                    instrument=instrument,
+                    price_increment=price_increment,
                     trailing_offset_type=order.trailing_offset_type,
                     side=order.side,
                     offset=float(order.trailing_offset),
                     bid=bid,
                     ask=ask,
                 )
                 if trigger_price._mem.raw < temp_trigger_price._mem.raw:
                     new_trigger_price = temp_trigger_price
                 if order.order_type == OrderType.TRAILING_STOP_LIMIT:
                     temp_price = TrailingStopCalculator.calculate_with_bid_ask(
-                        instrument=instrument,
+                        price_increment=price_increment,
                         trailing_offset_type=order.trailing_offset_type,
                         side=order.side,
                         offset=float(order.limit_offset),
                         bid=bid,
                         ask=ask,
                     )
                     if price is None or price._mem.raw < temp_price._mem.raw:
@@ -284,45 +283,45 @@
                 f"not currently supported",
             )
 
         return new_trigger_price, new_price
 
     @staticmethod
     cdef Price calculate_with_last(
-        Instrument instrument,
+        Price price_increment,
         TrailingOffsetType trailing_offset_type,
         OrderSide side,
         double offset,
         Price last,
     ):
         cdef double last_f64 = last.as_f64_c()
 
         if trailing_offset_type == TrailingOffsetType.PRICE:
             pass  # Offset already calculated
         elif trailing_offset_type == TrailingOffsetType.BASIS_POINTS:
             offset = last_f64 * (offset / 100) / 100
         elif trailing_offset_type == TrailingOffsetType.TICKS:
-            offset *= instrument.price_increment.as_f64_c()
+            offset *= price_increment.as_f64_c()
         else:
             raise RuntimeError(
                 f"cannot process trailing stop, "
                 f"`TrailingOffsetType` {trailing_offset_type_to_str(trailing_offset_type)} "
                 f"not currently supported",
             )
 
         if side == OrderSide.BUY:
-            return Price(last_f64 + offset, precision=instrument.price_precision)
+            return Price(last_f64 + offset, precision=price_increment.precision)
         elif side == OrderSide.SELL:
-            return Price(last_f64 - offset, precision=instrument.price_precision)
+            return Price(last_f64 - offset, precision=price_increment.precision)
         else:
             raise RuntimeError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)
 
     @staticmethod
     cdef Price calculate_with_bid_ask(
-        Instrument instrument,
+        Price price_increment,
         TrailingOffsetType trailing_offset_type,
         OrderSide side,
         double offset,
         Price bid,
         Price ask,
     ):
         cdef double ask_f64 = ask.as_f64_c()
@@ -332,21 +331,21 @@
             pass  # Offset already calculated
         elif trailing_offset_type == TrailingOffsetType.BASIS_POINTS:
             if side == OrderSide.BUY:
                 offset = ask_f64 * (offset / 100) / 100
             elif side == OrderSide.SELL:
                 offset = bid_f64 * (offset / 100) / 100
         elif trailing_offset_type == TrailingOffsetType.TICKS:
-            offset *= instrument.price_increment.as_f64_c()
+            offset *= price_increment.as_f64_c()
         else:
             raise RuntimeError(  # pragma: no cover (design-time error)
                 f"cannot process trailing stop, "  # pragma: no cover (design-time error)
                 f"`TrailingOffsetType` {trailing_offset_type_to_str(trailing_offset_type)} "  # pragma: no cover (design-time error)  # noqa
                 f"not currently supported",  # pragma: no cover (design-time error)
             )
 
         if side == OrderSide.BUY:
-            return Price(ask_f64 + offset, precision=instrument.price_precision)
+            return Price(ask_f64 + offset, precision=price_increment.precision)
         elif side == OrderSide.SELL:
-            return Price(bid_f64 - offset, precision=instrument.price_precision)
+            return Price(bid_f64 - offset, precision=price_increment.precision)
         else:
             raise RuntimeError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/base/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/indicators/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 The `indicator` subpackage provides a set of efficient indicators and analyzers.
 
-These are classes which can be used for signal discovery and filtering. The idea
-is to use the provided indicators as is, or as inspiration for a trader to
-implement their own proprietary indicator algorithms with the platform.
+These are classes which can be used for signal discovery and filtering. The idea is to
+use the provided indicators as is, or as inspiration for a trader to implement their own
+proprietary indicator algorithms with the platform.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/amat.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/amat.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/aroon.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/aroon.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/atr.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/atr.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/base/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/ama.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/ama.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/dema.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/dema.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/ema.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/ema.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/hma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/hma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ma_factory.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/ma_factory.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/moving_average.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/bias.pyx`

 * *Files 13% similar despite different names*

```diff
@@ -9,90 +9,83 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from enum import Enum
-from enum import unique
+from nautilus_trader.indicators.average.ma_factory import MovingAverageFactory
+from nautilus_trader.indicators.average.ma_factory import MovingAverageType
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.indicators.base.indicator cimport Indicator
-from nautilus_trader.model.enums_c cimport PriceType
+from nautilus_trader.model.data.bar cimport Bar
 
 
-@unique
-class MovingAverageType(Enum):
+cdef class Bias(Indicator):
     """
-    Represents the type of moving average.
-    """
-    SIMPLE = 0
-    EXPONENTIAL = 1
-    WEIGHTED = 2
-    HULL = 3
-    ADAPTIVE = 4
-    WILDER = 5
-    DOUBLE_EXPONENTIAL = 6
-    VARIABLE_INDEX_DYNAMIC = 7
-
-
-cdef class MovingAverage(Indicator):
-    """
-    The base class for all moving average type indicators.
+    Rate of change between the source and a moving average.
 
     Parameters
     ----------
     period : int
         The rolling window period for the indicator (> 0).
-    params : list
-        The initialization parameters for the indicator.
-    price_type : PriceType, optional
-        The specified price type for extracting values from quote ticks.
-
-    Warnings
-    --------
-    This class should not be used directly, but through a concrete subclass.
+    ma_type : MovingAverageType
+        The moving average type for the indicator (cannot be None).
     """
 
     def __init__(
         self,
         int period,
-        list params not None,
-        PriceType price_type,
+        ma_type not None: MovingAverageType=MovingAverageType.SIMPLE,
     ):
         Condition.positive_int(period, "period")
-        super().__init__(params)
+        params = [
+            period,
+            ma_type.name,
+        ]
+        super().__init__(params=params)
 
         self.period = period
-        self.price_type = price_type
+        self._ma = MovingAverageFactory.create(period, ma_type)
         self.value = 0
-        self.count = 0
 
-    cpdef void update_raw(self, double value):
+    cpdef void handle_bar(self, Bar bar):
         """
-        Update the indicator with the given raw value.
+        Update the indicator with the given bar.
 
         Parameters
         ----------
-        value : double
-            The update value.
+        bar : Bar
+            The update bar.
+
+        """
+        Condition.not_none(bar, "bar")
 
+        self.update_raw(
+            bar.close.as_double(),
+        )
+
+    cpdef void update_raw(self, double close):
         """
-        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+        Update the indicator with the given raw values.
+
+        Parameters
+        ----------
+        close : double
+            The close price.
 
-    cpdef void _increment_count(self):
-        self.count += 1
+        """
+        # Calculate average
+        self._ma.update_raw(close)
+        self.value = (close / self._ma.value) - 1.0
+        self._check_initialized()
 
-        # Initialization logic
+    cdef void _check_initialized(self):
         if not self.initialized:
             self._set_has_inputs(True)
-            if self.count >= self.period:
+            if self._ma.initialized:
                 self._set_initialized(True)
 
     cpdef void _reset(self):
-        self._reset_ma()
-        self.count = 0
+        self._ma.reset()
         self.value = 0
-
-    cpdef void _reset_ma(self):
-        pass  # Optionally override if additional values to reset
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/rma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/rma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/sma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/sma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/vidya.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/vidya.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/wma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/average/wma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/infrastructure/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/base/indicator.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/base/indicator.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/roc.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -9,21 +9,20 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.average.moving_average cimport MovingAverage
 from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-cdef class Bias(Indicator):
-    cdef MovingAverage _ma
+cdef class RateOfChange(Indicator):
+    cdef bint _use_log
+    cdef object _prices
 
     cdef readonly int period
     """The window period.\n\n:returns: `int`"""
     cdef readonly double value
     """The current value.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double close)
-    cdef void _check_initialized(self)
+    cpdef void update_raw(self, double price)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/psl.pyx`

 * *Files 12% similar despite different names*

```diff
@@ -17,17 +17,20 @@
 from nautilus_trader.indicators.average.ma_factory import MovingAverageType
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.indicators.base.indicator cimport Indicator
 from nautilus_trader.model.data.bar cimport Bar
 
 
-cdef class Bias(Indicator):
+cdef class PsychologicalLine(Indicator):
     """
-    Rate of change between the source and a moving average.
+    The Psychological Line is an oscillator-type indicator that compares the
+    number of the rising periods to the total number of periods. In other
+    words, it is the percentage of bars that close above the previous
+    bar over a given period.
 
     Parameters
     ----------
     period : int
         The rolling window period for the indicator (> 0).
     ma_type : MovingAverageType
         The moving average type for the indicator (cannot be None).
@@ -43,49 +46,57 @@
             period,
             ma_type.name,
         ]
         super().__init__(params=params)
 
         self.period = period
         self._ma = MovingAverageFactory.create(period, ma_type)
+        self._diff = 0
+        self._previous_close = 0
         self.value = 0
 
     cpdef void handle_bar(self, Bar bar):
         """
         Update the indicator with the given bar.
 
         Parameters
         ----------
         bar : Bar
             The update bar.
 
         """
         Condition.not_none(bar, "bar")
 
-        self.update_raw(
-            bar.close.as_double(),
-        )
+        self.update_raw(bar.close.as_double())
 
     cpdef void update_raw(self, double close):
         """
-        Update the indicator with the given raw values.
+        Update the indicator with the given raw value.
 
         Parameters
         ----------
         close : double
             The close price.
 
         """
-        # Calculate average
-        self._ma.update_raw(close)
-        self.value = (close / self._ma.value) - 1.0
-        self._check_initialized()
+        # Update inputs
+        if not self.has_inputs:
+            self._previous_close = close
+
+        self._diff = close - self._previous_close
+        if self._diff <= 0:
+            self._ma.update_raw(0)
+        else:
+            self._ma.update_raw(1)
+        self.value = 100.0 * self._ma.value
 
-    cdef void _check_initialized(self):
         if not self.initialized:
             self._set_has_inputs(True)
             if self._ma.initialized:
                 self._set_initialized(True)
+        self._previous_close = close
 
     cpdef void _reset(self):
         self._ma.reset()
+        self._diff = 0
+        self._previous_close = 0
         self.value = 0
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/bollinger_bands.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/bollinger_bands.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/cci.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/cci.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/cmo.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/cmo.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/dm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/dm.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/donchian_channel.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/donchian_channel.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/efficiency_ratio.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/efficiency_ratio.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enum.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enum.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/events/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -9,11 +9,11 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.fuzzy_enums.candle_size cimport CandleSize
+from nautilus_trader.indicators.fuzzy_enums.candle_wick cimport CandleWickSize
 
 
-__all__ = ["CandleSize"]
+__all__ = ["CandleWickSize"]
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/data/bar_aggregation.pyx`

 * *Files 8% similar despite different names*

```diff
@@ -9,11 +9,9 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.fuzzy_enums.candle_wick cimport CandleWickSize
 
-
-__all__ = ["CandleWickSize"]
+from nautilus_trader.model.data.bar_aggregation cimport BarAggregation  # type: ignore
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_channel.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_channel.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_position.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/keltner_position.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/kvo.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/kvo.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/linear_regression.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/linear_regression.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/macd.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/macd.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pxd` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,19 +9,8 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.base.indicator cimport Indicator
-
-
-cdef class OnBalanceVolume(Indicator):
-    cdef object _obv
-
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
-
-    cpdef void update_raw(self, double open, double close, double volume)
+from nautilus_trader.serialization.arrow import implementations  # noqa: F401
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/obv.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/pressure.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/pressure.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/psl.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/vhf.pyx`

 * *Files 17% similar despite different names*

```diff
@@ -9,28 +9,30 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from collections import deque
+
+from libc.math cimport fabs
+
 from nautilus_trader.indicators.average.ma_factory import MovingAverageFactory
 from nautilus_trader.indicators.average.ma_factory import MovingAverageType
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.indicators.base.indicator cimport Indicator
 from nautilus_trader.model.data.bar cimport Bar
 
 
-cdef class PsychologicalLine(Indicator):
+cdef class VerticalHorizontalFilter(Indicator):
     """
-    The Psychological Line is an oscillator-type indicator that compares the
-    number of the rising periods to the total number of periods. In other
-    words, it is the percentage of bars that close above the previous
-    bar over a given period.
+    The Vertical Horizon Filter (VHF) was created by Adam White to identify
+    trending and ranging markets.
 
     Parameters
     ----------
     period : int
         The rolling window period for the indicator (> 0).
     ma_type : MovingAverageType
         The moving average type for the indicator (cannot be None).
@@ -45,16 +47,16 @@
         params = [
             period,
             ma_type.name,
         ]
         super().__init__(params=params)
 
         self.period = period
+        self._prices = deque(maxlen=self.period)
         self._ma = MovingAverageFactory.create(period, ma_type)
-        self._diff = 0
         self._previous_close = 0
         self.value = 0
 
     cpdef void handle_bar(self, Bar bar):
         """
         Update the indicator with the given bar.
 
@@ -62,15 +64,17 @@
         ----------
         bar : Bar
             The update bar.
 
         """
         Condition.not_none(bar, "bar")
 
-        self.update_raw(bar.close.as_double())
+        self.update_raw(
+            bar.close.as_double(),
+        )
 
     cpdef void update_raw(self, double close):
         """
         Update the indicator with the given raw value.
 
         Parameters
         ----------
@@ -78,25 +82,30 @@
             The close price.
 
         """
         # Update inputs
         if not self.has_inputs:
             self._previous_close = close
 
-        self._diff = close - self._previous_close
-        if self._diff <= 0:
-            self._ma.update_raw(0)
-        else:
-            self._ma.update_raw(1)
-        self.value = 100.0 * self._ma.value
+        self._prices.append(close)
 
+        cdef double max_price = max(self._prices)
+        cdef double min_price = min(self._prices)
+
+        self._ma.update_raw(fabs(close - self._previous_close))
+        if self.initialized:
+            self.value = fabs(max_price - min_price) / self.period / self._ma.value
+        self._previous_close = close
+
+        self._check_initialized()
+
+    cdef void _check_initialized(self):
         if not self.initialized:
             self._set_has_inputs(True)
-            if self._ma.initialized:
+            if self._ma.initialized and len(self._prices) >= self.period:
                 self._set_initialized(True)
-        self._previous_close = close
 
     cpdef void _reset(self):
+        self._prices.clear()
         self._ma.reset()
-        self._diff = 0
         self._previous_close = 0
         self.value = 0
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd`

 * *Files 19% similar despite different names*

```diff
@@ -9,20 +9,25 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.base.indicator cimport Indicator
+cimport numpy as np
 
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.tick_scheme.base cimport TickScheme
 
-cdef class RateOfChange(Indicator):
-    cdef bint _use_log
-    cdef object _prices
 
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
+cdef class TieredTickScheme(TickScheme):
+    cdef list tiers
+    cdef int max_ticks_per_tier
+    cdef int tick_count
 
-    cpdef void update_raw(self, double price)
+    cdef readonly np.ndarray ticks
+
+    cpdef _build_ticks(self)
+
+    cpdef int find_tick_index(self, double value)
+    cpdef Price next_ask_price(self, double value, int n=*)
+    cpdef Price next_bid_price(self, double value, int n=*)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/roc.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/rsi.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/rsi.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/rvi.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/rvi.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/spread_analyzer.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/spread_analyzer.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/stochastics.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/stochastics.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/swings.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/swings.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/vhf.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/vhf.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/volatility_ratio.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/volatility_ratio.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pxd` & `nautilus_trader-1.176.0/nautilus_trader/indicators/vwap.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pyx` & `nautilus_trader-1.176.0/nautilus_trader/indicators/vwap.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orderbook/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/__init__.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -8,13 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""
-The `infrastructure` subpackage provides technology specific infrastructure implementations.
-
-Out of the box a `Redis <https://redis.io/>`_ backed cache is implemented.
-"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pxd` & `nautilus_trader-1.176.0/nautilus_trader/msgbus/subscription.pxd`

 * *Files 23% similar despite different names*

```diff
@@ -9,25 +9,15 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.cache.database cimport CacheDatabase
-from nautilus_trader.serialization.base cimport Serializer
 
-
-cdef class RedisCacheDatabase(CacheDatabase):
-    cdef str _key_trader
-    cdef str _key_general
-    cdef str _key_currencies
-    cdef str _key_instruments
-    cdef str _key_accounts
-    cdef str _key_orders
-    cdef str _key_positions
-    cdef str _key_actors
-    cdef str _key_strategies
-    cdef str _key_commands
-
-    cdef Serializer _serializer
-    cdef object _redis
+cdef class Subscription:
+    cdef readonly str topic
+    """The topic for the subscription.\n\n:returns: `str`"""
+    cdef readonly object handler
+    """The handler for the subscription.\n\n:returns: `Callable`"""
+    cdef readonly int priority
+    """The priority for the subscription.\n\n:returns: `int`"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pyx` & `nautilus_trader-1.176.0/nautilus_trader/infrastructure/cache.pyx`

 * *Files 9% similar despite different names*

```diff
@@ -14,39 +14,47 @@
 # -------------------------------------------------------------------------------------------------
 
 import warnings
 from typing import Optional
 
 from nautilus_trader.config import CacheDatabaseConfig
 
+from cpython.datetime cimport datetime
+
 from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.accounting.factory cimport AccountFactory
 from nautilus_trader.cache.database cimport CacheDatabase
 from nautilus_trader.common.actor cimport Actor
+from nautilus_trader.common.enums_c cimport LogColor
 from nautilus_trader.common.logging cimport Logger
 from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.datetime cimport format_iso8601
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
 from nautilus_trader.model.currency cimport Currency
+from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport currency_type_from_str
 from nautilus_trader.model.enums_c cimport currency_type_to_str
 from nautilus_trader.model.enums_c cimport order_type_to_str
 from nautilus_trader.model.events.order cimport OrderEvent
 from nautilus_trader.model.events.order cimport OrderFilled
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.identifiers cimport AccountId
+from nautilus_trader.model.identifiers cimport ClientId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ComponentId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.orders.limit cimport LimitOrder
 from nautilus_trader.model.orders.market cimport MarketOrder
 from nautilus_trader.model.orders.unpacker cimport OrderUnpacker
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.serialization.base cimport Serializer
 from nautilus_trader.trading.strategy cimport Strategy
@@ -58,21 +66,26 @@
     redis = None
 
 
 cdef str _UTF8 = "utf-8"
 cdef str _GENERAL = "general"
 cdef str _CURRENCIES = "currencies"
 cdef str _INSTRUMENTS = "instruments"
+cdef str _SYNTHETICS = "synthetics"
 cdef str _ACCOUNTS = "accounts"
 cdef str _TRADER = "trader"
 cdef str _ORDERS = "orders"
 cdef str _POSITIONS = "positions"
 cdef str _ACTORS = "actors"
 cdef str _STRATEGIES = "strategies"
-cdef str _COMMANDS = "commands"
+cdef str _INDEX_ORDER_POSITION = "index:order_position"
+cdef str _INDEX_ORDER_CLIENT = "index:order_client"
+cdef str _SNAPSHOTS_ORDERS = "snapshots:orders"
+cdef str _SNAPSHOTS_POSITIONS = "snapshots:positions"
+cdef str _HEARTBEAT = "health:heartbeat"
 
 
 cdef class RedisCacheDatabase(CacheDatabase):
     """
     Provides a cache database backed by Redis.
 
     Parameters
@@ -111,27 +124,34 @@
     ):
         if redis is None:
             warnings.warn("redis is not available.")
 
         if config is None:
             config = CacheDatabaseConfig()
         Condition.type(config, CacheDatabaseConfig, "config")
-        super().__init__(logger)
+        super().__init__(logger, config)
 
         # Database keys
         self._key_trader      = f"{_TRADER}-{trader_id}"              # noqa
         self._key_general     = f"{self._key_trader}:{_GENERAL}:"     # noqa
         self._key_currencies  = f"{self._key_trader}:{_CURRENCIES}:"  # noqa
         self._key_instruments = f"{self._key_trader}:{_INSTRUMENTS}:" # noqa
+        self._key_synthetics  = f"{self._key_trader}:{_SYNTHETICS}:"  # noqa
         self._key_accounts    = f"{self._key_trader}:{_ACCOUNTS}:"    # noqa
         self._key_orders      = f"{self._key_trader}:{_ORDERS}:"      # noqa
         self._key_positions   = f"{self._key_trader}:{_POSITIONS}:"   # noqa
         self._key_actors      = f"{self._key_trader}:{_ACTORS}:"      # noqa
         self._key_strategies  = f"{self._key_trader}:{_STRATEGIES}:"  # noqa
-        self._key_commands    = f"{self._key_trader}:{_COMMANDS}:"    # noqa
+
+        self._key_index_order_position = f"{self._key_trader}:{_INDEX_ORDER_POSITION}:"
+        self._key_index_order_client = f"{self._key_trader}:{_INDEX_ORDER_CLIENT}:"
+
+        self._key_snapshots_orders = f"{self._key_trader}:{_SNAPSHOTS_ORDERS}:"
+        self._key_snapshots_positions = f"{self._key_trader}:{_SNAPSHOTS_POSITIONS}:"
+        self._key_heartbeat = f"{self._key_trader}:{_HEARTBEAT}"
 
         # Serializers
         self._serializer = serializer
 
         # Redis client
         self._redis = redis.Redis(
             host=config.host,
@@ -147,15 +167,15 @@
     cpdef void flush(self):
         """
         Flush the database which clears all data.
 
         """
         self._log.debug("Flushing database....")
         self._redis.flushdb()
-        self._log.info("Flushed database.")
+        self._log.info("Flushed database.", LogColor.BLUE)
 
     cpdef dict load(self):
         """
         Load all general objects from the database.
 
         Returns
         -------
@@ -231,14 +251,43 @@
             instrument = self.load_instrument(instrument_id)
 
             if instrument is not None:
                 instruments[instrument.id] = instrument
 
         return instruments
 
+    cpdef dict load_synthetics(self):
+        """
+        Load all synthetic instruments from the database.
+
+        Returns
+        -------
+        dict[InstrumentId, SyntheticInstrument]
+
+        """
+        cdef dict synthetics = {}
+
+        cdef list synthetic_keys = self._redis.keys(f"{self._key_synthetics}*")
+        if not synthetic_keys:
+            return synthetics
+
+        cdef bytes key_bytes
+        cdef str key_str
+        cdef InstrumentId instrument_id
+        cdef SyntheticInstrument synthetic
+        for key_bytes in synthetic_keys:
+            key_str = key_bytes.decode(_UTF8).rsplit(':', maxsplit=1)[1]
+            instrument_id = InstrumentId.from_str_c(key_str)
+            synthetic = self.load_synthetic(instrument_id)
+
+            if synthetic is not None:
+                synthetics[synthetic.id] = synthetic
+
+        return synthetics
+
     cpdef dict load_accounts(self):
         """
         Load all accounts from the database.
 
         Returns
         -------
         dict[AccountId, Account]
@@ -318,115 +367,39 @@
             position = self.load_position(position_id)
 
             if position is not None:
                 positions[position.id] = position
 
         return positions
 
-    cpdef dict load_submit_order_commands(self):
-        """
-        Load all submit order commands from the database.
-
-        Returns
-        -------
-        dict[ClientOrderId, SubmitOrder]
-
-        """
-        cdef dict commands = {}
-
-        cdef list command_keys = self._redis.keys(f"{self._key_commands}submit_order:*")
-        if not command_keys:
-            return commands
-
-        cdef bytes key_bytes
-        cdef str key_str
-        cdef ClientOrderId client_order_id
-        cdef SubmitOrder command
-        for key_bytes in command_keys:
-            key_str = key_bytes.decode(_UTF8).rsplit(':', maxsplit=1)[1]
-            client_order_id = ClientOrderId(key_str)
-            command = self.load_submit_order_command(client_order_id)
-
-            if command is not None:
-                commands[client_order_id] = command
-
-        return commands
-
-    cpdef SubmitOrder load_submit_order_command(self, ClientOrderId client_order_id):
-        """
-        Load the command associated with the given client order ID (if found).
-
-        Parameters
-        ----------
-        client_order_id : ClientOrderId
-            The client order ID for the command to load.
-
-        Returns
-        -------
-        SubmitOrder or ``None``
-
+    cpdef dict load_index_order_position(self):
         """
-        Condition.not_none(client_order_id, "client_order_id")
-
-        cdef str key = f"{self._key_commands}submit_order:{client_order_id}"
-        cdef bytes command_bytes = self._redis.get(name=key)
-        if not command_bytes:
-            return None
-
-        return self._serializer.deserialize(command_bytes)
-
-    cpdef dict load_submit_order_list_commands(self):
-        """
-        Load all submit order list commands from the database.
+        Load the order to position index from the database.
 
         Returns
         -------
-        dict[OrderListId, SubmitOrderList]
+        dict[ClientOrderId, PositionId]
 
         """
-        cdef dict commands = {}
+        cdef dict raw_index = self._redis.hgetall(self._key_index_order_position)
 
-        cdef list command_keys = self._redis.keys(f"{self._key_commands}submit_order_list:*")
-        if not command_keys:
-            return commands
+        return {ClientOrderId(k.decode("utf-8")): PositionId(v.decode("utf-8")) for k, v in raw_index.items()}
 
-        cdef bytes key_bytes
-        cdef str key_str
-        cdef OrderListId order_list_id
-        cdef SubmitOrderList command
-        for key_bytes in command_keys:
-            key_str = key_bytes.decode(_UTF8).rsplit(':', maxsplit=1)[1]
-            order_list_id = OrderListId(key_str)
-            command = self.load_submit_order_list_command(order_list_id)
-
-            if command is not None:
-                commands[order_list_id] = command
-
-        return commands
-
-    cpdef SubmitOrderList load_submit_order_list_command(self, OrderListId order_list_id):
+    cpdef dict load_index_order_client(self):
         """
-        Load the command associated with the given order list ID (if found).
-
-        Parameters
-        ----------
-        order_list_id : OrderListId
-            The order list ID for the command to load.
+        Load the order to execution client index from the database.
 
         Returns
         -------
-        SubmitOrderList or ``None``
+        dict[ClientOrderId, ClientId]
 
         """
-        cdef str key = f"{self._key_commands}submit_order_list:{order_list_id}"
-        cdef bytes command_bytes = self._redis.get(name=key)
-        if not command_bytes:
-            return None
+        cdef dict raw_index = self._redis.hgetall(self._key_index_order_client)
 
-        return self._serializer.deserialize(command_bytes)
+        return {ClientOrderId(k.decode("utf-8")): ClientId(v.decode("utf-8")) for k, v in raw_index.items()}
 
     cpdef Currency load_currency(self, str code):
         """
         Load the currency associated with the given currency code (if found).
 
         Parameters
         ----------
@@ -473,14 +446,44 @@
         cdef str key = self._key_instruments + instrument_id.to_str()
         cdef bytes instrument_bytes = self._redis.get(name=key)
         if not instrument_bytes:
             return None
 
         return self._serializer.deserialize(instrument_bytes)
 
+    cpdef SyntheticInstrument load_synthetic(self, InstrumentId instrument_id):
+        """
+        Load the synthetic instrument associated with the given synthetic instrument ID
+        (if found).
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId
+            The synthetic instrument ID to load.
+
+        Returns
+        -------
+        SyntheticInstrument or ``None``
+
+        Raises
+        ------
+        ValueError
+            If `instrument_id` is not for a synthetic instrument.
+
+        """
+        Condition.not_none(instrument_id, "instrument_id")
+        Condition.true(instrument_id.is_synthetic(), "instrument_id was not for a synthetic instrument")
+
+        cdef str key = self._key_synthetics + instrument_id.to_str()
+        cdef bytes synthetic_bytes = self._redis.get(name=key)
+        if not synthetic_bytes:
+            return None
+
+        return self._serializer.deserialize(synthetic_bytes)
+
     cpdef Account load_account(self, AccountId account_id):
         """
         Load the account associated with the given account ID (if found).
 
         Parameters
         ----------
         account_id : AccountId
@@ -540,14 +543,19 @@
         cdef Order order = OrderUnpacker.from_init_c(init)
 
         cdef int event_count = 0
         cdef bytes event_bytes
         cdef OrderEvent event
         for event_bytes in events:
             event = self._serializer.deserialize(event_bytes)
+
+            # Check event integrity
+            if event in order._events:
+                raise RuntimeError(f"Corrupt cache with duplicate event for order {event}")
+
             if event_count > 0 and isinstance(event, OrderInitialized):
                 if event.order_type == OrderType.MARKET:
                     order = MarketOrder.transform(order, event.ts_init)
                 elif event.order_type == OrderType.LIMIT:
                     order = LimitOrder.transform(order, event.ts_init)
                 else:
                     raise RuntimeError(  # pragma: no cover (design-time error)
@@ -592,17 +600,30 @@
                 f"Cannot load position: "
                 f"no instrument found for {initial_fill.instrument_id}",
             )
             return
 
         cdef Position position = Position(instrument, initial_fill)
 
-        cdef bytes event_bytes
+        cdef:
+            bytes event_bytes
+            OrderFilled fill
         for event_bytes in events:
-            position.apply(self._serializer.deserialize(event_bytes))
+            event = self._serializer.deserialize(event_bytes)
+
+            # Check event integrity
+            if event in position._events:
+                raise RuntimeError(f"Corrupt cache with duplicate event for position {event}")
+            if event.trade_id in position._trade_ids:
+                raise RuntimeError(
+                    f"Duplicate {event.trade_id!r}, "
+                    f"existing {position.id!r} trade_ids={position._trade_ids}",
+                )
+
+            position.apply(event)
 
         return position
 
     cpdef dict load_actor(self, ComponentId component_id):
         """
         Load the state for the given actor.
 
@@ -734,14 +755,31 @@
         Condition.not_none(instrument, "instrument")
 
         cdef str key = self._key_instruments + instrument.id.to_str()
         self._redis.set(name=key, value=self._serializer.serialize(instrument))
 
         self._log.debug(f"Added instrument {instrument.id}.")
 
+    cpdef void add_synthetic(self, SyntheticInstrument synthetic):
+        """
+        Add the given synthetic instrument to the database.
+
+        Parameters
+        ----------
+        synthetic : SyntheticInstrument
+            The synthetic instrument to add.
+
+        """
+        Condition.not_none(synthetic, "synthetic")
+
+        cdef str key = self._key_synthetics + synthetic.id.value
+        self._redis.set(name=key, value=self._serializer.serialize(synthetic))
+
+        self._log.debug(f"Added synthetic instrument {synthetic.id}.")
+
     cpdef void add_account(self, Account account):
         """
         Add the given account to the database.
 
         Parameters
         ----------
         account : Account
@@ -757,43 +795,53 @@
 
         # Check data integrity of reply
         if len(reply) > 1:  # Reply = The length of the list after the push operation
             self._log.error(
                 f"The {repr(account.id)} already existed and was appended to.",
             )
 
-        self._log.debug(f"Added {account}).")
+        self._log.debug(f"Added {account}.")
 
-    cpdef void add_order(self, Order order):
+    cpdef void add_order(self, Order order, PositionId position_id = None, ClientId client_id = None):
         """
         Add the given order to the database.
 
         Parameters
         ----------
         order : Order
             The order to add.
+        position_id : PositionId, optional
+            The position ID to associate with this order.
+        client_id : ClientId, optional
+            The execution client ID to associate with this order.
 
         """
         Condition.not_none(order, "order")
 
         cdef bytes last_event = self._serializer.serialize(order.last_event_c())
         cdef int reply = self._redis.rpush(self._key_orders + order.client_order_id.to_str(), last_event)
 
         # Check data integrity of reply
         if reply > 1:  # Reply = The length of the list after the push operation
             # Dropped the log level to debug as this is expected for transformed orders
             self._log.debug(
                 f"The {repr(order.client_order_id)} already existed and was appended to.",
             )
 
-        self._log.debug(f"Added Order(id={order.client_order_id.to_str()}).")
+        self._log.debug(f"Added {order}.")
+
+        if position_id is not None:
+            self.index_order_position(order.client_order_id, position_id)
+        if client_id is not None:
+            self._redis.hset(self._key_index_order_client, order.client_order_id.to_str(), client_id.to_str())
+            self._log.debug(f"Indexed {order.client_order_id!r} -> {client_id!r}")
 
     cpdef void add_position(self, Position position):
         """
-        Add the given position associated with the given strategy ID.
+        Add the given position to the database.
 
         Parameters
         ----------
         position : Position
             The position to add.
 
         """
@@ -804,63 +852,38 @@
 
         # Check data integrity of reply
         if reply > 1:  # Reply = The length of the list after the push operation
             self._log.warning(
                 f"The {repr(position.id)} already existed and was appended to.",
             )
 
-        self._log.debug(f"Added Position(id={position.id.to_str()}).")
-
-    cpdef void add_submit_order_command(self, SubmitOrder command):
-        """
-        Add the given submit order command to the database.
-
-        Parameters
-        ----------
-        command : SubmitOrder
-            The command to add.
-
-        """
-        Condition.not_none(command, "command")
-
-        cdef str key = f"{self._key_commands}submit_order:{command.order.client_order_id.to_str()}"
-        cdef bytes command_bytes = self._serializer.serialize(command)
-        cdef int reply = self._redis.set(key, command_bytes)
-
-        # Check data integrity of reply
-        if reply > 1:  # Reply = The length of the list after the push operation
-            self._log.warning(
-                f"The {repr(command)} already existed.",
-            )
-
-        self._log.debug(f"Added {command}.")
+        self._log.debug(f"Added {position}.")
 
-    cpdef void add_submit_order_list_command(self, SubmitOrderList command):
+    cpdef void index_order_position(self, ClientOrderId client_order_id, PositionId position_id):
         """
-        Add the given submit order list command to the database.
+        Add an index entry for the given `client_order_id` to `position_id`.
 
         Parameters
         ----------
-        command : SubmitOrderList
-            The command to add.
+        client_order_id : ClientOrderId
+            The client order ID to index.
+        position_id : PositionId
+            The position ID to index.
 
         """
-        Condition.not_none(command, "command")
-
-        cdef str key = f"{self._key_commands}submit_order_list:{command.order_list.id.to_str()}"
-        cdef bytes command_bytes = self._serializer.serialize(command)
-        cdef int reply = self._redis.set(key, command_bytes)
+        Condition.not_none(client_order_id, "client_order_id")
+        Condition.not_none(position_id, "position_id")
 
-        # Check data integrity of reply
-        if reply > 1:  # Reply = The length of the list after the push operation
-            self._log.warning(
-                f"The {repr(command)} already existed.",
-            )
+        self._redis.hset(
+            self._key_index_order_position,
+            client_order_id.to_str(),
+            position_id.to_str(),
+        )
 
-        self._log.debug(f"Added {command}.")
+        self._log.debug(f"Indexed {client_order_id!r} -> {position_id!r}")
 
     cpdef void update_actor(self, Actor actor):
         """
         Update the given actor state in the database.
 
         Parameters
         ----------
@@ -961,7 +984,67 @@
         """
         Condition.not_none(position, "position")
 
         cdef bytes serialized_event = self._serializer.serialize(position.last_event_c())
         cdef int reply = self._redis.rpush(self._key_positions + position.id.to_str(), serialized_event)
 
         self._log.debug(f"Updated {position}.")
+
+    cpdef void snapshot_order_state(self, Order order):
+        """
+        Snapshot the state of the given `order`.
+
+        Parameters
+        ----------
+        order : Order
+            The order for the state snapshot.
+
+        """
+        Condition.not_none(order, "order")
+
+        cdef dict order_state = order.to_dict()
+        cdef bytes snapshot_bytes = self._serializer.serialize(order_state)
+
+        self._redis.rpush(self._key_snapshots_orders + order.client_order_id.to_str(), snapshot_bytes)
+
+        self._log.debug(f"Added state snapshot {order}.")
+
+    cpdef void snapshot_position_state(self, Position position, Money unrealized_pnl = None):
+        """
+        Snapshot the state of the given `position`.
+
+        Parameters
+        ----------
+        position : Position
+            The position for the state snapshot.
+        unrealized_pnl : Money, optional
+            The unrealized PnL for the state snapshot.
+
+        """
+        Condition.not_none(position, "position")
+
+        cdef dict position_state = position.to_dict()
+
+        if unrealized_pnl is not None:
+            position_state["unrealized_pnl"] = unrealized_pnl.to_str()
+
+        cdef bytes snapshot_bytes = self._serializer.serialize(position_state)
+        self._redis.rpush(self._key_snapshots_positions + position.id.to_str(), snapshot_bytes)
+
+        self._log.debug(f"Added state snapshot {position}.")
+
+    cpdef void heartbeat(self, datetime timestamp):
+        """
+        Add a heartbeat at the given `timestamp`.
+
+        Parameters
+        ----------
+        timestamp : datetime
+            The timestamp for the heartbeat.
+
+        """
+        Condition.not_none(timestamp, "timestamp")
+
+        cdef timestamp_str = format_iso8601(timestamp)
+        self._redis.set(self._key_heartbeat, timestamp_str)
+
+        self._log.debug(f"Set last heartbeat {timestamp_str}.")
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/live/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,14 +8,15 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 The `live` subpackage groups all engine and client implementations for live trading.
 
 Generally a common event loop is passed into each live engine to support the overarching
-design of a single efficient event loop, by default `uvloop <https://github.com/MagicStack/uvloop>`_.
+design of a single efficient event loop, by default
+`uvloop <https://github.com/MagicStack/uvloop>`_.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/__main__.py` & `nautilus_trader-1.176.0/nautilus_trader/live/__main__.py`

 * *Files 13% similar despite different names*

```diff
@@ -9,33 +9,33 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from typing import Optional
+from __future__ import annotations
 
 import click
 import fsspec
 import msgspec.json
 
 from nautilus_trader.config import TradingNodeConfig
 from nautilus_trader.live.node import TradingNode
 
 
 @click.command()
 @click.option("--raw", help="A raw string config")
 @click.option("--fsspec-url", help="A fsspec url to read config from")
 @click.option("--start", default=True, help="Start the live node")
 def main(
-    raw: Optional[str] = None,
-    fsspec_url: Optional[str] = None,
+    raw: str | None = None,
+    fsspec_url: str | None = None,
     start: bool = True,
-):
+) -> None:
     assert raw is not None or fsspec_url is not None, "Must pass one of `raw` or `fsspec_url`"
     if fsspec_url and raw is None:
         with fsspec.open(fsspec_url, "rb") as f:
             raw = f.read().decode()
     config: TradingNodeConfig = msgspec.json.decode(raw, type=TradingNodeConfig)
     node = TradingNode(config=config)
     node.build()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/data_client.py` & `nautilus_trader-1.176.0/nautilus_trader/live/data_client.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,26 +8,29 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `LiveDataClient` class is responsible for interfacing with a particular API
-which may be presented directly by an exchange, or broker intermediary. It
-could also be possible to write clients for specialized data publishers.
+The `LiveDataClient` class is responsible for interfacing with a particular API which
+may be presented directly by an exchange, or broker intermediary.
+
+It could also be possible to write clients for specialized data publishers.
+
 """
 
+from __future__ import annotations
+
 import asyncio
 import functools
 from asyncio import Task
 from collections.abc import Coroutine
-from typing import Any, Callable, Optional
+from typing import Any, Callable
 
 import pandas as pd
 
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
@@ -67,26 +70,27 @@
         The logger for the client.
     config : dict[str, object], optional
         The configuration for the instance.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client_id: ClientId,
-        venue: Optional[Venue],
+        venue: Venue | None,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        config: Optional[dict[str, Any]] = None,
+        config: dict[str, Any] | None = None,
     ) -> None:
         super().__init__(
             client_id=client_id,
             venue=venue,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
@@ -114,21 +118,21 @@
         """
         await asyncio.sleep(delay)
         return await coro
 
     def create_task(
         self,
         coro: Coroutine,
-        log_msg: Optional[str] = None,
-        actions: Optional[Callable] = None,
-        success: Optional[str] = None,
+        log_msg: str | None = None,
+        actions: Callable | None = None,
+        success: str | None = None,
     ) -> asyncio.Task:
         """
-        Run the given coroutine with error handling and optional callback
-        actions when done.
+        Run the given coroutine with error handling and optional callback actions when
+        done.
 
         Parameters
         ----------
         coro : Coroutine
             The coroutine to run.
         log_msg : str, optional
             The log message for the task.
@@ -155,16 +159,16 @@
                 success,
             ),
         )
         return task
 
     def _on_task_completed(
         self,
-        actions: Optional[Callable],
-        success: Optional[str],
+        actions: Callable | None,
+        success: str | None,
         task: Task,
     ) -> None:
         if task.exception():
             self._log.error(
                 f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
             )
         else:
@@ -279,27 +283,28 @@
         The logger for the client.
     config : dict[str, object], optional
         The configuration for the instance.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client_id: ClientId,
-        venue: Optional[Venue],
+        venue: Venue | None,
         instrument_provider: InstrumentProvider,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        config: Optional[dict[str, Any]] = None,
+        config: dict[str, Any] | None = None,
     ) -> None:
         PyCondition.type(instrument_provider, InstrumentProvider, "instrument_provider")
 
         super().__init__(
             client_id=client_id,
             venue=venue,
             msgbus=msgbus,
@@ -330,21 +335,21 @@
         """
         await asyncio.sleep(delay)
         return await coro
 
     def create_task(
         self,
         coro: Coroutine,
-        log_msg: Optional[str] = None,
-        actions: Optional[Callable] = None,
-        success: Optional[str] = None,
+        log_msg: str | None = None,
+        actions: Callable | None = None,
+        success: str | None = None,
     ) -> asyncio.Task:
         """
-        Run the given coroutine with error handling and optional callback
-        actions when done.
+        Run the given coroutine with error handling and optional callback actions when
+        done.
 
         Parameters
         ----------
         coro : Coroutine
             The coroutine to run.
         log_msg : str, optional
             The log message for the task.
@@ -371,16 +376,16 @@
                 success,
             ),
         )
         return task
 
     def _on_task_completed(
         self,
-        actions: Optional[Callable],
-        success: Optional[str],
+        actions: Callable | None,
+        success: str | None,
         task: Task,
     ) -> None:
         if task.exception():
             self._log.error(
                 f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
             )
         else:
@@ -441,16 +446,16 @@
             actions=lambda: self._add_subscription_instrument(instrument_id),
         )
 
     def subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
-        depth: Optional[int] = None,
-        kwargs: Optional[dict[str, Any]] = None,
+        depth: int | None = None,
+        kwargs: dict[str, Any] | None = None,
     ) -> None:
         self.create_task(
             self._subscribe_order_book_deltas(
                 instrument_id=instrument_id,
                 book_type=book_type,
                 depth=depth,
                 kwargs=kwargs,
@@ -459,16 +464,16 @@
             actions=lambda: self._add_subscription_order_book_deltas(instrument_id),
         )
 
     def subscribe_order_book_snapshots(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
-        depth: Optional[int] = None,
-        kwargs: Optional[dict[str, Any]] = None,
+        depth: int | None = None,
+        kwargs: dict[str, Any] | None = None,
     ) -> None:
         self.create_task(
             self._subscribe_order_book_snapshots(
                 instrument_id=instrument_id,
                 book_type=book_type,
                 depth=depth,
                 kwargs=kwargs,
@@ -619,16 +624,16 @@
         )
 
     def request_quote_ticks(
         self,
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> None:
         self._log.debug(f"Request quote ticks {instrument_id}.")
         self.create_task(
             self._request_quote_ticks(
                 instrument_id=instrument_id,
                 limit=limit,
                 correlation_id=correlation_id,
@@ -638,16 +643,16 @@
         )
 
     def request_trade_ticks(
         self,
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> None:
         self._log.debug(f"Request trade ticks {instrument_id}.")
         self.create_task(
             self._request_trade_ticks(
                 instrument_id=instrument_id,
                 limit=limit,
                 correlation_id=correlation_id,
@@ -657,16 +662,16 @@
         )
 
     def request_bars(
         self,
         bar_type: BarType,
         limit: int,
         correlation_id: UUID4,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> None:
         self._log.debug(f"Request bars {bar_type}.")
         self.create_task(
             self._request_bars(
                 bar_type=bar_type,
                 limit=limit,
                 correlation_id=correlation_id,
@@ -703,27 +708,27 @@
             "implement the `_subscribe_instrument` coroutine",  # pragma: no cover
         )
 
     async def _subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
-        depth: Optional[int] = None,
-        kwargs: Optional[dict[str, Any]] = None,
+        depth: int | None = None,
+        kwargs: dict[str, Any] | None = None,
     ) -> None:
         raise NotImplementedError(  # pragma: no cover
             "implement the `_subscribe_order_book_deltas` coroutine",  # pragma: no cover
         )
 
     async def _subscribe_order_book_snapshots(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
-        depth: Optional[int] = None,
-        kwargs: Optional[dict[str, Any]] = None,
+        depth: int | None = None,
+        kwargs: dict[str, Any] | None = None,
     ) -> None:
         raise NotImplementedError(  # pragma: no cover
             "implement the `_subscribe_order_book_snapshots` coroutine",  # pragma: no cover
         )
 
     async def _subscribe_ticker(self, instrument_id: InstrumentId) -> None:
         raise NotImplementedError(  # pragma: no cover
@@ -826,37 +831,37 @@
         )
 
     async def _request_quote_ticks(
         self,
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> None:
         raise NotImplementedError(  # pragma: no cover
             "implement the `_request_quote_ticks` coroutine",  # pragma: no cover
         )
 
     async def _request_trade_ticks(
         self,
         instrument_id: InstrumentId,
         limit: int,
         correlation_id: UUID4,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> None:
         raise NotImplementedError(  # pragma: no cover
             "implement the `_request_trade_ticks` coroutine",  # pragma: no cover
         )
 
     async def _request_bars(
         self,
         bar_type: BarType,
         limit: int,
         correlation_id: UUID4,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> None:
         raise NotImplementedError(  # pragma: no cover
             "implement the `_request_bars` coroutine",  # pragma: no cover
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/data_engine.py` & `nautilus_trader-1.176.0/nautilus_trader/live/data_engine.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,16 +9,17 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
-from typing import Optional
 
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.queue import Queue
 from nautilus_trader.config import LiveDataEngineConfig
 from nautilus_trader.core.correctness import PyCondition
@@ -49,26 +50,27 @@
     config : LiveDataEngineConfig, optional
         The configuration for the instance.
 
     Raises
     ------
     TypeError
         If `config` is not of type `LiveDataEngineConfig`.
+
     """
 
     _sentinel = None
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        config: Optional[LiveDataEngineConfig] = None,
+        config: LiveDataEngineConfig | None = None,
     ) -> None:
         if config is None:
             config = LiveDataEngineConfig()
         PyCondition.type(config, LiveDataEngineConfig, "config")
         super().__init__(
             msgbus=msgbus,
             cache=cache,
@@ -80,18 +82,18 @@
         self._loop: asyncio.AbstractEventLoop = loop
         self._cmd_queue: Queue = Queue(maxsize=config.qsize)
         self._req_queue: Queue = Queue(maxsize=config.qsize)
         self._res_queue: Queue = Queue(maxsize=config.qsize)
         self._data_queue: Queue = Queue(maxsize=config.qsize)
 
         # Async tasks
-        self._cmd_queue_task: Optional[asyncio.Task] = None
-        self._req_queue_task: Optional[asyncio.Task] = None
-        self._res_queue_task: Optional[asyncio.Task] = None
-        self._data_queue_task: Optional[asyncio.Task] = None
+        self._cmd_queue_task: asyncio.Task | None = None
+        self._req_queue_task: asyncio.Task | None = None
+        self._res_queue_task: asyncio.Task | None = None
+        self._data_queue_task: asyncio.Task | None = None
         self._kill: bool = False
 
     def connect(self) -> None:
         """
         Connect the engine by calling connect on all registered clients.
         """
         self._log.info("Connecting all clients...")
@@ -102,48 +104,48 @@
         """
         Disconnect the engine by calling disconnect on all registered clients.
         """
         self._log.info("Disconnecting all clients...")
         for client in self._clients.values():
             client.disconnect()
 
-    def get_cmd_queue_task(self) -> Optional[asyncio.Task]:
+    def get_cmd_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal command queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
         """
         return self._cmd_queue_task
 
-    def get_req_queue_task(self) -> Optional[asyncio.Task]:
+    def get_req_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal request queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
         """
         return self._req_queue_task
 
-    def get_res_queue_task(self) -> Optional[asyncio.Task]:
+    def get_res_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal response queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
         """
         return self._res_queue_task
 
-    def get_data_queue_task(self) -> Optional[asyncio.Task]:
+    def get_data_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal data queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
@@ -368,15 +370,15 @@
 
     async def _run_cmd_queue(self) -> None:
         self._log.debug(
             f"DataCommand message queue processing starting (qsize={self.cmd_qsize()})...",
         )
         try:
             while True:
-                command: Optional[DataCommand] = await self._cmd_queue.get()
+                command: DataCommand | None = await self._cmd_queue.get()
                 if command is self._sentinel:
                     break
                 self._execute_command(command)
         except asyncio.CancelledError:
             self._log.warning("DataCommand message queue canceled.")
         finally:
             stopped_msg = "DataCommand message queue stopped"
@@ -387,15 +389,15 @@
 
     async def _run_req_queue(self) -> None:
         self._log.debug(
             f"DataRequest message queue processing starting (qsize={self.req_qsize()})...",
         )
         try:
             while True:
-                request: Optional[DataRequest] = await self._req_queue.get()
+                request: DataRequest | None = await self._req_queue.get()
                 if request is self._sentinel:
                     break
                 self._handle_request(request)
         except asyncio.CancelledError:
             self._log.warning("DataRequest message queue canceled.")
         finally:
             stopped_msg = "DataRequest message queue stopped"
@@ -406,15 +408,15 @@
 
     async def _run_res_queue(self) -> None:
         self._log.debug(
             f"DataResponse message queue processing starting (qsize={self.res_qsize()})...",
         )
         try:
             while True:
-                response: Optional[DataRequest] = await self._res_queue.get()
+                response: DataRequest | None = await self._res_queue.get()
                 if response is self._sentinel:
                     break
                 self._handle_response(response)
         except asyncio.CancelledError:
             self._log.warning("DataResponse message queue canceled.")
         finally:
             stopped_msg = "DataResponse message queue stopped"
@@ -423,15 +425,15 @@
             else:
                 self._log.debug(stopped_msg + ".")
 
     async def _run_data_queue(self) -> None:
         self._log.debug(f"Data queue processing starting (qsize={self.data_qsize()})...")
         try:
             while True:
-                data: Optional[Data] = await self._data_queue.get()
+                data: Data | None = await self._data_queue.get()
                 if data is self._sentinel:
                     break
                 self._handle_data(data)
         except asyncio.CancelledError:
             self._log.warning("Data message queue canceled.")
         finally:
             stopped_msg = "Data message queue stopped"
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/execution_client.py` & `nautilus_trader-1.176.0/nautilus_trader/live/execution_client.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,26 +8,27 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-The `LiveExecutionClient` class is responsible for interfacing with a particular
-API which may be presented directly by an exchange, or broker intermediary.
+The `LiveExecutionClient` class is responsible for interfacing with a particular API
+which may be presented directly by an exchange, or broker intermediary.
 """
 
+from __future__ import annotations
+
 import asyncio
 import functools
 from asyncio import Task
 from collections.abc import Coroutine
 from datetime import timedelta
-from typing import Any, Callable, Optional
+from typing import Any, Callable
 
 import pandas as pd
 
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
@@ -89,30 +90,31 @@
     ------
     ValueError
         If `oms_type` is ``UNSPECIFIED`` (must be specified).
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client_id: ClientId,
-        venue: Optional[Venue],
+        venue: Venue | None,
         oms_type: OmsType,
         account_type: AccountType,
-        base_currency: Optional[Currency],
+        base_currency: Currency | None,
         instrument_provider: InstrumentProvider,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        config: Optional[dict[str, Any]] = None,
+        config: dict[str, Any] | None = None,
     ) -> None:
         PyCondition.type(instrument_provider, InstrumentProvider, "instrument_provider")
 
         super().__init__(
             client_id=client_id,
             venue=venue,
             oms_type=oms_type,
@@ -148,21 +150,21 @@
         """
         await asyncio.sleep(delay)
         return await coro
 
     def create_task(
         self,
         coro: Coroutine,
-        log_msg: Optional[str] = None,
-        actions: Optional[Callable] = None,
-        success: Optional[str] = None,
+        log_msg: str | None = None,
+        actions: Callable | None = None,
+        success: str | None = None,
     ) -> asyncio.Task:
         """
-        Run the given coroutine with error handling and optional callback
-        actions when done.
+        Run the given coroutine with error handling and optional callback actions when
+        done.
 
         Parameters
         ----------
         coro : Coroutine
             The coroutine to run.
         log_msg : str, optional
             The log message for the task.
@@ -189,16 +191,16 @@
                 success,
             ),
         )
         return task
 
     def _on_task_completed(
         self,
-        actions: Optional[Callable],
-        success: Optional[str],
+        actions: Callable | None,
+        success: str | None,
         task: Task,
     ) -> None:
         if task.exception():
             self._log.error(
                 f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
             )
         else:
@@ -270,17 +272,17 @@
             self._query_order(command),
             log_msg=f"query_order: {command}",
         )
 
     async def generate_order_status_report(
         self,
         instrument_id: InstrumentId,
-        client_order_id: Optional[ClientOrderId] = None,
-        venue_order_id: Optional[VenueOrderId] = None,
-    ) -> Optional[OrderStatusReport]:
+        client_order_id: ClientOrderId | None = None,
+        venue_order_id: VenueOrderId | None = None,
+    ) -> OrderStatusReport | None:
         """
         Generate an `OrderStatusReport` for the given order identifier parameter(s).
 
         If the order is not found, or an error occurs, then logs and returns ``None``.
 
         Parameters
         ----------
@@ -301,17 +303,17 @@
             If both the `client_order_id` and `venue_order_id` are ``None``.
 
         """
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_order_status_reports(
         self,
-        instrument_id: Optional[InstrumentId] = None,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        instrument_id: InstrumentId | None = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
         open_only: bool = False,
     ) -> list[OrderStatusReport]:
         """
         Generate a list of `OrderStatusReport`s with optional query filters.
 
         The returned list may be empty if no orders match the given parameters.
 
@@ -331,18 +333,18 @@
         list[OrderStatusReport]
 
         """
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_trade_reports(
         self,
-        instrument_id: Optional[InstrumentId] = None,
-        venue_order_id: Optional[VenueOrderId] = None,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        instrument_id: InstrumentId | None = None,
+        venue_order_id: VenueOrderId | None = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> list[TradeReport]:
         """
         Generate a list of `TradeReport`s with optional query filters.
 
         The returned list may be empty if no trades match the given parameters.
 
         Parameters
@@ -361,17 +363,17 @@
         list[TradeReport]
 
         """
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_position_status_reports(
         self,
-        instrument_id: Optional[InstrumentId] = None,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
+        instrument_id: InstrumentId | None = None,
+        start: pd.Timestamp | None = None,
+        end: pd.Timestamp | None = None,
     ) -> list[PositionStatusReport]:
         """
         Generate a list of `PositionStatusReport`s with optional query filters.
 
         The returned list may be empty if no positions match the given parameters.
 
         Parameters
@@ -388,42 +390,42 @@
         list[PositionStatusReport]
 
         """
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_mass_status(
         self,
-        lookback_mins: Optional[int] = None,
-    ) -> ExecutionMassStatus:
+        lookback_mins: int | None = None,
+    ) -> ExecutionMassStatus | None:
         """
         Generate an `ExecutionMassStatus` report.
 
         Parameters
         ----------
         lookback_mins : int, optional
             The maximum lookback for querying closed orders, trades and positions.
 
         Returns
         -------
-        ExecutionMassStatus
+        ExecutionMassStatus or ``None``
 
         """
-        self._log.info(f"Generating ExecutionMassStatus for {self.id}...")
+        self._log.info("Generating ExecutionMassStatus...")
 
         self.reconciliation_active = True
 
         mass_status = ExecutionMassStatus(
             client_id=self.id,
             account_id=self.account_id,
             venue=self.venue,
             report_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
-        since: Optional[pd.Timestamp] = None
+        since: pd.Timestamp | None = None
         if lookback_mins is not None:
             since = self._clock.utc_now() - timedelta(minutes=lookback_mins)
 
         try:
             reports = await asyncio.gather(
                 self.generate_order_status_reports(start=since),
                 self.generate_trade_reports(start=since),
@@ -435,19 +437,20 @@
             mass_status.add_position_reports(reports=reports[2])
 
             self.reconciliation_active = False
 
             return mass_status
         except Exception as e:
             self._log.exception("Cannot reconcile execution state", e)
+        return None
 
     async def _query_order(self, command: QueryOrder) -> None:
         self._log.debug(f"Synchronizing order status {command}.")
 
-        report: OrderStatusReport = await self.generate_order_status_report(
+        report: OrderStatusReport | None = await self.generate_order_status_report(
             instrument_id=command.instrument_id,
             client_order_id=command.client_order_id,
             venue_order_id=command.venue_order_id,
         )
 
         if report is None:
             self._log.warning("Did not received `OrderStatusReport` from request.")
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/execution_engine.py` & `nautilus_trader-1.176.0/nautilus_trader/live/execution_engine.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,18 +9,20 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
 import math
 from decimal import Decimal
-from typing import Any, Optional
+from typing import Any
 
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.queue import Queue
 from nautilus_trader.config import LiveExecEngineConfig
@@ -85,26 +87,27 @@
     config : LiveExecEngineConfig, optional
         The configuration for the instance.
 
     Raises
     ------
     TypeError
         If `config` is not of type `LiveExecEngineConfig`.
+
     """
 
     _sentinel = None
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        config: Optional[LiveExecEngineConfig] = None,
+        config: LiveExecEngineConfig | None = None,
     ) -> None:
         if config is None:
             config = LiveExecEngineConfig()
         PyCondition.type(config, LiveExecEngineConfig, "config")
         super().__init__(
             msgbus=msgbus,
             cache=cache,
@@ -116,22 +119,31 @@
         self._loop: asyncio.AbstractEventLoop = loop
         self._cmd_queue: Queue = Queue(maxsize=config.qsize)
         self._evt_queue: Queue = Queue(maxsize=config.qsize)
 
         # Settings
         self._reconciliation: bool = config.reconciliation
         self.reconciliation_lookback_mins: int = config.reconciliation_lookback_mins or 0
+        self.filter_unclaimed_external_orders: bool = config.filter_unclaimed_external_orders
+        self.filter_position_reports: bool = config.filter_position_reports
         self.inflight_check_interval_ms: int = config.inflight_check_interval_ms
         self.inflight_check_threshold_ms: int = config.inflight_check_threshold_ms
         self._inflight_check_threshold_ns: int = millis_to_nanos(self.inflight_check_threshold_ms)
 
+        self._log.info(f"{config.reconciliation=}", LogColor.BLUE)
+        self._log.info(f"{config.reconciliation_lookback_mins=}", LogColor.BLUE)
+        self._log.info(f"{config.filter_unclaimed_external_orders=}", LogColor.BLUE)
+        self._log.info(f"{config.filter_position_reports=}", LogColor.BLUE)
+        self._log.info(f"{config.inflight_check_interval_ms=}", LogColor.BLUE)
+        self._log.info(f"{config.inflight_check_threshold_ms=}", LogColor.BLUE)
+
         # Async tasks
-        self._cmd_queue_task: Optional[asyncio.Task] = None
-        self._evt_queue_task: Optional[asyncio.Task] = None
-        self._inflight_check_task: Optional[asyncio.Task] = None
+        self._cmd_queue_task: asyncio.Task | None = None
+        self._evt_queue_task: asyncio.Task | None = None
+        self._inflight_check_task: asyncio.Task | None = None
         self._kill: bool = False
 
         # Register endpoints
         self._msgbus.register(endpoint="ExecEngine.reconcile_report", handler=self.reconcile_report)
         self._msgbus.register(
             endpoint="ExecEngine.reconcile_mass_status",
             handler=self.reconcile_mass_status,
@@ -161,37 +173,37 @@
         """
         Disconnect the engine by calling disconnect on all registered clients.
         """
         self._log.info("Disconnecting all clients...")
         for client in self._clients.values():
             client.disconnect()
 
-    def get_cmd_queue_task(self) -> Optional[asyncio.Task]:
+    def get_cmd_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal command queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
         """
         return self._cmd_queue_task
 
-    def get_evt_queue_task(self) -> Optional[asyncio.Task]:
+    def get_evt_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal event queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
         """
         return self._evt_queue_task
 
-    def get_inflight_check_task(self) -> Optional[asyncio.Task]:
+    def get_inflight_check_task(self) -> asyncio.Task | None:
         """
         Return the internal in-flight check task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
@@ -328,15 +340,15 @@
 
     async def _run_cmd_queue(self) -> None:
         self._log.debug(
             f"Command message queue processing starting (qsize={self.cmd_qsize()})...",
         )
         try:
             while True:
-                command: Optional[TradingCommand] = await self._cmd_queue.get()
+                command: TradingCommand | None = await self._cmd_queue.get()
                 if command is self._sentinel:
                     break
                 self._execute_command(command)
         except asyncio.CancelledError:
             self._log.warning("Command message queue canceled.")
         finally:
             stopped_msg = "Command message queue stopped"
@@ -347,15 +359,15 @@
 
     async def _run_evt_queue(self) -> None:
         self._log.debug(
             f"Event message queue processing starting (qsize={self.evt_qsize()})...",
         )
         try:
             while True:
-                event: Optional[OrderEvent] = await self._evt_queue.get()
+                event: OrderEvent | None = await self._evt_queue.get()
                 if event is self._sentinel:
                     break
                 self._handle_event(event)
         except asyncio.CancelledError:
             self._log.warning("Event message queue canceled.")
         finally:
             stopped_msg = "Event message queue stopped"
@@ -392,15 +404,16 @@
                 )
                 self._execute_command(query)
 
     # -- RECONCILIATION -------------------------------------------------------------------------------
 
     async def reconcile_state(self, timeout_secs: float = 10.0) -> bool:
         """
-        Reconcile the internal execution state with all execution clients (external state).
+        Reconcile the internal execution state with all execution clients (external
+        state).
 
         Parameters
         ----------
         timeout_secs : double, default 10.0
             The timeout (seconds) for reconciliation to complete.
 
         Returns
@@ -419,15 +432,15 @@
         if not self.reconciliation:
             self._log.warning("Reconciliation deactivated.")
             return True
 
         results: list[bool] = []
 
         # Request execution mass status report from clients
-        reconciliation_lookback_mins: Optional[int] = (
+        reconciliation_lookback_mins: int | None = (
             self.reconciliation_lookback_mins if self.reconciliation_lookback_mins > 0 else None
         )
         mass_status_coros = [
             c.generate_mass_status(reconciliation_lookback_mins) for c in self._clients.values()
         ]
         mass_status_all = await asyncio.gather(*mass_status_coros)
 
@@ -487,41 +500,67 @@
         ----------
         report : ExecutionMassStatus
             The execution mass status report to reconcile.
 
         """
         self._reconcile_mass_status(report)
 
-    def _reconcile_mass_status(self, mass_status: ExecutionMassStatus) -> bool:
+    def _reconcile_mass_status(
+        self,
+        mass_status: ExecutionMassStatus,
+    ) -> bool:
         self._log.debug(f"[RECV][RPT] {mass_status}.")
         self.report_count += 1
 
+        if mass_status is None:
+            self._log.error("Error reconciling mass status (was None).")
+            return False
+
         self._log.info(
             f"Reconciling ExecutionMassStatus for {mass_status.venue}.",
             color=LogColor.BLUE,
         )
 
         results: list[bool] = []
+        reconciled_orders: set[ClientOrderId] = set()
+        reconciled_trades: set[TradeId] = set()
 
         # Reconcile all reported orders
         for venue_order_id, order_report in mass_status.order_reports().items():
             trades = mass_status.trade_reports().get(venue_order_id, [])
+
+            # Check and handle duplicate client order IDs
+            client_order_id = order_report.client_order_id
+            if client_order_id is not None and client_order_id in reconciled_orders:
+                self._log.error(f"Duplicate {client_order_id!r} detected: {order_report}")
+                continue  # Determine how to handle this
+
+            # Check for duplicate trade IDs
+            for trade_report in trades:
+                if trade_report.trade_id in reconciled_trades:
+                    self._log.error(
+                        f"Duplicate {trade_report.trade_id!r} detected: {trade_report}.",
+                    )
+                reconciled_trades.add(trade_report.trade_id)
+
             try:
                 result = self._reconcile_order_report(order_report, trades)
             except InvalidStateTrigger as e:
                 self._log.error(str(e))
                 result = False
             results.append(result)
+            reconciled_orders.add(order_report.client_order_id)
 
-        position_reports: list[PositionStatusReport]
-        # Reconcile all reported positions
-        for position_reports in mass_status.position_reports().values():
-            for report in position_reports:
-                result = self._reconcile_position_report(report)
-                results.append(result)
+        if not self.filter_position_reports:
+            position_reports: list[PositionStatusReport]
+            # Reconcile all reported positions
+            for position_reports in mass_status.position_reports().values():
+                for report in position_reports:
+                    result = self._reconcile_position_report(report)
+                    results.append(result)
 
         # Publish mass status
         self._msgbus.publish(
             topic=f"reports.execution.{mass_status.venue}",
             msg=mass_status,
         )
 
@@ -537,22 +576,24 @@
             client_order_id = self._cache.client_order_id(report.venue_order_id)
             if client_order_id is None:
                 # Generate external client order ID
                 client_order_id = self._generate_client_order_id()
             # Assign to report
             report.client_order_id = client_order_id
 
+        self._log.info(f"Reconciling order for {client_order_id!r}...", LogColor.BLUE)
+
         order: Order = self._cache.order(client_order_id)
         if order is None:
             order = self._generate_external_order(report)
             if order is None:
                 # External order dropped
                 return True  # No further reconciliation
             # Add to cache without determining any position ID initially
-            self._cache.add_order(order, position_id=None)
+            self._cache.add_order(order)
 
         if report.order_status == OrderStatus.REJECTED:
             if order.status != OrderStatus.REJECTED:
                 self._generate_order_rejected(order, report)
             return True  # Reconciled
 
         if report.order_status == OrderStatus.ACCEPTED:
@@ -570,40 +611,44 @@
 
         if report.order_status == OrderStatus.TRIGGERED:
             if order.status != OrderStatus.TRIGGERED:
                 self._generate_order_triggered(order, report)
             return True  # Reconciled
 
         if report.order_status == OrderStatus.CANCELED:
-            if order.status != OrderStatus.CANCELED:
+            if order.status != OrderStatus.CANCELED and order.is_open:
                 if report.ts_triggered > 0:
                     self._generate_order_triggered(order, report)
                 self._generate_order_canceled(order, report)
             return True  # Reconciled
 
         if report.order_status == OrderStatus.EXPIRED:
-            if order.status != OrderStatus.EXPIRED:
+            if order.status != OrderStatus.EXPIRED and order.is_open:
                 if report.ts_triggered > 0:
                     self._generate_order_triggered(order, report)
                 self._generate_order_expired(order, report)
             return True  # Reconciled
 
         # Order has some fills from this point
-        instrument: Optional[Instrument] = self._cache.instrument(order.instrument_id)
+        instrument: Instrument | None = self._cache.instrument(order.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot reconcile order {order.client_order_id}: "
                 f"instrument {order.instrument_id} not found.",
             )
             return False  # Failed
 
         # Reconcile all trades
         for trade in trades:
             self._reconcile_trade_report(order, trade, instrument)
 
+        if report.avg_px is None:
+            self._log.error("report.avg_px was `None` when a value was expected.")
+            return False  # Failed
+
         # Check reported filled qty against order filled qty
         if report.filled_qty != order.filled_qty:
             # This is due to missing trade report(s), there may now be some
             # information loss if multiple fills occurred to reach the reported
             # state, or if commissions differed from the default.
             fill: OrderFilled = self._generate_inferred_fill(order, report, instrument)
             self._handle_event(fill)
@@ -612,31 +657,31 @@
                 self._log.warning(
                     f"report.avg_px {report.avg_px} != order.avg_px {order.avg_px}",
                 )
 
         return True  # Reconciled
 
     def _reconcile_trade_report_single(self, report: TradeReport) -> bool:
-        client_order_id: Optional[ClientOrderId] = self._cache.client_order_id(
+        client_order_id: ClientOrderId | None = self._cache.client_order_id(
             report.venue_order_id,
         )
         if client_order_id is None:
             self._log.error(
-                "Cannot reconcile TradeReport: client order ID {client_order_id} not found.",
+                f"Cannot reconcile TradeReport: client order ID {client_order_id} not found.",
             )
             return False  # Failed
 
-        order: Optional[Order] = self._cache.order(client_order_id)
+        order: Order | None = self._cache.order(client_order_id)
         if order is None:
             self._log.error(
                 "Cannot reconcile TradeReport: no order for client order ID {client_order_id}",
             )
             return False  # Failed
 
-        instrument: Optional[Instrument] = self._cache.instrument(order.instrument_id)
+        instrument: Instrument | None = self._cache.instrument(order.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot reconcile order {order.client_order_id}: "
                 f"instrument {order.instrument_id} not found.",
             )
             return False  # Failed
 
@@ -665,45 +710,45 @@
     def _reconcile_position_report(self, report: PositionStatusReport) -> bool:
         if report.venue_position_id is not None:
             return self._reconcile_position_report_hedging(report)
         else:
             return self._reconcile_position_report_netting(report)
 
     def _reconcile_position_report_hedging(self, report: PositionStatusReport) -> bool:
-        position: Optional[Position] = self._cache.position(report.venue_position_id)
+        position: Position | None = self._cache.position(report.venue_position_id)
         if position is None:
             self._log.error(
                 f"Cannot reconcile position: position ID {report.venue_position_id} not found.",
             )
             return False  # Failed
         position_signed_decimal_qty: Decimal = position.signed_decimal_qty()
         if position_signed_decimal_qty != report.signed_decimal_qty:
             self._log.error(
-                f"Cannot reconcile position: "
-                f"position ID {report.venue_position_id} "
-                f"position signed qty {position_signed_decimal_qty} != reported {report.signed_decimal_qty}. "
+                f"Cannot reconcile {report.instrument_id} {report.venue_position_id}: position "
+                f"net qty {position_signed_decimal_qty} != reported net qty {report.signed_decimal_qty}. "
                 f"{report}.",
             )
             return False  # Failed
 
         return True  # Reconciled
 
     def _reconcile_position_report_netting(self, report: PositionStatusReport) -> bool:
         positions_open: list[Position] = self._cache.positions_open(
             venue=None,  # Faster query filtering
             instrument_id=report.instrument_id,
         )
+
         position_signed_decimal_qty: Decimal = Decimal()
         for position in positions_open:
             position_signed_decimal_qty += position.signed_decimal_qty()
         if position_signed_decimal_qty != report.signed_decimal_qty:
             self._log.error(
-                f"Cannot reconcile position: "
-                f"{report.instrument_id} "
-                f"position signed decimal qty {position_signed_decimal_qty} != reported {report.signed_decimal_qty}.",
+                f"Cannot reconcile {report.instrument_id}: position "
+                f"net qty {position_signed_decimal_qty} != reported net qty {report.signed_decimal_qty}. "
+                f"{report}.",
             )
             return False  # Failed
 
         return True  # Reconciled
 
     def _generate_client_order_id(self) -> ClientOrderId:
         return ClientOrderId(f"O-{UUID4().value}")
@@ -728,15 +773,15 @@
         # Calculate last qty
         last_qty: Quantity = instrument.make_qty(report.filled_qty - order.filled_qty)
 
         # Calculate last px
         if order.avg_px is None:
             last_px: Price = instrument.make_price(report.avg_px)
         else:
-            report_cost: float = float(report.avg_px) * float(report.filled_qty)
+            report_cost: float = float(report.avg_px or 0.0) * float(report.filled_qty)
             filled_cost = order.avg_px * float(order.filled_qty)
             last_px = instrument.make_price((report_cost - filled_cost) / float(last_qty))
 
         notional_value: Money = instrument.notional_value(last_qty, last_px)
         commission: Money = Money(notional_value * instrument.taker_fee, instrument.quote_currency)
 
         filled = OrderFilled(
@@ -760,17 +805,17 @@
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
 
         self._log.warning(f"Generated inferred {filled}.")
         return filled
 
-    def _generate_external_order(self, report: OrderStatusReport) -> Optional[Order]:
+    def _generate_external_order(self, report: OrderStatusReport) -> Order | None:
         self._log.info(
-            f"Generating external order {report.client_order_id!r}",
+            f"Generating order {report.client_order_id!r}",
             color=LogColor.BLUE,
         )
 
         # Prepare order options
         options: dict[str, Any] = {}
         if report.price is not None:
             options["price"] = str(report.price)
@@ -798,21 +843,20 @@
         if strategy_id is None:
             strategy_id = StrategyId("EXTERNAL")
             tags = "EXTERNAL"
         else:
             tags = None
 
         # Check if filtering
-        if self.filter_unclaimed_external_orders:
-            if strategy_id.value == "EXTERNAL":
-                # Experimental: will call this out with a warning log for now
-                self._log.warning(
-                    f"Filtering report for unclaimed EXTERNAL order, {report}.",
-                )
-                return None  # No further reconciliation
+        if self.filter_unclaimed_external_orders and strategy_id.value == "EXTERNAL":
+            # Experimental: will call this out with a warning log for now
+            self._log.warning(
+                f"Filtering report for unclaimed EXTERNAL order, {report}.",
+            )
+            return None  # No further reconciliation
 
         initialized = OrderInitialized(
             trader_id=self.trader_id,
             strategy_id=strategy_id,
             instrument_id=report.instrument_id,
             client_order_id=report.client_order_id,
             order_side=report.order_side,
@@ -971,22 +1015,23 @@
         )
         self._log.debug(f"Generated {filled}.")
         self._handle_event(filled)
 
     def _should_update(self, order: Order, report: OrderStatusReport) -> bool:
         if report.quantity != order.quantity:
             return True
-        elif order.order_type == OrderType.LIMIT:
-            if report.price != order.price:
-                return True
-        elif (
-            order.order_type == OrderType.STOP_MARKET
-            or order.order_type == OrderType.TRAILING_STOP_MARKET
+
+        if order.order_type == OrderType.LIMIT and report.price != order.price:
+            return True
+
+        if (
+            order.order_type in [OrderType.STOP_MARKET, OrderType.TRAILING_STOP_MARKET]
+            and report.trigger_price != order.trigger_price
+        ):
+            return True
+
+        if order.order_type in [OrderType.STOP_LIMIT, OrderType.TRAILING_STOP_LIMIT] and (
+            report.trigger_price != order.trigger_price or report.price != order.price
         ):
-            if report.trigger_price != order.trigger_price:
-                return True
-        elif (
-            order.order_type == OrderType.STOP_LIMIT
-            or order.order_type == OrderType.TRAILING_STOP_LIMIT
-        ) and (report.trigger_price != order.trigger_price or report.price != order.price):
             return True
+
         return False
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/factories.py` & `nautilus_trader-1.176.0/nautilus_trader/live/factories.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
 
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.config import LiveDataClientConfig
 from nautilus_trader.config import LiveExecClientConfig
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/node.py` & `nautilus_trader-1.176.0/nautilus_trader/live/node.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,19 +9,20 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
 import signal
 import time
 from datetime import timedelta
-from typing import Optional
 
 from nautilus_trader.cache.base import CacheFacade
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.config import TradingNodeConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.uuid import UUID4
@@ -41,20 +42,21 @@
     Parameters
     ----------
     config : TradingNodeConfig, optional
         The configuration for the instance.
     loop : asyncio.AbstractEventLoop, optional
         The event loop for the node.
         If ``None`` then will get the running event loop internally.
+
     """
 
     def __init__(
         self,
-        config: Optional[TradingNodeConfig] = None,
-        loop: Optional[asyncio.AbstractEventLoop] = None,
+        config: TradingNodeConfig | None = None,
+        loop: asyncio.AbstractEventLoop | None = None,
     ) -> None:
         if config is None:
             config = TradingNodeConfig()
         PyCondition.not_none(config, "config")
         PyCondition.type(config, TradingNodeConfig, "config")
 
         self._config: TradingNodeConfig = config
@@ -81,14 +83,17 @@
             log=self.kernel.log,
         )
 
         # Operation flags
         self._is_built = False
         self._is_running = False
 
+        self._task_heartbeats: asyncio.Task | None = None
+        self._task_position_snapshots: asyncio.Task | None = None
+
     @property
     def trader_id(self) -> TraderId:
         """
         Return the nodes trader ID.
 
         Returns
         -------
@@ -177,15 +182,15 @@
         Returns
         -------
         bool
 
         """
         return self._is_built
 
-    def get_event_loop(self) -> Optional[asyncio.AbstractEventLoop]:
+    def get_event_loop(self) -> asyncio.AbstractEventLoop | None:
         """
         Return the event loop of the trading node.
 
         Returns
         -------
         asyncio.AbstractEventLoop or ``None``
 
@@ -271,28 +276,30 @@
     def stop(self) -> None:
         """
         Stop the trading node gracefully.
 
         After a specified delay the internal `Trader` residual state will be checked.
 
         If save strategy is configured, then strategy states will be saved.
+
         """
         try:
             if self.kernel.loop.is_running():
                 self.kernel.loop.create_task(self.stop_async())
             else:
                 self.kernel.loop.run_until_complete(self.stop_async())
         except RuntimeError as e:
             self.kernel.log.exception("Error on stop", e)
 
     def dispose(self) -> None:  # noqa: C901
         """
         Dispose of the trading node.
 
         Gracefully shuts down the executor and event loop.
+
         """
         try:
             timeout = self.kernel.clock.utc_now() + timedelta(
                 seconds=self._config.timeout_disconnection,
             )
             while self._is_running:
                 time.sleep(0.1)
@@ -368,14 +375,50 @@
 
             self.kernel.log.info("DISPOSED.")
 
     def _loop_sig_handler(self, sig: signal.Signals) -> None:
         self.kernel.log.warning(f"Received {sig!s}, shutting down...")
         self.stop()
 
+    async def maintain_heartbeat(self, interval: float) -> None:
+        """
+        Maintain heartbeats at the given `interval` while the node is running.
+
+        Parameters
+        ----------
+        interval : float
+            The interval (seconds) between heartbeats.
+
+        """
+        try:
+            while True:
+                await asyncio.sleep(interval)
+                self.cache.heartbeat(self.kernel.clock.utc_now())
+        except asyncio.CancelledError:
+            pass
+
+    async def snapshot_open_positions(self, interval: float) -> None:
+        """
+        Snapshot the state of all open positions at the configured interval.
+
+        Parameters
+        ----------
+        interval : float
+            The interval (seconds) between open position state snapshotting.
+
+        """
+        try:
+            while True:
+                await asyncio.sleep(interval)
+                open_positions = self.kernel.cache.positions_open()
+                for position in open_positions:
+                    self.cache.snapshot_position_state(position)
+        except asyncio.CancelledError:
+            pass
+
     async def run_async(self) -> None:
         """
         Start and run the trading node asynchronously.
         """
         try:
             if not self._is_built:
                 raise RuntimeError(
@@ -398,28 +441,49 @@
                 self.kernel.data_engine.get_res_queue_task(),
                 self.kernel.data_engine.get_data_queue_task(),
                 self.kernel.risk_engine.get_cmd_queue_task(),
                 self.kernel.risk_engine.get_evt_queue_task(),
                 self.kernel.exec_engine.get_cmd_queue_task(),
                 self.kernel.exec_engine.get_evt_queue_task(),
             ]
+
+            if self._config.heartbeat_interval:
+                self._task_heartbeats = asyncio.create_task(
+                    self.maintain_heartbeat(self._config.heartbeat_interval),
+                )
+            if self._config.cache and self._config.cache.snapshot_positions_interval:
+                self._task_position_snapshots = asyncio.create_task(
+                    self.snapshot_open_positions(self._config.cache.snapshot_positions_interval),
+                )
+
             await asyncio.gather(*tasks)
         except asyncio.CancelledError as e:
             self.kernel.log.error(str(e))
 
-    async def stop_async(self) -> None:
+    async def stop_async(self) -> None:  # noqa (too complex)
         """
         Stop the trading node gracefully, asynchronously.
 
         After a specified delay the internal `Trader` residual state will be checked.
 
         If save strategy is configured, then strategy states will be saved.
+
         """
         self.kernel.log.info("STOPPING...")
 
+        if self._task_heartbeats:
+            self.kernel.log.info("Cancelling `task_heartbeats` task...")
+            self._task_heartbeats.cancel()
+            self._task_heartbeats = None
+
+        if self._task_position_snapshots:
+            self.kernel.log.info("Cancelling `task_position_snapshots` task...")
+            self._task_position_snapshots.cancel()
+            self._task_position_snapshots = None
+
         if self.kernel.trader.is_running:
             self.kernel.trader.stop()
             self.kernel.log.info(
                 f"Awaiting post stop ({self._config.timeout_post_stop}s timeout)...",
                 color=LogColor.BLUE,
             )
             await asyncio.sleep(self._config.timeout_post_stop)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/node_builder.py` & `nautilus_trader-1.176.0/nautilus_trader/live/node_builder.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
 
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.logging import LoggerAdapter
 from nautilus_trader.config import ImportableConfig
@@ -52,14 +54,15 @@
         The cache for building clients.
     clock : LiveClock
         The clock for building clients.
     logger : Logger
         The logger for building clients.
     log : LoggerAdapter
         The trading nodes logger.
+
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         data_engine: LiveDataEngine,
         exec_engine: LiveExecutionEngine,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/live/risk_engine.py` & `nautilus_trader-1.176.0/nautilus_trader/live/risk_engine.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,16 +9,17 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
-from typing import Optional
 
 from nautilus_trader.cache.base import CacheFacade
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.queue import Queue
 from nautilus_trader.config import LiveRiskEngineConfig
 from nautilus_trader.core.correctness import PyCondition
@@ -50,27 +51,28 @@
     config : LiveRiskEngineConfig
         The configuration for the instance.
 
     Raises
     ------
     TypeError
         If `config` is not of type `LiveRiskEngineConfig`.
+
     """
 
     _sentinel = None
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         portfolio: PortfolioFacade,
         msgbus: MessageBus,
         cache: CacheFacade,
         clock: LiveClock,
         logger: Logger,
-        config: Optional[LiveRiskEngineConfig] = None,
+        config: LiveRiskEngineConfig | None = None,
     ) -> None:
         if config is None:
             config = LiveRiskEngineConfig()
         PyCondition.type(config, LiveRiskEngineConfig, "config")
         super().__init__(
             portfolio=portfolio,
             msgbus=msgbus,
@@ -81,30 +83,30 @@
         )
 
         self._loop: asyncio.AbstractEventLoop = loop
         self._cmd_queue: Queue = Queue(maxsize=config.qsize)
         self._evt_queue: Queue = Queue(maxsize=config.qsize)
 
         # Async tasks
-        self._cmd_queue_task: Optional[asyncio.Task] = None
-        self._evt_queue_task: Optional[asyncio.Task] = None
+        self._cmd_queue_task: asyncio.Task | None = None
+        self._evt_queue_task: asyncio.Task | None = None
         self._kill: bool = False
 
-    def get_cmd_queue_task(self) -> Optional[asyncio.Task]:
+    def get_cmd_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal command queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
         """
         return self._cmd_queue_task
 
-    def get_evt_queue_task(self) -> Optional[asyncio.Task]:
+    def get_evt_queue_task(self) -> asyncio.Task | None:
         """
         Return the internal event queue task for the engine.
 
         Returns
         -------
         asyncio.Task or ``None``
 
@@ -234,15 +236,15 @@
 
     async def _run_cmd_queue(self) -> None:
         self._log.debug(
             f"Command message queue processing (qsize={self.cmd_qsize()})...",
         )
         try:
             while True:
-                command: Optional[Command] = await self._cmd_queue.get()
+                command: Command | None = await self._cmd_queue.get()
                 if command is self._sentinel:
                     break
                 self._execute_command(command)
         except asyncio.CancelledError:
             self._log.warning("Command message queue canceled.")
         finally:
             stopped_msg = "Command message queue stopped"
@@ -253,15 +255,15 @@
 
     async def _run_evt_queue(self) -> None:
         self._log.debug(
             f"Event message queue processing starting (qsize={self.evt_qsize()})...",
         )
         try:
             while True:
-                event: Optional[Event] = await self._evt_queue.get()
+                event: Event | None = await self._evt_queue.get()
                 if event is self._sentinel:
                     break
                 self._handle_event(event)
         except asyncio.CancelledError:
             self._log.warning("Event message queue canceled.")
         finally:
             stopped_msg = "Event message queue stopped"
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 The `model` subpackage defines a rich trading domain model.
 
-The domain model is agnostic of any system design, seeking to represent the logic
-and state transitions of trading in a generic way. Many system implementations could
-be built around this domain model.
+The domain model is agnostic of any system design, seeking to represent the logic and
+state transitions of trading in a generic way. Many system implementations could be
+built around this domain model.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/currencies.py` & `nautilus_trader-1.176.0/nautilus_trader/model/currencies.py`

 * *Files 1% similar despite different names*

```diff
@@ -74,17 +74,19 @@
 LINK = Currency.from_internal_map("LINK")
 LTC = Currency.from_internal_map("LTC")
 LUNA = Currency.from_internal_map("LUNA")
 NBT = Currency.from_internal_map("NBT")
 SOL = Currency.from_internal_map("SOL")
 TRX = Currency.from_internal_map("TRX")
 TRYB = Currency.from_internal_map("TRYB")
+TUSD = Currency.from_internal_map("TUSD")
 VTC = Currency.from_internal_map("VTC")
 XLM = Currency.from_internal_map("XLM")
 XMR = Currency.from_internal_map("XMR")
 XRP = Currency.from_internal_map("XRP")
 XTZ = Currency.from_internal_map("XTZ")
 USDC = Currency.from_internal_map("USDC")
+USDP = Currency.from_internal_map("USDP")
 USDT = Currency.from_internal_map("USDT")
 WSB = Currency.from_internal_map("WSB")
 XEC = Currency.from_internal_map("XEC")
 ZEC = Currency.from_internal_map("ZEC")
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/currency.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/currency.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/currency.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/currency.pyx`

 * *Files 8% similar despite different names*

```diff
@@ -13,27 +13,23 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint16_t
 
 from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.rust.model cimport currency_clone
-from nautilus_trader.core.rust.model cimport currency_code_to_cstr
-from nautilus_trader.core.rust.model cimport currency_drop
-from nautilus_trader.core.rust.model cimport currency_eq
 from nautilus_trader.core.rust.model cimport currency_exists
 from nautilus_trader.core.rust.model cimport currency_from_cstr
 from nautilus_trader.core.rust.model cimport currency_from_py
 from nautilus_trader.core.rust.model cimport currency_hash
-from nautilus_trader.core.rust.model cimport currency_name_to_cstr
 from nautilus_trader.core.rust.model cimport currency_register
 from nautilus_trader.core.rust.model cimport currency_to_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
+from nautilus_trader.core.string cimport ustr_to_pystr
 from nautilus_trader.model.enums_c cimport CurrencyType
 
 
 cdef class Currency:
     """
     Represents a medium of exchange in a specified denomination with a fixed
     decimal precision.
@@ -81,18 +77,14 @@
             pystr_to_cstr(code),
             precision,
             iso4217,
             pystr_to_cstr(name),
             currency_type,
         )
 
-    def __del__(self) -> None:
-        if self._mem.code != NULL:
-            currency_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return (
             self.code,
             self._mem.precision,
             self._mem.iso4217,
             self.name,
             <CurrencyType>self._mem.currency_type,
@@ -104,48 +96,50 @@
             state[1],
             state[2],
             pystr_to_cstr(state[3]),
             state[4],
         )
 
     def __eq__(self, Currency other) -> bool:
-        return currency_eq(&self._mem, &other._mem)
+        if other is None:
+            raise RuntimeError("other was None in __eq__")
+        return self._mem.code == other._mem.code
 
     def __hash__(self) -> int:
         return currency_hash(&self._mem)
 
     def __str__(self) -> str:
-        return cstr_to_pystr(currency_code_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.code)
 
     def __repr__(self) -> str:
         return cstr_to_pystr(currency_to_cstr(&self._mem))
 
     @property
-    def code(self) -> int:
+    def code(self) -> str:
         """
         Return the currency code.
 
         Returns
         -------
         str
 
         """
-        return cstr_to_pystr(currency_code_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.code)
 
     @property
-    def name(self) -> int:
+    def name(self) -> str:
         """
         Return the currency name.
 
         Returns
         -------
         str
 
         """
-        return cstr_to_pystr(currency_name_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.name)
 
     @property
     def precision(self) -> int:
         """
         Return the currency decimal precision.
 
         Returns
@@ -183,15 +177,15 @@
         return self._mem.precision
 
     @staticmethod
     cdef void register_c(Currency currency, bint overwrite=False):
         cdef Currency existing = Currency.from_internal_map_c(currency.code)
         if existing is not None and not overwrite:
             return  # Already exists in internal map
-        currency_register(currency_clone(&currency._mem))
+        currency_register(currency._mem)
 
     @staticmethod
     cdef Currency from_internal_map_c(str code):
         cdef const char* code_ptr = pystr_to_cstr(code)
         if not currency_exists(code_ptr):
             return None
         cdef Currency currency = Currency.__new__(Currency)
@@ -211,14 +205,16 @@
             code=code,
             precision=8,
             iso4217=0,
             name=code,
             currency_type=CurrencyType.CRYPTO,
         )
         print(f"Currency '{code}' not found, created {repr(currency)}")
+        currency_register(currency._mem)
+
         return currency
 
     @staticmethod
     cdef bint is_fiat_c(str code):
         cdef Currency currency = Currency.from_internal_map_c(code)
         if currency is None:
             return False
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/data/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,23 +8,25 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""Defines the fundamental data types represented within the trading domain."""
+"""
+Defines the fundamental data types represented within the trading domain.
+"""
 
 from nautilus_trader.model.data.bar import Bar
 from nautilus_trader.model.data.bar import BarSpecification
 from nautilus_trader.model.data.bar import BarType
 from nautilus_trader.model.data.bar_aggregation import BarAggregation
 from nautilus_trader.model.data.base import DataType
 from nautilus_trader.model.data.base import GenericData
+from nautilus_trader.model.data.book import NULL_ORDER
 from nautilus_trader.model.data.book import BookOrder
 from nautilus_trader.model.data.book import OrderBookDelta
 from nautilus_trader.model.data.book import OrderBookDeltas
 from nautilus_trader.model.data.tick import QuoteTick
 from nautilus_trader.model.data.tick import TradeTick
 from nautilus_trader.model.data.ticker import Ticker
 from nautilus_trader.model.data.venue import InstrumentClose
@@ -33,14 +35,15 @@
 
 
 __all__ = [
     "Bar",
     "BarSpecification",
     "BarType",
     "GenericData",
+    "NULL_ORDER",
     "BarAggregation",
     "DataType",
     "BookOrder",
     "OrderBookDelta",
     "OrderBookDeltas",
     "QuoteTick",
     "Ticker",
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/bar.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/data/bar.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -16,50 +16,48 @@
 from cpython.datetime cimport timedelta
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.model cimport BarSpecification_t
 from nautilus_trader.core.rust.model cimport BarType_t
-from nautilus_trader.core.rust.model cimport bar_drop
 from nautilus_trader.core.rust.model cimport bar_eq
 from nautilus_trader.core.rust.model cimport bar_hash
 from nautilus_trader.core.rust.model cimport bar_new
 from nautilus_trader.core.rust.model cimport bar_new_from_raw
 from nautilus_trader.core.rust.model cimport bar_specification_eq
 from nautilus_trader.core.rust.model cimport bar_specification_ge
 from nautilus_trader.core.rust.model cimport bar_specification_gt
 from nautilus_trader.core.rust.model cimport bar_specification_hash
 from nautilus_trader.core.rust.model cimport bar_specification_le
 from nautilus_trader.core.rust.model cimport bar_specification_lt
 from nautilus_trader.core.rust.model cimport bar_specification_new
 from nautilus_trader.core.rust.model cimport bar_specification_to_cstr
 from nautilus_trader.core.rust.model cimport bar_to_cstr
-from nautilus_trader.core.rust.model cimport bar_type_clone
-from nautilus_trader.core.rust.model cimport bar_type_drop
 from nautilus_trader.core.rust.model cimport bar_type_eq
 from nautilus_trader.core.rust.model cimport bar_type_ge
 from nautilus_trader.core.rust.model cimport bar_type_gt
 from nautilus_trader.core.rust.model cimport bar_type_hash
 from nautilus_trader.core.rust.model cimport bar_type_le
 from nautilus_trader.core.rust.model cimport bar_type_lt
 from nautilus_trader.core.rust.model cimport bar_type_new
 from nautilus_trader.core.rust.model cimport bar_type_to_cstr
-from nautilus_trader.core.rust.model cimport instrument_id_clone
 from nautilus_trader.core.rust.model cimport instrument_id_new_from_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
 from nautilus_trader.model.data.bar_aggregation cimport BarAggregation
 from nautilus_trader.model.enums_c cimport AggregationSource
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.enums_c cimport aggregation_source_from_str
 from nautilus_trader.model.enums_c cimport bar_aggregation_from_str
 from nautilus_trader.model.enums_c cimport bar_aggregation_to_str
 from nautilus_trader.model.enums_c cimport price_type_from_str
 from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.identifiers cimport Symbol
+from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
 cdef class BarSpecification:
     """
     Represents a bar aggregation specification including a step, aggregation
@@ -476,45 +474,40 @@
     def __init__(
         self,
         InstrumentId instrument_id not None,
         BarSpecification bar_spec not None,
         AggregationSource aggregation_source=AggregationSource.EXTERNAL,
     ):
         self._mem = bar_type_new(
-            instrument_id_clone(&instrument_id._mem),
+            instrument_id._mem,
             bar_spec._mem,
             aggregation_source
         )
 
     def __getstate__(self):
         return (
             self.instrument_id.value,
             self._mem.spec.step,
             self._mem.spec.aggregation,
             self._mem.spec.price_type,
             self._mem.aggregation_source
         )
 
     def __setstate__(self, state):
+        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
         self._mem = bar_type_new(
-            instrument_id_new_from_cstr(
-                pystr_to_cstr(state[0]),
-            ),
+            instrument_id._mem,
             bar_specification_new(
                 state[1],
                 state[2],
                 state[3]
             ),
             state[4],
         )
 
-    def __del__(self) -> None:
-        if self._mem.instrument_id.symbol.value != NULL:
-            bar_type_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     cdef str to_str(self):
         return cstr_to_pystr(bar_type_to_cstr(&self._mem))
 
     def __eq__(self, BarType other) -> bool:
         return bar_type_eq(&self._mem, &other._mem)
 
     def __lt__(self, BarType other) -> bool:
@@ -537,23 +530,22 @@
 
     def __repr__(self) -> str:
         return f"{type(self).__name__}({self})"
 
     @staticmethod
     cdef BarType from_mem_c(BarType_t mem):
         cdef BarType bar_type = BarType.__new__(BarType)
-        bar_type._mem = bar_type_clone(&mem)
+        bar_type._mem = mem
         return bar_type
 
     @staticmethod
     cdef BarType from_str_c(str value):
         Condition.valid_string(value, 'value')
 
         cdef list pieces = value.rsplit('-', maxsplit=4)
-
         if len(pieces) != 5:
             raise ValueError(f"The `BarType` string value was malformed, was {value}")
 
         cdef InstrumentId instrument_id = InstrumentId.from_str_c(pieces[0])
         cdef BarSpecification bar_spec = BarSpecification(
             int(pieces[1]),
             bar_aggregation_from_str(pieces[2]),
@@ -698,15 +690,15 @@
         Condition.true(high._mem.raw >= open._mem.raw, "high was < open")
         Condition.true(high._mem.raw >= low._mem.raw, "high was < low")
         Condition.true(high._mem.raw >= close._mem.raw, "high was < close")
         Condition.true(low._mem.raw <= close._mem.raw, "low was > close")
         Condition.true(low._mem.raw <= open._mem.raw, "low was > open")
 
         self._mem = bar_new(
-            bar_type_clone(&bar_type._mem),
+            bar_type._mem,
             open._mem,
             high._mem,
             low._mem,
             close._mem,
             volume._mem,
             ts_event,
             ts_init,
@@ -728,19 +720,18 @@
             self._mem.volume.raw,
             self._mem.volume.precision,
             self.ts_event,
             self.ts_init,
         )
 
     def __setstate__(self, state):
+        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
         self._mem = bar_new_from_raw(
             bar_type_new(
-                instrument_id_new_from_cstr(
-                    pystr_to_cstr(state[0]),
-                ),
+                instrument_id._mem,
                 bar_specification_new(
                     state[1],
                     state[2],
                     state[3],
                 ),
                 state[4],
             ),
@@ -751,18 +742,14 @@
             state[9],
             state[10],
             state[11],
             state[12],
             state[13],
         )
 
-    def __del__(self) -> None:
-        if self._mem.bar_type.instrument_id.symbol.value != NULL:
-            bar_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __eq__(self, Bar other) -> bool:
         return bar_eq(&self._mem, &other._mem)
 
     def __hash__(self) -> int:
         return bar_hash(&self._mem)
 
     cdef str to_str(self):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/bar_aggregation.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pyx` & `nautilus_trader-1.176.0/nautilus_trader/analysis/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,10 +8,11 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-
-from nautilus_trader.model.data.bar_aggregation cimport BarAggregation  # type: ignore
+"""
+The `analysis` subpackage groups components relating to trading performance statistics
+and analysis.
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/base.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/data/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/book.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/book.pxd`

 * *Files 8% similar despite different names*

```diff
@@ -16,18 +16,14 @@
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.model cimport BookOrder_t
 from nautilus_trader.core.rust.model cimport OrderBookDelta_t
 from nautilus_trader.model.data.book cimport OrderBookDelta
 from nautilus_trader.model.data.book cimport OrderBookDeltas
-from nautilus_trader.model.enums_c cimport BookAction
-from nautilus_trader.model.enums_c cimport BookType
-from nautilus_trader.model.enums_c cimport OrderSide
-from nautilus_trader.model.enums_c cimport TimeInForce
 from nautilus_trader.model.identifiers cimport InstrumentId
 
 
 cdef class BookOrder:
     cdef BookOrder_t _mem
 
     cpdef double exposure(self)
@@ -63,16 +59,14 @@
         uint64_t sequence=*,
     )
 
 
 cdef class OrderBookDeltas(Data):
     cdef readonly InstrumentId instrument_id
     """The instrument ID for the order book.\n\n:returns: `InstrumentId`"""
-    cdef readonly uint64_t sequence
-    """The unique sequence number.\n\n:returns: `uint64`"""
     cdef readonly list deltas
     """The order book deltas.\n\n:returns: `list[OrderBookDelta]`"""
     cdef readonly bint is_snapshot
     """If the deltas represent a snapshot (an initial CLEAR then deltas).\n\n:returns: `bool`"""
     cdef readonly uint64_t ts_event
     """The UNIX timestamp (nanoseconds) when the data event occurred.\n\n:returns: `uint64_t`"""
     cdef readonly uint64_t ts_init
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/book.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/data/book.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -12,46 +12,47 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
-import uuid
-
 import msgspec
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.model cimport book_order_debug_to_cstr
 from nautilus_trader.core.rust.model cimport book_order_eq
 from nautilus_trader.core.rust.model cimport book_order_exposure
 from nautilus_trader.core.rust.model cimport book_order_from_raw
 from nautilus_trader.core.rust.model cimport book_order_hash
 from nautilus_trader.core.rust.model cimport book_order_signed_size
-from nautilus_trader.core.rust.model cimport instrument_id_clone
-from nautilus_trader.core.rust.model cimport orderbook_delta_clone
-from nautilus_trader.core.rust.model cimport orderbook_delta_drop
 from nautilus_trader.core.rust.model cimport orderbook_delta_eq
 from nautilus_trader.core.rust.model cimport orderbook_delta_hash
 from nautilus_trader.core.rust.model cimport orderbook_delta_new
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.model.enums_c cimport BookAction
-from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport book_action_from_str
 from nautilus_trader.model.enums_c cimport book_action_to_str
-from nautilus_trader.model.enums_c cimport book_type_from_str
-from nautilus_trader.model.enums_c cimport book_type_to_str
 from nautilus_trader.model.enums_c cimport order_side_from_str
 from nautilus_trader.model.enums_c cimport order_side_to_str
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
+# Represents a 'NULL' order (used for 'CLEAR' actions by OrderBookDelta)
+NULL_ORDER = BookOrder(
+    side=OrderSide.NO_ORDER_SIDE,
+    price=Price(0, 0),
+    size=Quantity(0, 0),
+    order_id=0,
+)
+
+
 cdef class BookOrder:
     """
     Represents an order in a book.
 
     Parameters
     ----------
     side : OrderSide {``BUY``, ``SELL``}
@@ -63,16 +64,16 @@
     order_id : uint64_t
         The order ID.
     """
 
     def __init__(
         self,
         OrderSide side,
-        Price price,
-        Quantity size,
+        Price price not None,
+        Quantity size not None,
         uint64_t order_id,
     ):
         self._mem = book_order_from_raw(
             side,
             price._mem.raw,
             price._mem.precision,
             size._mem.raw,
@@ -222,24 +223,24 @@
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the book.
     action : BookAction {``ADD``, ``UPDATE``, ``DELETE``, ``CLEAR``}
         The order book delta action.
-    order : Order
+    order : BookOrder
         The order to apply.
     ts_event : uint64_t
         The UNIX timestamp (nanoseconds) when the data event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
     sequence : uint64_t, default 0
         The unique sequence number for the update. If default 0 then will increment the `sequence`.
-    flags : uint8_t, default 0
-        The unique sequence number for the update. If default 0 then will increment the `sequence`.
+    flags : uint8_t, default 0 (no flags)
+        A combination of packet end with matching engine status.
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
         BookAction action,
         BookOrder order,
@@ -254,27 +255,23 @@
             0,
             0,
             0,
             0,
             0,
         )
         self._mem = orderbook_delta_new(
-            instrument_id_clone(&instrument_id._mem),
+            instrument_id._mem,
             action,
             book_order,
             flags,
             sequence,
             ts_event,
             ts_init,
         )
 
-    def __del__(self) -> None:
-        if self._mem.instrument_id.symbol.value != NULL:
-            orderbook_delta_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __eq__(self, OrderBookDelta other) -> bool:
         return orderbook_delta_eq(&self._mem, &other._mem)
 
     def __hash__(self) -> int:
         return orderbook_delta_hash(&self._mem)
 
     def __repr__(self) -> str:
@@ -420,27 +417,22 @@
 
         """
         return self._mem.ts_init
 
     @staticmethod
     cdef OrderBookDelta from_mem_c(OrderBookDelta_t mem):
         cdef OrderBookDelta delta = OrderBookDelta.__new__(OrderBookDelta)
-        delta._mem = orderbook_delta_clone(&mem)
+        delta._mem = mem
         return delta
 
     @staticmethod
     cdef OrderBookDelta from_dict_c(dict values):
         Condition.not_none(values, "values")
         cdef BookAction action = book_action_from_str(values["action"])
-        cdef BookOrder order = BookOrder.from_dict_c({
-            "side": values["side"],
-            "price": values["price"],
-            "size": values["size"],
-            "order_id": values["order_id"],
-        }) if values["action"] != "CLEAR" else None
+        cdef BookOrder order = BookOrder.from_dict_c(values["order"])
         return OrderBookDelta(
             instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
             action=action,
             order=order,
             flags=values["flags"],
             sequence=values["sequence"],
             ts_event=values["ts_event"],
@@ -451,18 +443,20 @@
     cdef dict to_dict_c(OrderBookDelta obj):
         Condition.not_none(obj, "obj")
         cdef BookOrder order = obj.order
         return {
             "type": "OrderBookDelta",
             "instrument_id": obj.instrument_id.value,
             "action": book_action_to_str(obj._mem.action),
-            "side": order_side_to_str(order.side) if order else None,
-            "price": str(obj.order.price) if order else None,
-            "size": str(obj.order.size) if order else None,
-            "order_id": order._mem.order_id if order else None,
+            "order": {
+                "side": order_side_to_str(order._mem.side),
+                "price": str(order.price),
+                "size": str(order.size),
+                "order_id": order._mem.order_id,
+            },
             "flags": obj._mem.flags,
             "sequence": obj._mem.sequence,
             "ts_event": obj._mem.ts_event,
             "ts_init": obj._mem.ts_init,
         }
 
     @staticmethod
@@ -553,15 +547,14 @@
         return hash(frozenset(OrderBookDeltas.to_dict_c(self)))
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
             f"instrument_id={self.instrument_id}, "
             f"{self.deltas}, "
-            f"sequence={self.sequence}, "
             f"is_snapshot={self.is_snapshot}, "
             f"ts_event={self.ts_event}, "
             f"ts_init={self.ts_init})"
         )
 
     @staticmethod
     cdef OrderBookDeltas from_dict_c(dict values):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/tick.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/data/tick.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -16,34 +16,36 @@
 from libc.stdint cimport int64_t
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.core cimport CVec
-from nautilus_trader.core.rust.model cimport instrument_id_clone
 from nautilus_trader.core.rust.model cimport instrument_id_new_from_cstr
-from nautilus_trader.core.rust.model cimport quote_tick_clone
-from nautilus_trader.core.rust.model cimport quote_tick_drop
+from nautilus_trader.core.rust.model cimport quote_tick_eq
+from nautilus_trader.core.rust.model cimport quote_tick_hash
 from nautilus_trader.core.rust.model cimport quote_tick_new
 from nautilus_trader.core.rust.model cimport quote_tick_to_cstr
-from nautilus_trader.core.rust.model cimport trade_id_clone
+from nautilus_trader.core.rust.model cimport symbol_new
 from nautilus_trader.core.rust.model cimport trade_id_new
-from nautilus_trader.core.rust.model cimport trade_tick_clone
-from nautilus_trader.core.rust.model cimport trade_tick_drop
+from nautilus_trader.core.rust.model cimport trade_tick_eq
+from nautilus_trader.core.rust.model cimport trade_tick_hash
 from nautilus_trader.core.rust.model cimport trade_tick_new
 from nautilus_trader.core.rust.model cimport trade_tick_to_cstr
+from nautilus_trader.core.rust.model cimport venue_new
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
 from nautilus_trader.model.enums_c cimport AggressorSide
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.enums_c cimport aggressor_side_from_str
 from nautilus_trader.model.enums_c cimport aggressor_side_to_str
 from nautilus_trader.model.enums_c cimport price_type_to_str
 from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.identifiers cimport Symbol
+from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
 cdef class QuoteTick(Data):
     """
     Represents a single quote tick in a financial market.
@@ -85,31 +87,27 @@
         uint64_t ts_event,
         uint64_t ts_init,
     ):
         Condition.equal(bid._mem.precision, ask._mem.precision, "bid.precision", "ask.precision")
         Condition.equal(bid_size._mem.precision, ask_size._mem.precision, "bid_size.precision", "ask_size.precision")
 
         self._mem = quote_tick_new(
-            instrument_id_clone(&instrument_id._mem),
+            instrument_id._mem,
             bid._mem.raw,
             ask._mem.raw,
             bid._mem.precision,
             ask._mem.precision,
             bid_size._mem.raw,
             ask_size._mem.raw,
             bid_size._mem.precision,
             ask_size._mem.precision,
             ts_event,
             ts_init,
         )
 
-    def __del__(self) -> None:
-        if self._mem.instrument_id.symbol.value != NULL:
-            quote_tick_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return (
             self.instrument_id.value,
             self._mem.bid.raw,
             self._mem.ask.raw,
             self._mem.bid.precision,
             self._mem.ask.precision,
@@ -118,35 +116,34 @@
             self._mem.bid_size.precision,
             self._mem.ask_size.precision,
             self.ts_event,
             self.ts_init,
         )
 
     def __setstate__(self, state):
+        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
         self._mem = quote_tick_new(
-            instrument_id_new_from_cstr(
-                pystr_to_cstr(state[0]),
-            ),
+            instrument_id._mem,
             state[1],
             state[2],
             state[3],
             state[4],
             state[5],
             state[6],
             state[7],
             state[8],
             state[9],
             state[10],
         )
 
     def __eq__(self, QuoteTick other) -> bool:
-        return self.to_str() == other.to_str()
+        return quote_tick_eq(&self._mem, &other._mem)
 
     def __hash__(self) -> int:
-        return hash(self.to_str())
+        return quote_tick_hash(&self._mem)
 
     def __str__(self) -> str:
         return self.to_str()
 
     def __repr__(self) -> str:
         return f"{type(self).__name__}({self})"
 
@@ -276,15 +273,15 @@
         uint8_t bid_size_prec,
         uint8_t ask_size_prec,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
         cdef QuoteTick tick = QuoteTick.__new__(QuoteTick)
         tick._mem = quote_tick_new(
-            instrument_id_clone(&instrument_id._mem),
+            instrument_id._mem,
             raw_bid,
             raw_ask,
             bid_price_prec,
             ask_price_prec,
             raw_bid_size,
             raw_ask_size,
             bid_size_prec,
@@ -293,15 +290,15 @@
             ts_init,
         )
         return tick
 
     @staticmethod
     cdef QuoteTick from_mem_c(QuoteTick_t mem):
         cdef QuoteTick quote_tick = QuoteTick.__new__(QuoteTick)
-        quote_tick._mem = quote_tick_clone(&mem)
+        quote_tick._mem = mem
         return quote_tick
 
     # Safety: Do NOT deallocate the capsule here
     # It is supposed to be deallocated by the creator
     @staticmethod
     cdef inline list capsule_to_quote_tick_list(object capsule):
         cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
@@ -527,62 +524,57 @@
         Quantity size not None,
         AggressorSide aggressor_side,
         TradeId trade_id not None,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
         self._mem = trade_tick_new(
-            instrument_id_clone(&instrument_id._mem),
+            instrument_id._mem,
             price._mem.raw,
             price._mem.precision,
             size._mem.raw,
             size._mem.precision,
             aggressor_side,
-            trade_id_clone(&trade_id._mem),
+            trade_id._mem,
             ts_event,
             ts_init,
         )
 
-    def __del__(self) -> None:
-        if self._mem.instrument_id.symbol.value != NULL:
-            trade_tick_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return (
             self.instrument_id.value,
             self._mem.price.raw,
             self._mem.price.precision,
             self._mem.size.raw,
             self._mem.size.precision,
             self._mem.aggressor_side,
             self.trade_id.value,
             self.ts_event,
             self.ts_init,
         )
 
     def __setstate__(self, state):
+        cdef InstrumentId instrument_id = InstrumentId.from_str_c(state[0])
         self._mem = trade_tick_new(
-            instrument_id_new_from_cstr(
-                pystr_to_cstr(state[0]),
-            ),
+            instrument_id._mem,
             state[1],
             state[2],
             state[3],
             state[4],
             state[5],
-            trade_id_new(pystr_to_cstr(state[6])),
+            TradeId(state[6])._mem,
             state[7],
             state[8],
         )
 
     def __eq__(self, TradeTick other) -> bool:
-        return self.to_str() == other.to_str()
+        return trade_tick_eq(&self._mem, &other._mem)
 
     def __hash__(self) -> int:
-        return hash(self.to_str())
+        return trade_tick_hash(&self._mem)
 
     def __str__(self) -> str:
         return self.to_str()
 
     def __repr__(self) -> str:
         return f"{type(self).__name__}({self.to_str()})"
 
@@ -683,30 +675,30 @@
         AggressorSide aggressor_side,
         TradeId trade_id,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
         cdef TradeTick tick = TradeTick.__new__(TradeTick)
         tick._mem = trade_tick_new(
-            instrument_id_clone(&instrument_id._mem),
+            instrument_id._mem,
             raw_price,
             price_prec,
             raw_size,
             size_prec,
             aggressor_side,
-            trade_id_clone(&trade_id._mem),
+            trade_id._mem,
             ts_event,
             ts_init,
         )
         return tick
 
     @staticmethod
     cdef TradeTick from_mem_c(TradeTick_t mem):
         cdef TradeTick trade_tick = TradeTick.__new__(TradeTick)
-        trade_tick._mem = trade_tick_clone(&mem)
+        trade_tick._mem = mem
         return trade_tick
 
     # Safety: Do NOT deallocate the capsule here
     # It is supposed to be deallocated by the creator
     @staticmethod
     cdef inline list capsule_to_trade_tick_list(object capsule):
         cdef CVec* data = <CVec *>PyCapsule_GetPointer(capsule, NULL)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/ticker.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/data/ticker.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/data/venue.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/data/venue.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/enums.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/enums.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/enums_c.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/enums_c.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/msgbus/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/events/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,16 +8,17 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""Defines the fundamental event types represented within the trading domain."""
+"""
+Defines the fundamental event types represented within the trading domain.
+"""
 
 from nautilus_trader.model.events.account import AccountState
 from nautilus_trader.model.events.order import OrderAccepted
 from nautilus_trader.model.events.order import OrderCanceled
 from nautilus_trader.model.events.order import OrderCancelRejected
 from nautilus_trader.model.events.order import OrderDenied
 from nautilus_trader.model.events.order import OrderEvent
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/account.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/events/account.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/account.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/events/account.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/order.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/base.pxd`

 * *Files 20% similar despite different names*

```diff
@@ -9,244 +9,188 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.core.message cimport Event
-from nautilus_trader.core.rust.model cimport OrderDenied_t
-from nautilus_trader.model.currency cimport Currency
+from libc.stdint cimport uint64_t
+
+from nautilus_trader.core.fsm cimport FiniteStateMachine
+from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OrderSide
+from nautilus_trader.model.enums_c cimport OrderStatus
 from nautilus_trader.model.enums_c cimport OrderType
+from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport TimeInForce
 from nautilus_trader.model.enums_c cimport TriggerType
+from nautilus_trader.model.events.order cimport OrderAccepted
+from nautilus_trader.model.events.order cimport OrderCanceled
+from nautilus_trader.model.events.order cimport OrderDenied
+from nautilus_trader.model.events.order cimport OrderEvent
+from nautilus_trader.model.events.order cimport OrderExpired
+from nautilus_trader.model.events.order cimport OrderFilled
+from nautilus_trader.model.events.order cimport OrderInitialized
+from nautilus_trader.model.events.order cimport OrderRejected
+from nautilus_trader.model.events.order cimport OrderSubmitted
+from nautilus_trader.model.events.order cimport OrderTriggered
+from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.identifiers cimport AccountId
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TradeId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.identifiers cimport VenueOrderId
-from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
-cdef class OrderEvent(Event):
+cdef tuple VALID_STOP_ORDER_TYPES
+cdef tuple VALID_LIMIT_ORDER_TYPES
+
+
+cdef class Order:
+    cdef list _events
+    cdef list _venue_order_ids
+    cdef list _trade_ids
+    cdef dict _commissions
+    cdef FiniteStateMachine _fsm
+    cdef OrderStatus _previous_status
+    cdef Price _triggered_price
+
     cdef readonly TraderId trader_id
-    """The trader ID associated with the event.\n\n:returns: `TraderId`"""
+    """The trader ID associated with the position.\n\n:returns: `TraderId`"""
     cdef readonly StrategyId strategy_id
-    """The strategy ID associated with the event.\n\n:returns: `StrategyId`"""
+    """The strategy ID associated with the order.\n\n:returns: `StrategyId`"""
     cdef readonly InstrumentId instrument_id
-    """The instrument ID associated with the event.\n\n:returns: `InstrumentId`"""
+    """The order instrument ID.\n\n:returns: `InstrumentId`"""
     cdef readonly ClientOrderId client_order_id
-    """The client order ID associated with the event.\n\n:returns: `ClientOrderId`"""
+    """The client order ID.\n\n:returns: `ClientOrderId`"""
     cdef readonly VenueOrderId venue_order_id
-    """The venue order ID associated with the event.\n\n:returns: `VenueOrderId` or ``None``"""
+    """The venue assigned order ID.\n\n:returns: `VenueOrderId` or ``None``"""
+    cdef readonly PositionId position_id
+    """The position ID associated with the order.\n\n:returns: `PositionId` or ``None``"""
     cdef readonly AccountId account_id
-    """The account ID associated with the event.\n\n:returns: `AccountId` or ``None``"""
-    cdef readonly bint reconciliation
-    """If the event was generated during reconciliation.\n\n:returns: `bool`"""
-
-
-cdef class OrderInitialized(OrderEvent):
+    """The account ID associated with the order.\n\n:returns: `AccountId` or ``None``"""
+    cdef readonly TradeId last_trade_id
+    """The orders last trade match ID.\n\n:returns: `TradeId` or ``None``"""
     cdef readonly OrderSide side
     """The order side.\n\n:returns: `OrderSide`"""
     cdef readonly OrderType order_type
     """The order type.\n\n:returns: `OrderType`"""
-    cdef readonly Quantity quantity
-    """The order quantity.\n\n:returns: `Quantity`"""
     cdef readonly TimeInForce time_in_force
     """The order time in force.\n\n:returns: `TimeInForce`"""
-    cdef readonly bint post_only
+    cdef readonly LiquiditySide liquidity_side
+    """The order liquidity side.\n\n:returns: `LiquiditySide`"""
+    cdef readonly bint is_post_only
     """If the order will only provide liquidity (make a market).\n\n:returns: `bool`"""
-    cdef readonly bint reduce_only
+    cdef readonly bint is_reduce_only
     """If the order carries the 'reduce-only' execution instruction.\n\n:returns: `bool`"""
-    cdef readonly bint quote_quantity
+    cdef readonly bint is_quote_quantity
     """If the order quantity is denominated in the quote currency.\n\n:returns: `bool`"""
-    cdef readonly dict options
-    """The order initialization options.\n\n:returns: `dict`"""
+    cdef readonly Quantity quantity
+    """The order quantity.\n\n:returns: `Quantity`"""
+    cdef readonly Quantity filled_qty
+    """The order total filled quantity.\n\n:returns: `Quantity`"""
+    cdef readonly Quantity leaves_qty
+    """The order total leaves quantity.\n\n:returns: `Quantity`"""
+    cdef readonly double avg_px
+    """The order average fill price.\n\n:returns: `double`"""
+    cdef readonly double slippage
+    """The order total price slippage.\n\n:returns: `double`"""
     cdef readonly TriggerType emulation_trigger
     """The order emulation trigger type.\n\n:returns: `TriggerType`"""
     cdef readonly InstrumentId trigger_instrument_id
     """The order emulation trigger instrument ID (will be `instrument_id` if ``None``).\n\n:returns: `InstrumentId` or ``None``"""
     cdef readonly ContingencyType contingency_type
     """The orders contingency type.\n\n:returns: `ContingencyType`"""
     cdef readonly OrderListId order_list_id
     """The order list ID associated with the order.\n\n:returns: `OrderListId` or ``None``"""
     cdef readonly list linked_order_ids
     """The orders linked client order ID(s).\n\n:returns: `list[ClientOrderId]` or ``None``"""
     cdef readonly ClientOrderId parent_order_id
-    """The orders parent client order ID.\n\n:returns: `ClientOrderId` or ``None``"""
+    """The parent client order ID.\n\n:returns: `ClientOrderId` or ``None``"""
     cdef readonly ExecAlgorithmId exec_algorithm_id
     """The execution algorithm ID for the order.\n\n:returns: `ExecAlgorithmId` or ``None``"""
     cdef readonly dict exec_algorithm_params
     """The execution algorithm parameters for the order.\n\n:returns: `dict[str, Any]` or ``None``"""
     cdef readonly ClientOrderId exec_spawn_id
     """The execution algorithm spawning client order ID.\n\n:returns: `ClientOrderId` or ``None``"""
     cdef readonly str tags
     """The order custom user tags.\n\n:returns: `str` or ``None``"""
-
-    @staticmethod
-    cdef OrderInitialized from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderInitialized obj)
-
-
-cdef class OrderDenied(OrderEvent):
-    cdef OrderDenied_t _mem
-
-    @staticmethod
-    cdef OrderDenied from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderDenied obj)
-
-
-
-cdef class OrderSubmitted(OrderEvent):
-
-    @staticmethod
-    cdef OrderSubmitted from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderSubmitted obj)
-
-
-cdef class OrderAccepted(OrderEvent):
-
-    @staticmethod
-    cdef OrderAccepted from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderAccepted obj)
-
-
-cdef class OrderRejected(OrderEvent):
-    cdef readonly str reason
-    """The reason the order was rejected.\n\n:returns: `str`"""
-
-    @staticmethod
-    cdef OrderRejected from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderRejected obj)
-
-
-cdef class OrderCanceled(OrderEvent):
-
-    @staticmethod
-    cdef OrderCanceled from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderCanceled obj)
-
-
-cdef class OrderExpired(OrderEvent):
-
-    @staticmethod
-    cdef OrderExpired from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderExpired obj)
-
-
-cdef class OrderTriggered(OrderEvent):
-
-    @staticmethod
-    cdef OrderTriggered from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderTriggered obj)
-
-
-cdef class OrderPendingUpdate(OrderEvent):
-
-    @staticmethod
-    cdef OrderPendingUpdate from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderPendingUpdate obj)
-
-
-cdef class OrderPendingCancel(OrderEvent):
-
-    @staticmethod
-    cdef OrderPendingCancel from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderPendingCancel obj)
-
-
-cdef class OrderModifyRejected(OrderEvent):
-    cdef readonly str reason
-    """The reason for modify order rejection.\n\n:returns: `str`"""
-
-    @staticmethod
-    cdef OrderModifyRejected from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderModifyRejected obj)
-
-
-cdef class OrderCancelRejected(OrderEvent):
-    cdef readonly str reason
-    """The reason for order cancel rejection.\n\n:returns: `str`"""
-
-    @staticmethod
-    cdef OrderCancelRejected from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderCancelRejected obj)
-
-
-cdef class OrderUpdated(OrderEvent):
-    cdef readonly Quantity quantity
-    """The orders current quantity.\n\n:returns: `Quantity`"""
-    cdef readonly Price price
-    """The orders current price.\n\n:returns: `Price`"""
-    cdef readonly Price trigger_price
-    """The orders current trigger price.\n\n:returns: `Price` or ``None``"""
-
-    @staticmethod
-    cdef OrderUpdated from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderUpdated obj)
-
-
-cdef class OrderFilled(OrderEvent):
-    cdef readonly TradeId trade_id
-    """The trade match ID (assigned by the venue).\n\n:returns: `TradeId`"""
-    cdef readonly PositionId position_id
-    """The position ID (assigned by the venue).\n\n:returns: `PositionId` or ``None``"""
-    cdef readonly OrderSide order_side
-    """The order side.\n\n:returns: `OrderSide`"""
-    cdef readonly OrderType order_type
-    """The order type.\n\n:returns: `OrderType`"""
-    cdef readonly Quantity last_qty
-    """The fill quantity.\n\n:returns: `Quantity`"""
-    cdef readonly Price last_px
-    """The fill price for this execution.\n\n:returns: `Price`"""
-    cdef readonly Currency currency
-    """The currency of the price.\n\n:returns: `Currency`"""
-    cdef readonly Money commission
-    """The commission generated from the fill.\n\n:returns: `Money`"""
-    cdef readonly LiquiditySide liquidity_side
-    """The liquidity side of the event {``MAKER``, ``TAKER``}.\n\n:returns: `LiquiditySide`"""
-    cdef readonly dict info
-    """The additional fill information.\n\n:returns: `dict[str, object]`"""
-
-    @staticmethod
-    cdef OrderFilled from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderFilled obj)
+    cdef readonly UUID4 init_id
+    """The event ID of the `OrderInitialized` event.\n\n:returns: `UUID4`"""
+    cdef readonly uint64_t ts_init
+    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t ts_last
+    """The UNIX timestamp (nanoseconds) when the last event occurred.\n\n:returns: `uint64_t`"""
+
+    cpdef str info(self)
+    cpdef str status_string(self)
+    cpdef str side_string(self)
+    cpdef str type_string(self)
+    cpdef dict to_dict(self)
+
+    cdef void set_triggered_price_c(self, Price triggered_price)
+    cdef Price get_triggered_price_c(self)
+    cdef OrderStatus status_c(self)
+    cdef OrderInitialized init_event_c(self)
+    cdef OrderEvent last_event_c(self)
+    cdef list events_c(self)
+    cdef list venue_order_ids_c(self)
+    cdef list trade_ids_c(self)
+    cdef int event_count_c(self)
+    cdef str status_string_c(self)
+    cdef str type_string_c(self)
+    cdef str side_string_c(self)
+    cdef str tif_string_c(self)
+    cdef bint has_price_c(self)
+    cdef bint has_trigger_price_c(self)
     cdef bint is_buy_c(self)
     cdef bint is_sell_c(self)
+    cdef bint is_passive_c(self)
+    cdef bint is_aggressive_c(self)
+    cdef bint is_emulated_c(self)
+    cdef bint is_primary_c(self)
+    cdef bint is_spawned_c(self)
+    cdef bint is_contingency_c(self)
+    cdef bint is_parent_order_c(self)
+    cdef bint is_child_order_c(self)
+    cdef bint is_open_c(self)
+    cdef bint is_canceled_c(self)
+    cdef bint is_closed_c(self)
+    cdef bint is_inflight_c(self)
+    cdef bint is_pending_update_c(self)
+    cdef bint is_pending_cancel_c(self)
+
+    @staticmethod
+    cdef OrderSide opposite_side_c(OrderSide side)
+
+    @staticmethod
+    cdef OrderSide closing_side_c(PositionSide position_side)
+
+    cpdef signed_decimal_qty(self)
+    cpdef bint would_reduce_only(self, PositionSide position_side, Quantity position_qty)
+    cpdef list commissions(self)
+
+    cpdef void apply(self, OrderEvent event)
+
+    cdef void _denied(self, OrderDenied event)
+    cdef void _submitted(self, OrderSubmitted event)
+    cdef void _rejected(self, OrderRejected event)
+    cdef void _accepted(self, OrderAccepted event)
+    cdef void _updated(self, OrderUpdated event)
+    cdef void _triggered(self, OrderTriggered event)
+    cdef void _canceled(self, OrderCanceled event)
+    cdef void _expired(self, OrderExpired event)
+    cdef void _filled(self, OrderFilled event)
+    cdef double _calculate_avg_px(self, double last_qty, double last_px)
+    cdef void _set_slippage(self)
+
+    @staticmethod
+    cdef void _hydrate_initial_events(Order original, Order transformed)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/order.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/events/order.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -18,22 +18,17 @@
 
 import msgspec
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.message cimport Event
-from nautilus_trader.core.rust.core cimport uuid4_clone
-from nautilus_trader.core.rust.model cimport client_order_id_clone
-from nautilus_trader.core.rust.model cimport component_id_to_cstr
-from nautilus_trader.core.rust.model cimport instrument_id_clone
 from nautilus_trader.core.rust.model cimport order_denied_new
 from nautilus_trader.core.rust.model cimport order_denied_reason_to_cstr
 from nautilus_trader.core.rust.model cimport strategy_id_new
-from nautilus_trader.core.rust.model cimport trade_id_clone
 from nautilus_trader.core.rust.model cimport trader_id_new
 from nautilus_trader.core.string cimport cstr_to_pybytes
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport ContingencyType
@@ -319,14 +314,15 @@
         Condition.not_none(values, "values")
         cdef str trigger_instrument_id = values["trigger_instrument_id"]
         cdef str order_list_id_str = values["order_list_id"]
         cdef str linked_order_ids_str = values["linked_order_ids"]
         cdef str parent_order_id_str = values["parent_order_id"]
         cdef str exec_algorithm_id_str = values["exec_algorithm_id"]
         cdef str exec_spawn_id_str = values["exec_spawn_id"]
+        exec_algorithm_params_json = values["exec_algorithm_params"]
         return OrderInitialized(
             trader_id=TraderId(values["trader_id"]),
             strategy_id=StrategyId(values["strategy_id"]),
             instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
             client_order_id=ClientOrderId(values["client_order_id"]),
             order_side=order_side_from_str(values["order_side"]),
             order_type=order_type_from_str(values["order_type"]),
@@ -339,15 +335,15 @@
             emulation_trigger=trigger_type_from_str(values["emulation_trigger"]),
             trigger_instrument_id=InstrumentId.from_str_c(trigger_instrument_id) if trigger_instrument_id is not None else None,
             contingency_type=contingency_type_from_str(values["contingency_type"]),
             order_list_id=OrderListId(order_list_id_str) if order_list_id_str is not None else None,
             linked_order_ids=[ClientOrderId(o_str) for o_str in linked_order_ids_str.split(",")] if linked_order_ids_str is not None else None,
             parent_order_id=ClientOrderId(parent_order_id_str) if parent_order_id_str is not None else None,
             exec_algorithm_id=ExecAlgorithmId(exec_algorithm_id_str) if exec_algorithm_id_str is not None else None,
-            exec_algorithm_params=json.loads(values["exec_algorithm_params"]),  # Using vanilla json due mixed schema types
+            exec_algorithm_params=json.loads(exec_algorithm_params_json) if exec_algorithm_params_json is not None else None,
             exec_spawn_id=ClientOrderId(exec_spawn_id_str) if exec_spawn_id_str is not None else None,
             tags=values["tags"],
             event_id=UUID4(values["event_id"]),
             ts_init=values["ts_init"],
             reconciliation=values.get("reconciliation", False),
         )
 
@@ -372,15 +368,15 @@
             "emulation_trigger": trigger_type_to_str(obj.emulation_trigger),
             "trigger_instrument_id": obj.trigger_instrument_id.to_str() if obj.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(obj.contingency_type),
             "order_list_id": obj.order_list_id.to_str() if obj.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in obj.linked_order_ids]) if obj.linked_order_ids is not None else None,  # noqa
             "parent_order_id": obj.parent_order_id.to_str() if obj.parent_order_id is not None else None,
             "exec_algorithm_id": obj.exec_algorithm_id.to_str() if obj.exec_algorithm_id is not None else None,
-            "exec_algorithm_params": json.dumps(obj.exec_algorithm_params),  # Using vanilla json due mixed schema types
+            "exec_algorithm_params": json.dumps(obj.exec_algorithm_params) if obj.exec_algorithm_params else None,
             "exec_spawn_id": obj.exec_spawn_id.to_str() if obj.exec_spawn_id is not None else None,
             "tags": obj.tags,
             "event_id": obj.id.to_str(),
             "ts_init": obj.ts_init,
             "reconciliation": obj.reconciliation,
         }
 
@@ -465,20 +461,20 @@
             event_id,
             ts_init,  # Timestamp identical to ts_init
             ts_init,
             reconciliation=False,  # Internal system event
         )
 
         self._mem = order_denied_new(
-            trader_id_new(component_id_to_cstr(&trader_id._mem)),
-            strategy_id_new(component_id_to_cstr(&strategy_id._mem)),
-            instrument_id_clone(&instrument_id._mem),
-            client_order_id_clone(&client_order_id._mem),
+            trader_id._mem,
+            strategy_id._mem,
+            instrument_id._mem,
+            client_order_id._mem,
             pystr_to_cstr(reason),
-            uuid4_clone(&event_id._mem),
+            event_id._mem,
             ts_init,
             ts_init,
         )
 
     def __str__(self) -> str:
         return (
             f"{type(self).__name__}("
@@ -2361,14 +2357,15 @@
             f"ts_init={self.ts_init})"
         )
 
     @staticmethod
     cdef OrderFilled from_dict_c(dict values):
         Condition.not_none(values, "values")
         cdef str position_id_str = values["position_id"]
+        cdef bytes info_bytes = values["info"]
         return OrderFilled(
             trader_id=TraderId(values["trader_id"]),
             strategy_id=StrategyId(values["strategy_id"]),
             instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
             client_order_id=ClientOrderId(values["client_order_id"]),
             venue_order_id=VenueOrderId(values["venue_order_id"]),
             account_id=AccountId(values["account_id"]),
@@ -2380,15 +2377,15 @@
             last_px=Price.from_str_c(values["last_px"]),
             currency=Currency.from_str_c(values["currency"]),
             commission=Money.from_str_c(values["commission"]),
             liquidity_side=liquidity_side_from_str(values["liquidity_side"]),
             event_id=UUID4(values["event_id"]),
             ts_event=values["ts_event"],
             ts_init=values["ts_init"],
-            info=msgspec.json.decode(values["info"]),
+            info=msgspec.json.decode(info_bytes) if info_bytes is not None else None,
             reconciliation=values.get("reconciliation", False),
         )
 
     @staticmethod
     cdef dict to_dict_c(OrderFilled obj):
         Condition.not_none(obj, "obj")
         return {
@@ -2407,15 +2404,15 @@
             "last_px": str(obj.last_px),
             "currency": obj.currency.code,
             "commission": obj.commission.to_str(),
             "liquidity_side": liquidity_side_to_str(obj.liquidity_side),
             "event_id": obj.id.to_str(),
             "ts_event": obj.ts_event,
             "ts_init": obj.ts_init,
-            "info": msgspec.json.encode(obj.info),
+            "info": msgspec.json.encode(obj.info) if obj.info is not None else None,
             "reconciliation": obj.reconciliation,
         }
 
     @staticmethod
     def from_dict(dict values) -> OrderFilled:
         """
         Return an order filled event from the given dict values.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/position.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/events/position.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/events/position.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/events/position.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/identifiers.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -10,75 +10,87 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.core.rust.model cimport AccountId_t
+from nautilus_trader.core.rust.model cimport ClientId_t
 from nautilus_trader.core.rust.model cimport ClientOrderId_t
 from nautilus_trader.core.rust.model cimport ComponentId_t
+from nautilus_trader.core.rust.model cimport ExecAlgorithmId_t
 from nautilus_trader.core.rust.model cimport InstrumentId_t
 from nautilus_trader.core.rust.model cimport OrderListId_t
 from nautilus_trader.core.rust.model cimport PositionId_t
+from nautilus_trader.core.rust.model cimport StrategyId_t
 from nautilus_trader.core.rust.model cimport Symbol_t
 from nautilus_trader.core.rust.model cimport TradeId_t
+from nautilus_trader.core.rust.model cimport TraderId_t
 from nautilus_trader.core.rust.model cimport Venue_t
 from nautilus_trader.core.rust.model cimport VenueOrderId_t
 
 
 cdef class Identifier:
     cdef str to_str(self)
 
 
 cdef class Symbol(Identifier):
     cdef Symbol_t _mem
 
     @staticmethod
-    cdef Symbol from_mem_c(Symbol_t* mem)
+    cdef Symbol from_mem_c(Symbol_t mem)
 
 
 cdef class Venue(Identifier):
     cdef Venue_t _mem
 
     @staticmethod
-    cdef Venue from_mem_c(Venue_t* mem)
+    cdef Venue from_mem_c(Venue_t mem)
+
+    cpdef bint is_synthetic(self)
 
 
 cdef class InstrumentId(Identifier):
     cdef InstrumentId_t _mem
 
     @staticmethod
     cdef InstrumentId from_mem_c(InstrumentId_t mem)
 
     @staticmethod
     cdef InstrumentId from_str_c(str value)
 
+    cpdef bint is_synthetic(self)
+
 
 cdef class ComponentId(Identifier):
     cdef ComponentId_t _mem
 
 
-cdef class ClientId(ComponentId):
-    pass
+cdef class ClientId(Identifier):
+    cdef ClientId_t _mem
 
 
-cdef class TraderId(ComponentId):
+cdef class TraderId(Identifier):
+    cdef TraderId_t _mem
+
     cpdef str get_tag(self)
 
 
-cdef class StrategyId(ComponentId):
+cdef class StrategyId(Identifier):
+    cdef StrategyId_t _mem
+
     cpdef str get_tag(self)
     cpdef bint is_external(self)
 
     @staticmethod
     cdef StrategyId external_c()
 
 
-cdef class ExecAlgorithmId(ComponentId):
-    pass
+cdef class ExecAlgorithmId(Identifier):
+    cdef ExecAlgorithmId_t _mem
 
 
 cdef class AccountId(Identifier):
     cdef AccountId_t _mem
 
     cpdef str get_issuer(self)
     cpdef str get_id(self)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/identifiers.pyx`

 * *Files 9% similar despite different names*

```diff
@@ -9,72 +9,53 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from libc.stdio cimport printf
+
 from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.rust.model cimport account_id_drop
-from nautilus_trader.core.rust.model cimport account_id_eq
 from nautilus_trader.core.rust.model cimport account_id_hash
 from nautilus_trader.core.rust.model cimport account_id_new
-from nautilus_trader.core.rust.model cimport account_id_to_cstr
-from nautilus_trader.core.rust.model cimport client_order_id_drop
-from nautilus_trader.core.rust.model cimport client_order_id_eq
+from nautilus_trader.core.rust.model cimport client_id_hash
+from nautilus_trader.core.rust.model cimport client_id_new
 from nautilus_trader.core.rust.model cimport client_order_id_hash
 from nautilus_trader.core.rust.model cimport client_order_id_new
-from nautilus_trader.core.rust.model cimport client_order_id_to_cstr
-from nautilus_trader.core.rust.model cimport component_id_drop
-from nautilus_trader.core.rust.model cimport component_id_eq
 from nautilus_trader.core.rust.model cimport component_id_hash
 from nautilus_trader.core.rust.model cimport component_id_new
-from nautilus_trader.core.rust.model cimport component_id_to_cstr
-from nautilus_trader.core.rust.model cimport instrument_id_clone
-from nautilus_trader.core.rust.model cimport instrument_id_drop
-from nautilus_trader.core.rust.model cimport instrument_id_eq
+from nautilus_trader.core.rust.model cimport exec_algorithm_id_hash
+from nautilus_trader.core.rust.model cimport exec_algorithm_id_new
 from nautilus_trader.core.rust.model cimport instrument_id_hash
+from nautilus_trader.core.rust.model cimport instrument_id_is_synthetic
 from nautilus_trader.core.rust.model cimport instrument_id_new
 from nautilus_trader.core.rust.model cimport instrument_id_new_from_cstr
 from nautilus_trader.core.rust.model cimport instrument_id_to_cstr
-from nautilus_trader.core.rust.model cimport order_list_id_drop
-from nautilus_trader.core.rust.model cimport order_list_id_eq
+from nautilus_trader.core.rust.model cimport interned_string_stats
 from nautilus_trader.core.rust.model cimport order_list_id_hash
 from nautilus_trader.core.rust.model cimport order_list_id_new
-from nautilus_trader.core.rust.model cimport order_list_id_to_cstr
-from nautilus_trader.core.rust.model cimport position_id_drop
-from nautilus_trader.core.rust.model cimport position_id_eq
 from nautilus_trader.core.rust.model cimport position_id_hash
 from nautilus_trader.core.rust.model cimport position_id_new
-from nautilus_trader.core.rust.model cimport position_id_to_cstr
-from nautilus_trader.core.rust.model cimport symbol_clone
-from nautilus_trader.core.rust.model cimport symbol_drop
-from nautilus_trader.core.rust.model cimport symbol_eq
+from nautilus_trader.core.rust.model cimport strategy_id_hash
+from nautilus_trader.core.rust.model cimport strategy_id_new
 from nautilus_trader.core.rust.model cimport symbol_hash
 from nautilus_trader.core.rust.model cimport symbol_new
-from nautilus_trader.core.rust.model cimport symbol_to_cstr
-from nautilus_trader.core.rust.model cimport trade_id_clone
-from nautilus_trader.core.rust.model cimport trade_id_drop
-from nautilus_trader.core.rust.model cimport trade_id_eq
 from nautilus_trader.core.rust.model cimport trade_id_hash
 from nautilus_trader.core.rust.model cimport trade_id_new
-from nautilus_trader.core.rust.model cimport trade_id_to_cstr
-from nautilus_trader.core.rust.model cimport venue_clone
-from nautilus_trader.core.rust.model cimport venue_drop
-from nautilus_trader.core.rust.model cimport venue_eq
+from nautilus_trader.core.rust.model cimport trader_id_hash
+from nautilus_trader.core.rust.model cimport trader_id_new
 from nautilus_trader.core.rust.model cimport venue_hash
+from nautilus_trader.core.rust.model cimport venue_is_synthetic
 from nautilus_trader.core.rust.model cimport venue_new
-from nautilus_trader.core.rust.model cimport venue_order_id_drop
-from nautilus_trader.core.rust.model cimport venue_order_id_eq
 from nautilus_trader.core.rust.model cimport venue_order_id_hash
 from nautilus_trader.core.rust.model cimport venue_order_id_new
-from nautilus_trader.core.rust.model cimport venue_order_id_to_cstr
-from nautilus_trader.core.rust.model cimport venue_to_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
+from nautilus_trader.core.string cimport ustr_to_pystr
 
 
 cdef class Identifier:
     """
     The abstract base class for all identifiers.
     """
 
@@ -141,40 +122,36 @@
     https://en.wikipedia.org/wiki/Ticker_symbol
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         self._mem = symbol_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            symbol_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = symbol_new(pystr_to_cstr(state))
 
     def __eq__(self, Symbol other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return symbol_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return symbol_hash(&self._mem)
 
     @staticmethod
-    cdef Symbol from_mem_c(Symbol_t* mem):
+    cdef Symbol from_mem_c(Symbol_t mem):
         cdef Symbol symbol = Symbol.__new__(Symbol)
-        symbol._mem = symbol_clone(mem)
+        symbol._mem = mem
         return symbol
 
     cdef str to_str(self):
-        return cstr_to_pystr(symbol_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
 
 cdef class Venue(Identifier):
     """
     Represents a valid trading venue ID.
 
     Parameters
@@ -188,40 +165,47 @@
         If `name` is not a valid string.
     """
 
     def __init__(self, str name not None):
         Condition.valid_string(name, "name")
         self._mem = venue_new(pystr_to_cstr(name))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            venue_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = venue_new(pystr_to_cstr(state))
 
     def __eq__(self, Venue other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return venue_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return venue_hash(&self._mem)
 
     @staticmethod
-    cdef Venue from_mem_c(Venue_t* mem):
+    cdef Venue from_mem_c(Venue_t mem):
         cdef Venue venue = Venue.__new__(Venue)
-        venue._mem = venue_clone(mem)
+        venue._mem = mem
         return venue
 
     cdef str to_str(self):
-        return cstr_to_pystr(venue_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
+
+    cpdef bint is_synthetic(self):
+        """
+        Return whether the venue is synthetic ('SYNTH').
+
+        Returns
+        -------
+        bool
+
+        """
+        return <bint>venue_is_synthetic(&self._mem)
 
 
 cdef class InstrumentId(Identifier):
     """
     Represents a valid instrument ID.
 
     The symbol and venue combination should uniquely identify the instrument.
@@ -232,69 +216,65 @@
         The instruments ticker symbol.
     venue : Venue
         The instruments trading venue.
     """
 
     def __init__(self, Symbol symbol not None, Venue venue not None):
         self._mem = instrument_id_new(
-            <Symbol_t *>&symbol._mem,
-            <Venue_t *>&venue._mem,
+            symbol._mem,
+            venue._mem,
         )
 
     @property
     def symbol(self) -> Symbol:
         """
         Returns the instrument ticker symbol.
 
         Returns
         -------
         Symbol
 
         """
-        return Symbol.from_mem_c(&self._mem.symbol)
+        return Symbol.from_mem_c(self._mem.symbol)
 
     @property
     def venue(self) -> Venue:
         """
         Returns the instrument trading venue.
 
         Returns
         -------
         Venue
 
         """
-        return Venue.from_mem_c(&self._mem.venue)
-
-    def __del__(self) -> None:
-        if self._mem.symbol.value != NULL:
-            instrument_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
+        return Venue.from_mem_c(self._mem.venue)
 
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = instrument_id_new_from_cstr(
             pystr_to_cstr(state),
         )
 
     def __eq__(self, InstrumentId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return instrument_id_eq(&self._mem, &other._mem)
+        return self._mem.symbol.value == other._mem.symbol.value and self._mem.venue.value == other._mem.venue.value
 
     def __hash__ (self) -> int:
         return instrument_id_hash(&self._mem)
 
     cdef str to_str(self):
         return cstr_to_pystr(instrument_id_to_cstr(&self._mem))
 
     @staticmethod
     cdef InstrumentId from_mem_c(InstrumentId_t mem):
         cdef InstrumentId instrument_id = InstrumentId.__new__(InstrumentId)
-        instrument_id._mem = instrument_id_clone(&mem)
+        instrument_id._mem = mem
         return instrument_id
 
     @staticmethod
     cdef InstrumentId from_str_c(str value):
         cdef InstrumentId instrument_id = InstrumentId.__new__(InstrumentId)
         instrument_id._mem = instrument_id_new_from_cstr(pystr_to_cstr(value))
         return instrument_id
@@ -316,14 +296,25 @@
         Returns
         -------
         InstrumentId
 
         """
         return InstrumentId.from_str_c(value)
 
+    cpdef bint is_synthetic(self):
+        """
+        Return whether the instrument ID is a synthetic instrument (with venue of 'SYNTH').
+
+        Returns
+        -------
+        bool
+
+        """
+        return <bint>instrument_id_is_synthetic(&self._mem)
+
 
 cdef class ComponentId(Identifier):
     """
     Represents a valid component ID.
 
     Parameters
     ----------
@@ -340,37 +331,33 @@
     The ID value must be unique at the trader level.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         self._mem = component_id_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            component_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = component_id_new(pystr_to_cstr(state))
 
     def __eq__(self, ComponentId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return component_id_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__(self) -> int:
         return component_id_hash(&self._mem)
 
     cdef str to_str(self):
-        return cstr_to_pystr(component_id_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
 
-cdef class ClientId(ComponentId):
+cdef class ClientId(Identifier):
     """
     Represents a system client ID.
 
     Parameters
     ----------
     value : str
         The client ID value.
@@ -383,18 +370,35 @@
     Warnings
     --------
     The ID value must be unique at the trader level.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
-        super().__init__(value)
+        self._mem = client_id_new(pystr_to_cstr(value))
+
+    def __getstate__(self):
+        return self.to_str()
+
+    def __setstate__(self, state):
+        self._mem = client_id_new(pystr_to_cstr(state))
 
+    def __eq__(self, ClientId other) -> bool:
+        if other is None:
+            raise RuntimeError("other was None in __eq__")
+        return self._mem.value == other._mem.value
+
+    def __hash__(self) -> int:
+        return client_id_hash(&self._mem)
 
-cdef class TraderId(ComponentId):
+    cdef str to_str(self):
+        return ustr_to_pystr(self._mem.value)
+
+
+cdef class TraderId(Identifier):
     """
     Represents a valid trader ID.
 
     Must be correctly formatted with two valid strings either side of a hyphen.
     It is expected a trader ID is the abbreviated name of the trader
     with an order ID tag number separated by a hyphen.
 
@@ -416,16 +420,32 @@
     Warnings
     --------
     The name and tag combination ID value must be unique at the firm level.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
-        Condition.true("-" in value, "value was malformed: did not contain a hyphen '-'")
-        super().__init__(value)
+        self._mem = trader_id_new(pystr_to_cstr(value))
+
+    def __getstate__(self):
+        return self.to_str()
+
+    def __setstate__(self, state):
+        self._mem = trader_id_new(pystr_to_cstr(state))
+
+    def __eq__(self, TraderId other) -> bool:
+        if other is None:
+            raise RuntimeError("other was None in __eq__")
+        return self._mem.value == other._mem.value
+
+    def __hash__(self) -> int:
+        return trader_id_hash(&self._mem)
+
+    cdef str to_str(self):
+        return ustr_to_pystr(self._mem.value)
 
     cpdef str get_tag(self):
         """
         Return the order ID tag value for this ID.
 
         Returns
         -------
@@ -435,15 +455,15 @@
         return self.to_str().split("-")[-1]
 
 
 # External strategy ID constant
 cdef StrategyId EXTERNAL_STRATEGY_ID = StrategyId("EXTERNAL")
 
 
-cdef class StrategyId(ComponentId):
+cdef class StrategyId(Identifier):
     """
     Represents a valid strategy ID.
 
     Must be correctly formatted with two valid strings either side of a hyphen.
     It is expected a strategy ID is the class name of the strategy,
     with an order ID tag number separated by a hyphen.
 
@@ -466,15 +486,33 @@
     --------
     The name and tag combination must be unique at the trader level.
     """
 
     def __init__(self, str value):
         Condition.valid_string(value, "value")
         Condition.true(value == "EXTERNAL" or "-" in value, "value was malformed: did not contain a hyphen '-'")
-        super().__init__(value)
+
+        self._mem = strategy_id_new(pystr_to_cstr(value))
+
+    def __getstate__(self):
+        return self.to_str()
+
+    def __setstate__(self, state):
+        self._mem = strategy_id_new(pystr_to_cstr(state))
+
+    def __eq__(self, StrategyId other) -> bool:
+        if other is None:
+            raise RuntimeError("other was None in __eq__")
+        return self._mem.value == other._mem.value
+
+    def __hash__(self) -> int:
+        return strategy_id_hash(&self._mem)
+
+    cdef str to_str(self):
+        return ustr_to_pystr(self._mem.value)
 
     cpdef str get_tag(self):
         """
         Return the order ID tag value for this ID.
 
         Returns
         -------
@@ -497,15 +535,15 @@
         return self == EXTERNAL_STRATEGY_ID
 
     @staticmethod
     cdef StrategyId external_c():
         return EXTERNAL_STRATEGY_ID
 
 
-cdef class ExecAlgorithmId(ComponentId):
+cdef class ExecAlgorithmId(Identifier):
     """
     Represents a valid execution algorithm ID.
 
     Parameters
     ----------
     value : str
         The execution algorithm ID value.
@@ -514,15 +552,32 @@
     ------
     ValueError
         If `value` is not a valid string.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
-        super().__init__(value)
+        self._mem = exec_algorithm_id_new(pystr_to_cstr(value))
+
+    def __getstate__(self):
+        return self.to_str()
+
+    def __setstate__(self, state):
+        self._mem = exec_algorithm_id_new(pystr_to_cstr(state))
+
+    def __eq__(self, ExecAlgorithmId other) -> bool:
+        if other is None:
+            raise RuntimeError("other was None in __eq__")
+        return self._mem.value == other._mem.value
+
+    def __hash__(self) -> int:
+        return exec_algorithm_id_hash(&self._mem)
+
+    cdef str to_str(self):
+        return ustr_to_pystr(self._mem.value)
 
 
 
 cdef class AccountId(Identifier):
     """
     Represents a valid account ID.
 
@@ -548,34 +603,30 @@
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         Condition.true("-" in value, "value was malformed: did not contain a hyphen '-'")
         self._mem = account_id_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            account_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = account_id_new(pystr_to_cstr(state))
 
     def __eq__(self, AccountId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return account_id_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return account_id_hash(&self._mem)
 
     cdef str to_str(self):
-        return cstr_to_pystr(account_id_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
     cpdef str get_issuer(self):
         """
         Return the account issuer for this ID.
 
         Returns
         -------
@@ -615,34 +666,30 @@
     The ID value must be unique at the firm level.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         self._mem = client_order_id_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            client_order_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = client_order_id_new(pystr_to_cstr(state))
 
     def __eq__(self, ClientOrderId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return client_order_id_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return client_order_id_hash(&self._mem)
 
     cdef str to_str(self):
-        return cstr_to_pystr(client_order_id_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
     cpdef bint is_this_trader(self, TraderId trader_id):
         """
         Return whether this client order ID is for the given trader ID instance.
 
         Will compare the given `trader_id.get_tag()` with this identifier.
 
@@ -678,34 +725,30 @@
         If `value` is not a valid string.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         self._mem = venue_order_id_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            venue_order_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = venue_order_id_new(pystr_to_cstr(state))
 
     def __eq__(self, VenueOrderId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return venue_order_id_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return venue_order_id_hash(&self._mem)
 
     cdef str to_str(self):
-        return cstr_to_pystr(venue_order_id_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
 
 cdef class OrderListId(Identifier):
     """
     Represents a valid order list ID (assigned by the Nautilus system).
 
     Parameters
@@ -719,34 +762,30 @@
         If `value` is not a valid string.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         self._mem = order_list_id_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            order_list_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = order_list_id_new(pystr_to_cstr(state))
 
     def __eq__(self, OrderListId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return order_list_id_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return order_list_id_hash(&self._mem)
 
     cdef str to_str(self):
-        return cstr_to_pystr(order_list_id_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
 
 cdef class PositionId(Identifier):
     """
     Represents a valid position ID.
 
     Parameters
@@ -760,34 +799,30 @@
         If `value` is not a valid string containing a hyphen.
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         self._mem = position_id_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            position_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = position_id_new(pystr_to_cstr(state))
 
     def __eq__(self, PositionId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return position_id_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return position_id_hash(&self._mem)
 
     cdef str to_str(self):
-        return cstr_to_pystr(position_id_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
     cdef bint is_virtual_c(self):
         return self.to_str().startswith("P-")
 
     @staticmethod
     cdef PositionId from_mem_c(PositionId_t mem):
         cdef PositionId position_id = PositionId.__new__(PositionId)
@@ -819,33 +854,29 @@
     https://www.onixs.biz/fix-dictionary/5.0/tagnum_1003.html
     """
 
     def __init__(self, str value not None):
         Condition.valid_string(value, "value")
         self._mem = trade_id_new(pystr_to_cstr(value))
 
-    def __del__(self) -> None:
-        if self._mem.value != NULL:
-            trade_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
-
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
         self._mem = trade_id_new(pystr_to_cstr(state))
 
     def __eq__(self, TradeId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
-        return trade_id_eq(&self._mem, &other._mem)
+        return self._mem.value == other._mem.value
 
     def __hash__ (self) -> int:
         return trade_id_hash(&self._mem)
 
     cdef str to_str(self):
-        return cstr_to_pystr(trade_id_to_cstr(&self._mem))
+        return ustr_to_pystr(self._mem.value)
 
     @staticmethod
     cdef TradeId from_mem_c(TradeId_t mem):
         cdef TradeId trade_id = TradeId.__new__(TradeId)
-        trade_id._mem = trade_id_clone(&mem)
+        trade_id._mem = mem
         return trade_id
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,33 +8,34 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
-Defines tradable asset/contract instruments with specific properties dependent
-on the asset class and asset type.
+Defines tradable asset/contract instruments with specific properties dependent on the
+asset class and asset type.
 """
 
 from nautilus_trader.model.instruments.base import Instrument
 from nautilus_trader.model.instruments.betting import BettingInstrument
 from nautilus_trader.model.instruments.crypto_future import CryptoFuture
 from nautilus_trader.model.instruments.crypto_perpetual import CryptoPerpetual
 from nautilus_trader.model.instruments.currency_pair import CurrencyPair
 from nautilus_trader.model.instruments.equity import Equity
 from nautilus_trader.model.instruments.futures_contract import FuturesContract
 from nautilus_trader.model.instruments.options_contract import OptionsContract
+from nautilus_trader.model.instruments.synthetic import SyntheticInstrument
 
 
 __all__ = [
     "Instrument",
     "BettingInstrument",
     "CryptoFuture",
     "CryptoPerpetual",
     "CurrencyPair",
     "Equity",
     "FuturesContract",
     "OptionsContract",
+    "SyntheticInstrument",
 ]
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/base.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -28,16 +28,16 @@
 
 
 cdef class Instrument(Data):
     cdef TickScheme _tick_scheme
 
     cdef readonly InstrumentId id
     """The instrument ID.\n\n:returns: `InstrumentId`"""
-    cdef readonly Symbol native_symbol
-    """The native/local symbol on the exchange for the instrument.\n\n:returns: `Symbol`"""
+    cdef readonly Symbol raw_symbol
+    """The native/local/raw symbol for the instrument, assigned by the venue.\n\n:returns: `Symbol`"""
     cdef readonly AssetClass asset_class
     """The asset class of the instrument.\n\n:returns: `AssetClass`"""
     cdef readonly AssetType asset_type
     """The asset type of the instrument.\n\n:returns: `AssetType`"""
     cdef readonly Currency quote_currency
     """The quote currency for the instrument.\n\n:returns: `Currency`"""
     cdef readonly bint is_inverse
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/base.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
 from typing import Optional
 
 import msgspec
 
+from libc.math cimport pow
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.rust.model cimport AssetClass
 from nautilus_trader.core.rust.model cimport AssetType
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport asset_class_from_str
@@ -41,16 +42,16 @@
     Represents a tradable financial market instrument. This class can be used to
     define an instrument, or act as a parent class for more specific instruments.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the instrument.
-    native_symbol : Symbol
-        The native/local symbol on the exchange for the instrument.
+    raw_symbol : Symbol
+        The native/local/raw symbol for the instrument, assigned by the venue.
     asset_class : AssetClass
         The instrument asset class.
     asset_type : AssetType
         The instrument asset type.
     quote_currency : Currency
         The quote currency.
     is_inverse : Currency
@@ -129,15 +130,15 @@
     ValueError
         If `min_price` is negative (< 0).
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
-        Symbol native_symbol not None,
+        Symbol raw_symbol not None,
         AssetClass asset_class,
         AssetType asset_type,
         Currency quote_currency not None,
         bint is_inverse,
         int price_precision,
         int size_precision,
         Quantity size_increment not None,
@@ -190,21 +191,21 @@
         Condition.not_negative(margin_init, "margin_init")
         Condition.type(margin_maint, Decimal, "margin_maint")
         Condition.not_negative(margin_maint, "margin_maint")
         Condition.type(maker_fee, Decimal, "maker_fee")
         Condition.type(taker_fee, Decimal, "taker_fee")
 
         self.id = instrument_id
-        self.native_symbol = native_symbol
+        self.raw_symbol = raw_symbol
         self.asset_class = asset_class
         self.asset_type = asset_type
         self.quote_currency = quote_currency
         self.is_inverse = is_inverse
         self.price_precision = price_precision
-        self.price_increment = price_increment
+        self.price_increment = price_increment or Price(pow(10.0, -price_precision), price_precision)
         self.tick_scheme_name = tick_scheme_name
         self.size_precision = size_precision
         self.size_increment = size_increment
         self.multiplier = multiplier
         self.lot_size = lot_size
         self.max_quantity = max_quantity
         self.min_quantity = min_quantity
@@ -230,15 +231,15 @@
     def __hash__(self) -> int:
         return hash(self.id)
 
     def __repr__(self) -> str:  # TODO(cs): tick_scheme_name pending
         return (
             f"{type(self).__name__}"
             f"(id={self.id.to_str()}, "
-            f"native_symbol={self.native_symbol}, "
+            f"raw_symbol={self.raw_symbol}, "
             f"asset_class={asset_class_to_str(self.asset_class)}, "
             f"asset_type={asset_type_to_str(self.asset_type)}, "
             f"quote_currency={self.quote_currency}, "
             f"is_inverse={self.is_inverse}, "
             f"price_precision={self.price_precision}, "
             f"price_increment={self.price_increment}, "
             f"size_precision={self.size_precision}, "
@@ -260,15 +261,15 @@
         cdef str max_n = values["max_notional"]
         cdef str min_n = values["min_notional"]
         cdef str max_p = values["max_price"]
         cdef str min_p = values["min_price"]
         cdef bytes info = values["info"]
         return Instrument(
             instrument_id=InstrumentId.from_str_c(values["id"]),
-            native_symbol=Symbol(values["native_symbol"]),
+            raw_symbol=Symbol(values["raw_symbol"]),
             asset_class=asset_class_from_str(values["asset_class"]),
             asset_type=asset_type_from_str(values["asset_type"]),
             quote_currency=Currency.from_str_c(values["quote_currency"]),
             is_inverse=values["is_inverse"],
             price_precision=values["price_precision"],
             size_precision=values["size_precision"],
             price_increment=Price.from_str_c(values["price_increment"]),
@@ -291,15 +292,15 @@
         )
 
     @staticmethod
     cdef dict base_to_dict_c(Instrument obj):
         return {
             "type": "Instrument",
             "id": obj.id.to_str(),
-            "native_symbol": obj.native_symbol.to_str(),
+            "raw_symbol": obj.raw_symbol.to_str(),
             "asset_class": asset_class_to_str(obj.asset_class),
             "asset_type": asset_type_to_str(obj.asset_type),
             "quote_currency": obj.quote_currency.code,
             "is_inverse": obj.is_inverse,
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/betting.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/betting.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -10,30 +10,34 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
+from typing import Optional
 
 import pandas as pd
 
 from cpython.datetime cimport datetime
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.rust.model cimport AssetClass
 from nautilus_trader.core.rust.model cimport AssetType
 from nautilus_trader.model.currency cimport Currency
+from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.identifiers cimport Symbol
+from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
-
-from nautilus_trader.adapters.betfair.parsing.common import betfair_instrument_id
+from nautilus_trader.model.tick_scheme.base cimport register_tick_scheme
+from nautilus_trader.model.tick_scheme.implementations.tiered cimport TieredTickScheme
 
 
 cdef class BettingInstrument(Instrument):
     """
     Represents an instrument in a betting market.
     """
 
@@ -55,15 +59,15 @@
         str market_type not None,
         str selection_id not None,
         str selection_name not None,
         str currency not None,
         str selection_handicap,
         uint64_t ts_event,
         uint64_t ts_init,
-        str tick_scheme_name="BETFAIR",
+        str tick_scheme_name=None,
         int price_precision=7,  # TODO(bm): pending refactor
         Price min_price = None,
         Price max_price = None,
         dict info = {},
     ):
         assert event_open_date.tzinfo or market_start_time.tzinfo is not None
 
@@ -88,21 +92,20 @@
         self.market_name = market_name
         self.market_start_time = pd.Timestamp(market_start_time).tz_convert("UTC")
 
         # Selection/Runner (individual selection/runner) e.g. (LA Lakers)
         self.selection_id = selection_id
         self.selection_name = selection_name
         self.selection_handicap = selection_handicap
-        instrument_id = betfair_instrument_id(
-            market_id=market_id, selection_id=selection_id, selection_handicap=selection_handicap
-        )
+
+        cdef Symbol symbol = make_symbol(market_id, selection_id, selection_handicap)
 
         super().__init__(
-            instrument_id=instrument_id,
-            native_symbol=instrument_id.symbol,
+            instrument_id=InstrumentId(symbol=symbol, venue=Venue(venue_name)),
+            raw_symbol=symbol,
             asset_class=AssetClass.SPORTS_BETTING,
             asset_type=AssetType.SPOT,
             quote_currency=Currency.from_str_c(currency),
             is_inverse=False,
             size_precision=4,
             price_precision=price_precision,
             price_increment=None,
@@ -139,15 +142,15 @@
 
     @staticmethod
     cdef dict to_dict_c(BettingInstrument obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "BettingInstrument",
             "id": obj.id.to_str(),
-            "venue_name": obj.id.venue.to_str(),
+            "venue_name": obj.id.venue.value,
             "event_type_id": obj.event_type_id,
             "event_type_name": obj.event_type_name,
             "competition_id": obj.competition_id,
             "competition_name": obj.competition_name,
             "event_id": obj.event_id,
             "event_name": obj.event_name,
             "event_country_code": obj.event_country_code,
@@ -194,7 +197,30 @@
         """
         return BettingInstrument.to_dict_c(obj)
 
     cpdef Money notional_value(self, Quantity quantity, Price price, bint use_quote_for_inverse=False):
         Condition.not_none(quantity, "quantity")
         cdef double bet_price = 1.0 / price.as_f64_c()
         return Money(quantity.as_f64_c() * float(self.multiplier) * bet_price, self.quote_currency)
+
+
+def make_symbol(
+    market_id: str,
+    selection_id: str,
+    selection_handicap: Optional[str],
+) -> Symbol:
+    """
+    Make symbol.
+
+    >>> make_symbol(market_id="1.201070830", selection_id="123456", selection_handicap=None)
+    Symbol('1.201070830|123456|None')
+
+    """
+
+    def _clean(s):
+        return str(s).replace(" ", "").replace(":", "")
+
+    value: str = "|".join(
+        [_clean(k) for k in (market_id, selection_id, selection_handicap)],
+    )
+    assert len(value) <= 32, f"Symbol too long ({len(value)}): '{value}'"
+    return Symbol(value)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_future.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_future.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -38,16 +38,16 @@
     Represents a `Deliverable Futures Contract` instrument, with crypto assets
     as underlying and for settlement.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the instrument.
-    native_symbol : Symbol
-        The native/local symbol on the exchange for the instrument.
+    raw_symbol : Symbol
+        The native/local/raw symbol for the instrument, assigned by the venue.
     underlying : Currency
         The underlying asset.
     quote_currency : Currency
         The contract quote currency.
     expiry_date : date
         The contract expiry date.
     price_precision : int
@@ -114,15 +114,15 @@
     ValueError
         If `min_price` is negative (< 0).
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
-        Symbol native_symbol not None,
+        Symbol raw_symbol not None,
         Currency underlying not None,
         Currency quote_currency not None,
         Currency settlement_currency not None,
         date expiry_date,
         int price_precision,
         int size_precision,
         Price price_increment not None,
@@ -141,15 +141,15 @@
         Money min_notional: Optional[Money] = None,
         Price max_price: Optional[Price] = None,
         Price min_price: Optional[Price] = None,
         dict info = None,
     ):
         super().__init__(
             instrument_id=instrument_id,
-            native_symbol=native_symbol,
+            raw_symbol=raw_symbol,
             asset_class=AssetClass.CRYPTOCURRENCY,
             asset_type=AssetType.FUTURE,
             quote_currency=quote_currency,
             is_inverse=False,
             price_precision=price_precision,
             size_precision=size_precision,
             price_increment=price_increment,
@@ -194,15 +194,15 @@
         cdef str max_n = values["max_notional"]
         cdef str min_n = values["min_notional"]
         cdef str max_p = values["max_price"]
         cdef str min_p = values["min_price"]
         cdef bytes info = values["info"]
         return CryptoFuture(
             instrument_id=InstrumentId.from_str_c(values["id"]),
-            native_symbol=Symbol(values["native_symbol"]),
+            raw_symbol=Symbol(values["raw_symbol"]),
             underlying=Currency.from_str_c(values["underlying"]),
             quote_currency=Currency.from_str_c(values["quote_currency"]),
             settlement_currency=Currency.from_str_c(values["settlement_currency"]),
             expiry_date=date.fromisoformat(values['expiry_date']),
             price_precision=values["price_precision"],
             size_precision=values["size_precision"],
             price_increment=Price.from_str_c(values["price_increment"]),
@@ -224,15 +224,15 @@
 
     @staticmethod
     cdef dict to_dict_c(CryptoFuture obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "CryptoFuture",
             "id": obj.id.to_str(),
-            "native_symbol": obj.native_symbol.to_str(),
+            "raw_symbol": obj.raw_symbol.to_str(),
             "underlying": obj.underlying.code,
             "quote_currency": obj.quote_currency.code,
             "settlement_currency": obj.settlement_currency.code,
             "expiry_date": obj.expiry_date.isoformat(),
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_perpetual.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/crypto_perpetual.pyx`

 * *Files 9% similar despite different names*

```diff
@@ -37,16 +37,16 @@
     Represents a Crypto `Perpetual Futures` contract instrument (a.k.a. `Perpetual
     Swap`).
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the instrument.
-    native_symbol : Symbol
-        The native/local symbol on the exchange for the instrument.
+    raw_symbol : Symbol
+        The native/local/raw symbol for the instrument, assigned by the venue.
     base_currency : Currency, optional
         The base currency.
     quote_currency : Currency
         The quote currency.
     settlement_currency : Currency
         The settlement currency.
     is_inverse : Currency
@@ -115,15 +115,15 @@
     ValueError
         If `min_price` is negative (< 0).
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
-        Symbol native_symbol not None,
+        Symbol raw_symbol not None,
         Currency base_currency not None,
         Currency quote_currency not None,
         Currency settlement_currency not None,
         bint is_inverse,
         int price_precision,
         int size_precision,
         Price price_increment not None,
@@ -140,15 +140,15 @@
         Money min_notional: Optional[Money] = None,
         Price max_price: Optional[Price] = None,
         Price min_price: Optional[Price] = None,
         dict info = None,
     ):
         super().__init__(
             instrument_id=instrument_id,
-            native_symbol=native_symbol,
+            raw_symbol=raw_symbol,
             asset_class=AssetClass.CRYPTOCURRENCY,
             asset_type=AssetType.SWAP,
             quote_currency=quote_currency,
             is_inverse=is_inverse,
             price_precision=price_precision,
             size_precision=size_precision,
             price_increment=price_increment,
@@ -196,15 +196,15 @@
         cdef str max_n = values["max_notional"]
         cdef str min_n = values["min_notional"]
         cdef str max_p = values["max_price"]
         cdef str min_p = values["min_price"]
         cdef bytes info = values["info"]
         return CryptoPerpetual(
             instrument_id=InstrumentId.from_str_c(values["id"]),
-            native_symbol=Symbol(values["native_symbol"]),
+            raw_symbol=Symbol(values["raw_symbol"]),
             base_currency=Currency.from_str_c(values["base_currency"]),
             quote_currency=Currency.from_str_c(values["quote_currency"]),
             settlement_currency=Currency.from_str_c(values["settlement_currency"]),
             is_inverse=values["is_inverse"],
             price_precision=values["price_precision"],
             size_precision=values["size_precision"],
             price_increment=Price.from_str_c(values["price_increment"]),
@@ -226,15 +226,15 @@
 
     @staticmethod
     cdef dict to_dict_c(CryptoPerpetual obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "CryptoPerpetual",
             "id": obj.id.to_str(),
-            "native_symbol": obj.native_symbol.to_str(),
+            "raw_symbol": obj.raw_symbol.to_str(),
             "base_currency": obj.base_currency.code,
             "quote_currency": obj.quote_currency.code,
             "settlement_currency": obj.settlement_currency.code,
             "is_inverse": obj.is_inverse,
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/currency_pair.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/currency_pair.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -39,16 +39,16 @@
 
     Can represent both Fiat FX and Cryptocurrency pairs.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the instrument.
-    native_symbol : Symbol
-        The native/local symbol on the exchange for the instrument.
+    raw_symbol : Symbol
+        The native/local/raw symbol for the instrument, assigned by the venue.
     base_currency : Currency
         The base currency.
     quote_currency : Currency
         The quote currency.
     price_precision : int
         The price decimal precision.
     size_precision : int
@@ -119,15 +119,15 @@
     ValueError
         If `min_price` is negative (< 0).
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
-        Symbol native_symbol not None,
+        Symbol raw_symbol not None,
         Currency base_currency not None,
         Currency quote_currency not None,
         int price_precision,
         int size_precision,
         Price price_increment not None,
         Quantity size_increment not None,
         margin_init not None: Decimal,
@@ -152,15 +152,15 @@
             or quote_currency.currency_type == CurrencyType.CRYPTO
         ):
             asset_class = AssetClass.CRYPTOCURRENCY
         else:
             asset_class = AssetClass.FX
         super().__init__(
             instrument_id=instrument_id,
-            native_symbol=native_symbol,
+            raw_symbol=raw_symbol,
             asset_class=asset_class,
             asset_type=AssetType.SPOT,
             quote_currency=quote_currency,
             is_inverse=False,
             price_precision=price_precision,
             size_precision=size_precision,
             price_increment=price_increment,
@@ -205,15 +205,15 @@
         cdef str max_n = values["max_notional"]
         cdef str min_n = values["min_notional"]
         cdef str max_p = values["max_price"]
         cdef str min_p = values["min_price"]
         cdef bytes info = values["info"]
         return CurrencyPair(
             instrument_id=InstrumentId.from_str_c(values["id"]),
-            native_symbol=Symbol(values["native_symbol"]),
+            raw_symbol=Symbol(values["raw_symbol"]),
             base_currency=Currency.from_str_c(values["base_currency"]),
             quote_currency=Currency.from_str_c(values["quote_currency"]),
             price_precision=values["price_precision"],
             size_precision=values["size_precision"],
             price_increment=Price.from_str_c(values["price_increment"]),
             size_increment=Quantity.from_str_c(values["size_increment"]),
             lot_size=Quantity.from_str_c(lot_s) if lot_s is not None else None,
@@ -234,15 +234,15 @@
 
     @staticmethod
     cdef dict to_dict_c(CurrencyPair obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "CurrencyPair",
             "id": obj.id.to_str(),
-            "native_symbol": obj.native_symbol.to_str(),
+            "raw_symbol": obj.raw_symbol.to_str(),
             "base_currency": obj.base_currency.code,
             "quote_currency": obj.quote_currency.code,
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
             "size_increment": str(obj.size_increment),
             "lot_size": str(obj.lot_size) if obj.lot_size is not None else None,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/equity.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/equity.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -33,16 +33,16 @@
     """
     Represents a generic Equity instrument.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID.
-    native_symbol : Symbol
-        The native/local symbol on the exchange for the instrument.
+    raw_symbol : Symbol
+        The native/local/raw symbol for the instrument, assigned by the venue.
     currency : Currency
         The futures contract currency.
     price_precision : int
         The price decimal precision.
     price_increment : Decimal
         The minimum price increment (tick size).
     multiplier : Decimal
@@ -77,15 +77,15 @@
     ValueError
         If `lot_size` is not positive (> 0).
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
-        Symbol native_symbol not None,
+        Symbol raw_symbol not None,
         Currency currency not None,
         int price_precision,
         Price price_increment not None,
         Quantity multiplier not None,
         Quantity lot_size not None,
         uint64_t ts_event,
         uint64_t ts_init,
@@ -94,15 +94,15 @@
         margin_maint: Optional[Decimal] = None,
         maker_fee: Optional[Decimal] = None,
         taker_fee: Optional[Decimal] = None,
         dict info = None,
     ):
         super().__init__(
             instrument_id=instrument_id,
-            native_symbol=native_symbol,
+            raw_symbol=raw_symbol,
             asset_class=AssetClass.EQUITY,
             asset_type=AssetType.SPOT,
             quote_currency=currency,
             is_inverse=False,
             price_precision=price_precision,
             size_precision=0,  # No fractional units
             price_increment=price_increment,
@@ -126,15 +126,15 @@
         self.isin = isin
 
     @staticmethod
     cdef Equity from_dict_c(dict values):
         Condition.not_none(values, "values")
         return Equity(
             instrument_id=InstrumentId.from_str_c(values["id"]),
-            native_symbol=Symbol(values["native_symbol"]),
+            raw_symbol=Symbol(values["raw_symbol"]),
             currency=Currency.from_str_c(values["currency"]),
             price_precision=values["price_precision"],
             price_increment=Price.from_str(values["price_increment"]),
             multiplier=Quantity.from_str(values["multiplier"]),
             lot_size=Quantity.from_str(values["lot_size"]),
             isin=values.get("isin"),  # Can be None,
             margin_init=Decimal(values.get("margin_init", 0)),  # Can be None,
@@ -147,15 +147,15 @@
 
     @staticmethod
     cdef dict to_dict_c(Equity obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "Equity",
             "id": obj.id.to_str(),
-            "native_symbol": obj.native_symbol.to_str(),
+            "raw_symbol": obj.raw_symbol.to_str(),
             "currency": obj.quote_currency.code,
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
             "size_increment": str(obj.size_increment),
             "multiplier": str(obj.multiplier),
             "lot_size": str(obj.lot_size),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/futures_contract.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/futures_contract.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -35,16 +35,16 @@
     """
     Represents a generic deliverable futures contract instrument.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID.
-    native_symbol : Symbol
-        The native/local symbol on the exchange for the instrument.
+    raw_symbol : Symbol
+        The native/local/raw symbol for the instrument, assigned by the venue.
     asset_class : AssetClass
         The futures contract asset class.
     currency : Currency
         The futures contract currency.
     price_precision : int
         The price decimal precision.
     price_increment : Decimal
@@ -75,30 +75,30 @@
     ValueError
         If `lot_size` is not positive (> 0).
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
-        Symbol native_symbol not None,
+        Symbol raw_symbol not None,
         AssetClass asset_class,
         Currency currency not None,
         int price_precision,
         Price price_increment not None,
         Quantity multiplier,
         Quantity lot_size not None,
         str underlying,
         date expiry_date,
         uint64_t ts_event,
         uint64_t ts_init,
         dict info = None,
     ):
         super().__init__(
             instrument_id=instrument_id,
-            native_symbol=native_symbol,
+            raw_symbol=raw_symbol,
             asset_class=asset_class,
             asset_type=AssetType.FUTURE,
             quote_currency=currency,
             is_inverse=False,
             price_precision=price_precision,
             size_precision=0,  # No fractional units
             price_increment=price_increment,
@@ -123,15 +123,15 @@
         self.expiry_date = expiry_date
 
     @staticmethod
     cdef FuturesContract from_dict_c(dict values):
         Condition.not_none(values, "values")
         return FuturesContract(
             instrument_id=InstrumentId.from_str_c(values["id"]),
-            native_symbol=Symbol(values["native_symbol"]),
+            raw_symbol=Symbol(values["raw_symbol"]),
             asset_class=asset_class_from_str(values["asset_class"]),
             currency=Currency.from_str_c(values['currency']),
             price_precision=values['price_precision'],
             price_increment=Price.from_str(values['price_increment']),
             multiplier=Quantity.from_str(values['multiplier']),
             lot_size=Quantity.from_str(values['lot_size']),
             underlying=values['underlying'],
@@ -142,15 +142,15 @@
 
     @staticmethod
     cdef dict to_dict_c(FuturesContract obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "FuturesContract",
             "id": obj.id.to_str(),
-            "native_symbol": obj.native_symbol.to_str(),
+            "raw_symbol": obj.raw_symbol.to_str(),
             "asset_class": asset_class_to_str(obj.asset_class),
             "currency": obj.quote_currency.code,
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
             "size_increment": str(obj.size_increment),
             "multiplier": str(obj.multiplier),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/options_contract.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/instruments/options_contract.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -38,16 +38,16 @@
     """
     Represents a generic options contract instrument.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID.
-    native_symbol : Symbol
-        The native/local symbol on the exchange for the instrument.
+    raw_symbol : Symbol
+        The native/local/raw symbol for the instrument, assigned by the venue.
     asset_class : AssetClass
         The futures contract asset class.
     currency : Currency
         The futures contract currency.
     price_precision : int
         The price decimal precision.
     price_increment : Price
@@ -80,15 +80,15 @@
     ValueError
         If `lot_size` is not positive (> 0).
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
-        Symbol native_symbol not None,
+        Symbol raw_symbol not None,
         AssetClass asset_class,
         Currency currency not None,
         int price_precision,
         Price price_increment not None,
         Quantity multiplier not None,
         Quantity lot_size not None,
         Price strike_price not None,
@@ -98,15 +98,15 @@
         uint64_t ts_event,
         uint64_t ts_init,
         dict info = None,
     ):
         Condition.positive_int(multiplier, "multiplier")
         super().__init__(
             instrument_id=instrument_id,
-            native_symbol=native_symbol,
+            raw_symbol=raw_symbol,
             asset_class=asset_class,
             asset_type=AssetType.OPTION,
             quote_currency=currency,
             is_inverse=False,
             price_precision=price_precision,
             size_precision=0,  # No fractional contracts
             price_increment=price_increment,
@@ -133,15 +133,15 @@
         self.kind = kind
 
     @staticmethod
     cdef OptionsContract from_dict_c(dict values):
         Condition.not_none(values, "values")
         return OptionsContract(
             instrument_id=InstrumentId.from_str_c(values["id"]),
-            native_symbol=Symbol(values["native_symbol"]),
+            raw_symbol=Symbol(values["raw_symbol"]),
             asset_class=asset_class_from_str(values["asset_class"]),
             currency=Currency.from_str_c(values["currency"]),
             price_precision=values["price_precision"],
             price_increment=Price.from_str(values["price_increment"]),
             multiplier=Quantity.from_str(values["multiplier"]),
             lot_size=Quantity.from_str(values["lot_size"]),
             underlying=values['underlying'],
@@ -154,15 +154,15 @@
 
     @staticmethod
     cdef dict to_dict_c(OptionsContract obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "OptionsContract",
             "id": obj.id.to_str(),
-            "native_symbol": obj.native_symbol.to_str(),
+            "raw_symbol": obj.raw_symbol.to_str(),
             "asset_class": asset_class_to_str(obj.asset_class),
             "currency": obj.quote_currency.code,
             "price_precision": obj.price_precision,
             "price_increment": str(obj.price_increment),
             "size_precision": obj.size_precision,
             "size_increment": str(obj.size_increment),
             "multiplier": str(obj.multiplier),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/instruments/synthetic.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,17 +9,14 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.core.rust.core cimport CVec
-from nautilus_trader.core.rust.model cimport SyntheticInstrument_API
-from nautilus_trader.model.objects cimport Price
+# Required to register tick schemes
+# fmt: off
+from nautilus_trader.model.tick_scheme.implementations.fixed import FOREX_3DECIMAL_TICK_SCHEME  # noqa: F401
+from nautilus_trader.model.tick_scheme.implementations.fixed import FOREX_5DECIMAL_TICK_SCHEME  # noqa: F401
 
 
-cdef class SyntheticInstrument:
-    cdef SyntheticInstrument_API _mem
-
-    cpdef void change_formula(self, str formula)
-    cpdef Price calculate(self, list[double] inputs)
+# fmt: on
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/objects.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/objects.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/objects.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/objects.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -36,18 +36,15 @@
 from nautilus_trader.core.rust.model cimport MONEY_MAX as RUST_MONEY_MAX
 from nautilus_trader.core.rust.model cimport MONEY_MIN as RUST_MONEY_MIN
 from nautilus_trader.core.rust.model cimport PRICE_MAX as RUST_PRICE_MAX
 from nautilus_trader.core.rust.model cimport PRICE_MIN as RUST_PRICE_MIN
 from nautilus_trader.core.rust.model cimport QUANTITY_MAX as RUST_QUANTITY_MAX
 from nautilus_trader.core.rust.model cimport QUANTITY_MIN as RUST_QUANTITY_MIN
 from nautilus_trader.core.rust.model cimport Currency_t
-from nautilus_trader.core.rust.model cimport currency_clone
 from nautilus_trader.core.rust.model cimport currency_code_to_cstr
-from nautilus_trader.core.rust.model cimport currency_eq
-from nautilus_trader.core.rust.model cimport money_drop
 from nautilus_trader.core.rust.model cimport money_from_raw
 from nautilus_trader.core.rust.model cimport money_new
 from nautilus_trader.core.rust.model cimport price_from_raw
 from nautilus_trader.core.rust.model cimport price_new
 from nautilus_trader.core.rust.model cimport quantity_from_raw
 from nautilus_trader.core.rust.model cimport quantity_new
 from nautilus_trader.core.string cimport cstr_to_pystr
@@ -836,48 +833,42 @@
                 f"invalid `value` greater than `MONEY_MAX` {MONEY_MAX:_}, was {value:_}",
             )
         if value_f64 < MONEY_MIN:
             raise ValueError(
                 f"invalid `value` less than `MONEY_MIN` {MONEY_MIN:_}, was {value:_}",
             )
 
-        cdef Currency_t currency_t = currency._mem
-        self._mem = money_new(value_f64, currency_clone(&currency_t))
-
-    def __del__(self) -> None:
-        if self._mem.currency.code != NULL:
-            money_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
+        self._mem = money_new(value_f64, currency._mem)
 
     def __getstate__(self):
         return self._mem.raw, self.currency_code_c()
 
     def __setstate__(self, state):
         cdef Currency currency = Currency.from_str_c(state[1])
-        cdef Currency_t currency_t = currency._mem
-        self._mem = money_from_raw(state[0], currency_clone(&currency_t))
+        self._mem = money_from_raw(state[0], currency._mem)
 
     def __eq__(self, Money other) -> bool:
-        Condition.true(currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency")
-        return self._mem.raw == other.raw_int64_c()
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
+        return self._mem.raw == other._mem.raw
 
     def __lt__(self, Money other) -> bool:
-        Condition.true(currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency")
-        return self._mem.raw < other.raw_int64_c()
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
+        return self._mem.raw < other._mem.raw
 
     def __le__(self, Money other) -> bool:
-        Condition.true(currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency")
-        return self._mem.raw <= other.raw_int64_c()
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
+        return self._mem.raw <= other._mem.raw
 
     def __gt__(self, Money other) -> bool:
-        Condition.true(currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency")
-        return self._mem.raw > other.raw_int64_c()
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
+        return self._mem.raw > other._mem.raw
 
     def __ge__(self, Money other) -> bool:
-        Condition.true(currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency")
-        return self._mem.raw >= other.raw_int64_c()
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
+        return self._mem.raw >= other._mem.raw
 
     def __add__(a, b) -> Union[decimal.Decimal, float]:
         if isinstance(a, float) or isinstance(b, float):
             return float(a) + float(b)
         return Money._extract_decimal(a) + Money._extract_decimal(b)
 
     def __radd__(b, a) -> Union[decimal.Decimal, float]:
@@ -975,27 +966,27 @@
     cdef bint is_negative(self):
         return self._mem.raw < 0
 
     cdef bint is_positive(self):
         return self._mem.raw > 0
 
     cdef Money add(self, Money other):
-        assert currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency"
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
         return Money.from_raw_c(self._mem.raw + other._mem.raw, self.currency)
 
     cdef Money sub(self, Money other):
-        assert currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency"
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
         return Money.from_raw_c(self._mem.raw - other._mem.raw, self.currency)
 
     cdef void add_assign(self, Money other):
-        assert currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency"
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
         self._mem.raw += other._mem.raw
 
     cdef void sub_assign(self, Money other):
-        assert currency_eq(&self._mem.currency, &other._mem.currency), "currency != other.currency"
+        Condition.true(self._mem.currency.code == other._mem.currency.code, "currency != other.currency")
         self._mem.raw -= other._mem.raw
 
     cdef int64_t raw_int64_c(self):
         return self._mem.raw
 
     cdef double as_f64_c(self):
         return self._mem.raw / RUST_FIXED_SCALAR
@@ -1007,16 +998,15 @@
     @staticmethod
     def from_raw(uint64_t raw, uint8_t precision):
         return Money.from_raw_c(raw, precision)
 
     @staticmethod
     cdef Money from_raw_c(uint64_t raw, Currency currency):
         cdef Money money = Money.__new__(Money)
-        cdef Currency_t currency_t = currency._mem
-        money._mem = money_from_raw(raw, currency_clone(&currency_t))
+        money._mem = money_from_raw(raw, currency._mem)
         return money
 
     @staticmethod
     cdef object _extract_decimal(object obj):
         assert not isinstance(obj, float)  # Design-time error
         if hasattr(obj, "as_decimal"):
             return obj.as_decimal()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/persistence/external/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/orderbook/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 Defines real-time and simulated order book components and data.
 """
 
 from nautilus_trader.model.data.book import BookOrder
 from nautilus_trader.model.data.book import OrderBookDelta
 from nautilus_trader.model.data.book import OrderBookDeltas
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/book.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orderbook/book.pxd`

 * *Files 13% similar despite different names*

```diff
@@ -13,22 +13,24 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.data cimport Data
+from nautilus_trader.core.rust.model cimport Level_API
 from nautilus_trader.core.rust.model cimport OrderBook_API
 from nautilus_trader.model.data.book cimport BookOrder
 from nautilus_trader.model.data.book cimport OrderBookDelta
 from nautilus_trader.model.data.book cimport OrderBookDeltas
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
-from nautilus_trader.model.enums_c cimport BookType
-from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.enums_c cimport OrderSide
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
 cdef class OrderBook(Data):
     cdef OrderBook_API _mem
 
     cpdef void reset(self)
@@ -39,17 +41,31 @@
     cpdef void clear_bids(self, uint64_t ts_event, uint64_t sequence=*)
     cpdef void clear_asks(self, uint64_t ts_event, uint64_t sequence=*)
     cpdef void apply_delta(self, OrderBookDelta delta)
     cpdef void apply_deltas(self, OrderBookDeltas deltas)
     cpdef void apply(self, Data data)
     cpdef void check_integrity(self)
 
+    cpdef list bids(self)
+    cpdef list asks(self)
     cpdef best_bid_price(self)
     cpdef best_ask_price(self)
     cpdef best_bid_size(self)
     cpdef best_ask_size(self)
     cpdef spread(self)
     cpdef midpoint(self)
+    cpdef double get_avg_px_for_quantity(self, Quantity quantity, OrderSide order_side)
     cpdef list simulate_fills(self, Order order, uint8_t price_prec, bint is_aggressive)
     cpdef void update_quote_tick(self, QuoteTick tick)
     cpdef void update_trade_tick(self, TradeTick tick)
     cpdef str pprint(self, int num_levels=*)
+
+
+cdef class Level:
+    cdef Level_API _mem
+
+    cpdef list orders(self)
+    cpdef double volume(self)
+    cpdef double exposure(self)
+
+    @staticmethod
+    cdef Level from_mem_c(Level_API mem)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/book.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orderbook/book.pyx`

 * *Files 17% similar despite different names*

```diff
@@ -13,45 +13,51 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from operator import itemgetter
 
 import pandas as pd
 
-from nautilus_trader.model.orderbook.error import BookIntegrityError
-
 from libc.stdint cimport INT64_MAX
 from libc.stdint cimport INT64_MIN
 from libc.stdint cimport int64_t
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.core cimport CVec
 from nautilus_trader.core.rust.model cimport BookOrder_t
+from nautilus_trader.core.rust.model cimport Level_API
+from nautilus_trader.core.rust.model cimport OrderBook_API
 from nautilus_trader.core.rust.model cimport Price_t
 from nautilus_trader.core.rust.model cimport Quantity_t
 from nautilus_trader.core.rust.model cimport book_order_from_raw
-from nautilus_trader.core.rust.model cimport instrument_id_clone
+from nautilus_trader.core.rust.model cimport level_clone
+from nautilus_trader.core.rust.model cimport level_drop
+from nautilus_trader.core.rust.model cimport level_exposure
+from nautilus_trader.core.rust.model cimport level_orders
+from nautilus_trader.core.rust.model cimport level_price
+from nautilus_trader.core.rust.model cimport level_volume
 from nautilus_trader.core.rust.model cimport orderbook_add
 from nautilus_trader.core.rust.model cimport orderbook_apply_delta
+from nautilus_trader.core.rust.model cimport orderbook_asks
 from nautilus_trader.core.rust.model cimport orderbook_best_ask_price
 from nautilus_trader.core.rust.model cimport orderbook_best_ask_size
 from nautilus_trader.core.rust.model cimport orderbook_best_bid_price
 from nautilus_trader.core.rust.model cimport orderbook_best_bid_size
+from nautilus_trader.core.rust.model cimport orderbook_bids
 from nautilus_trader.core.rust.model cimport orderbook_book_type
 from nautilus_trader.core.rust.model cimport orderbook_check_integrity
 from nautilus_trader.core.rust.model cimport orderbook_clear
 from nautilus_trader.core.rust.model cimport orderbook_clear_asks
 from nautilus_trader.core.rust.model cimport orderbook_clear_bids
 from nautilus_trader.core.rust.model cimport orderbook_count
 from nautilus_trader.core.rust.model cimport orderbook_delete
-from nautilus_trader.core.rust.model cimport orderbook_delta_clone
-from nautilus_trader.core.rust.model cimport orderbook_drop
+from nautilus_trader.core.rust.model cimport orderbook_get_avg_px_for_quantity
 from nautilus_trader.core.rust.model cimport orderbook_has_ask
 from nautilus_trader.core.rust.model cimport orderbook_has_bid
 from nautilus_trader.core.rust.model cimport orderbook_instrument_id
 from nautilus_trader.core.rust.model cimport orderbook_midpoint
 from nautilus_trader.core.rust.model cimport orderbook_new
 from nautilus_trader.core.rust.model cimport orderbook_pprint_to_cstr
 from nautilus_trader.core.rust.model cimport orderbook_reset
@@ -59,14 +65,16 @@
 from nautilus_trader.core.rust.model cimport orderbook_simulate_fills
 from nautilus_trader.core.rust.model cimport orderbook_spread
 from nautilus_trader.core.rust.model cimport orderbook_ts_last
 from nautilus_trader.core.rust.model cimport orderbook_update
 from nautilus_trader.core.rust.model cimport orderbook_update_quote_tick
 from nautilus_trader.core.rust.model cimport orderbook_update_trade_tick
 from nautilus_trader.core.rust.model cimport vec_fills_drop
+from nautilus_trader.core.rust.model cimport vec_levels_drop
+from nautilus_trader.core.rust.model cimport vec_orders_drop
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.model.data.book cimport BookOrder
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.enums_c cimport BookAction
 from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
@@ -85,22 +93,18 @@
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
         BookType book_type,
     ):
         self._mem = orderbook_new(
-            instrument_id_clone(&instrument_id._mem),
+            instrument_id._mem,
             book_type,
         )
 
-    def __del__(self) -> None:
-        if self._mem._0 != NULL:
-            orderbook_drop(self._mem)
-
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__} {book_type_to_str(self.book_type)}\n"
             f"instrument: {self.instrument_id}\n"
             f"sequence: {self.sequence}\n"
             f"ts_last: {self.ts_last}\n"
             f"count: {self.count}\n"
@@ -276,16 +280,15 @@
         ------
         ValueError
             If `delta.book_type` is not equal to `self.type`.
 
         """
         Condition.not_none(delta, "delta")
 
-        # We have to clone the delta because of the heap allocation `instrument_id`
-        orderbook_apply_delta(&self._mem, orderbook_delta_clone(&delta._mem))
+        orderbook_apply_delta(&self._mem, delta._mem)
 
     cpdef void apply_deltas(self, OrderBookDeltas deltas):
         """
         Apply the bulk deltas to the order book.
 
         Parameters
         ----------
@@ -321,22 +324,65 @@
         Check book integrity.
 
         For now will panic from Rust and print the error message to stdout.
 
         For all order books:
         - The bid side price should not be greater than the ask side price.
 
-        Raises
-        ------
-        BookIntegrityError
-            If any check fails.
-
         """
         orderbook_check_integrity(&self._mem)
 
+    cpdef list bids(self):
+        """
+        Return the bid levels for the order book.
+
+        Returns
+        -------
+        list[Level]
+            Sorted in descending order of price.
+
+        """
+        cdef CVec raw_levels_vec = orderbook_bids(&self._mem)
+        cdef Level_API* raw_levels = <Level_API*>raw_levels_vec.ptr
+
+        cdef list levels = []
+
+        cdef:
+            uint64_t i
+        for i in range(raw_levels_vec.len):
+            levels.append(Level.from_mem_c(raw_levels[i]))
+
+        vec_levels_drop(raw_levels_vec)
+
+        return levels
+
+    cpdef list asks(self):
+        """
+        Return the bid levels for the order book.
+
+        Returns
+        -------
+        list[Level]
+            Sorted in ascending order of price.
+
+        """
+        cdef CVec raw_levels_vec = orderbook_asks(&self._mem)
+        cdef Level_API* raw_levels = <Level_API*>raw_levels_vec.ptr
+
+        cdef list levels = []
+
+        cdef:
+            uint64_t i
+        for i in range(raw_levels_vec.len):
+            levels.append(Level.from_mem_c(raw_levels[i]))
+
+        vec_levels_drop(raw_levels_vec)
+
+        return levels
+
     cpdef best_bid_price(self):
         """
         Return the best bid price in the book (if no bids then returns ``None``).
 
         Returns
         -------
         double
@@ -413,14 +459,45 @@
 
         """
         if not orderbook_has_bid(&self._mem) or not orderbook_has_ask(&self._mem):
             return None
 
         return orderbook_midpoint(&self._mem)
 
+    cpdef double get_avg_px_for_quantity(self, Quantity quantity, OrderSide order_side):
+        """
+        Return the average price expected for the given `quantity` based on the current state
+        of the order book.
+
+        Parameters
+        ----------
+        quantity : Quantity
+            The quantity for the calculation.
+        order_side : OrderSide
+            The order side for the calculation.
+
+        Returns
+        -------
+        double
+
+        Raises
+        ------
+        ValueError
+            If `order_side` is equal to ``NO_ORDER_SIDE``
+
+        Warnings
+        --------
+        If no average price can be calculated then will return 0.0 (zero).
+
+        """
+        Condition.not_none(quantity, "quantity")
+        Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
+
+        return orderbook_get_avg_px_for_quantity(&self._mem, quantity._mem, order_side)
+
     cpdef list simulate_fills(self, Order order, uint8_t price_prec, bint is_aggressive):
         """
         Simulate filling the book with the given order.
 
         Parameters
         ----------
         order : Order
@@ -500,7 +577,112 @@
 
         Returns
         -------
         str
 
         """
         return cstr_to_pystr(orderbook_pprint_to_cstr(&self._mem, num_levels))
+
+
+cdef class Level:
+    """
+    Represents a read-only order book `Level`.
+
+    A price level on one side of the order book with one or more individual orders.
+
+    Parameters
+    ----------
+    price : Price
+        The price for the level.
+    orders : list[BookOrder]
+        The orders for the level.
+
+    Raises
+    ------
+    ValueError
+        If `orders` is empty.
+    """
+
+    def __del__(self) -> None:
+        if self._mem._0 != NULL:
+            level_drop(self._mem)
+
+    def __eq__(self, Level other) -> bool:
+        return self.price._mem.raw == other.price._mem.raw
+
+    def __lt__(self, Level other) -> bool:
+        return self.price._mem.raw < other.price._mem.raw
+
+    def __le__(self, Level other) -> bool:
+        return self.price._mem.raw <= other.price._mem.raw
+
+    def __gt__(self, Level other) -> bool:
+        return self.price._mem.raw > other.price._mem.raw
+
+    def __ge__(self, Level other) -> bool:
+        return self.price._mem.raw >= other.price._mem.raw
+
+    def __repr__(self) -> str:
+        return f"Level(price={self.price}, orders={self.orders()})"
+
+    @property
+    def price(self) -> Price:
+        """
+        Return the price for the level.
+
+        Returns
+        -------
+        Price
+
+        """
+        return Price.from_mem_c(level_price(&self._mem))
+
+    @staticmethod
+    cdef Level from_mem_c(Level_API mem):
+        cdef Level level = Level.__new__(Level)
+        level._mem = level_clone(&mem)
+        return level
+
+    cpdef list orders(self):
+        """
+        Return the orders for the level.
+
+        Returns
+        -------
+        list[BookOrder]
+
+        """
+        cdef CVec raw_orders_vec = level_orders(&self._mem)
+        cdef BookOrder_t* raw_orders = <BookOrder_t*>raw_orders_vec.ptr
+
+        cdef list book_orders = []
+
+        cdef:
+            uint64_t i
+        for i in range(raw_orders_vec.len):
+            book_orders.append(BookOrder.from_mem_c(raw_orders[i]))
+
+        vec_orders_drop(raw_orders_vec)
+
+        return book_orders
+
+    cpdef double volume(self):
+        """
+        Return the volume at this level.
+
+        Returns
+        -------
+        double
+
+        """
+        return level_volume(&self._mem)
+
+    cpdef double exposure(self):
+        """
+        Return the exposure at this level (price * volume).
+
+        Returns
+        -------
+        double
+
+        """
+        return level_exposure(&self._mem)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/error.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,12 +9,13 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.adapters.interactive_brokers.client.client import InteractiveBrokersClient
 
-class BookIntegrityError(Exception):
-    """
-    Represents an error condition where the order books integrity has been lost.
-    """
+
+__all__ = [
+    "InteractiveBrokersClient",
+]
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,16 +8,18 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""Provides a full range of standard order types, as well as more advanced types and order lists."""
+"""
+Provides a full range of standard order types, as well as more advanced types and order
+lists.
+"""
 
 from nautilus_trader.model.orders.base import Order
 from nautilus_trader.model.orders.limit import LimitOrder
 from nautilus_trader.model.orders.limit_if_touched import LimitIfTouchedOrder
 from nautilus_trader.model.orders.list import OrderList
 from nautilus_trader.model.orders.market import MarketOrder
 from nautilus_trader.model.orders.market_if_touched import MarketIfTouchedOrder
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/base.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 
 from nautilus_trader.model.enums import order_status_to_str
 
 from libc.stdint cimport int64_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderStatus
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport contingency_type_to_str
@@ -44,14 +45,15 @@
 from nautilus_trader.model.events.order cimport OrderPendingCancel
 from nautilus_trader.model.events.order cimport OrderPendingUpdate
 from nautilus_trader.model.events.order cimport OrderRejected
 from nautilus_trader.model.events.order cimport OrderSubmitted
 from nautilus_trader.model.events.order cimport OrderTriggered
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.identifiers cimport TradeId
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Quantity
 
 
 VALID_STOP_ORDER_TYPES = (
     OrderType.STOP_MARKET,
     OrderType.STOP_LIMIT,
     OrderType.MARKET_IF_TOUCHED,
@@ -101,14 +103,15 @@
     (OrderStatus.PENDING_UPDATE, OrderStatus.PENDING_UPDATE): OrderStatus.PENDING_UPDATE,  # Allow multiple requests
     (OrderStatus.PENDING_UPDATE, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,
     (OrderStatus.PENDING_UPDATE, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
     (OrderStatus.PENDING_UPDATE, OrderStatus.FILLED): OrderStatus.FILLED,
     (OrderStatus.PENDING_CANCEL, OrderStatus.REJECTED): OrderStatus.REJECTED,  # Real world possibility
     (OrderStatus.PENDING_CANCEL, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,  # Allow multiple requests
     (OrderStatus.PENDING_CANCEL, OrderStatus.CANCELED): OrderStatus.CANCELED,
+    (OrderStatus.PENDING_CANCEL, OrderStatus.EXPIRED): OrderStatus.EXPIRED,
     (OrderStatus.PENDING_CANCEL, OrderStatus.ACCEPTED): OrderStatus.ACCEPTED,  # Allows failed cancel requests
     (OrderStatus.PENDING_CANCEL, OrderStatus.PARTIALLY_FILLED): OrderStatus.PARTIALLY_FILLED,
     (OrderStatus.PENDING_CANCEL, OrderStatus.FILLED): OrderStatus.FILLED,
     (OrderStatus.TRIGGERED, OrderStatus.REJECTED): OrderStatus.REJECTED,
     (OrderStatus.TRIGGERED, OrderStatus.PENDING_UPDATE): OrderStatus.PENDING_UPDATE,
     (OrderStatus.TRIGGERED, OrderStatus.PENDING_CANCEL): OrderStatus.PENDING_CANCEL,
     (OrderStatus.TRIGGERED, OrderStatus.CANCELED): OrderStatus.CANCELED,
@@ -140,14 +143,15 @@
 
     def __init__(self, OrderInitialized init not None):
         Condition.positive(init.quantity, "init.quantity")
 
         self._events: list[OrderEvent] = [init]
         self._venue_order_ids: list[VenueOrderId] = []
         self._trade_ids: list[TradeId] = []
+        self._commissions: dict[Currency, Money] = {}
         self._fsm = FiniteStateMachine(
             state_transition_table=_ORDER_STATE_TABLE,
             initial_state=OrderStatus.INITIALIZED,
             trigger_parser=order_status_to_str,
             state_parser=order_status_to_str,
         )
         self._previous_status = OrderStatus.INITIALIZED
@@ -180,23 +184,23 @@
         self.parent_order_id = init.parent_order_id  # Can be None
         self.exec_algorithm_id = init.exec_algorithm_id  # Can be None
         self.exec_algorithm_params = init.exec_algorithm_params  # Can be None
         self.exec_spawn_id = init.exec_spawn_id  # Can be None
         self.tags = init.tags
 
         # Execution
-        self.filled_qty = Quantity.zero_c(precision=0)
+        self.filled_qty = Quantity.zero_c(self.quantity._mem.precision)
         self.leaves_qty = init.quantity
         self.avg_px = 0.0  # No fills yet
         self.slippage = 0.0
 
         # Timestamps
         self.init_id = init.id
         self.ts_init = init.ts_init
-        self.ts_last = 0  # No fills yet
+        self.ts_last = init.ts_init
 
     def __eq__(self, Order other) -> bool:
         return self.client_order_id == other.client_order_id
 
     def __hash__(self) -> int:
         return hash(self.client_order_id)
 
@@ -209,24 +213,58 @@
         cdef str exec_algorithm_params_str = "" if self.exec_algorithm_params is None else f", exec_algorithm_params={self.exec_algorithm_params}"
         cdef str exec_spawn_id_str = "" if self.exec_spawn_id is None else f", exec_spawn_id={self.exec_spawn_id.to_str()}"
         return (
             f"{type(self).__name__}("
             f"{self.info()}, "
             f"status={self._fsm.state_string_c()}, "
             f"client_order_id={self.client_order_id.to_str()}, "
-            f"venue_order_id={self.venue_order_id}"  # Can be None (no whitespace before contingency_str)
+            f"venue_order_id={self.venue_order_id}, "  # Can be None (no whitespace before contingency_str)
+            f"position_id={self.position_id}"  # Can be None (no whitespace before contingency_str)
             f"{contingency_str}"
             f"{linked_order_ids_str}"
             f"{parent_order_id_str}"
             f"{exec_algorithm_id_str}"
             f"{exec_algorithm_params_str}"
             f"{exec_spawn_id_str}"
             f", tags={self.tags})"
         )
 
+    cpdef str status_string(self):
+        """
+        Return the orders current status as a string.
+
+        Returns
+        -------
+        str
+
+        """
+        return self.status_string_c()
+
+    cpdef str side_string(self):
+        """
+        Return the orders side as a string.
+
+        Returns
+        -------
+        str
+
+        """
+        return self.side_string_c()
+
+    cpdef str type_string(self):
+        """
+        Return the orders type as a string.
+
+        Returns
+        -------
+        str
+
+        """
+        return self.type_string_c()
+
     cpdef str info(self):
         """
         Return a summary description of the order.
 
         Returns
         -------
         str
@@ -380,26 +418,14 @@
         -------
         Venue
 
         """
         return self.instrument_id.venue
 
     @property
-    def side_string(self) -> str:
-        """
-        Return the orders side as a string.
-
-        Returns
-        -------
-        str
-
-        """
-        return self.side_string_c()
-
-    @property
     def status(self):
         """
         Return the orders current status.
 
         Returns
         -------
         OrderStatus
@@ -844,14 +870,25 @@
             if position_side == PositionSide.SHORT:
                 return False  # Would increase position
             elif position_side == PositionSide.LONG and self.leaves_qty._mem.raw > position_qty._mem.raw:
                 return False  # Would increase position
 
         return True  # Would reduce only
 
+    cpdef list commissions(self):
+        """
+        Return the total commissions generated by the order.
+
+        Returns
+        -------
+        list[Money]
+
+        """
+        return list(self._commissions.values())
+
     cpdef void apply(self, OrderEvent event):
         """
         Apply the given order event to the order.
 
         Parameters
         ----------
         event : OrderEvent
@@ -936,14 +973,15 @@
             )
 
         # Update previous status and events last as FSM may raise `InvalidStateTrigger`
         if previous_status != OrderStatus.PENDING_UPDATE and previous_status != OrderStatus.PENDING_CANCEL:
             self._previous_status = previous_status
 
         self._events.append(event)
+        self.ts_last = event.ts_event
 
     cdef void _denied(self, OrderDenied event):
         pass  # Do nothing else
 
     cdef void _submitted(self, OrderSubmitted event):
         self.account_id = event.account_id
 
@@ -986,19 +1024,24 @@
                 f"order.quantity={self.quantity}, "
                 f"order.filled_qty={self.filled_qty}, "
                 f"fill.last_qty={fill.last_qty}, "
                 f"fill={fill}",
             )
         self.filled_qty.add_assign(fill.last_qty)
         self.leaves_qty = Quantity.from_raw_c(<uint64_t>raw_leaves_qty, fill.last_qty._mem.precision)
-        self.ts_last = fill.ts_event
         self.avg_px = self._calculate_avg_px(fill.last_qty.as_f64_c(), fill.last_px.as_f64_c())
         self.liquidity_side = fill.liquidity_side
         self._set_slippage()
 
+        # Calculate cumulative commission
+        cdef Currency currency = fill.commission.currency
+        cdef Money commissions = self._commissions.get(currency)
+        cdef double total_commissions = commissions.as_f64_c() if commissions is not None else 0.0
+        self._commissions[currency] = Money(total_commissions + fill.commission.as_f64_c(), currency)
+
     cdef double _calculate_avg_px(self, double last_qty, double last_px):
         if self.avg_px == 0.0:
             return last_px
 
         cdef double filled_qty_f64 = self.filled_qty.as_f64_c()
         cdef double total_qty = filled_qty_f64 + last_qty
         if total_qty > 0:  # Protect divide by zero
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/limit.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -282,16 +282,17 @@
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "price": str(self.price),
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "expire_time_ns": self.expire_time_ns,
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
             "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
@@ -299,16 +300,16 @@
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
     cdef LimitOrder create(OrderInitialized init):
         """
         Return a `Limit` order from the given initialized event.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/limit_if_touched.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/limit_if_touched.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -314,16 +314,17 @@
             "price": str(self.price),
             "trigger_price": str(self.trigger_price),
             "trigger_type": trigger_type_to_str(self.trigger_type),
             "expire_time_ns": self.expire_time_ns,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
             "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
@@ -331,16 +332,16 @@
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
     cdef LimitIfTouchedOrder create(OrderInitialized init):
         """
         Return a `Limit-If-Touched` order from the given initialized event.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/list.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/list.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/market.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/market_to_limit.pyx`

 * *Files 10% similar despite different names*

```diff
@@ -14,21 +14,24 @@
 # -------------------------------------------------------------------------------------------------
 
 import msgspec
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.datetime cimport format_iso8601
+from nautilus_trader.core.datetime cimport unix_nanos_to_dt
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport TimeInForce
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.enums_c cimport contingency_type_to_str
+from nautilus_trader.model.enums_c cimport liquidity_side_to_str
 from nautilus_trader.model.enums_c cimport order_side_to_str
 from nautilus_trader.model.enums_c cimport order_type_to_str
 from nautilus_trader.model.enums_c cimport time_in_force_to_str
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
@@ -36,26 +39,23 @@
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class MarketOrder(Order):
+cdef class MarketToLimitOrder(Order):
     """
-    Represents a `Market` order.
+    Represents a `Market-To-Limit` (MTL) order.
 
-    A Market order is an order to BUY (or SELL) at the market bid or offer price.
-    A market order may increase the likelihood of a fill and the speed of
-    execution, but unlike the Limit order - a Market order provides no price
-    protection and may fill at a price far lower/higher than the top of book
-    bid/ask.
-
-    - A `Market-On-Open (MOO)` order can be represented using a time in force of ``AT_THE_OPEN``.
-    - A `Market-On-Close (MOC)` order can be represented using a time in force of ``AT_THE_CLOSE``.
+    A Market-to-Limit (MTL) order is submitted as a market order to execute at
+    the current best market price. If the order is only partially filled, the
+    remainder of the order is canceled and re-submitted as a Limit order with
+    the limit price equal to the price at which the filled portion of the order
+    executed.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the order.
     strategy_id : StrategyId
         The strategy ID associated with the order.
@@ -67,20 +67,24 @@
         The order side.
     quantity : Quantity
         The order quantity (> 0).
     init_id : UUID4
         The order initialization event ID.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
-    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
+    time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
+    expire_time_ns : uint64_t, default 0 (no expiry)
+        The UNIX timestamp (nanoseconds) when the order will expire.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
     quote_quantity : bool, default False
         If the order quantity is denominated in the quote currency.
+    display_qty : Quantity, optional
+        The quantity of the limit order to display on the public book (iceberg).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -98,60 +102,76 @@
     Raises
     ------
     ValueError
         If `order_side` is ``NO_ORDER_SIDE``.
     ValueError
         If `quantity` is not positive (> 0).
     ValueError
-        If `time_in_force` is ``GTD``.
+        If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
 
     References
     ----------
-    https://www.interactivebrokers.com/en/trading/orders/market.php
+    https://www.interactivebrokers.com/en/trading/orders/mtl.php
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         InstrumentId instrument_id not None,
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         Quantity quantity not None,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
+        uint64_t expire_time_ns = 0,
         bint reduce_only = False,
         bint quote_quantity = False,
+        Quantity display_qty = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
         str tags = None,
     ):
         Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
-        Condition.not_equal(time_in_force, TimeInForce.GTD, "time_in_force", "GTD")
+        Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
+        Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")
+
+        if time_in_force == TimeInForce.GTD:
+            # Must have an expire time
+            Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
+        else:
+            # Should not have an expire time
+            Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
+
+        # Set options
+        cdef dict options = {
+            "display_qty": str(display_qty) if display_qty is not None else None,
+            "expire_time_ns": expire_time_ns,
+        }
 
         # Create initialization event
         cdef OrderInitialized init = OrderInitialized(
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_side=order_side,
-            order_type=OrderType.MARKET,
+            order_type=OrderType.MARKET_TO_LIMIT,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
             quote_quantity=quote_quantity,
-            options={},
+            options=options,
             emulation_trigger=TriggerType.NO_TRIGGER,
             trigger_instrument_id=None,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
@@ -159,38 +179,66 @@
             exec_spawn_id=exec_spawn_id,
             tags=tags,
             event_id=init_id,
             ts_init=ts_init,
         )
         super().__init__(init=init)
 
+        self.price = None
+        self.expire_time_ns = expire_time_ns
+        self.display_qty = display_qty
+
     cdef void _updated(self, OrderUpdated event):
+        if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
+            self._venue_order_ids.append(self.venue_order_id)
+            self.venue_order_id = event.venue_order_id
         if event.quantity is not None:
             self.quantity = event.quantity
             self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
+        if event.price is not None:
+            self.price = event.price
+
+    cdef void _set_slippage(self):
+        if self.side == OrderSide.BUY:
+            self.slippage = self.avg_px - self.price.as_f64_c()
+        elif self.side == OrderSide.SELL:
+            self.slippage = self.price.as_f64_c() - self.avg_px
 
     cdef bint has_price_c(self):
-        return False
+        return self.price is not None
 
     cdef bint has_trigger_price_c(self):
         return False
 
+    @property
+    def expire_time(self):
+        """
+        Return the expire time for the order (UTC).
+
+        Returns
+        -------
+        datetime or ``None``
+
+        """
+        return None if self.expire_time_ns == 0 else unix_nanos_to_dt(self.expire_time_ns)
+
     cpdef str info(self):
         """
         Return a summary description of the order.
 
         Returns
         -------
         str
 
         """
+        cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {format_iso8601(unix_nanos_to_dt(self.expire_time_ns))}"
         return (
             f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
-            f"{order_type_to_str(self.order_type)} "
-            f"{time_in_force_to_str(self.time_in_force)}"
+            f"{order_type_to_str(self.order_type)} @ {self.price} "
+            f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
         )
 
     cpdef dict to_dict(self):
         """
         Return a dictionary representation of this object.
 
         Returns
@@ -207,123 +255,79 @@
             "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
+            "price": str(self.price),
             "time_in_force": time_in_force_to_str(self.time_in_force),
+            "expire_time_ns": self.expire_time_ns,
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
+            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "filled_qty": str(self.filled_qty),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
-    cdef MarketOrder create(OrderInitialized init):
+    cdef MarketToLimitOrder create(OrderInitialized init):
         """
-        Return a `market` order from the given initialized event.
+        Return a `Market-To-Limit` order from the given initialized event.
 
         Parameters
         ----------
         init : OrderInitialized
             The event to initialize with.
 
         Returns
         -------
-        MarketOrder
+        MarketToLimitOrder
 
         Raises
         ------
         ValueError
-            If `init.order_type` is not equal to ``MARKET``.
+            If `init.order_type` is not equal to ``MARKET_TO_LIMIT``.
 
         """
         Condition.not_none(init, "init")
-        Condition.equal(init.order_type, OrderType.MARKET, "init.order_type", "OrderType")
+        Condition.equal(init.order_type, OrderType.MARKET_TO_LIMIT, "init.order_type", "OrderType")
 
-        return MarketOrder(
+        cdef str display_qty_str = init.options.get("display_qty")
+
+        return MarketToLimitOrder(
             trader_id=init.trader_id,
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
             time_in_force=init.time_in_force,
+            expire_time_ns=init.options["expire_time_ns"],
             reduce_only=init.reduce_only,
             quote_quantity=init.quote_quantity,
+            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             init_id=init.id,
             ts_init=init.ts_init,
-            contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
+            contingency_type=init.contingency_type,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
             tags=init.tags,
         )
-
-    @staticmethod
-    cdef MarketOrder transform(Order order, uint64_t ts_init):
-        """
-        Transform the given order to a `market` order.
-
-        All existing events will be prepended to the orders internal events
-        prior to the new `OrderInitialized` event.
-
-        Parameters
-        ----------
-        order : Order
-            The order to transform from.
-        ts_init : uint64_t
-            The UNIX timestamp (nanoseconds) when the object was initialized.
-
-        Returns
-        -------
-        MarketOrder
-
-        """
-        Condition.not_none(order, "order")
-
-        cdef list original_events = order.events_c()
-        cdef MarketOrder transformed = MarketOrder(
-            trader_id=order.trader_id,
-            strategy_id=order.strategy_id,
-            instrument_id=order.instrument_id,
-            client_order_id=order.client_order_id,
-            order_side=order.side,
-            quantity=order.quantity,
-            time_in_force=order.time_in_force if order.time_in_force != TimeInForce.GTD else TimeInForce.GTC,
-            reduce_only=order.is_reduce_only,
-            quote_quantity=order.is_quote_quantity,
-            init_id=UUID4(),
-            ts_init=ts_init,
-            contingency_type=order.contingency_type,
-            order_list_id=order.order_list_id,
-            linked_order_ids=order.linked_order_ids,
-            parent_order_id=order.parent_order_id,
-            exec_algorithm_id=order.exec_algorithm_id,
-            exec_algorithm_params=order.exec_algorithm_params,
-            exec_spawn_id=order.exec_spawn_id,
-            tags=order.tags,
-        )
-
-        Order._hydrate_initial_events(original=order, transformed=transformed)
-
-        return transformed
-
-    @staticmethod
-    def transform_py(Order order, uint64_t ts_init) -> MarketOrder:
-        return MarketOrder.transform(order, ts_init)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/market_if_touched.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_market.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -42,23 +42,28 @@
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class MarketIfTouchedOrder(Order):
+cdef class StopMarketOrder(Order):
     """
-    Represents a `Market-If-Touched` (MIT) conditional order.
+    Represents a `Stop-Market` conditional order.
 
-    A Market-If-Touched (MIT) is an order to BUY (or SELL) an instrument below
-    (or above) the market. This order is held in the system until the trigger
-    price is touched, and is then submitted as a market order. An MIT order is
-    similar to a Stop-Order, except that an MIT SELL order is placed above the
-    current market price, and a stop SELL order is placed below.
+    A Stop-Market order is an instruction to submit a BUY (or SELL) market order
+    if and when the specified stop trigger price is attained or penetrated.
+    A Stop-Market order is not guaranteed a specific execution price and may execute
+    significantly away from its stop price.
+
+    A SELL Stop-Market order is always placed below the current market price,
+    and is typically used to limit a loss or protect a profit on a long position.
+
+    A BUY Stop-Market order is always placed above the current market price,
+    and is typically used to limit a loss or protect a profit on a short position.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the order.
     strategy_id : StrategyId
         The strategy ID associated with the order.
@@ -82,16 +87,16 @@
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
     quote_quantity : bool, default False
         If the order quantity is denominated in the quote currency.
-    emulation_trigger : EmulationTrigger, default ``NO_TRIGGER``
-        The emulation trigger for the order.
+    emulation_trigger : TriggerType, default ``NO_TRIGGER``
+        The order emulation trigger.
     trigger_instrument_id : InstrumentId, optional
         The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
@@ -119,15 +124,15 @@
     ValueError
         If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
     ValueError
         If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
 
     References
     ----------
-    https://www.interactivebrokers.com/en/trading/orders/mit.php
+    https://www.interactivebrokers.com/en/trading/orders/stop.php
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         InstrumentId instrument_id not None,
@@ -175,15 +180,15 @@
         # Create initialization event
         cdef OrderInitialized init = OrderInitialized(
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_side=order_side,
-            order_type=OrderType.MARKET_IF_TOUCHED,
+            order_type=OrderType.STOP_MARKET,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
             quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
@@ -269,70 +274,71 @@
         """
         cdef ClientOrderId o
         return {
             "trader_id": self.trader_id.to_str(),
             "strategy_id": self.strategy_id.to_str(),
             "instrument_id": self.instrument_id.to_str(),
             "client_order_id": self.client_order_id.to_str(),
-            "venue_order_id": self.venue_order_id if self.venue_order_id is not None else None,
+            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "trigger_price": str(self.trigger_price),
             "trigger_type": trigger_type_to_str(self.trigger_type),
             "expire_time_ns": self.expire_time_ns,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
             "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
-    cdef MarketIfTouchedOrder create(OrderInitialized init):
+    cdef StopMarketOrder create(OrderInitialized init):
         """
-        Return a `Market-If-Touched` order from the given initialized event.
+        Return a `Stop-Market` order from the given initialized event.
 
         Parameters
         ----------
         init : OrderInitialized
             The event to initialize with.
 
         Returns
         -------
         StopMarketOrder
 
         Raises
         ------
         ValueError
-            If `init.order_type` is not equal to ``MARKET_IF_TOUCHED``.
+            If `init.order_type` is not equal to ``STOP_MARKET``.
 
         """
         Condition.not_none(init, "init")
-        Condition.equal(init.order_type, OrderType.MARKET_IF_TOUCHED, "init.order_type", "OrderType")
+        Condition.equal(init.order_type, OrderType.STOP_MARKET, "init.order_type", "OrderType")
 
-        return MarketIfTouchedOrder(
+        return StopMarketOrder(
             trader_id=init.trader_id,
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
             trigger_price=Price.from_str_c(init.options["trigger_price"]),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/market_to_limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/market_if_touched.pyx`

 * *Files 14% similar despite different names*

```diff
@@ -23,38 +23,42 @@
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport TimeInForce
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.enums_c cimport contingency_type_to_str
+from nautilus_trader.model.enums_c cimport liquidity_side_to_str
 from nautilus_trader.model.enums_c cimport order_side_to_str
 from nautilus_trader.model.enums_c cimport order_type_to_str
 from nautilus_trader.model.enums_c cimport time_in_force_to_str
+from nautilus_trader.model.enums_c cimport trigger_type_from_str
+from nautilus_trader.model.enums_c cimport trigger_type_to_str
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
+from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class MarketToLimitOrder(Order):
+cdef class MarketIfTouchedOrder(Order):
     """
-    Represents a `Market-To-Limit` (MTL) order.
+    Represents a `Market-If-Touched` (MIT) conditional order.
 
-    A Market-to-Limit (MTL) order is submitted as a market order to execute at
-    the current best market price. If the order is only partially filled, the
-    remainder of the order is canceled and re-submitted as a Limit order with
-    the limit price equal to the price at which the filled portion of the order
-    executed.
+    A Market-If-Touched (MIT) is an order to BUY (or SELL) an instrument below
+    (or above) the market. This order is held in the system until the trigger
+    price is touched, and is then submitted as a market order. An MIT order is
+    similar to a Stop-Order, except that an MIT SELL order is placed above the
+    current market price, and a stop SELL order is placed below.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the order.
     strategy_id : StrategyId
         The strategy ID associated with the order.
@@ -62,28 +66,34 @@
         The order instrument ID.
     client_order_id : ClientOrderId
         The client order ID.
     order_side : OrderSide {``BUY``, ``SELL``}
         The order side.
     quantity : Quantity
         The order quantity (> 0).
+    trigger_price : Price
+        The order trigger price (STOP).
+    trigger_type : TriggerType
+        The order trigger type.
     init_id : UUID4
         The order initialization event ID.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
     quote_quantity : bool, default False
         If the order quantity is denominated in the quote currency.
-    display_qty : Quantity, optional
-        The quantity of the limit order to display on the public book (iceberg).
+    emulation_trigger : EmulationTrigger, default ``NO_TRIGGER``
+        The emulation trigger for the order.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -101,116 +111,125 @@
     Raises
     ------
     ValueError
         If `order_side` is ``NO_ORDER_SIDE``.
     ValueError
         If `quantity` is not positive (> 0).
     ValueError
+        If `trigger_type` is ``NO_TRIGGER``.
+    ValueError
         If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
+    ValueError
+        If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
 
     References
     ----------
-    https://www.interactivebrokers.com/en/trading/orders/mtl.php
+    https://www.interactivebrokers.com/en/trading/orders/mit.php
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         InstrumentId instrument_id not None,
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         Quantity quantity not None,
+        Price trigger_price not None,
+        TriggerType trigger_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint reduce_only = False,
         bint quote_quantity = False,
-        Quantity display_qty = None,
+        TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
         str tags = None,
     ):
         Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
+        Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
         Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
         Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")
 
         if time_in_force == TimeInForce.GTD:
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
 
         # Set options
         cdef dict options = {
-            "display_qty": str(display_qty) if display_qty is not None else None,
+            "trigger_price": str(trigger_price),
+            "trigger_type": trigger_type_to_str(trigger_type),
             "expire_time_ns": expire_time_ns,
         }
 
         # Create initialization event
         cdef OrderInitialized init = OrderInitialized(
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_side=order_side,
-            order_type=OrderType.MARKET_TO_LIMIT,
+            order_type=OrderType.MARKET_IF_TOUCHED,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
             quote_quantity=quote_quantity,
             options=options,
-            emulation_trigger=TriggerType.NO_TRIGGER,
-            trigger_instrument_id=None,
+            emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
             tags=tags,
             event_id=init_id,
             ts_init=ts_init,
         )
         super().__init__(init=init)
 
-        self.price = None
+        self.trigger_price = trigger_price
+        self.trigger_type = trigger_type
         self.expire_time_ns = expire_time_ns
-        self.display_qty = display_qty
 
     cdef void _updated(self, OrderUpdated event):
         if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
             self._venue_order_ids.append(self.venue_order_id)
             self.venue_order_id = event.venue_order_id
         if event.quantity is not None:
             self.quantity = event.quantity
             self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
-        if event.price is not None:
-            self.price = event.price
+        if event.trigger_price is not None:
+            self.trigger_price = event.trigger_price
 
     cdef void _set_slippage(self):
         if self.side == OrderSide.BUY:
-            self.slippage = self.avg_px - self.price.as_f64_c()
+            self.slippage = self.avg_px - self.trigger_price.as_f64_c()
         elif self.side == OrderSide.SELL:
-            self.slippage = self.price.as_f64_c() - self.avg_px
+            self.slippage = self.trigger_price.as_f64_c() - self.avg_px
 
     cdef bint has_price_c(self):
-        return self.price is not None
+        return False
 
     cdef bint has_trigger_price_c(self):
-        return False
+        return True
 
     @property
     def expire_time(self):
         """
         Return the expire time for the order (UTC).
 
         Returns
@@ -226,18 +245,21 @@
 
         Returns
         -------
         str
 
         """
         cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {format_iso8601(unix_nanos_to_dt(self.expire_time_ns))}"
+        cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
         return (
             f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
-            f"{order_type_to_str(self.order_type)} @ {self.price} "
+            f"{order_type_to_str(self.order_type)} @ {self.trigger_price}"
+            f"[{trigger_type_to_str(self.trigger_type)}] "
             f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
+            f"{emulation_str}"
         )
 
     cpdef dict to_dict(self):
         """
         Return a dictionary representation of this object.
 
         Returns
@@ -254,77 +276,82 @@
             "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
-            "price": str(self.price),
-            "time_in_force": time_in_force_to_str(self.time_in_force),
+            "trigger_price": str(self.trigger_price),
+            "trigger_type": trigger_type_to_str(self.trigger_type),
             "expire_time_ns": self.expire_time_ns,
-            "is_reduce_only": self.is_reduce_only,
-            "is_quote_quantity": self.is_quote_quantity,
-            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
+            "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "liquidity_side": liquidity_side_to_str(self.liquidity_side),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
+            "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
+            "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
-    cdef MarketToLimitOrder create(OrderInitialized init):
+    cdef MarketIfTouchedOrder create(OrderInitialized init):
         """
-        Return a `Market-To-Limit` order from the given initialized event.
+        Return a `Market-If-Touched` order from the given initialized event.
 
         Parameters
         ----------
         init : OrderInitialized
             The event to initialize with.
 
         Returns
         -------
-        MarketToLimitOrder
+        StopMarketOrder
 
         Raises
         ------
         ValueError
-            If `init.order_type` is not equal to ``MARKET_TO_LIMIT``.
+            If `init.order_type` is not equal to ``MARKET_IF_TOUCHED``.
 
         """
         Condition.not_none(init, "init")
-        Condition.equal(init.order_type, OrderType.MARKET_TO_LIMIT, "init.order_type", "OrderType")
-
-        cdef str display_qty_str = init.options.get("display_qty")
+        Condition.equal(init.order_type, OrderType.MARKET_IF_TOUCHED, "init.order_type", "OrderType")
 
-        return MarketToLimitOrder(
+        return MarketIfTouchedOrder(
             trader_id=init.trader_id,
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
+            trigger_price=Price.from_str_c(init.options["trigger_price"]),
+            trigger_type=trigger_type_from_str(init.options["trigger_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
-            reduce_only=init.reduce_only,
-            quote_quantity=init.quote_quantity,
-            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             init_id=init.id,
             ts_init=init.ts_init,
-            order_list_id=init.order_list_id,
+            reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
+            emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
+            order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
             tags=init.tags,
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_limit.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -316,16 +316,17 @@
             "price": str(self.price),
             "trigger_price": str(self.trigger_price),
             "trigger_type": trigger_type_to_str(self.trigger_type),
             "expire_time_ns": self.expire_time_ns,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
             "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
@@ -333,16 +334,16 @@
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
     cdef StopLimitOrder create(OrderInitialized init):
         """
         Return a `Stop-Limit` order from the given initialized event.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/stop_market.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_market.pyx`

 * *Files 10% similar despite different names*

```diff
@@ -9,14 +9,17 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from decimal import Decimal
+from typing import Optional
+
 import msgspec
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.datetime cimport format_iso8601
 from nautilus_trader.core.datetime cimport unix_nanos_to_dt
@@ -27,14 +30,16 @@
 from nautilus_trader.model.enums_c cimport TimeInForce
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.enums_c cimport contingency_type_to_str
 from nautilus_trader.model.enums_c cimport liquidity_side_to_str
 from nautilus_trader.model.enums_c cimport order_side_to_str
 from nautilus_trader.model.enums_c cimport order_type_to_str
 from nautilus_trader.model.enums_c cimport time_in_force_to_str
+from nautilus_trader.model.enums_c cimport trailing_offset_type_from_str
+from nautilus_trader.model.enums_c cimport trailing_offset_type_to_str
 from nautilus_trader.model.enums_c cimport trigger_type_from_str
 from nautilus_trader.model.enums_c cimport trigger_type_to_str
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
@@ -42,28 +47,17 @@
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class StopMarketOrder(Order):
+cdef class TrailingStopMarketOrder(Order):
     """
-    Represents a `Stop-Market` conditional order.
-
-    A Stop-Market order is an instruction to submit a BUY (or SELL) market order
-    if and when the specified stop trigger price is attained or penetrated.
-    A Stop-Market order is not guaranteed a specific execution price and may execute
-    significantly away from its stop price.
-
-    A SELL Stop-Market order is always placed below the current market price,
-    and is typically used to limit a loss or protect a profit on a long position.
-
-    A BUY Stop-Market order is always placed above the current market price,
-    and is typically used to limit a loss or protect a profit on a short position.
+    Represents a `Trailing-Stop-Market` conditional order.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the order.
     strategy_id : StrategyId
         The strategy ID associated with the order.
@@ -71,18 +65,23 @@
         The order instrument ID.
     client_order_id : ClientOrderId
         The client order ID.
     order_side : OrderSide {``BUY``, ``SELL``}
         The order side.
     quantity : Quantity
         The order quantity (> 0).
-    trigger_price : Price
-        The order trigger price (STOP).
+    trigger_price : Price, optional with no default so ``None`` must be passed explicitly
+        The order trigger price (STOP). If ``None`` then will typically default
+        to the delta of market price and `trailing_offset`.
     trigger_type : TriggerType
         The order trigger type.
+    trailing_offset : Decimal
+        The trailing offset for the trigger price (STOP).
+    trailing_offset_type : TrailingOffsetType
+        The order trailing offset type.
     init_id : UUID4
         The order initialization event ID.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
@@ -118,33 +117,33 @@
     ValueError
         If `order_side` is ``NO_ORDER_SIDE``.
     ValueError
         If `quantity` is not positive (> 0).
     ValueError
         If `trigger_type` is ``NO_TRIGGER``.
     ValueError
+        If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
+    ValueError
         If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
     ValueError
         If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
-
-    References
-    ----------
-    https://www.interactivebrokers.com/en/trading/orders/stop.php
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         InstrumentId instrument_id not None,
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         Quantity quantity not None,
-        Price trigger_price not None,
+        Price trigger_price: Optional[Price],
         TriggerType trigger_type,
+        trailing_offset: Decimal,
+        TrailingOffsetType trailing_offset_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint reduce_only = False,
         bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
@@ -156,39 +155,42 @@
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
         str tags = None,
     ):
         Condition.not_equal(order_side, OrderSide.NO_ORDER_SIDE, "order_side", "NO_ORDER_SIDE")
         Condition.not_equal(trigger_type, TriggerType.NO_TRIGGER, "trigger_type", "NO_TRIGGER")
+        Condition.not_equal(trailing_offset_type, TrailingOffsetType.NO_TRAILING_OFFSET, "trailing_offset_type", "NO_TRAILING_OFFSET")
         Condition.not_equal(time_in_force, TimeInForce.AT_THE_OPEN, "time_in_force", "AT_THE_OPEN`")
         Condition.not_equal(time_in_force, TimeInForce.AT_THE_CLOSE, "time_in_force", "AT_THE_CLOSE`")
 
         if time_in_force == TimeInForce.GTD:
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
 
         # Set options
         cdef dict options = {
-            "trigger_price": str(trigger_price),
+            "trigger_price": str(trigger_price) if trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(trigger_type),
+            "trailing_offset": str(trailing_offset),
+            "trailing_offset_type": trailing_offset_type_to_str(trailing_offset_type),
             "expire_time_ns": expire_time_ns,
         }
 
         # Create initialization event
         cdef OrderInitialized init = OrderInitialized(
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_side=order_side,
-            order_type=OrderType.STOP_MARKET,
+            order_type=OrderType.TRAILING_STOP_MARKET,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
             quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
@@ -204,37 +206,42 @@
             event_id=init_id,
             ts_init=ts_init,
         )
         super().__init__(init=init)
 
         self.trigger_price = trigger_price
         self.trigger_type = trigger_type
+        self.trailing_offset = trailing_offset
+        self.trailing_offset_type = trailing_offset_type
         self.expire_time_ns = expire_time_ns
 
     cdef void _updated(self, OrderUpdated event):
         if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
             self._venue_order_ids.append(self.venue_order_id)
             self.venue_order_id = event.venue_order_id
         if event.quantity is not None:
             self.quantity = event.quantity
             self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
         if event.trigger_price is not None:
             self.trigger_price = event.trigger_price
 
     cdef void _set_slippage(self):
+        if self.trigger_price is None:
+            return  # Prevents an attribute error below
+
         if self.side == OrderSide.BUY:
             self.slippage = self.avg_px - self.trigger_price.as_f64_c()
         elif self.side == OrderSide.SELL:
             self.slippage = self.trigger_price.as_f64_c() - self.avg_px
 
     cdef bint has_price_c(self):
         return False
 
     cdef bint has_trigger_price_c(self):
-        return True
+        return self.trigger_price is not None
 
     @property
     def expire_time(self):
         """
         Return the expire time for the order (UTC).
 
         Returns
@@ -253,16 +260,17 @@
         str
 
         """
         cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {format_iso8601(unix_nanos_to_dt(self.expire_time_ns))}"
         cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
         return (
             f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
-            f"{order_type_to_str(self.order_type)} @ {self.trigger_price}"
-            f"[{trigger_type_to_str(self.trigger_type)}] "
+            f"{order_type_to_str(self.order_type)}[{trigger_type_to_str(self.trigger_type)}] "
+            f"{'@ ' + str(self.trigger_price) + '-STOP ' if self.trigger_price else ''}"
+            f"{self.trailing_offset}-TRAILING_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
             f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
             f"{emulation_str}"
         )
 
     cpdef dict to_dict(self):
         """
         Return a dictionary representation of this object.
@@ -274,78 +282,85 @@
         """
         cdef ClientOrderId o
         return {
             "trader_id": self.trader_id.to_str(),
             "strategy_id": self.strategy_id.to_str(),
             "instrument_id": self.instrument_id.to_str(),
             "client_order_id": self.client_order_id.to_str(),
-            "venue_order_id": self.venue_order_id if self.venue_order_id is not None else None,
+            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
-            "trigger_price": str(self.trigger_price),
+            "trigger_price": str(self.trigger_price) if self.trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(self.trigger_type),
+            "trailing_offset": str(self.trailing_offset),
+            "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
             "expire_time_ns": self.expire_time_ns,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
             "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
-    cdef StopMarketOrder create(OrderInitialized init):
+    cdef TrailingStopMarketOrder create(OrderInitialized init):
         """
-        Return a `Stop-Market` order from the given initialized event.
+        Return a `Trailing-Stop-Market` order from the given initialized event.
 
         Parameters
         ----------
         init : OrderInitialized
             The event to initialize with.
 
         Returns
         -------
-        StopMarketOrder
+        TrailingStopMarketOrder
 
         Raises
         ------
         ValueError
-            If `init.order_type` is not equal to ``STOP_MARKET``.
+            If `init.order_type` is not equal to ``TRAILING_STOP_MARKET``.
 
         """
         Condition.not_none(init, "init")
-        Condition.equal(init.order_type, OrderType.STOP_MARKET, "init.order_type", "OrderType")
+        Condition.equal(init.order_type, OrderType.TRAILING_STOP_MARKET, "init.order_type", "OrderType")
+
+        cdef str trigger_price_str = init.options.get("trigger_price")
 
-        return StopMarketOrder(
+        return TrailingStopMarketOrder(
             trader_id=init.trader_id,
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
-            trigger_price=Price.from_str_c(init.options["trigger_price"]),
+            trigger_price=Price.from_str_c(trigger_price_str) if trigger_price_str is not None else None,
             trigger_type=trigger_type_from_str(init.options["trigger_type"]),
+            trailing_offset=Decimal(init.options["trailing_offset"]),
+            trailing_offset_type=trailing_offset_type_from_str(init.options["trailing_offset_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             init_id=init.id,
             ts_init=init.ts_init,
             reduce_only=init.reduce_only,
             quote_quantity=init.quote_quantity,
             emulation_trigger=init.emulation_trigger,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_limit.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -332,16 +332,17 @@
             "limit_offset": str(self.limit_offset),
             "trailing_offset": str(self.trailing_offset),
             "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
             "expire_time_ns": self.expire_time_ns,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
-            "avg_px": str(self.avg_px),
-            "slippage": str(self.slippage),
+            "avg_px": str(self.avg_px) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "slippage": str(self.slippage) if self.filled_qty.as_f64_c() > 0.0 else None,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
             "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
             "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
@@ -349,16 +350,16 @@
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
-            "ts_last": self.ts_last,
             "ts_init": self.ts_init,
+            "ts_last": self.ts_last,
         }
 
     @staticmethod
     cdef TrailingStopLimitOrder create(OrderInitialized init):
         """
         Return a `Trailing-Stop-Limit` order from the given initialized event.
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_market.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/trailing_stop_market.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/unpacker.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/orders/unpacker.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/position.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/position.pxd`

 * *Files 1% similar despite different names*

```diff
@@ -71,22 +71,22 @@
     """The multiplier for the positions instrument.\n\n:returns: `Quantity`"""
     cdef readonly bint is_inverse
     """If the quantity is expressed in quote currency.\n\n:returns: `bool`"""
     cdef readonly Currency quote_currency
     """The position quote currency.\n\n:returns: `Currency`"""
     cdef readonly Currency base_currency
     """The position base currency (if applicable).\n\n:returns: `Currency` or ``None``"""
-    cdef readonly Currency cost_currency
-    """The position cost currency (for PnL).\n\n:returns: `Currency`"""
+    cdef readonly Currency settlement_currency
+    """The position settlement currency (for PnL).\n\n:returns: `Currency`"""
     cdef readonly uint64_t ts_init
     """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
     cdef readonly uint64_t ts_opened
     """The UNIX timestamp (nanoseconds) when the position was opened.\n\n:returns: `uint64_t`"""
     cdef readonly uint64_t ts_last
-    """The UNIX timestamp (nanoseconds) when the last fill occurred.\n\n:returns: `uint64_t`"""
+    """The UNIX timestamp (nanoseconds) when the last event occurred.\n\n:returns: `uint64_t`"""
     cdef readonly uint64_t ts_closed
     """The UNIX timestamp (nanoseconds) when the position was closed.\n\n:returns: `uint64_t`"""
     cdef readonly uint64_t duration_ns
     """The total open duration (nanoseconds).\n\n:returns: `uint64_t`"""
     cdef readonly double avg_px_open
     """The average open price.\n\n:returns: `double`"""
     cdef readonly double avg_px_close
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/position.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/position.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -90,15 +90,15 @@
         self.avg_px_close = 0.0
         self.price_precision = instrument.price_precision
         self.size_precision = instrument.size_precision
         self.multiplier = instrument.multiplier
         self.is_inverse = instrument.is_inverse
         self.quote_currency = instrument.quote_currency
         self.base_currency = instrument.get_base_currency()  # Can be None
-        self.cost_currency = instrument.get_settlement_currency()
+        self.settlement_currency = instrument.get_settlement_currency()
 
         self.realized_return = 0.0
         self.realized_pnl = None
 
         self.apply(fill)
 
     def __eq__(self, Position other) -> bool:
@@ -129,35 +129,36 @@
         Returns
         -------
         dict[str, object]
 
         """
         return {
             "position_id": self.id.to_str(),
+            "strategy_id": self.strategy_id.to_str(),
+            "instrument_id": self.instrument_id.to_str(),
             "account_id": self.account_id.to_str(),
             "opening_order_id": self.opening_order_id.to_str(),
             "closing_order_id": self.closing_order_id.to_str() if self.closing_order_id is not None else None,
-            "strategy_id": self.strategy_id.to_str(),
-            "instrument_id": self.instrument_id.to_str(),
             "entry": order_side_to_str(self.entry),
             "side": position_side_to_str(self.side),
             "signed_qty": self.signed_qty,
             "quantity": str(self.quantity),
             "peak_qty": str(self.peak_qty),
             "ts_opened": self.ts_opened,
-            "ts_closed": self.ts_closed,
-            "duration_ns": self.duration_ns,
+            "ts_last": self.ts_last,
+            "ts_closed": self.ts_closed if self.ts_closed > 0 else None,
+            "duration_ns": self.duration_ns if self.duration_ns > 0 else None,
             "avg_px_open": str(self.avg_px_open),
-            "avg_px_close": str(self.avg_px_close),
+            "avg_px_close": str(self.avg_px_close) if self.avg_px_close > 0 else None,
             "quote_currency": self.quote_currency.code,
             "base_currency": self.base_currency.code if self.base_currency is not None else None,
-            "cost_currency": self.cost_currency.code,
+            "settlement_currency": self.settlement_currency.code,
+            "commissions": str([c.to_str() for c in self.commissions()]) if self._commissions else None,
             "realized_return": str(round(self.realized_return, 5)),
-            "realized_pnl": str(self.realized_pnl.to_str()),
-            "commissions": str([c.to_str() for c in self.commissions()]),
+            "realized_pnl": self.realized_pnl.to_str(),
         }
 
     cdef list client_order_ids_c(self):
         # Note the inner set {}
         return sorted(list({fill.client_order_id for fill in self._events}))
 
     cdef list venue_order_ids_c(self):
@@ -540,23 +541,24 @@
             The average close price.
         quantity : Quantity
             The quantity for the calculation.
 
         Returns
         -------
         Money
+            In settlement currency.
 
         """
         cdef double pnl = self._calculate_pnl(
             avg_px_open=avg_px_open,
             avg_px_close=avg_px_close,
             quantity=quantity.as_f64_c(),
         )
 
-        return Money(pnl, self.cost_currency)
+        return Money(pnl, self.settlement_currency)
 
     cpdef Money unrealized_pnl(self, Price last):
         """
         Return the unrealized PnL from the given last quote tick.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
@@ -570,23 +572,23 @@
         -------
         Money
 
         """
         Condition.not_none(last, "last")
 
         if self.side == PositionSide.FLAT:
-            return Money(0, self.quote_currency)
+            return Money(0, self.settlement_currency)
 
         cdef double pnl = self._calculate_pnl(
             avg_px_open=self.avg_px_open,
             avg_px_close=last.as_f64_c(),
             quantity=self.quantity.as_f64_c(),
         )
 
-        return Money(pnl, self.cost_currency)
+        return Money(pnl, self.settlement_currency)
 
     cpdef Money total_pnl(self, Price last):
         """
         Return the total PnL from the given last quote tick.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
@@ -600,15 +602,15 @@
         -------
         Money
 
         """
         Condition.not_none(last, "last")
 
         cdef double realized_pnl = self.realized_pnl.as_f64_c() if self.realized_pnl is not None else 0.0
-        return Money(realized_pnl + self.unrealized_pnl(last).as_f64_c(), self.cost_currency)
+        return Money(realized_pnl + self.unrealized_pnl(last).as_f64_c(), self.settlement_currency)
 
     cpdef list commissions(self):
         """
         Return the total commissions generated by the position.
 
         Returns
         -------
@@ -616,15 +618,15 @@
 
         """
         return list(self._commissions.values())
 
     cdef void _handle_buy_order_fill(self, OrderFilled fill):
         # Initialize realized PnL for fill
         cdef double realized_pnl
-        if fill.commission.currency == self.cost_currency:
+        if fill.commission.currency == self.settlement_currency:
             realized_pnl = -fill.commission.as_f64_c()
         else:
             realized_pnl = 0.0
 
         cdef double last_px = fill.last_px.as_f64_c()
         cdef double last_qty = fill.last_qty.as_f64_c()
         cdef Quantity last_qty_obj = fill.last_qty
@@ -637,26 +639,26 @@
         # SHORT POSITION
         elif self.signed_qty < 0:
             self.avg_px_close = self._calculate_avg_px_close_px(last_px, last_qty)
             self.realized_return = self._calculate_return(self.avg_px_open, self.avg_px_close)
             realized_pnl += self._calculate_pnl(self.avg_px_open, last_px, last_qty)
 
         if self.realized_pnl is None:
-            self.realized_pnl = Money(realized_pnl, self.cost_currency)
+            self.realized_pnl = Money(realized_pnl, self.settlement_currency)
         else:
-            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.cost_currency)
+            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.settlement_currency)
 
         self._buy_qty.add_assign(last_qty_obj)
         self.signed_qty += last_qty
         self.signed_qty = round(self.signed_qty, self.size_precision)
 
     cdef void _handle_sell_order_fill(self, OrderFilled fill):
         # Initialize realized PnL for fill
         cdef double realized_pnl
-        if fill.commission.currency == self.cost_currency:
+        if fill.commission.currency == self.settlement_currency:
             realized_pnl = -fill.commission.as_f64_c()
         else:
             realized_pnl = 0.0
 
         cdef double last_px = fill.last_px.as_f64_c()
         cdef double last_qty = fill.last_qty.as_f64_c()
         cdef Quantity last_qty_obj = fill.last_qty
@@ -669,17 +671,17 @@
         # LONG POSITION
         elif self.signed_qty > 0:
             self.avg_px_close = self._calculate_avg_px_close_px(last_px, last_qty)
             self.realized_return = self._calculate_return(self.avg_px_open, self.avg_px_close)
             realized_pnl += self._calculate_pnl(self.avg_px_open, last_px, last_qty)
 
         if self.realized_pnl is None:
-            self.realized_pnl = Money(realized_pnl, self.cost_currency)
+            self.realized_pnl = Money(realized_pnl, self.settlement_currency)
         else:
-            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.cost_currency)
+            self.realized_pnl = Money(self.realized_pnl.as_f64_c() + realized_pnl, self.settlement_currency)
 
         self._sell_qty.add_assign(last_qty_obj)
         self.signed_qty -= last_qty
         self.signed_qty = round(self.signed_qty, self.size_precision)
 
     cdef double _calculate_avg_px_open_px(self, double last_px, double last_qty):
         return self._calculate_avg_px(self.quantity.as_f64_c(), self.avg_px_open, last_px, last_qty)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/portfolio/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,16 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""Defines a scheme for modeling the tick space for various instruments."""
+"""
+Defines a scheme for modeling the tick space for various instruments.
+"""
 
 # Required to register tick schemes
 from nautilus_trader.model.tick_scheme.base import get_tick_scheme  # noqa: F401
 from nautilus_trader.model.tick_scheme.base import list_tick_schemes  # noqa: F401
 from nautilus_trader.model.tick_scheme.base import register_tick_scheme  # noqa: F401
 from nautilus_trader.model.tick_scheme.implementations import *  # noqa: F403
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/migrate.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,14 +9,36 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-# Required to register tick schemes
-# fmt: off
-from nautilus_trader.model.tick_scheme.implementations.fixed import FOREX_3DECIMAL_TICK_SCHEME  # noqa: F401
-from nautilus_trader.model.tick_scheme.implementations.fixed import FOREX_5DECIMAL_TICK_SCHEME  # noqa: F401
+from nautilus_trader.persistence.catalog.base import BaseDataCatalog
+from nautilus_trader.persistence.external.core import write_objects
 
 
-# fmt: on
+# TODO (bm)
+
+
+def create_temp_table(func):
+    """
+    Make a temporary copy of any parquet dataset class called by `write_tables`
+    """
+
+    def inner(*args, **kwargs):
+        try:
+            return func(*args, **kwargs)
+        except Exception:
+            # Restore old table
+            print()
+
+    return inner
+
+
+write_objects = create_temp_table(write_objects)
+
+
+def migrate(catalog: BaseDataCatalog, version_from: str, version_to: str):
+    """
+    Migrate the `catalog` between versions `version_from` and `version_to`
+    """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd` & `nautilus_trader-1.176.0/nautilus_trader/risk/sizing.pxd`

 * *Files 27% similar despite different names*

```diff
@@ -9,25 +9,37 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-cimport numpy as np
-
+from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.tick_scheme.base cimport TickScheme
+from nautilus_trader.model.objects cimport Quantity
 
 
-cdef class TieredTickScheme(TickScheme):
-    cdef list tiers
-    cdef int max_ticks_per_tier
-    cdef int tick_count
+cdef class PositionSizer:
+    cdef readonly Instrument instrument
+    """The instrument for position sizing.\n\n:returns: `Instrument`"""
+
+    cpdef void update_instrument(self, Instrument instrument)
+    cpdef Quantity calculate(
+        self,
+        Price entry,
+        Price stop_loss,
+        Money equity,
+        risk,
+        commission_rate=*,
+        exchange_rate=*,
+        hard_limit=*,
+        unit_batch_size=*,
+        int units=*,
+    )
 
-    cdef readonly np.ndarray ticks
+    cdef object _calculate_risk_ticks(self, Price entry, Price stop_loss)
+    cdef object _calculate_riskable_money(self, equity, risk, commission_rate)
 
-    cpdef _build_ticks(self)
 
-    cpdef int find_tick_index(self, double value)
-    cpdef Price next_ask_price(self, double value, int n=*)
-    cpdef Price next_bid_price(self, double value, int n=*)
+cdef class FixedRiskSizer(PositionSizer):
+    pass
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx` & `nautilus_trader-1.176.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/risk/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/serializer.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -9,11 +9,10 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-"""
-The `msgbus` subpackage provides a universal message bus for connecting system components in a
-loosely coupled way.
-"""
+
+cdef class ParquetSerializer:
+    pass
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pxd` & `nautilus_trader-1.176.0/nautilus_trader/msgbus/bus.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.core.message cimport Request
 from nautilus_trader.core.message cimport Response
+from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.msgbus.subscription cimport Subscription
 
 
 cdef class MessageBus:
     cdef Clock _clock
     cdef LoggerAdapter _log
@@ -41,14 +42,15 @@
     """The count of messages published by the bus.\n\n:returns: `int`"""
 
     cpdef list endpoints(self)
     cpdef list topics(self)
     cpdef list subscriptions(self, str pattern=*)
     cpdef bint has_subscribers(self, str pattern=*)
     cpdef bint is_subscribed(self, str topic, handler)
+    cpdef bint is_pending_request(self, UUID4 request_id)
 
     cpdef void register(self, str endpoint, handler)
     cpdef void deregister(self, str endpoint, handler)
     cpdef void send(self, str endpoint, msg)
     cpdef void request(self, str endpoint, Request request)
     cpdef void response(self, Response response)
     cpdef void subscribe(self, str topic, handler, int priority=*)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pyx` & `nautilus_trader-1.176.0/nautilus_trader/msgbus/bus.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -184,14 +184,32 @@
         cdef Subscription sub = Subscription(
             topic=topic,
             handler=handler,
         )
 
         return sub in self._subscriptions
 
+    cpdef bint is_pending_request(self, UUID4 request_id):
+        """
+        Return if the given `request_id` is still pending a response.
+
+        Parameters
+        ----------
+        request_id : UUID4
+            The request ID to check (to match the correlation_id).
+
+        Returns
+        -------
+        bool
+
+        """
+        Condition.not_none(request_id, "request_id")
+
+        return request_id in self._correlation_index
+
     cpdef void register(self, str endpoint, handler: Callable[[Any], None]):
         """
         Register the given `handler` to receive messages at the `endpoint` address.
 
         Parameters
         ----------
         endpoint : str
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pxd` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -8,16 +8,11 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-
-cdef class Subscription:
-    cdef readonly str topic
-    """The topic for the subscription.\n\n:returns: `str`"""
-    cdef readonly object handler
-    """The handler for the subscription.\n\n:returns: `Callable`"""
-    cdef readonly int priority
-    """The priority for the subscription.\n\n:returns: `int`"""
+"""
+The test kit contains test doubles and helpers to support the NautilusTrader test suite,
+as well as supporting testing for downstream projects and packages.
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pyx` & `nautilus_trader-1.176.0/nautilus_trader/msgbus/subscription.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/network/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/serialization/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/network/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/__init__.pxd`

 * *Files 16% similar despite different names*

```diff
@@ -8,14 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""
-The `network` subpackage provides low-level base components for networking clients.
-
-The base classes can be inherited to assist with writing adapters for integrations with exchanges,
-brokerages, data providers/feeds and other venues or services.
-"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/network/error.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/catalog/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,12 +9,15 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.persistence.catalog.base import BaseDataCatalog
+from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog
 
-class MaxRetriesExceeded(ConnectionError):
-    """
-    Represents an error where the maximum number of connection retries has been exceeded.
-    """
+
+__all__ = (
+    "BaseDataCatalog",
+    "ParquetDataCatalog",
+)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/msgpack/__init__.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -8,9 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""The `persistence` subpackage handles data storage and retrieval, mainly to support backtesting."""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py`

 * *Files 20% similar despite different names*

```diff
@@ -9,15 +9,23 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.persistence.catalog.base import BaseDataCatalog
-from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog
+import msgspec
 
 
-__all__ = (
-    "BaseDataCatalog",
-    "ParquetDataCatalog",
-)
+################################################################################
+# HTTP responses
+################################################################################
+
+
+class BinanceSpotTradeFee(msgspec.Struct, frozen=True):
+    """
+    Schema of a single `Binance Spot/Margin` tradeFee.
+    """
+
+    symbol: str
+    makerCommission: str
+    takerCommission: str
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/base.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/catalog/base.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/parquet.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/catalog/parquet.py`

 * *Files 0% similar despite different names*

```diff
@@ -66,26 +66,28 @@
         The fsspec filesystem protocol to use.
     fs_storage_options : dict, optional
         The fs storage options.
 
     Warnings
     --------
     The catalog is not threadsafe.
+
     """
 
     def __init__(
         self,
         path: str,
         fs_protocol: Optional[str] = "file",
         fs_storage_options: Optional[dict] = None,
     ):
         self.fs_protocol = fs_protocol
         self.fs_storage_options = fs_storage_options or {}
         self.fs: fsspec.AbstractFileSystem = fsspec.filesystem(
-            self.fs_protocol, **self.fs_storage_options
+            self.fs_protocol,
+            **self.fs_storage_options,
         )
 
         path = make_path_posix(str(path))
 
         if (
             isinstance(self.fs, MemoryFileSystem)
             and platform.system() == "Windows"
@@ -231,15 +233,18 @@
         mappings = self.load_inverse_mappings(path=full_path)
 
         if "as_nautilus" in kwargs:
             as_dataframe = not kwargs.pop("as_nautilus")
 
         if as_dataframe:
             return self._handle_table_dataframe(
-                table=table, mappings=mappings, raise_on_empty=raise_on_empty, **kwargs
+                table=table,
+                mappings=mappings,
+                raise_on_empty=raise_on_empty,
+                **kwargs,
             )
         else:
             return self._handle_table_nautilus(table=table, cls=cls, mappings=mappings)
 
     def make_path(self, cls: type, instrument_id: Optional[str] = None) -> str:
         path = f"{self.path}/data/{class_to_filename(cls=cls)}.parquet"
         if instrument_id is not None:
@@ -483,15 +488,15 @@
             except Exception as e:
                 if raise_on_failed_deserialize:
                     raise
                 print(f"Failed to deserialize {cls_name}: {e}")
         return sorted(sum(data.values(), []), key=lambda x: x.ts_init)
 
 
-def read_feather_file(path: str, fs: fsspec.AbstractFileSystem = None):
+def read_feather_file(path: str, fs: Optional[fsspec.AbstractFileSystem] = None):
     fs = fs or fsspec.filesystem("file")
     if not fs.exists(path):
         return
     try:
         with fs.open(path) as f:
             reader = pa.ipc.open_stream(f)
             return reader.read_pandas()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/external/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/msgpack/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/external/core.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/external/core.py`

 * *Files 2% similar despite different names*

```diff
@@ -22,14 +22,15 @@
 from typing import Optional, Union
 
 import fsspec
 import pandas as pd
 import pyarrow as pa
 from fsspec.core import OpenFile
 from pyarrow import ArrowInvalid
+from pyarrow import ArrowTypeError
 from pyarrow import dataset as ds
 from pyarrow import parquet as pq
 from tqdm import tqdm
 
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.model.data import GenericData
 from nautilus_trader.model.instruments import Instrument
@@ -48,24 +49,26 @@
 from nautilus_trader.serialization.arrow.util import class_to_filename
 from nautilus_trader.serialization.arrow.util import clean_partition_cols
 from nautilus_trader.serialization.arrow.util import maybe_list
 
 
 class RawFile:
     """
-    Provides a wrapper of `fsspec.OpenFile` that processes a raw file and writes to parquet.
+    Provides a wrapper of `fsspec.OpenFile` that processes a raw file and writes to
+    parquet.
 
     Parameters
     ----------
     open_file : fsspec.core.OpenFile
         The fsspec.OpenFile source of this data.
     block_size: int
         The max block (chunk) size in bytes to read from the file.
     progress: bool, default False
         If a progress bar should be shown when processing this individual file.
+
     """
 
     def __init__(
         self,
         open_file: OpenFile,
         block_size: Optional[int] = None,
     ):
@@ -106,15 +109,15 @@
     glob_path,
     reader: Reader,
     catalog: ParquetDataCatalog,
     block_size: str = "128mb",
     compression: str = "infer",
     executor: Optional[Executor] = None,
     use_rust=False,
-    instrument: Instrument = None,
+    instrument: Optional[Instrument] = None,
     **kwargs,
 ):
     PyCondition.type_or_none(executor, Executor, "executor")
     if use_rust:
         assert instrument, "Instrument needs to be provided when saving rust data."
 
     executor = executor or ThreadPoolExecutor()
@@ -155,15 +158,16 @@
 def scan_files(glob_path, compression="infer", **kw) -> list[OpenFile]:
     open_files = fsspec.open_files(glob_path, compression=compression, **kw)
     return list(open_files)
 
 
 def split_and_serialize(objs: list) -> dict[type, dict[Optional[str], list]]:
     """
-    Given a list of Nautilus `objs`; serialize and split into dictionaries per type / instrument ID.
+    Given a list of Nautilus `objs`; serialize and split into dictionaries per type /
+    instrument ID.
     """
     # Split objects into their respective tables
     values: dict[type, dict[str, list]] = {}
     for obj in objs:
         cls = get_cls_table(type(obj))
         if isinstance(obj, GenericData):
             cls = obj.data_type.type
@@ -194,15 +198,15 @@
             if "instrument_id" in df.columns:
                 df = df.astype({"instrument_id": "category"})
             tables[cls][ins_id] = df
 
     return tables
 
 
-def determine_partition_cols(cls: type, instrument_id: str = None) -> Union[list, None]:
+def determine_partition_cols(cls: type, instrument_id: Optional[str] = None) -> Union[list, None]:
     """
     Determine partition columns (if any) for this type `cls`.
     """
     partition_keys = get_partition_keys(cls)
     if partition_keys:
         return list(partition_keys)
     elif instrument_id is not None:
@@ -210,31 +214,34 @@
     return None
 
 
 def merge_existing_data(catalog: BaseDataCatalog, cls: type, df: pd.DataFrame) -> pd.DataFrame:
     """
     Handle existing data for instrument subclasses.
 
-    Instruments all live in a single file, so merge with existing data.
-    For all other classes, simply return data unchanged.
+    Instruments all live in a single file, so merge with existing data. For all other
+    classes, simply return data unchanged.
+
     """
     if cls not in Instrument.__subclasses__():
         return df
     else:
         try:
             existing = catalog.instruments(instrument_type=cls)
             subset = [c for c in df.columns if c not in ("ts_init", "ts_event", "type")]
             merged = pd.concat([existing, df.drop(["type"], axis=1)])
             return merged.drop_duplicates(subset=subset)
         except pa.lib.ArrowInvalid:
             return df
 
 
 def write_tables(
-    catalog: ParquetDataCatalog, tables: dict[type, dict[str, pd.DataFrame]], **kwargs
+    catalog: ParquetDataCatalog,
+    tables: dict[type, dict[str, pd.DataFrame]],
+    **kwargs,
 ):
     """
     Write tables to catalog.
     """
     rows_written = 0
 
     iterator = [
@@ -247,18 +254,19 @@
         try:
             schema = get_schema(cls)
         except KeyError:
             print(f"Can't find parquet schema for type: {cls}, skipping!")
             continue
         partition_cols = determine_partition_cols(cls=cls, instrument_id=instrument_id)
         path = f"{catalog.path}/data/{class_to_filename(cls)}.parquet"
-        if kwargs.get("merge_existing_data") is False:
-            merged = df
-        else:
-            merged = merge_existing_data(catalog=catalog, cls=cls, df=df)
+        merged = (
+            df
+            if kwargs.get("merge_existing_data") is False
+            else merge_existing_data(catalog=catalog, cls=cls, df=df)
+        )
         kwargs.pop("merge_existing_data", None)
 
         write_parquet(
             fs=catalog.fs,
             path=path,
             df=merged,
             partition_cols=partition_cols,
@@ -320,15 +328,19 @@
     Write a single dataframe to parquet.
     """
     # Check partition values are valid before writing to parquet
     mappings = check_partition_columns(df=df, partition_columns=partition_cols)
     df = clean_partition_cols(df=df, mappings=mappings)
 
     # Dataframe -> pyarrow Table
-    table = pa.Table.from_pandas(df, schema=schema)
+    try:
+        table = pa.Table.from_pandas(df, schema)
+    except (ArrowTypeError, ArrowInvalid) as e:
+        logging.error(f"Failed to convert dataframe to pyarrow table with {schema=}, exception={e}")
+        raise
 
     if "basename_template" not in kwargs and "ts_init" in df.columns:
         if "bar_type" in df.columns:
             suffix = df.iloc[0]["bar_type"].split(".")[-1]
             kwargs["basename_template"] = (
                 f"{df['ts_init'].min()}-{df['ts_init'].max()}" + "-" + suffix + "-{i}.parquet"
             )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/external/metadata.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/external/metadata.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/external/readers.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/external/readers.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,16 +23,16 @@
 
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.model.instruments import Instrument
 
 
 class LinePreprocessor:
     """
-    Provides pre-processing lines before they are passed to a `Reader` class
-    (currently only `TextReader`).
+    Provides pre-processing lines before they are passed to a `Reader` class (currently
+    only `TextReader`).
 
     Used if the input data requires any pre-processing that may also be required
     as attributes on the resulting Nautilus objects that are created.
 
     Examples
     --------
     For example, if you were logging data in Python with a prepended timestamp, as below:
@@ -49,14 +49,15 @@
     >>>        timestamp, json_data = line.split(' - ')
     >>>        yield json_data, {'ts_init': pd.Timestamp(timestamp)}
     >>>
     >>>    @staticmethod
     >>>    def post_process(obj: Any, state: dict):
     >>>        obj.ts_init = state['ts_init']
     >>>        return obj
+
     """
 
     def __init__(self):
         self.state = {}
         self.line = None
 
     @staticmethod
@@ -87,15 +88,15 @@
     """
     Provides parsing of raw byte blocks to Nautilus objects.
     """
 
     def __init__(
         self,
         instrument_provider: Optional[InstrumentProvider] = None,
-        instrument_provider_update: Callable = None,
+        instrument_provider_update: Optional[Callable] = None,
     ):
         self.instrument_provider = instrument_provider
         self.instrument_provider_update = instrument_provider_update
         self.buffer = b""
 
     def check_instrument_provider(self, data: Union[bytes, str]) -> list[Instrument]:
         if self.instrument_provider_update is not None:
@@ -119,33 +120,34 @@
 
     def parse(self, block: bytes) -> Generator:
         raise NotImplementedError  # pragma: no cover
 
 
 class ByteReader(Reader):
     """
-    A Reader subclass for reading blocks of raw bytes; `byte_parser` will be
-    passed a blocks of raw bytes.
+    A Reader subclass for reading blocks of raw bytes; `byte_parser` will be passed a
+    blocks of raw bytes.
 
     Parameters
     ----------
     block_parser : Callable
         The handler which takes a blocks of bytes and yields Nautilus objects.
     instrument_provider : InstrumentProvider, optional
         The instrument provider for the reader.
     instrument_provider_update : Callable , optional
         An optional hook/callable to update instrument provider before data is passed to `byte_parser`
         (in many cases instruments need to be known ahead of parsing).
+
     """
 
     def __init__(
         self,
         block_parser: Callable,
         instrument_provider: Optional[InstrumentProvider] = None,
-        instrument_provider_update: Callable = None,
+        instrument_provider_update: Optional[Callable] = None,
     ):
         super().__init__(
             instrument_provider_update=instrument_provider_update,
             instrument_provider=instrument_provider,
         )
         assert inspect.isgeneratorfunction(block_parser)
         self.parser = block_parser
@@ -155,16 +157,16 @@
         if instruments:
             yield from instruments
         yield from self.parser(block)
 
 
 class TextReader(ByteReader):
     """
-    A Reader subclass for reading lines of a text-like file; `line_parser` will
-    be passed a single row of bytes.
+    A Reader subclass for reading lines of a text-like file; `line_parser` will be
+    passed a single row of bytes.
 
     Parameters
     ----------
     line_parser : Callable
         The handler which takes byte strings and yields Nautilus objects.
     line_preprocessor : Callable, optional
         The context manager for pre-processing (cleaning log lines) of lines
@@ -175,20 +177,21 @@
         The instrument provider for the reader.
     instrument_provider_update : Callable, optional
         An optional hook/callable to update instrument provider before
         data is passed to `line_parser` (in many cases instruments need to
         be known ahead of parsing).
     newline : bytes
         The newline char value.
+
     """
 
     def __init__(
         self,
         line_parser: Callable,
-        line_preprocessor: LinePreprocessor = None,
+        line_preprocessor: Optional[LinePreprocessor] = None,
         instrument_provider: Optional[InstrumentProvider] = None,
         instrument_provider_update: Optional[Callable] = None,
         newline: bytes = b"\n",
     ):
         assert line_preprocessor is None or isinstance(line_preprocessor, LinePreprocessor)
         super().__init__(
             instrument_provider_update=instrument_provider_update,
@@ -237,14 +240,15 @@
         If first row contains names of columns, header has to be set to `None`.
         If data starts right at the first row, header has to be provided the list of column names.
     chunked: bool, default True
         If chunked=False, each CSV line will be passed to `block_parser` individually, if chunked=True, the data
         passed will potentially contain many lines (a block).
     as_dataframe: bool, default False
         If as_dataframe=True, the passes block will be parsed into a DataFrame before passing to `block_parser`.
+
     """
 
     def __init__(
         self,
         block_parser: Callable,
         instrument_provider: Optional[InstrumentProvider] = None,
         instrument_provider_update: Optional[Callable] = None,
@@ -317,19 +321,20 @@
     parser : Callable
         The parser.
     instrument_provider : InstrumentProvider, optional
         The readers instrument provider.
     instrument_provider_update : Callable , optional
         An optional hook/callable to update instrument provider before data is passed to `byte_parser`
         (in many cases instruments need to be known ahead of parsing).
+
     """
 
     def __init__(
         self,
-        parser: Callable = None,
+        parser: Optional[Callable] = None,
         instrument_provider: Optional[InstrumentProvider] = None,
         instrument_provider_update: Optional[Callable] = None,
     ):
         super().__init__(
             block_parser=parser,
             instrument_provider_update=instrument_provider_update,
             instrument_provider=instrument_provider,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/external/util.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/external/util.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 import os
 import re
 import sys
 from typing import Optional
 
 import pandas as pd
 
-from nautilus_trader.core.nautilus_pyo3.persistence import ParquetType
+from nautilus_trader.core.nautilus_pyo3.persistence import NautilusDataType
 from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.data import TradeTick
 
 
 class Singleton(type):
     """
     The base class to ensure a singleton.
@@ -120,14 +120,14 @@
     if start is None:
         return None
 
     start = pd.Timestamp(start)
     return instrument_id, start
 
 
-def py_type_to_parquet_type(cls: type) -> ParquetType:
+def py_type_to_parquet_type(cls: type) -> NautilusDataType:
     if cls == QuoteTick:
-        return ParquetType.QuoteTick
+        return NautilusDataType.QuoteTick
     elif cls == TradeTick:
-        return ParquetType.TradeTick
+        return NautilusDataType.TradeTick
     else:
-        raise RuntimeError(f"Type {cls} not supported as a `ParquetType` yet.")
+        raise RuntimeError(f"Type {cls} not supported as a `NautilusDataType` yet.")
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/funcs.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/funcs.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/loaders.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/loaders.py`

 * *Files 0% similar despite different names*

```diff
@@ -163,14 +163,15 @@
 
         Parameters
         ----------
         file_path : str, path object or file-like object
             The path to the Parquet file.
         timestamp_column: str
             Name of the timestamp column in the parquet data
+
         Returns
         -------
         pd.DataFrame
 
         """
         df = pd.read_parquet(file_path)
         df = df.set_index(timestamp_column)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/migrate.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/bar.py`

 * *Files 21% similar despite different names*

```diff
@@ -9,32 +9,28 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.persistence.catalog.base import BaseDataCatalog
-from nautilus_trader.persistence.external.core import write_objects
+from nautilus_trader.model.data import Bar
+from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
-# TODO (bm)
+def serialize(bar: Bar):
+    data = bar.to_dict(bar)
+    data["instrument_id"] = bar.bar_type.instrument_id.value
+    return data
 
 
-def create_temp_table(func):
-    """Make a temporary copy of any parquet dataset class called by `write_tables`"""
+def deserialize(data: dict) -> Bar:
+    ignore = ("instrument_id",)
+    bar = Bar.from_dict({k: v for k, v in data.items() if k not in ignore})
+    return bar
 
-    def inner(*args, **kwargs):
-        try:
-            return func(*args, **kwargs)
-        except Exception:
-            # Restore old table
-            print()
 
-    return inner
-
-
-write_objects = create_temp_table(write_objects)
-
-
-def migrate(catalog: BaseDataCatalog, version_from: str, version_to: str):
-    """Migrate the `catalog` between versions `version_from` and `version_to`"""
+register_parquet(
+    Bar,
+    serializer=serialize,
+    deserializer=deserialize,
+)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/system/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/batching.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/batching.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/engine.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/engine.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/writer.py` & `nautilus_trader-1.176.0/nautilus_trader/persistence/streaming/writer.py`

 * *Files 0% similar despite different names*

```diff
@@ -47,14 +47,15 @@
         The logger for the writer.
     fs_protocol : str, default 'file'
         The `fsspec` file system protocol.
     flush_interval_ms : int, optional
         The flush interval (milliseconds) for writing chunks.
     replace : bool, default False
         If existing files at the given `path` should be replaced.
+
     """
 
     def __init__(
         self,
         path: str,
         logger: LoggerAdapter,
         fs_protocol: Optional[str] = "file",
@@ -208,14 +209,15 @@
         The name of the signal data.
     value_type : type
         The type for the signal data value.
 
     Returns
     -------
     SignalData
+
     """
 
     class SignalData(Data):
         """
         Represents generic signal data.
         """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pxd` & `nautilus_trader-1.176.0/nautilus_trader/persistence/wranglers.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pyx` & `nautilus_trader-1.176.0/nautilus_trader/persistence/wranglers.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -29,14 +29,15 @@
 from nautilus_trader.core.datetime cimport as_utc_index
 from nautilus_trader.core.rust.core cimport CVec
 from nautilus_trader.core.rust.core cimport secs_to_nanos
 from nautilus_trader.core.rust.model cimport Data_t
 from nautilus_trader.core.rust.model cimport Data_t_Tag
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.bar cimport BarType
+from nautilus_trader.model.data.book cimport OrderBookDelta
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.enums_c cimport AggressorSide
 from nautilus_trader.model.identifiers cimport TradeId
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
@@ -50,14 +51,16 @@
 
     cdef uint64_t i
     for i in range(0, data.len):
         if ptr[i].tag == Data_t_Tag.TRADE:
             ticks.append(TradeTick.from_mem_c(ptr[i].trade))
         elif ptr[i].tag == Data_t_Tag.QUOTE:
             ticks.append(QuoteTick.from_mem_c(ptr[i].quote))
+        elif ptr[i].tag == Data_t_Tag.DELTA:
+            ticks.append(OrderBookDelta.from_mem_c(ptr[i].delta))
 
     return ticks
 
 
 def list_from_capsule(capsule) -> list[Data]:
     return capsule_to_data_list(capsule)
 
@@ -78,15 +81,15 @@
     def process(
         self,
         data: pd.DataFrame,
         default_volume: float=1_000_000.0,
         ts_init_delta: int=0,
     ):
         """
-        Process the give tick dataset into Nautilus `QuoteTick` objects.
+        Process the given tick dataset into Nautilus `QuoteTick` objects.
 
         Expects columns ['bid', 'ask'] with 'timestamp' index.
         Note: The 'bid_size' and 'ask_size' columns are optional, will then use
         the `default_volume`.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,9 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""The `portfolio` subpackage provides portfolio management functionality."""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pxd` & `nautilus_trader-1.176.0/nautilus_trader/portfolio/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/portfolio/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pxd` & `nautilus_trader-1.176.0/nautilus_trader/portfolio/portfolio.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pyx` & `nautilus_trader-1.176.0/nautilus_trader/portfolio/portfolio.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -107,15 +107,15 @@
             cache=cache,
             clock=clock,
             log=self._log,
         )
 
         self._venue = None  # Venue for specific portfolio behaviour (Interactive Brokers)
         self._unrealized_pnls: dict[InstrumentId, Money] = {}
-        self._net_positions: dict[InstrumentId, float] = {}
+        self._net_positions: dict[InstrumentId, Decimal] = {}
         self._pending_calcs: set[InstrumentId] = set()
 
         self.analyzer = PortfolioAnalyzer()
 
         # Register default statistics
         self.analyzer.register_statistic(statistics.winner_max.MaxWinner())
         self.analyzer.register_statistic(statistics.winner_avg.AvgWinner())
@@ -746,15 +746,15 @@
 
         cdef dict net_exposures = {}  # type: dict[Currency, float]
 
         cdef:
             Position position
             Instrument instrument
             Price last
-            Currency cost_currency
+            Currency settlement_currency
             double xrate
         for position in positions_open:
             instrument = self._cache.instrument(position.instrument_id)
             if instrument is None:
                 self._log.error(
                     f"Cannot calculate net exposures: "
                     f"no instrument for {position.instrument_id}."
@@ -779,28 +779,28 @@
                 self._log.error(
                     f"Cannot calculate net exposures: "
                     f"insufficient data for {instrument.get_settlement_currency()}/{account.base_currency}."
                 )
                 return None  # Cannot calculate
 
             if account.base_currency is not None:
-                cost_currency = account.base_currency
+                settlement_currency = account.base_currency
             else:
-                cost_currency = instrument.get_settlement_currency()
+                settlement_currency = instrument.get_settlement_currency()
 
             net_exposure = instrument.notional_value(
                 position.quantity,
                 last,
             ).as_f64_c()
-            net_exposure = round(net_exposure * xrate, cost_currency.get_precision())
+            net_exposure = round(net_exposure * xrate, settlement_currency._mem.precision)
 
-            total_net_exposure = net_exposures.get(cost_currency, 0.0)
+            total_net_exposure = net_exposures.get(settlement_currency, 0.0)
             total_net_exposure += net_exposure
 
-            net_exposures[cost_currency] = total_net_exposure
+            net_exposures[settlement_currency] = total_net_exposure
 
         return {k: Money(v, k) for k, v in net_exposures.items()}
 
     cpdef Money unrealized_pnl(self, InstrumentId instrument_id):
         """
         Return the unrealized PnL for the given instrument ID (if found).
 
@@ -1001,22 +1001,22 @@
 
 # -- INTERNAL -------------------------------------------------------------------------------------
 
     cdef object _net_position(self, InstrumentId instrument_id):
         return self._net_positions.get(instrument_id, Decimal(0))
 
     cdef void _update_net_position(self, InstrumentId instrument_id, list positions_open):
-        cdef double net_position = 0.0
+        net_position = Decimal(0)
 
         cdef Position position
         for position in positions_open:
-            net_position += position.signed_qty
+            net_position += position.signed_decimal_qty()
 
-        cdef double existing_position = self._net_positions.get(instrument_id, 0.0)
-        if existing_position is None or existing_position != net_position:
+        existing_position: Decimal = self._net_positions.get(instrument_id, Decimal(0))
+        if existing_position != net_position:
             self._net_positions[instrument_id] = net_position
             self._log.info(f"{instrument_id} net_position={net_position}")
 
     cdef Money _calculate_unrealized_pnl(self, InstrumentId instrument_id):
         cdef Account account = self._cache.account_for_venue(self._venue or instrument_id.venue)
         if account is None:
             self._log.error(
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/risk/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/trading/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/risk/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/risk/__init__.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -8,14 +8,14 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
 """
 The `risk` subpackage groups all risk specific components and tooling.
 
 Included is a `PositionSizer` component which can be used by trading strategies
 to help with risk management through position sizing.
+
 """
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/risk/engine.pxd` & `nautilus_trader-1.176.0/nautilus_trader/risk/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/risk/engine.pyx` & `nautilus_trader-1.176.0/nautilus_trader/risk/engine.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -790,15 +790,15 @@
             return
 
         if order.status_c() != OrderStatus.INITIALIZED:
             # Already denied or duplicated (INITIALIZED -> DENIED only valid state transition)
             return
 
         if not self._cache.order_exists(order.client_order_id):
-            self._cache.add_order(order, position_id=None)
+            self._cache.add_order(order)
 
         # Generate event
         cdef OrderDenied denied = OrderDenied(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/risk/sizing.pyx` & `nautilus_trader-1.176.0/nautilus_trader/risk/sizing.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_trader/serialization/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -8,7 +8,15 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
+"""
+The `serialization` subpackage groups all serialization components and serializer
+implementations.
+
+Base classes are defined which can allow for other serialization implementations beside
+the built-in specification serializers.
+
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/base.pxd`

 * *Files 26% similar despite different names*

```diff
@@ -9,13 +9,14 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-"""
-The `serialization` subpackage groups all serialization components and serializer implementations.
+cdef dict _OBJECT_TO_DICT_MAP
+cdef dict _OBJECT_FROM_DICT_MAP
 
-Base classes are defined which can allow for other serialization implementations
-beside the built-in specification serializers.
-"""
+
+cdef class Serializer:
+    cpdef bytes serialize(self, object obj)
+    cpdef object deserialize(self, bytes obj_bytes)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.pxd` & `nautilus_trader-1.176.0/nautilus_core/persistence/src/wranglers/mod.rs`

 * *Files 24% similar despite different names*

```diff
@@ -1,14 +1,19 @@
-# -------------------------------------------------------------------------------------------------
-#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-#  https://nautechsystems.io
-#
-#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-#  You may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-# -------------------------------------------------------------------------------------------------
+// -------------------------------------------------------------------------------------------------
+//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+//  https://nautechsystems.io
+//
+//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+//  You may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+// -------------------------------------------------------------------------------------------------
+
+pub mod bar;
+pub mod delta;
+pub mod quote;
+pub mod trade;
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/instruments.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,8 +9,13 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.serialization.arrow import implementations  # noqa: F401
+from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.serialization.arrow.serializer import register_parquet
+
+
+for cls in Instrument.__subclasses__():
+    register_parquet(cls, partition_keys=())
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/__init__.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/account_state.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/account_state.py`

 * *Files 0% similar despite different names*

```diff
@@ -87,15 +87,15 @@
                 "currency": v["balance_currency"],
             },
         )
 
     margins = []
     for v in values:
         initial = v.get("margin_initial")
-        if pd.isnull(initial):
+        if pd.isna(initial):
             continue
         margins.append(
             {
                 "initial": initial,
                 "maintenance": v["margin_maintenance"],
                 "currency": v["margin_currency"],
                 "instrument_id": v["margin_instrument_id"],
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/bar.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/msgpack/serializer.pxd`

 * *Files 21% similar despite different names*

```diff
@@ -9,28 +9,15 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.data import Bar
-from nautilus_trader.serialization.arrow.serializer import register_parquet
+from nautilus_trader.serialization.base cimport Serializer
 
 
-def serialize(bar: Bar):
-    data = bar.to_dict(bar)
-    data["instrument_id"] = bar.bar_type.instrument_id.value
-    return data
-
-
-def deserialize(data: dict) -> Bar:
-    ignore = ("instrument_id",)
-    bar = Bar.from_dict({k: v for k, v in data.items() if k not in ignore})
-    return bar
-
-
-register_parquet(
-    Bar,
-    serializer=serialize,
-    deserializer=deserialize,
-)
+cdef class MsgPackSerializer(Serializer):
+    cdef readonly bint timestamps_as_str
+    """If the serializer converts timestamp `int64_t` to integer strings.\n\n:returns: `bool`"""
+    cdef readonly bint timestamps_as_iso8601
+    """If the serializer converts timestamp `int64_t` to ISO 8601 strings.\n\n:returns: `bool`"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/instruments.py` & `nautilus_trader-1.176.0/nautilus_trader/trading/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -8,14 +8,15 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
+"""
+The `trading` subpackage groups all trading domain specific components and tooling.
 
-from nautilus_trader.model.instruments import Instrument
-from nautilus_trader.serialization.arrow.serializer import register_parquet
+This is a top-level package where the majority of users will interface with the
+framework. Custom trading strategies can be implemented by inheriting from the
+`Strategy` base class.
 
-
-for cls in Instrument.__subclasses__():
-    register_parquet(cls, partition_keys=())
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_book.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py`

 * *Files 3% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 
 from nautilus_trader.model.data import OrderBookDelta
 from nautilus_trader.model.data import OrderBookDeltas
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
-def _parse_delta(delta: OrderBookDelta, cls):
+def _parse_delta(delta: Union[OrderBookDelta, OrderBookDeltas], cls):
     return dict(**OrderBookDelta.to_dict(delta), _type=cls.__name__)
 
 
 def serialize(data: Union[OrderBookDelta, OrderBookDeltas]):
     if isinstance(data, OrderBookDelta):
         result = [_parse_delta(delta=data, cls=OrderBookDelta)]
     elif isinstance(data, OrderBookDeltas):
@@ -55,15 +55,18 @@
 
     # bids = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "BUY"]
     # asks = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "SELL"]
 
     deltas = [OrderBookDelta.clear(instrument_id, ts_event, ts_init)]
     deltas += [OrderBookDelta.from_dict(v) for v in values]
 
-    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
+    return OrderBookDeltas(
+        instrument_id=instrument_id,
+        deltas=deltas,
+    )
 
 
 def _build_order_book_deltas(values):
     return OrderBookDeltas(
         instrument_id=InstrumentId.from_str(values[0]["instrument_id"]),
         deltas=[OrderBookDelta.from_dict(v) for v in values],
     )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_events.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/order_events.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/order_book.py`

 * *Files 5% similar despite different names*

```diff
@@ -18,23 +18,23 @@
 
 from nautilus_trader.model.data import OrderBookDelta
 from nautilus_trader.model.data import OrderBookDeltas
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
-def _parse_delta(delta: Union[OrderBookDelta, OrderBookDeltas], cls):
-    return dict(**OrderBookDelta.to_dict(delta), _type=cls.__name__)
+def _parse_delta(delta: OrderBookDelta):
+    return dict(**OrderBookDelta.to_dict(delta))
 
 
 def serialize(data: Union[OrderBookDelta, OrderBookDeltas]):
     if isinstance(data, OrderBookDelta):
-        result = [_parse_delta(delta=data, cls=OrderBookDelta)]
+        result = [_parse_delta(delta=data)]
     elif isinstance(data, OrderBookDeltas):
-        result = [_parse_delta(delta=delta, cls=OrderBookDeltas) for delta in data.deltas]
+        result = [_parse_delta(delta=delta) for delta in data.deltas]
     else:  # pragma: no cover (design-time error)
         raise TypeError(f"invalid order book data, was {type(data)}")
     # Add a "last" message to let downstream consumers know the end of this group of messages
     if result:
         result[-1]["_last"] = True
     return result
 
@@ -55,18 +55,15 @@
 
     # bids = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "BUY"]
     # asks = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "SELL"]
 
     deltas = [OrderBookDelta.clear(instrument_id, ts_event, ts_init)]
     deltas += [OrderBookDelta.from_dict(v) for v in values]
 
-    return OrderBookDeltas(
-        instrument_id=instrument_id,
-        deltas=deltas,
-    )
+    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 def _build_order_book_deltas(values):
     return OrderBookDeltas(
         instrument_id=InstrumentId.from_str(values[0]["instrument_id"]),
         deltas=[OrderBookDelta.from_dict(v) for v in values],
     )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/position_events.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/implementations/position_events.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/schema.py`

 * *Files 0% similar despite different names*

```diff
@@ -54,25 +54,22 @@
 from nautilus_trader.model.instruments import OptionsContract
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
 NAUTILUS_PARQUET_SCHEMA = {
     OrderBookDelta: pa.schema(
         {
-            "instrument_id": pa.dictionary(pa.int64(), pa.string()),
+            "action": pa.uint8(),
+            "side": pa.uint8(),
+            "price": pa.int64(),
+            "size": pa.uint64(),
+            "order_id": pa.uint64(),
+            "flags": pa.uint8(),
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
-            "action": pa.string(),
-            "side": pa.string(),
-            "price": pa.float64(),
-            "size": pa.float64(),
-            "order_id": pa.string(),
-            # Track grouped OrderBookDeltas
-            "_type": pa.dictionary(pa.int8(), pa.string()),
-            "_last": pa.bool_(),
         },
         metadata={"type": "OrderBookDelta"},
     ),
     Ticker: pa.schema(
         {
             "instrument_id": pa.dictionary(pa.int64(), pa.string()),
             "ts_event": pa.uint64(),
@@ -536,15 +533,15 @@
             "ts_init": pa.uint64(),
         },
         metadata={"type": "BettingInstrument"},
     ),
     CurrencyPair: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
-            "native_symbol": pa.string(),
+            "raw_symbol": pa.string(),
             "base_currency": pa.dictionary(pa.int16(), pa.string()),
             "quote_currency": pa.dictionary(pa.int16(), pa.string()),
             "price_precision": pa.uint8(),
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
             "lot_size": pa.dictionary(pa.int16(), pa.string()),
@@ -562,15 +559,15 @@
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     CryptoPerpetual: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
-            "native_symbol": pa.string(),
+            "raw_symbol": pa.string(),
             "base_currency": pa.dictionary(pa.int16(), pa.string()),
             "quote_currency": pa.dictionary(pa.int16(), pa.string()),
             "settlement_currency": pa.dictionary(pa.int16(), pa.string()),
             "is_inverse": pa.bool_(),
             "price_precision": pa.uint8(),
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
@@ -589,15 +586,15 @@
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     CryptoFuture: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
-            "native_symbol": pa.string(),
+            "raw_symbol": pa.string(),
             "underlying": pa.dictionary(pa.int16(), pa.string()),
             "quote_currency": pa.dictionary(pa.int16(), pa.string()),
             "settlement_currency": pa.dictionary(pa.int16(), pa.string()),
             "expiry_date": pa.dictionary(pa.int16(), pa.string()),
             "price_precision": pa.uint8(),
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
@@ -616,15 +613,15 @@
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     Equity: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
-            "native_symbol": pa.string(),
+            "raw_symbol": pa.string(),
             "currency": pa.dictionary(pa.int16(), pa.string()),
             "price_precision": pa.uint8(),
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
             "multiplier": pa.dictionary(pa.int16(), pa.string()),
             "lot_size": pa.dictionary(pa.int16(), pa.string()),
@@ -636,15 +633,15 @@
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     FuturesContract: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
-            "native_symbol": pa.string(),
+            "raw_symbol": pa.string(),
             "underlying": pa.dictionary(pa.int16(), pa.string()),
             "asset_class": pa.dictionary(pa.int8(), pa.string()),
             "currency": pa.dictionary(pa.int16(), pa.string()),
             "price_precision": pa.uint8(),
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
@@ -654,15 +651,15 @@
             "ts_event": pa.uint64(),
             "ts_init": pa.uint64(),
         },
     ),
     OptionsContract: pa.schema(
         {
             "id": pa.dictionary(pa.int64(), pa.string()),
-            "native_symbol": pa.string(),
+            "raw_symbol": pa.string(),
             "underlying": pa.dictionary(pa.int16(), pa.string()),
             "asset_class": pa.dictionary(pa.int8(), pa.string()),
             "currency": pa.dictionary(pa.int16(), pa.string()),
             "price_precision": pa.uint8(),
             "size_precision": pa.uint8(),
             "price_increment": pa.dictionary(pa.int16(), pa.string()),
             "size_increment": pa.dictionary(pa.int16(), pa.string()),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema_v2.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/schema_v2.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/serializer.pyx` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/serializer.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/util.py` & `nautilus_trader-1.176.0/nautilus_trader/serialization/arrow/util.py`

 * *Files 0% similar despite different names*

```diff
@@ -41,14 +41,15 @@
 
 def dict_of_lists_to_list_of_dicts(dict_lists: dict[Any, list]) -> list[dict]:
     """
     Convert a dictionary of lists into a list of dictionaries.
 
     >>> dict_of_lists_to_list_of_dicts({'a': [1, 2], 'b': [3, 4]})
     [{'a': 1, 'b': 3}, {'a': 2, 'b': 4}]
+
     """
     return [dict(zip(dict_lists, t)) for t in zip(*dict_lists.values())]
 
 
 def maybe_list(obj):
     if isinstance(obj, dict):
         return [obj]
@@ -63,14 +64,15 @@
     Check partition columns.
 
     When writing a parquet dataset, parquet uses the values in `partition_columns`
     as part of the filename. The values in `df` could potentially contain illegal
     characters. This function generates a mapping of {illegal: legal} that is
     used to "clean" the values before they are written to the filename (and also
     saving this mapping for reversing the process on reload).
+
     """
     if partition_columns:
         missing = [c for c in partition_columns if c not in df.columns]
         assert (
             not missing
         ), f"Missing `partition_columns`: {missing} in dataframe columns: {df.columns}"
 
@@ -98,14 +100,15 @@
 def clean_partition_cols(df: pd.DataFrame, mappings: dict[str, dict[str, str]]):
     """
     Clean partition columns.
 
     The values in `partition_cols` may have characters that are illegal in
     filenames. Strip them out and return a dataframe we can write into a parquet
     file.
+
     """
     for col, val_map in mappings.items():
         df[col] = df[col].map(val_map)
     return df
 
 
 def clean_key(s: str):
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/base.pyx` & `nautilus_trader-1.176.0/nautilus_trader/serialization/base.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -54,14 +54,15 @@
 from nautilus_trader.model.instruments.betting cimport BettingInstrument
 from nautilus_trader.model.instruments.crypto_future cimport CryptoFuture
 from nautilus_trader.model.instruments.crypto_perpetual cimport CryptoPerpetual
 from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
 from nautilus_trader.model.instruments.equity cimport Equity
 from nautilus_trader.model.instruments.futures_contract cimport FuturesContract
 from nautilus_trader.model.instruments.options_contract cimport OptionsContract
+from nautilus_trader.model.instruments.synthetic cimport SyntheticInstrument
 
 
 # Default mappings for Nautilus objects
 _OBJECT_TO_DICT_MAP: dict[str, Callable[[None], dict]] = {
     CancelOrder.__name__: CancelOrder.to_dict_c,
     SubmitOrder.__name__: SubmitOrder.to_dict_c,
     SubmitOrderList.__name__: SubmitOrderList.to_dict_c,
@@ -83,14 +84,15 @@
     OrderTriggered.__name__: OrderTriggered.to_dict_c,
     OrderModifyRejected.__name__: OrderModifyRejected.to_dict_c,
     OrderUpdated.__name__: OrderUpdated.to_dict_c,
     PositionOpened.__name__: PositionOpened.to_dict_c,
     PositionChanged.__name__: PositionChanged.to_dict_c,
     PositionClosed.__name__: PositionClosed.to_dict_c,
     Instrument.__name__: Instrument.base_to_dict_c,
+    SyntheticInstrument.__name__: SyntheticInstrument.to_dict_c,
     BettingInstrument.__name__: BettingInstrument.to_dict_c,
     Equity.__name__: Equity.to_dict_c,
     FuturesContract.__name__: FuturesContract.to_dict_c,
     OptionsContract.__name__: OptionsContract.to_dict_c,
     CurrencyPair.__name__: CurrencyPair.to_dict_c,
     CryptoPerpetual.__name__: CryptoPerpetual.to_dict_c,
     CryptoFuture.__name__: CryptoFuture.to_dict_c,
@@ -129,14 +131,15 @@
     OrderTriggered.__name__: OrderTriggered.from_dict_c,
     OrderModifyRejected.__name__: OrderModifyRejected.from_dict_c,
     OrderUpdated.__name__: OrderUpdated.from_dict_c,
     PositionOpened.__name__: PositionOpened.from_dict_c,
     PositionChanged.__name__: PositionChanged.from_dict_c,
     PositionClosed.__name__: PositionClosed.from_dict_c,
     Instrument.__name__: Instrument.base_from_dict_c,
+    SyntheticInstrument.__name__: SyntheticInstrument.from_dict_c,
     BettingInstrument.__name__: BettingInstrument.from_dict_c,
     Equity.__name__: Equity.from_dict_c,
     FuturesContract.__name__: FuturesContract.from_dict_c,
     OptionsContract.__name__: OptionsContract.from_dict_c,
     CurrencyPair.__name__: CurrencyPair.from_dict_c,
     CryptoPerpetual.__name__: CryptoPerpetual.from_dict_c,
     CryptoFuture.__name__: CryptoFuture.from_dict_c,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/serializer.pxd` & `nautilus_trader-1.176.0/nautilus_trader/infrastructure/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -8,14 +8,14 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
+"""
+The `infrastructure` subpackage provides technology specific infrastructure
+implementations.
 
-from nautilus_trader.serialization.base cimport Serializer
+Out of the box a `Redis <https://redis.io/>`_ backed cache is implemented.
 
-
-cdef class MsgPackSerializer(Serializer):
-    cdef readonly bint timestamps_as_str
-    """If the serializer converts timestamp int64_t to str.\n\n:returns: `bool`"""
+"""
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/system/kernel.py` & `nautilus_trader-1.176.0/nautilus_trader/system/kernel.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,23 +9,25 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from __future__ import annotations
+
 import asyncio
 import concurrent.futures
 import platform
 import signal
 import socket
 import time
 from concurrent.futures import ThreadPoolExecutor
 from datetime import timedelta
-from typing import Callable, Optional
+from typing import Callable
 
 import msgspec
 
 from nautilus_trader.cache.base import CacheFacade
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common import Environment
 from nautilus_trader.common.actor import Actor
@@ -100,22 +102,23 @@
 
     Raises
     ------
     ValueError
         If `name` is not a valid string.
     TypeError
         If any configuration object is not of the expected type.
+
     """
 
     def __init__(  # noqa (too complex)
         self,
         name: str,
         config: NautilusKernelConfig,
-        loop: Optional[asyncio.AbstractEventLoop] = None,
-        loop_sig_callback: Optional[Callable] = None,
+        loop: asyncio.AbstractEventLoop | None = None,
+        loop_sig_callback: Callable | None = None,
     ) -> None:
         PyCondition.valid_string(name, "name")
         PyCondition.type(config, NautilusKernelConfig, "config")
 
         self._config: NautilusKernelConfig = config
         self._environment: Environment = config.environment
         self._load_state: bool = config.load_state
@@ -167,15 +170,15 @@
             logger=self._logger,
         )
 
         nautilus_header(self._log)
         self.log.info("Building system kernel...")
 
         # Setup loop (if sandbox live)
-        self._loop: Optional[asyncio.AbstractEventLoop] = None
+        self._loop: asyncio.AbstractEventLoop | None = None
         if self._environment != Environment.BACKTEST:
             self._loop = loop or asyncio.get_running_loop()
             if loop is not None:
                 self._executor = concurrent.futures.ThreadPoolExecutor()
                 self._loop.set_default_executor(self.executor)
                 self._loop.set_debug(config.loop_debug)
                 self._loop_sig_callback = loop_sig_callback
@@ -186,15 +189,18 @@
 
         if config.cache_database is None or config.cache_database.type == "in-memory":
             cache_db = None
         elif config.cache_database.type == "redis":
             cache_db = RedisCacheDatabase(
                 trader_id=self._trader_id,
                 logger=self._logger,
-                serializer=MsgPackSerializer(timestamps_as_str=True),
+                serializer=MsgPackSerializer(
+                    timestamps_as_str=True,  # Hardcoded for now
+                    timestamps_as_iso8601=config.cache_database.timestamps_as_iso8601,
+                ),
                 config=config.cache_database,
             )
         else:
             raise ValueError(
                 "The `cache_db_config.type` is unrecognized. "
                 "Use one of {{'in-memory', 'redis'}}.",
             )
@@ -314,20 +320,20 @@
             loop=self._loop,
         )
 
         if self._load_state:
             self._trader.load()
 
         # Setup stream writer
-        self._writer: Optional[StreamingFeatherWriter] = None
+        self._writer: StreamingFeatherWriter | None = None
         if config.streaming:
             self._setup_streaming(config=config.streaming)
 
         # Setup data catalog
-        self._catalog: Optional[ParquetDataCatalog] = None
+        self._catalog: ParquetDataCatalog | None = None
         if config.catalog:
             self._catalog = ParquetDataCatalog(
                 path=config.catalog.path,
                 fs_protocol=config.catalog.fs_protocol,
                 fs_storage_options=config.catalog.fs_storage_options,
             )
             self._data_engine.register_catalog(
@@ -419,27 +425,27 @@
         -------
         AbstractEventLoop
 
         """
         return self._loop or asyncio.get_running_loop()
 
     @property
-    def loop_sig_callback(self) -> Optional[Callable]:
+    def loop_sig_callback(self) -> Callable | None:
         """
         Return the kernels signal handling callback.
 
         Returns
         -------
         Callable or ``None``
 
         """
         return self._loop_sig_callback
 
     @property
-    def executor(self) -> Optional[ThreadPoolExecutor]:
+    def executor(self) -> ThreadPoolExecutor | None:
         """
         Return the kernels default executor.
 
         Returns
         -------
         ThreadPoolExecutor or ``None``
 
@@ -659,40 +665,43 @@
         -------
         Trader
 
         """
         return self._trader
 
     @property
-    def writer(self) -> Optional[StreamingFeatherWriter]:
+    def writer(self) -> StreamingFeatherWriter | None:
         """
         Return the kernels writer.
 
         Returns
         -------
         StreamingFeatherWriter or ``None``
 
         """
         return self._writer
 
     @property
-    def catalog(self) -> Optional[ParquetDataCatalog]:
+    def catalog(self) -> ParquetDataCatalog | None:
         """
         Return the kernels data catalog.
 
         Returns
         -------
         ParquetDataCatalog or ``None``
 
         """
         return self._catalog
 
     async def start(self) -> None:
         self._log.info("STARTING...")
 
+        if self._config.cache_database is not None and self._config.cache_database.flush_on_start:
+            self._cache.flush_db()
+
         # Start system
         self._data_engine.start()
         self._risk_engine.start()
         self._exec_engine.start()
 
         # Connect all clients
         self._data_engine.connect()
@@ -793,16 +802,17 @@
 
         return True  # Portfolio initialized
 
     def dispose(self) -> None:
         """
         Dispose of the kernel releasing system resources.
 
-        Calling this method multiple times has the same effect as calling it once (it is idempotent).
-        Once called, it cannot be reversed, and no other methods should be called on this instance.
+        Calling this method multiple times has the same effect as calling it once (it is
+        idempotent). Once called, it cannot be reversed, and no other methods should be
+        called on this instance.
 
         """
         # Stop all engines
         if self.data_engine.is_running:
             self.data_engine.stop()
         if self.risk_engine.is_running:
             self.risk_engine.stop()
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/__init__.py` & `nautilus_trader-1.176.0/nautilus_core/model/src/orders/mod.rs`

 * *Files 22% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-# -------------------------------------------------------------------------------------------------
-#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-#  https://nautechsystems.io
-#
-#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-#  You may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-# -------------------------------------------------------------------------------------------------
+// -------------------------------------------------------------------------------------------------
+//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+//  https://nautechsystems.io
+//
+//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+//  You may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+// -------------------------------------------------------------------------------------------------
 
-"""
-The test kit contains test doubles and helpers to support the NautilusTrader
-test suite, as well as supporting testing for downstream projects and packages.
-"""
+#![allow(dead_code)]
+
+pub mod base;
+pub mod limit;
+pub mod limit_if_touched;
+pub mod market;
+pub mod market_if_touched;
+pub mod market_to_limit;
+pub mod stop_limit;
+pub mod trailing_stop_limit;
+pub mod trailing_stop_market;
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/functions.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/functions.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/actors.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/actors.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/cache_database.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/cache_database.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,135 +14,141 @@
 # -------------------------------------------------------------------------------------------------
 
 from typing import Optional
 
 from nautilus_trader.accounting.accounts.base import Account
 from nautilus_trader.cache.database import CacheDatabase
 from nautilus_trader.common.logging import Logger
-from nautilus_trader.execution.messages import SubmitOrder
-from nautilus_trader.execution.messages import SubmitOrderList
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.identifiers import AccountId
+from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import OrderListId
 from nautilus_trader.model.identifiers import PositionId
 from nautilus_trader.model.identifiers import StrategyId
 from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.model.instruments import SyntheticInstrument
 from nautilus_trader.model.orders import Order
 from nautilus_trader.model.position import Position
 from nautilus_trader.trading.strategy import Strategy
 
 
 class MockCacheDatabase(CacheDatabase):
     """
     Provides a mock cache database for testing.
 
     Parameters
     ----------
     logger : Logger
         The logger for the database.
+
     """
 
     def __init__(self, logger: Logger):
         super().__init__(logger)
 
         self.general: dict[str, bytes] = {}
         self.currencies: dict[str, Currency] = {}
         self.instruments: dict[InstrumentId, Instrument] = {}
+        self.synthetics: dict[InstrumentId, SyntheticInstrument] = {}
         self.accounts: dict[AccountId, Account] = {}
         self.orders: dict[ClientOrderId, Order] = {}
         self.positions: dict[PositionId, Position] = {}
-        self.submit_order_commands: dict[ClientOrderId, SubmitOrder] = {}
-        self.submit_order_list_commands: dict[OrderListId, SubmitOrderList] = {}
+        self._index_order_position: dict[ClientOrderId, PositionId] = {}
+        self._index_order_client: dict[ClientOrderId, ClientId] = {}
 
     def flush(self) -> None:
         self.general.clear()
         self.currencies.clear()
         self.instruments.clear()
+        self.synthetics.clear()
         self.accounts.clear()
         self.orders.clear()
         self.positions.clear()
-        self.submit_order_commands.clear()
-        self.submit_order_list_commands.clear()
+        self._index_order_position.clear()
+        self._index_order_client.clear()
 
     def load(self) -> dict:
         return self.general.copy()
 
     def load_currencies(self) -> dict:
         return self.currencies.copy()
 
     def load_instruments(self) -> dict:
         return self.instruments.copy()
 
+    def load_synthetics(self) -> dict:
+        return self.synthetics.copy()
+
     def load_accounts(self) -> dict:
         return self.accounts.copy()
 
     def load_orders(self) -> dict:
         return self.orders.copy()
 
     def load_positions(self) -> dict:
         return self.positions.copy()
 
-    def load_submit_order_commands(self) -> dict:
-        return self.submit_order_commands.copy()
-
-    def load_submit_order_list_commands(self) -> dict:
-        return self.submit_order_list_commands.copy()
-
     def load_currency(self, code: str) -> Currency:
         return self.currencies.get(code)
 
-    def load_instrument(self, instrument_id: InstrumentId) -> Optional[InstrumentId]:
+    def load_instrument(self, instrument_id: InstrumentId) -> Optional[Instrument]:
         return self.instruments.get(instrument_id)
 
+    def load_synthetic(self, instrument_id: InstrumentId) -> Optional[SyntheticInstrument]:
+        return self.synthetics.get(instrument_id)
+
     def load_account(self, account_id: AccountId) -> Optional[Account]:
         return self.accounts.get(account_id)
 
     def load_order(self, client_order_id: ClientOrderId) -> Optional[Order]:
         return self.orders.get(client_order_id)
 
+    def load_index_order_position(self) -> dict[ClientOrderId, PositionId]:
+        return self._index_order_position
+
+    def load_index_order_client(self) -> dict[ClientOrderId, ClientId]:
+        return self._index_order_client
+
     def load_position(self, position_id: PositionId) -> Optional[Position]:
         return self.positions.get(position_id)
 
     def load_strategy(self, strategy_id: StrategyId) -> dict:
         return {}
 
     def delete_strategy(self, strategy_id: StrategyId) -> None:
         pass
 
-    def load_submit_order_command(self, client_order_id: ClientOrderId) -> Optional[SubmitOrder]:
-        return self.submit_order_commands.get(client_order_id)
-
-    def load_submit_order_list_command(
-        self,
-        order_list_id: OrderListId,
-    ) -> Optional[SubmitOrderList]:
-        return self.submit_order_commands.get(order_list_id)
-
     def add_currency(self, currency: Currency) -> None:
         self.currencies[currency.code] = currency
 
     def add_instrument(self, instrument: Instrument) -> None:
         self.instruments[instrument.id] = instrument
 
+    def add_synthetic(self, synthetic: SyntheticInstrument) -> None:
+        self.synthetics[synthetic.id] = synthetic
+
     def add_account(self, account: Account) -> None:
         self.accounts[account.id] = account
 
-    def add_order(self, order: Order) -> None:
+    def add_order(
+        self,
+        order: Order,
+        position_id: Optional[PositionId] = None,
+        client_id: Optional[ClientId] = None,
+    ) -> None:
         self.orders[order.client_order_id] = order
+        self._index_order_position[order.client_order_id] = position_id
+        self._index_order_client[order.client_order_id] = client_id
 
     def add_position(self, position: Position) -> None:
         self.positions[position.id] = position
 
-    def add_submit_order_command(self, command: SubmitOrder) -> None:
-        self.submit_order_commands[command.order.client_order_id] = command
-
-    def add_submit_order_list_command(self, command: SubmitOrderList) -> None:
-        self.submit_order_list_commands[command.order_list.id] = command
+    def index_order_position(self, client_order_id: ClientOrderId, position_id: PositionId) -> None:
+        self._index_order_position[client_order_id] = position_id
 
     def update_account(self, event: Account) -> None:
         pass  # Would persist the event
 
     def update_order(self, order: Order) -> None:
         pass  # Would persist the event
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/data.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/data.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,15 +36,17 @@
 
 class MockReader(Reader):
     def parse(self, block: bytes) -> Generator:
         yield block
 
 
 class NewsEventData(NewsEvent):
-    """Generic data NewsEvent"""
+    """
+    Generic data NewsEvent.
+    """
 
 
 def data_catalog_setup(protocol, path=None) -> ParquetDataCatalog:
     if protocol not in ("memory", "file"):
         raise ValueError("`protocol` should only be one of `memory` or `file` for testing")
 
     clear_singleton_instances(ParquetDataCatalog)
@@ -63,22 +65,22 @@
 
     return catalog
 
 
 def aud_usd_data_loader(catalog: ParquetDataCatalog):
     from nautilus_trader.test_kit.providers import TestInstrumentProvider
     from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
-    from tests.unit_tests.backtest.test_backtest_config import TEST_DATA_DIR
+    from tests.unit_tests.backtest.test_config import TEST_DATA_DIR
 
     venue = Venue("SIM")
     instrument = TestInstrumentProvider.default_fx_ccy("AUD/USD", venue=venue)
 
     def parse_csv_tick(df, instrument_id):
         yield instrument
-        for r in df.values:
+        for r in df.to_numpy():
             ts = pd.Timestamp(r[0], tz="UTC").value
             tick = QuoteTick(
                 instrument_id=instrument_id,
                 bid=Price(r[1], 5),
                 ask=Price(r[2], 5),
                 bid_size=Quantity.from_int(1_000_000),
                 ask_size=Quantity.from_int(1_000_000),
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/engines.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/engines.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,15 +15,17 @@
 
 from nautilus_trader.live.data_engine import LiveDataEngine
 from nautilus_trader.live.execution_engine import LiveExecutionEngine
 from nautilus_trader.live.risk_engine import LiveRiskEngine
 
 
 class MockLiveDataEngine(LiveDataEngine):
-    """Provides a mock live data engine for testing."""
+    """
+    Provides a mock live data engine for testing.
+    """
 
     def __init__(
         self,
         loop,
         msgbus,
         cache,
         clock,
@@ -50,15 +52,17 @@
         self.events.append(event)
 
     def receive(self, response):
         self.responses.append(response)
 
 
 class MockLiveExecutionEngine(LiveExecutionEngine):
-    """Provides a mock live execution engine for testing."""
+    """
+    Provides a mock live execution engine for testing.
+    """
 
     def __init__(
         self,
         loop,
         msgbus,
         cache,
         clock,
@@ -81,15 +85,17 @@
         self.commands.append(command)
 
     def process(self, event):
         self.events.append(event)
 
 
 class MockLiveRiskEngine(LiveRiskEngine):
-    """Provides a mock live risk engine for testing."""
+    """
+    Provides a mock live risk engine for testing.
+    """
 
     def __init__(
         self,
         loop,
         portfolio,
         msgbus,
         cache,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/exec_clients.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/exec_clients.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,14 +51,15 @@
         The message bus for the client.
     cache : Cache
         The cache for the client
     clock : Clock
         The clock for the client.
     logger : Logger
         The logger for the client.
+
     """
 
     def __init__(
         self,
         client_id,
         venue,
         account_type,
@@ -168,14 +169,15 @@
         The message bus for the client.
     cache : Cache
         The cache for the client.
     clock : Clock
         The clock for the client.
     logger : Logger
         The logger for the client.
+
     """
 
     def __init__(
         self,
         loop,
         client_id,
         venue,
@@ -292,15 +294,15 @@
         if current_frame:
             self.calls.append(current_frame.f_code.co_name)
 
         return self._order_status_reports.get(venue_order_id)
 
     async def generate_order_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
         open_only: bool = False,
     ) -> list[OrderStatusReport]:
         current_frame = inspect.currentframe()
         if current_frame:
             self.calls.append(current_frame.f_code.co_name)
@@ -318,16 +320,16 @@
         if end is not None:
             reports = [r for r in reports if r.ts_accepted <= end]
 
         return reports
 
     async def generate_trade_reports(
         self,
-        instrument_id: InstrumentId = None,
-        venue_order_id: VenueOrderId = None,
+        instrument_id: Optional[InstrumentId] = None,
+        venue_order_id: Optional[VenueOrderId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[TradeReport]:
         current_frame = inspect.currentframe()
         if current_frame:
             self.calls.append(current_frame.f_code.co_name)
 
@@ -347,15 +349,15 @@
         if end is not None:
             trades = [t for t in trades if t.ts_event <= end]
 
         return trades
 
     async def generate_position_status_reports(
         self,
-        instrument_id: InstrumentId = None,
+        instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[PositionStatusReport]:
         current_frame = inspect.currentframe()
         if current_frame:
             self.calls.append(current_frame.f_code.co_name)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/strategies.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/mocks/strategies.py`

 * *Files 0% similar despite different names*

```diff
@@ -27,14 +27,15 @@
     """
     Provides a mock trading strategy for testing.
 
     Parameters
     ----------
     bar_type : BarType
         The bar type for the strategy.
+
     """
 
     def __init__(self, bar_type: BarType) -> None:
         super().__init__()
 
         self.store: list[object] = []
         self.bar_type = bar_type
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/performance.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/performance.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/providers.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/providers.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,43 +10,54 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import pathlib
+import random
 from datetime import date
 from decimal import Decimal
-from typing import Optional
+from typing import Any, Optional
 
 import fsspec
+import numpy as np
 import pandas as pd
 from fsspec.implementations.local import LocalFileSystem
 from pandas.io.parsers.readers import TextFileReader
 
-from nautilus_trader.adapters.betfair.common import BETFAIR_VENUE
+from nautilus_trader.adapters.betfair.common import BETFAIR_TICK_SCHEME
+from nautilus_trader.adapters.betfair.constants import BETFAIR_VENUE
 from nautilus_trader.core.correctness import PyCondition
+from nautilus_trader.core.datetime import dt_to_unix_nanos
+from nautilus_trader.core.datetime import secs_to_nanos
+from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.model.currencies import ADA
 from nautilus_trader.model.currencies import BTC
 from nautilus_trader.model.currencies import ETH
 from nautilus_trader.model.currencies import USD
 from nautilus_trader.model.currencies import USDT
 from nautilus_trader.model.currency import Currency
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.enums import AggressorSide
 from nautilus_trader.model.enums import AssetClass
 from nautilus_trader.model.enums import OptionKind
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Symbol
+from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.instruments import BettingInstrument
 from nautilus_trader.model.instruments import CryptoFuture
 from nautilus_trader.model.instruments import CryptoPerpetual
 from nautilus_trader.model.instruments import CurrencyPair
 from nautilus_trader.model.instruments import Equity
 from nautilus_trader.model.instruments import FuturesContract
 from nautilus_trader.model.instruments import OptionsContract
+from nautilus_trader.model.instruments import SyntheticInstrument
 from nautilus_trader.model.objects import Money
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 from nautilus_trader.persistence.loaders import CSVBarDataLoader
 from nautilus_trader.persistence.loaders import CSVTickDataLoader
 from nautilus_trader.persistence.loaders import ParquetBarDataLoader
 from nautilus_trader.persistence.loaders import ParquetTickDataLoader
@@ -68,15 +79,15 @@
 
         """
         return CurrencyPair(
             instrument_id=InstrumentId(
                 symbol=Symbol("ADABTC"),
                 venue=Venue("BINANCE"),
             ),
-            native_symbol=Symbol("ADABTC"),
+            raw_symbol=Symbol("ADABTC"),
             base_currency=ADA,
             quote_currency=BTC,
             price_precision=8,
             size_precision=8,
             price_increment=Price(1e-08, precision=8),
             size_increment=Quantity(1e-08, precision=8),
             lot_size=None,
@@ -105,15 +116,15 @@
 
         """
         return CurrencyPair(
             instrument_id=InstrumentId(
                 symbol=Symbol("BTCUSDT"),
                 venue=Venue("BINANCE"),
             ),
-            native_symbol=Symbol("BTCUSDT"),
+            raw_symbol=Symbol("BTCUSDT"),
             base_currency=BTC,
             quote_currency=USDT,
             price_precision=2,
             size_precision=6,
             price_increment=Price(1e-02, precision=2),
             size_increment=Quantity(1e-06, precision=6),
             lot_size=None,
@@ -142,15 +153,15 @@
 
         """
         return CurrencyPair(
             instrument_id=InstrumentId(
                 symbol=Symbol("ETHUSDT"),
                 venue=Venue("BINANCE"),
             ),
-            native_symbol=Symbol("ETHUSDT"),
+            raw_symbol=Symbol("ETHUSDT"),
             base_currency=ETH,
             quote_currency=USDT,
             price_precision=2,
             size_precision=5,
             price_increment=Price(1e-02, precision=2),
             size_increment=Quantity(1e-05, precision=5),
             lot_size=None,
@@ -179,15 +190,15 @@
 
         """
         return CryptoPerpetual(
             instrument_id=InstrumentId(
                 symbol=Symbol("ETHUSDT-PERP"),
                 venue=Venue("BINANCE"),
             ),
-            native_symbol=Symbol("ETHUSDT"),
+            raw_symbol=Symbol("ETHUSDT"),
             base_currency=ETH,
             quote_currency=USDT,
             settlement_currency=USDT,
             is_inverse=False,
             price_precision=2,
             size_precision=3,
             price_increment=Price.from_str("0.01"),
@@ -224,15 +235,15 @@
         if expiry is None:
             expiry = date(2022, 3, 25)
         return CryptoFuture(
             instrument_id=InstrumentId(
                 symbol=Symbol(f"BTCUSDT_{expiry.strftime('%y%m%d')}"),
                 venue=Venue("BINANCE"),
             ),
-            native_symbol=Symbol("BTCUSDT"),
+            raw_symbol=Symbol("BTCUSDT"),
             underlying=BTC,
             quote_currency=USDT,
             settlement_currency=USDT,
             expiry_date=expiry,
             price_precision=2,
             size_precision=6,
             price_increment=Price(1e-02, precision=2),
@@ -262,15 +273,15 @@
 
         """
         return CryptoPerpetual(
             instrument_id=InstrumentId(
                 symbol=Symbol("BTC/USD"),
                 venue=Venue("BITMEX"),
             ),
-            native_symbol=Symbol("XBTUSD"),
+            raw_symbol=Symbol("XBTUSD"),
             base_currency=BTC,
             quote_currency=USD,
             settlement_currency=BTC,
             is_inverse=True,
             price_precision=1,
             size_precision=0,
             price_increment=Price.from_str("0.5"),
@@ -300,15 +311,15 @@
 
         """
         return CryptoPerpetual(
             instrument_id=InstrumentId(
                 symbol=Symbol("ETH/USD"),
                 venue=Venue("BITMEX"),
             ),
-            native_symbol=Symbol("ETHUSD"),
+            raw_symbol=Symbol("ETHUSD"),
             base_currency=ETH,
             quote_currency=USD,
             settlement_currency=BTC,
             is_inverse=True,
             price_precision=2,
             size_precision=0,
             price_increment=Price.from_str("0.05"),
@@ -324,15 +335,15 @@
             maker_fee=Decimal("-0.00025"),
             taker_fee=Decimal("0.00075"),
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
-    def default_fx_ccy(symbol: str, venue: Venue = None) -> CurrencyPair:
+    def default_fx_ccy(symbol: str, venue: Optional[Venue] = None) -> CurrencyPair:
         """
         Return a default FX currency pair instrument from the given symbol and venue.
 
         Parameters
         ----------
         symbol : str
             The currency pair symbol.
@@ -368,15 +379,15 @@
             tick_scheme_name = "FOREX_3DECIMAL"
         else:
             price_precision = 5
             tick_scheme_name = "FOREX_5DECIMAL"
 
         return CurrencyPair(
             instrument_id=instrument_id,
-            native_symbol=Symbol(symbol),
+            raw_symbol=Symbol(symbol),
             base_currency=Currency.from_str(base_currency),
             quote_currency=Currency.from_str(quote_currency),
             price_precision=price_precision,
             size_precision=0,
             price_increment=Price(1 / 10**price_precision, price_precision),
             size_increment=Quantity.from_int(1),
             lot_size=Quantity.from_str("1000"),
@@ -392,18 +403,18 @@
             taker_fee=Decimal("0.00002"),
             tick_scheme_name=tick_scheme_name,
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
-    def equity(symbol: str = "AAPL", venue: str = "NASDAQ"):
+    def equity(symbol: str = "AAPL", venue: str = "NASDAQ") -> Equity:
         return Equity(
             instrument_id=InstrumentId(symbol=Symbol(symbol), venue=Venue(venue)),
-            native_symbol=Symbol(symbol),
+            raw_symbol=Symbol(symbol),
             currency=USD,
             price_precision=2,
             price_increment=Price.from_str("0.01"),
             multiplier=Quantity.from_int(1),
             lot_size=Quantity.from_int(1),
             isin="US0378331005",
             ts_event=0,
@@ -414,15 +425,15 @@
     def aapl_equity():
         return TestInstrumentProvider.equity(symbol="AAPL", venue="NASDAQ")
 
     @staticmethod
     def es_future() -> FuturesContract:
         return FuturesContract(
             instrument_id=InstrumentId(symbol=Symbol("ESZ21"), venue=Venue("CME")),
-            native_symbol=Symbol("ESZ21"),
+            raw_symbol=Symbol("ESZ21"),
             asset_class=AssetClass.INDEX,
             currency=USD,
             price_precision=2,
             price_increment=Price.from_str("0.01"),
             multiplier=Quantity.from_int(1),
             lot_size=Quantity.from_int(1),
             underlying="ES",
@@ -431,15 +442,15 @@
             ts_init=0,
         )
 
     @staticmethod
     def aapl_option() -> OptionsContract:
         return OptionsContract(
             instrument_id=InstrumentId(symbol=Symbol("AAPL211217C00150000"), venue=Venue("OPRA")),
-            native_symbol=Symbol("AAPL211217C00150000"),
+            raw_symbol=Symbol("AAPL211217C00150000"),
             asset_class=AssetClass.EQUITY,
             currency=USD,
             price_precision=2,
             price_increment=Price.from_str("0.01"),
             multiplier=Quantity.from_int(100),
             lot_size=Quantity.from_int(1),
             underlying="AAPL",
@@ -471,14 +482,15 @@
             market_name="AFC Conference Winner",
             market_start_time=pd.Timestamp("2022-02-07 23:30:00+00:00"),
             market_type="SPECIAL",
             selection_handicap=selection_handicap,
             selection_id=selection_id,
             selection_name="Kansas City Chiefs",
             currency="GBP",
+            tick_scheme_name=BETFAIR_TICK_SCHEME.name,
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
     def betting_instrument_handicap() -> BettingInstrument:
         return BettingInstrument.from_dict(
@@ -502,26 +514,42 @@
                 "selection_handicap": "-5.5",
                 "currency": "AUD",
                 "ts_event": 0,
                 "ts_init": 0,
             },
         )
 
+    @staticmethod
+    def synthetic_instrument() -> SyntheticInstrument:
+        return SyntheticInstrument(
+            symbol=Symbol("BTC-ETH"),
+            price_precision=8,
+            components=[
+                TestInstrumentProvider.btcusdt_binance().id,
+                TestInstrumentProvider.ethusdt_binance().id,
+            ],
+            formula="(BTCUSDT.BINANCE + ETHUSDT.BINANCE) / 2",
+            ts_event=0,
+            ts_init=0,
+        )
+
 
 class TestDataProvider:
     """
-    Provides an API to load data from either the 'test/' directory or the projects GitHub repo.
+    Provides an API to load data from either the 'test/' directory or the projects
+    GitHub repo.
 
     Parameters
     ----------
     branch : str
         The NautilusTrader GitHub branch for the path.
+
     """
 
-    def __init__(self, branch="develop") -> None:
+    def __init__(self, branch: str = "develop") -> None:
         self.fs: Optional[fsspec.AbstractFileSystem] = None
         self.root: Optional[str] = None
         self._determine_filesystem()
         self.branch = branch
 
     @staticmethod
     def _test_data_directory() -> Optional[str]:
@@ -580,7 +608,104 @@
         with fsspec.open(uri) as f:
             return ParquetTickDataLoader.load(file_path=f, timestamp_column=timestamp_column)
 
     def read_parquet_bars(self, path: str) -> pd.DataFrame:
         uri = self._make_uri(path=path)
         with fsspec.open(uri) as f:
             return ParquetBarDataLoader.load(file_path=f)
+
+
+class TestDataGenerator:
+    @staticmethod
+    def simulate_value_diffs(
+        count: int,
+        max_diff: float = 10,
+        prob_increase: float = 0.25,
+        prob_decrease: float = 0.25,
+    ) -> pd.Series:
+        gen = np.random.default_rng()
+
+        def sim():
+            if random.random() <= prob_increase:  # noqa: S311
+                return gen.uniform(0, max_diff)
+            elif random.random() <= prob_decrease:  # noqa: S311
+                return -gen.uniform(0, max_diff)
+            else:
+                return 0
+
+        return pd.Series([sim() for _ in range(count)])
+
+    @staticmethod
+    def generate_time_series_index(
+        start_timestamp: str = "2020-01-01",
+        max_freq: str = "1s",
+        count: int = 100_000,
+    ) -> pd.DatetimeIndex:
+        gen = np.random.default_rng()
+        start = dt_to_unix_nanos(pd.Timestamp(start_timestamp))
+        freq_in_nanos = secs_to_nanos(pd.Timedelta(max_freq).total_seconds())
+        diffs = gen.uniform(0, freq_in_nanos, size=count - 1)
+        srs = pd.Series([start, *diffs.tolist()])
+        return pd.to_datetime(srs.cumsum(), unit="us")
+
+    @staticmethod
+    def generate_time_series(
+        start_timestamp: str = "2020-01-01",
+        start_price: float = 100.0,
+        default_quantity: int = 10,
+        max_freq: str = "1s",
+        count: int = 100_000,
+    ) -> pd.DataFrame:
+        gen = np.random.default_rng()
+        price_diffs = gen.uniform(-1, 1, size=count - 1)
+        prices = pd.Series([start_price, *price_diffs.tolist()]).cumsum()
+
+        quantity_diffs = TestDataGenerator.simulate_value_diffs(count)
+        quantity = pd.Series(default_quantity + quantity_diffs).astype(int)
+
+        index = TestDataGenerator.generate_time_series_index(start_timestamp, max_freq, count)
+        return pd.DataFrame(
+            index=index,
+            data={"price": prices.to_numpy(), "quantity": quantity.to_numpy()},
+        )
+
+    @staticmethod
+    def generate_quote_ticks(
+        instrument_id: str,
+        price_prec: int = 4,
+        quantity_prec: int = 4,
+        **kwargs: Any,
+    ) -> list[QuoteTick]:
+        df: pd.DataFrame = TestDataGenerator.generate_time_series(**kwargs)
+        return [
+            QuoteTick(
+                InstrumentId.from_str(instrument_id),
+                Price(row["price"] + 1, price_prec),
+                Price(row["price"] - 1, price_prec),
+                Quantity(row["quantity"], quantity_prec),
+                Quantity(row["quantity"], quantity_prec),
+                dt_to_unix_nanos(idx),
+                dt_to_unix_nanos(idx),
+            )
+            for idx, row in df.iterrows()
+        ]
+
+    @staticmethod
+    def generate_trade_ticks(
+        instrument_id: str,
+        price_prec: int = 4,
+        quantity_prec: int = 4,
+        **kwargs: Any,
+    ) -> list[TradeTick]:
+        df: pd.DataFrame = TestDataGenerator.generate_time_series(**kwargs)
+        return [
+            TradeTick(
+                InstrumentId.from_str(instrument_id),
+                Price(row["price"], price_prec),
+                Quantity(row["quantity"], quantity_prec),
+                AggressorSide.NO_AGGRESSOR,
+                TradeId(UUID4().value),
+                dt_to_unix_nanos(idx),
+                dt_to_unix_nanos(idx),
+            )
+            for idx, row in df.iterrows()
+        ]
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/commands.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/commands.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/component.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/component.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/config.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/data.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/data.py`

 * *Files 2% similar despite different names*

```diff
@@ -90,25 +90,25 @@
             ts_init=ts_init,
         )
 
     @staticmethod
     def trade_tick(
         instrument: Optional[Instrument] = None,
         price: float = 1.0,
-        quantity: float = 100_000,
+        size: float = 100_000,
         aggressor_side: AggressorSide = AggressorSide.BUYER,
         trade_id: str = "123456",
         ts_event: int = 0,
         ts_init: int = 0,
     ) -> TradeTick:
         inst: Instrument = instrument or TestInstrumentProvider.default_fx_ccy("AUD/USD")
         return TradeTick(
             instrument_id=inst.id,
             price=inst.make_price(price),
-            size=inst.make_qty(quantity),
+            size=inst.make_qty(size),
             aggressor_side=aggressor_side,
             trade_id=TradeId(trade_id),
             ts_event=ts_event,
             ts_init=ts_init,
         )
 
     @staticmethod
@@ -206,15 +206,15 @@
             volume=Quantity.from_int(1_000_000),
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
     def instrument_close() -> InstrumentClose:
-        from nautilus_trader.adapters.betfair.common import BETFAIR_PRICE_PRECISION
+        from nautilus_trader.adapters.betfair.constants import BETFAIR_PRICE_PRECISION
 
         return InstrumentClose(
             TestIdStubs.betting_instrument_id(),
             Price(1.0, BETFAIR_PRICE_PRECISION),
             InstrumentCloseType.CONTRACT_EXPIRED,
             0,
             0,
@@ -366,28 +366,28 @@
             book.add(order, 0)
             asks_counter += 1
 
         return book
 
     @staticmethod
     def venue_status_update(
-        venue: Venue = None,
-        status: MarketStatus = None,
+        venue: Optional[Venue] = None,
+        status: Optional[MarketStatus] = None,
     ) -> VenueStatusUpdate:
         return VenueStatusUpdate(
             venue=venue or Venue("BINANCE"),
             status=status or MarketStatus.OPEN,
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
     def instrument_status_update(
-        instrument_id: InstrumentId = None,
-        status: MarketStatus = None,
+        instrument_id: Optional[InstrumentId] = None,
+        status: Optional[MarketStatus] = None,
     ) -> InstrumentStatusUpdate:
         return InstrumentStatusUpdate(
             instrument_id=instrument_id or InstrumentId(Symbol("BTCUSDT"), Venue("BINANCE")),
             status=status or MarketStatus.PAUSE,
             ts_event=0,
             ts_init=0,
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/events.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/events.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/execution.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/execution.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,14 @@
 
 from typing import Optional
 
 from nautilus_trader.accounting.accounts.betting import BettingAccount
 from nautilus_trader.accounting.accounts.cash import CashAccount
 from nautilus_trader.accounting.accounts.margin import MarginAccount
 from nautilus_trader.accounting.factory import AccountFactory
-from nautilus_trader.adapters.interactive_brokers.common import IBOrderTags
 from nautilus_trader.core.datetime import dt_to_unix_nanos
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.model.enums import ContingencyType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.identifiers import AccountId
@@ -95,14 +94,15 @@
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             tags=tags,
         )
 
+    @staticmethod
     def limit_with_stop_market(
         instrument_id=None,
         order_side=None,
         price=None,
         quantity=None,
         time_in_force=None,
         trader_id: Optional[TradeId] = None,
@@ -145,15 +145,15 @@
             trigger_price=sl_trigger_price or Price.from_str("50.0"),
             trigger_type=TriggerType.MID_POINT,
             init_id=UUID4(),
             ts_init=0,
             time_in_force=TimeInForce.GTC,
             order_list_id=order_list_id or TestIdStubs.order_list_id(),
             parent_order_id=entry_order.client_order_id,
-            tags=IBOrderTags(outsideRth=True).value,
+            tags=None,
         )
         return OrderList(order_list_id or TestIdStubs.order_list_id(), [entry_order, sl_order])
 
     @staticmethod
     def market_order(
         instrument_id=None,
         order_side=None,
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/identifiers.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/identifiers.py`

 * *Files 1% similar despite different names*

```diff
@@ -83,14 +83,18 @@
         return betfair_instrument_id(
             market_id="1.179082386",
             selection_id="50214",
             selection_handicap=None,
         )
 
     @staticmethod
+    def synthetic_id():
+        return InstrumentId(Symbol("BTC-ETH"), Venue("SYNTH"))
+
+    @staticmethod
     def client_order_id(counter: int = 1) -> ClientOrderId:
         return ClientOrderId(f"O-20210410-022422-001-001-{counter}")
 
     @staticmethod
     def order_list_id(counter: int = 1) -> OrderListId:
         return OrderListId(f"OL-20210410-022422-001-001-{counter}")
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/persistence.py` & `nautilus_trader-1.176.0/nautilus_trader/test_kit/stubs/persistence.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/trading/filters.pyx` & `nautilus_trader-1.176.0/nautilus_trader/trading/filters.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,51 +9,51 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from datetime import datetime
-
-from libc.stdint cimport uint64_t
+from __future__ import annotations
 
+from datetime import datetime
+from datetime import timedelta
 from enum import Enum
 from enum import unique
 
 import pandas as pd
 import pytz
 
-from cpython.datetime cimport datetime
-from cpython.datetime cimport timedelta
-
-from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.datetime cimport is_datetime_utc
+from nautilus_trader.core.correctness import PyCondition
+from nautilus_trader.core.data import Data
+from nautilus_trader.core.datetime import is_datetime_utc
+from nautilus_trader.model.currency import Currency
 
 
 @unique
 class ForexSession(Enum):
     SYDNEY = 1
     TOKYO = 2
     LONDON = 3
     NEW_YORK = 4
 
 
-cdef class ForexSessionFilter:
+class ForexSessionFilter:
     """
-    Provides methods to help filter trading strategy rules dependent on Forex session times.
+    Provides methods to help filter trading strategy rules dependent on Forex session
+    times.
     """
 
     def __init__(self):
         self._tz_sydney = pytz.timezone("Australia/Sydney")
         self._tz_tokyo = pytz.timezone("Asia/Tokyo")
         self._tz_london = pytz.timezone("Europe/London")
         self._tz_new_york = pytz.timezone("America/New_York")
 
-    cpdef datetime local_from_utc(self, session: ForexSession, datetime time_now):
+    def local_from_utc(self, session: ForexSession, time_now: datetime) -> datetime:
         """
         Return the local datetime from the given session and time_now (UTC).
 
         Parameters
         ----------
         session : ForexSession
             The session for the local timezone conversion.
@@ -67,30 +67,30 @@
 
         Raises
         ------
         ValueError
             If `time_now` is not tz aware UTC.
 
         """
-        Condition.type(session, ForexSession, "session")
-        Condition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
+        PyCondition.type(session, ForexSession, "session")
+        PyCondition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
 
         if session == ForexSession.SYDNEY:
             return time_now.astimezone(self._tz_sydney)
 
         if session == ForexSession.TOKYO:
             return time_now.astimezone(self._tz_tokyo)
 
         if session == ForexSession.LONDON:
             return time_now.astimezone(self._tz_london)
 
         if session == ForexSession.NEW_YORK:
             return time_now.astimezone(self._tz_new_york)
 
-    cpdef datetime next_start(self, session: ForexSession, datetime time_now):
+    def next_start(self, session: ForexSession, time_now: datetime) -> datetime:
         """
         Return the next session start.
 
         All FX sessions run Monday to Friday local time.
 
         Sydney Session    0700-1600 'Australia/Sydney'
 
@@ -113,42 +113,52 @@
 
         Raises
         ------
         ValueError
             If `time_now` is not tz aware UTC.
 
         """
-        Condition.type(session, ForexSession, "session")
-        Condition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
+        PyCondition.type(session, ForexSession, "session")
+        PyCondition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
 
-        cdef datetime local_now = self.local_from_utc(session, time_now)
-        cdef datetime next_start = None
+        local_now: datetime = self.local_from_utc(session, time_now)
+        next_start: datetime | None = None
 
         # Local days session start
         if session == ForexSession.SYDNEY:
-            next_start = self._tz_sydney.localize(datetime(local_now.year, local_now.month, local_now.day, 7))
+            next_start = self._tz_sydney.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 7),
+            )
         elif session == ForexSession.TOKYO:
-            next_start = self._tz_tokyo.localize(datetime(local_now.year, local_now.month, local_now.day, 9))
+            next_start = self._tz_tokyo.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 9),
+            )
         elif session == ForexSession.LONDON:
-            next_start = self._tz_london.localize(datetime(local_now.year, local_now.month, local_now.day, 8))
+            next_start = self._tz_london.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 8),
+            )
         elif session == ForexSession.NEW_YORK:
-            next_start = self._tz_new_york.localize(datetime(local_now.year, local_now.month, local_now.day, 8))
+            next_start = self._tz_new_york.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 8),
+            )
+        if next_start is None:
+            raise ValueError("`next_start` was `None`, expected a value")
 
         # Already past this days session start
         if local_now > next_start:
             next_start += timedelta(days=1)
 
         # Weekend - next session start becomes next Mondays session start
         if next_start.weekday() > 4:
             diff = 7 - next_start.weekday()
             next_start += timedelta(days=diff)
 
         return next_start.astimezone(pytz.utc)
 
-    cpdef datetime prev_start(self, session: ForexSession, datetime time_now):
+    def prev_start(self, session: ForexSession, time_now: datetime) -> datetime:
         """
         Return the previous session start.
 
         All FX sessions run Monday to Friday local time.
 
         Sydney Session    0700-1600 'Australia/Sydney'
 
@@ -171,42 +181,52 @@
 
         Raises
         ------
         ValueError
             If `time_now` is not tz aware UTC.
 
         """
-        Condition.type(session, ForexSession, "session")
-        Condition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
+        PyCondition.type(session, ForexSession, "session")
+        PyCondition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
 
-        cdef datetime local_now = self.local_from_utc(session, time_now)
-        cdef datetime prev_start = None
+        local_now: datetime = self.local_from_utc(session, time_now)
+        prev_start: datetime | None = None
 
         # Local days session start
         if session == ForexSession.SYDNEY:
-            prev_start = self._tz_sydney.localize(datetime(local_now.year, local_now.month, local_now.day, 7))
+            prev_start = self._tz_sydney.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 7),
+            )
         elif session == ForexSession.TOKYO:
-            prev_start = self._tz_tokyo.localize(datetime(local_now.year, local_now.month, local_now.day, 9))
+            prev_start = self._tz_tokyo.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 9),
+            )
         elif session == ForexSession.LONDON:
-            prev_start = self._tz_london.localize(datetime(local_now.year, local_now.month, local_now.day, 8))
+            prev_start = self._tz_london.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 8),
+            )
         elif session == ForexSession.NEW_YORK:
-            prev_start = self._tz_new_york.localize(datetime(local_now.year, local_now.month, local_now.day, 8))
+            prev_start = self._tz_new_york.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 8),
+            )
+        if prev_start is None:
+            raise ValueError("`prev_start` was `None`, expected a value")
 
         # Prior to this days session start
         if local_now < prev_start:
             prev_start -= timedelta(days=1)
 
         # Weekend - previous session start becomes last Fridays session start
         if prev_start.weekday() > 4:
             diff = prev_start.weekday() - 4
             prev_start -= timedelta(days=diff)
 
         return prev_start.astimezone(pytz.utc)
 
-    cpdef datetime next_end(self, session: ForexSession, datetime time_now):
+    def next_end(self, session: ForexSession, time_now: datetime) -> datetime:
         """
         Return the next session end.
 
         All FX sessions run Monday to Friday local time.
 
         Sydney Session    0700-1600 'Australia/Sydney'
 
@@ -229,42 +249,52 @@
 
         Raises
         ------
         ValueError
             If `time_now` is not tz aware UTC.
 
         """
-        Condition.type(session, ForexSession, "session")
-        Condition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
+        PyCondition.type(session, ForexSession, "session")
+        PyCondition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
 
-        cdef datetime local_now = self.local_from_utc(session, time_now)
-        cdef datetime next_end = None
+        local_now: datetime = self.local_from_utc(session, time_now)
+        next_end: datetime | None = None
 
         # Local days session end
         if session == ForexSession.SYDNEY:
-            next_end = self._tz_sydney.localize(datetime(local_now.year, local_now.month, local_now.day, 16))
+            next_end = self._tz_sydney.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 16),
+            )
         elif session == ForexSession.TOKYO:
-            next_end = self._tz_tokyo.localize(datetime(local_now.year, local_now.month, local_now.day, 18))
+            next_end = self._tz_tokyo.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 18),
+            )
         elif session == ForexSession.LONDON:
-            next_end = self._tz_london.localize(datetime(local_now.year, local_now.month, local_now.day, 16))
+            next_end = self._tz_london.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 16),
+            )
         elif session == ForexSession.NEW_YORK:
-            next_end = self._tz_new_york.localize(datetime(local_now.year, local_now.month, local_now.day, 17))
+            next_end = self._tz_new_york.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 17),
+            )
+        if next_end is None:
+            raise ValueError("`next_end` was `None`, expected a value")
 
         # Already past this days session end
         if local_now > next_end:
             next_end += timedelta(days=1)
 
         # Weekend - next session end becomes last Mondays session end
         if next_end.weekday() > 4:
             diff = 7 - next_end.weekday()
             next_end += timedelta(days=diff)
 
         return next_end.astimezone(pytz.utc)
 
-    cpdef datetime prev_end(self, session: ForexSession, datetime time_now):
+    def prev_end(self, session: ForexSession, time_now: datetime) -> datetime:
         """
         Return the previous sessions end.
 
         All FX sessions run Monday to Friday local time.
 
         Sydney Session    0700-1600 'Australia/Sydney'
 
@@ -287,29 +317,39 @@
 
         Raises
         ------
         ValueError
             If `time_now` is not tz aware UTC.
 
         """
-        Condition.type(session, ForexSession, "session")
-        Condition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
+        PyCondition.type(session, ForexSession, "session")
+        PyCondition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
 
-        cdef datetime local_now = self.local_from_utc(session, time_now)
-        cdef datetime prev_end = None
+        local_now: datetime = self.local_from_utc(session, time_now)
+        prev_end: datetime | None = None
 
         # Local days session end
         if session == ForexSession.SYDNEY:
-            prev_end = self._tz_sydney.localize(datetime(local_now.year, local_now.month, local_now.day, 16))
+            prev_end = self._tz_sydney.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 16),
+            )
         elif session == ForexSession.TOKYO:
-            prev_end = self._tz_tokyo.localize(datetime(local_now.year, local_now.month, local_now.day, 18))
+            prev_end = self._tz_tokyo.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 18),
+            )
         elif session == ForexSession.LONDON:
-            prev_end = self._tz_london.localize(datetime(local_now.year, local_now.month, local_now.day, 16))
+            prev_end = self._tz_london.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 16),
+            )
         elif session == ForexSession.NEW_YORK:
-            prev_end = self._tz_new_york.localize(datetime(local_now.year, local_now.month, local_now.day, 17))
+            prev_end = self._tz_new_york.localize(
+                datetime(local_now.year, local_now.month, local_now.day, 17),
+            )
+        if prev_end is None:
+            raise ValueError("`prev_end` was `None`, expected a value")
 
         # Prior to this days session end
         if local_now < prev_end:
             prev_end -= timedelta(days=1)
 
         # Weekend - previous session end becomes Fridays session end
         if prev_end.weekday() > 4:
@@ -323,74 +363,89 @@
 class NewsImpact(Enum):
     NONE = 1
     LOW = 2
     MEDIUM = 3
     HIGH = 4
 
 
-cdef class NewsEvent(Data):
+class NewsEvent(Data):
     """
     Represents an economic news event.
 
     Parameters
     ----------
     impact : NewsImpact
         The expected impact for the economic news event.
     name : str
         The name of the economic news event.
     currency : Currency
         The currency the economic news event is expected to affect.
-    ts_event : uint64_t
+    ts_event : int
         The UNIX timestamp (nanoseconds) when the news event occurred.
-    ts_init : uint64_t
+    ts_init : int
         The UNIX timestamp (nanoseconds) when the data object was initialized.
+
     """
 
     def __init__(
         self,
         impact: NewsImpact,
-        str name,
-        Currency currency,
-        uint64_t ts_event,
-        uint64_t ts_init,
+        name: str,
+        currency: Currency,
+        ts_event: int,
+        ts_init: int,
     ):
-        self.impact = impact
-        self.name = name
-        self.currency = currency
+        self._impact = impact
+        self._name = name
+        self._currency = currency
         self._ts_event = ts_event
         self._ts_init = ts_init
 
     @property
+    def impact(self) -> NewsImpact:
+        return self._impact
+
+    @property
+    def name(self) -> str:
+        return self._name
+
+    @property
+    def currency(self) -> Currency:
+        return self._currency
+
+    @property
     def ts_event(self) -> int:
         return self._ts_event
 
     @property
     def ts_init(self) -> int:
         return self._ts_init
 
 
-cdef class EconomicNewsEventFilter:
+class EconomicNewsEventFilter:
     """
-    Provides methods to help filter trading strategy rules based on economic news events.
+    Provides methods to help filter trading strategy rules based on economic news
+    events.
 
     Parameters
     ----------
     currencies : list[str]
         The list of three letter currency codes to filter.
     impacts : list[str]
         The list of impact levels to filter ('LOW', 'MEDIUM', 'HIGH').
     news_data : pd.DataFrame
         The economic news data.
+
     """
 
     def __init__(
         self,
-        list currencies not None,
-        list impacts not None,
-        news_data not None: pd.DataFrame,
+        currencies: list[str],
+        impacts: list[str],
+        news_data: pd.DataFrame,
     ):
         self._currencies = currencies
         self._impacts = impacts
 
         self._unfiltered_data_start = news_data.index[0]
         self._unfiltered_data_end = news_data.index[-1]
 
@@ -442,22 +497,23 @@
         Returns
         -------
         list[str]
 
         """
         return self._impacts
 
-    cpdef NewsEvent next_event(self, datetime time_now):
+    def next_event(self, time_now: datetime) -> NewsEvent | None:
         """
-        Return the next news event matching the filter conditions.
-        Will return None if no news events match the filter conditions.
+        Return the next news event matching the filter conditions. Will return None if
+        no news events match the filter conditions.
 
         Parameters
         ----------
         time_now : datetime
+            The current time.
 
         Returns
         -------
         NewsEvent or ``None``
             The next news event in the filtered data if any.
 
         Raises
@@ -466,48 +522,53 @@
             The `time_now` < `self.unfiltered_data_start`.
         ValueError
             The `time_now` > `self.unfiltered_data_end`.
         ValueError
             If `time_now` is not tz aware UTC.
 
         """
-        Condition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
+        PyCondition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
 
         if time_now < self._unfiltered_data_start:
-            raise ValueError(f"The given time_now at {time_now} was prior to the "
-                             f"available news data start at {self._unfiltered_data_start}")
+            raise ValueError(
+                f"The given time_now at {time_now} was prior to the "
+                f"available news data start at {self._unfiltered_data_start}",
+            )
 
         if time_now > self._unfiltered_data_end:
-            raise ValueError(f"The given time_now at {time_now} was after the "
-                             f"available news data end at {self._unfiltered_data_end}")
+            raise ValueError(
+                f"The given time_now at {time_now} was after the "
+                f"available news data end at {self._unfiltered_data_end}",
+            )
 
         events = self._news_data[self._news_data.index >= time_now]
 
         if events.empty:
             return None
 
-        cdef int index = 0
+        index = 0
         row = events.iloc[index]
-        cdef uint64_t ts_event = pd.Timestamp(events.index[index]).value
+        ts_event = pd.Timestamp(events.index[index]).value
         return NewsEvent(
             NewsImpact[row["Impact"]],
             row["Name"],
-            Currency.from_str_c(row["Currency"]),
+            Currency.from_str(row["Currency"]),
             ts_event,
             ts_event,
         )
 
-    cpdef NewsEvent prev_event(self, datetime time_now):
+    def prev_event(self, time_now: datetime) -> NewsEvent | None:
         """
-        Return the previous news event matching the initial filter conditions.
-        Will return None if no news events match the filter conditions.
+        Return the previous news event matching the initial filter conditions. Will
+        return None if no news events match the filter conditions.
 
         Parameters
         ----------
         time_now : datetime
+            The current time.
 
         Returns
         -------
         NewsEvent or ``None``
             The previous news event in the filtered data if any.
 
         Raises
@@ -516,31 +577,35 @@
             The `time_now` < `self.unfiltered_data_start`.
         ValueError
             The `time_now` > `self.unfiltered_data_end`.
         ValueError
             If `time_now` is not tz aware UTC.
 
         """
-        Condition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
+        PyCondition.true(is_datetime_utc(time_now), "time_now was not tz aware UTC")
 
         if time_now < self._unfiltered_data_start:
-            raise ValueError(f"The given time_now at {time_now} was prior to the "
-                             f"available news data start at {self._unfiltered_data_start}")
+            raise ValueError(
+                f"The given time_now at {time_now} was prior to the "
+                f"available news data start at {self._unfiltered_data_start}",
+            )
 
         if time_now > self._unfiltered_data_end:
-            raise ValueError(f"The given time_now at {time_now} was after the "
-                             f"available news data end at {self._unfiltered_data_end}")
+            raise ValueError(
+                f"The given time_now at {time_now} was after the "
+                f"available news data end at {self._unfiltered_data_end}",
+            )
 
         events = self._news_data[self._news_data.index <= time_now]
         if events.empty:
             return None
 
-        cdef int index = -1
+        index = -1
         row = events.iloc[index]
-        cdef uint64_t ts_event = pd.Timestamp(events.index[index]).value
+        ts_event = pd.Timestamp(events.index[index]).value
         return NewsEvent(
             NewsImpact[row["Impact"]],
             row["Name"],
-            Currency.from_str_c(row["Currency"]),
+            Currency.from_str(row["Currency"]),
             ts_event,
             ts_event,
         )
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pxd` & `nautilus_trader-1.176.0/nautilus_trader/trading/strategy.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -107,18 +107,19 @@
         ClientId client_id=*,
     )
     cpdef void cancel_order(self, Order order, ClientId client_id=*)
     cpdef void cancel_all_orders(self, InstrumentId instrument_id, OrderSide order_side=*, ClientId client_id=*)
     cpdef void close_position(self, Position position, ClientId client_id=*, str tags=*)
     cpdef void close_all_positions(self, InstrumentId instrument_id, PositionSide position_side=*, ClientId client_id=*, str tags=*)
     cpdef void query_order(self, Order order, ClientId client_id=*)
+    cpdef void cancel_gtd_expiry(self, Order order)
 
+    cdef bint _has_gtd_expiry_timer(self, ClientOrderId client_order_id)
     cdef str _get_gtd_expiry_timer_name(self, ClientOrderId client_order_id)
     cdef void _set_gtd_expiry(self, Order order)
-    cdef void _cancel_gtd_expiry(self, Order order)
     cpdef void _expire_gtd_order(self, TimeEvent event)
 
 # -- HANDLERS -------------------------------------------------------------------------------------
 
     cdef void _handle_indicators_for_quote(self, list indicators, QuoteTick tick)
     cdef void _handle_indicators_for_trade(self, list indicators, TradeTick tick)
     cdef void _handle_indicators_for_bar(self, list indicators, Bar bar)
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pyx` & `nautilus_trader-1.176.0/nautilus_trader/trading/strategy.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -296,14 +296,15 @@
 
         self.portfolio = portfolio  # Assigned as PortfolioFacade
 
         self.order_factory = OrderFactory(
             trader_id=self.trader_id,
             strategy_id=self.id,
             clock=self.clock,
+            cache=self.cache,
         )
 
         # Required subscriptions
         self._msgbus.subscribe(topic=f"events.order.{self.id}", handler=self.handle_event)
         self._msgbus.subscribe(topic=f"events.position.{self.id}", handler=self.handle_event)
 
     cpdef void register_indicator_for_quote_ticks(self, InstrumentId instrument_id, Indicator indicator):
@@ -480,28 +481,26 @@
         )
 
         # Check for duplicate client order ID
         if self.cache.order_exists(order.client_order_id):
             self._deny_order(order, f"duplicate {repr(order.client_order_id)}")
             return
 
-        self.cache.add_order(order, position_id)
+        self.cache.add_order(order, position_id, client_id)
 
         cdef SubmitOrder command = SubmitOrder(
             trader_id=self.trader_id,
             strategy_id=self.id,
             order=order,
             command_id=UUID4(),
             ts_init=self.clock.timestamp_ns(),
             position_id=position_id,
             client_id=client_id,
         )
 
-        self.cache.add_submit_order_command(command)
-
         if manage_gtd_expiry and order.time_in_force == TimeInForce.GTD:
             self._set_gtd_expiry(order)
 
         # Route order
         if order.is_emulated_c():
             self._send_emulator_command(command)
         elif order.exec_algorithm_id is not None:
@@ -580,28 +579,26 @@
                     self._deny_order(
                         order,
                         reason=f"duplicate {repr(order.client_order_id)}",
                     )
                 return
 
         for order in order_list.orders:
-            self.cache.add_order(order, position_id)
+            self.cache.add_order(order, position_id, client_id)
 
         cdef SubmitOrderList command = SubmitOrderList(
             trader_id=self.trader_id,
             strategy_id=self.id,
             order_list=order_list,
             position_id=position_id,
             command_id=UUID4(),
             ts_init=self.clock.timestamp_ns(),
             client_id=client_id,
         )
 
-        self.cache.add_submit_order_list_command(command)
-
         if manage_gtd_expiry:
             for order in command.order_list.orders:
                 if order.time_in_force == TimeInForce.GTD:
                     self._set_gtd_expiry(order)
 
         # Route order
         if command.has_emulated_order:
@@ -1027,41 +1024,62 @@
             command_id=UUID4(),
             ts_init=self.clock.timestamp_ns(),
             client_id=client_id,
         )
 
         self._send_exec_command(command)
 
+    cpdef void cancel_gtd_expiry(self, Order order):
+        """
+        Cancel the managed GTD expiry for the given order.
+
+        If there is no current GTD expiry timer, then an error will be logged.
+
+        Parameters
+        ----------
+        order : Order
+            The order to cancel the GTD expiry for.
+
+        """
+        Condition.not_none(order, "order")
+
+        cdef str timer_name = self._get_gtd_expiry_timer_name(order.client_order_id)
+        cdef str expire_time_str = f" @ {order.expire_time.isoformat()}" if hasattr(order, "expire_time") else ""
+
+        if timer_name not in self._clock.timer_names:
+            self._log.error(f"Cannot find managed GTD timer for order {order.client_order_id!r}")
+            return
+
+        self._log.info(
+            f"Canceling managed GTD expiry timer for {order.client_order_id}{expire_time_str}.",
+            LogColor.BLUE,
+        )
+        self._clock.cancel_timer(name=timer_name)
+
     cdef str _get_gtd_expiry_timer_name(self, ClientOrderId client_order_id):
         return f"GTD-EXPIRY:{client_order_id.to_str()}"
 
+    cdef bint _has_gtd_expiry_timer(self, ClientOrderId client_order_id):
+        cdef str timer_name = self._get_gtd_expiry_timer_name(client_order_id)
+        return timer_name in self._clock.timer_names
+
     cdef void _set_gtd_expiry(self, Order order):
         self._log.info(
-            f"Setting managed GTD expiry timer for {order.client_order_id} @ {order.expire_time}.",
+            f"Setting managed GTD expiry timer for {order.client_order_id} @ {order.expire_time.isoformat()}.",
             LogColor.BLUE,
         )
         cdef str timer_name = self._get_gtd_expiry_timer_name(order.client_order_id)
         self._clock.set_time_alert_ns(
             name=timer_name,
             alert_time_ns=order.expire_time_ns,
             callback=self._expire_gtd_order,
         )
         # For now, we flip this opt-in flag
         self._manage_gtd_expiry = True
 
-    cdef void _cancel_gtd_expiry(self, Order order):
-        cdef str timer_name = self._get_gtd_expiry_timer_name(order.client_order_id)
-        cdef str expire_time_str = f" @ {order.expire_time}" if hasattr(order, "expire_time") else ""
-        if timer_name in self._clock.timer_names:
-            self._log.info(
-                f"Canceling managed GTD expiry timer for {order.client_order_id}{expire_time_str}.",
-                LogColor.BLUE,
-            )
-            self._clock.cancel_timer(name=timer_name)
-
     cpdef void _expire_gtd_order(self, TimeEvent event):
         cdef ClientOrderId client_order_id = ClientOrderId(event.to_str().partition(":")[2])
         cdef Order order = self.cache.order(client_order_id)
         if order is None:
             self._log.warning(
                 f"Order with {repr(client_order_id)} not found in the cache to apply {event}."
             )
@@ -1310,16 +1328,16 @@
             self.log.warning(f"{RECV}{EVT} {event}.")
         else:
             self.log.info(f"{RECV}{EVT} {event}.")
 
         cdef Order order
         if self._manage_gtd_expiry and isinstance(event, OrderEvent):
             order = self.cache.order(event.client_order_id)
-            if order is not None and order.is_closed_c():
-                self._cancel_gtd_expiry(order)
+            if order is not None and order.is_closed_c() and self._has_gtd_expiry_timer(order.client_order_id):
+                self.cancel_gtd_expiry(order)
 
         if self._fsm.state == ComponentState.RUNNING:
             try:
                 self.on_event(event)
             except Exception as e:
                 self.log.exception(f"Error on handling {repr(event)}", e)
                 raise
@@ -1397,15 +1415,15 @@
             ts_init=ts_now,
         )
 
     cdef void _deny_order(self, Order order, str reason):
         self._log.error(f"Order denied: {reason}.")
 
         if not self.cache.order_exists(order.client_order_id):
-            self.cache.add_order(order, position_id=None)
+            self.cache.add_order(order)
 
         # Generate event
         cdef OrderDenied event = self._generate_order_denied(order, reason)
 
         try:
             order.apply(event)
         except InvalidStateTrigger as e:
```

### Comparing `nautilus_trader-1.175.0/nautilus_trader/trading/trader.pxd` & `nautilus_trader-1.176.0/nautilus_trader/trading/trader.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/nautilus_trader/trading/trader.pyx` & `nautilus_trader-1.176.0/nautilus_trader/trading/trader.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.175.0/pyproject.toml` & `nautilus_trader-1.176.0/pyproject.toml`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "nautilus_trader"
-version = "1.175.0"
+version = "1.176.0"
 description = "A high-performance algorithmic trading platform and event-driven backtester"
 authors = ["Nautech Systems <info@nautechsystems.io>"]
 license = "LGPL-3.0-or-later"
 readme = "README.md"
 homepage = "https://nautilustrader.io"
 repository = "https://github.com/nautechsystems/nautilus_trader"
 classifiers = [
@@ -29,76 +29,75 @@
     { path = "nautilus_trader/**/*.pyd", format = "wheel" },
 ]
 
 [build-system]
 requires = [
     "setuptools",
     "poetry-core>=1.6.1",
-    "numpy>=1.24.3",
-    "Cython==3.0.0b3",
+    "numpy>=1.25.1",
+    "Cython==3.0.0",
 ]
 build-backend = "poetry.core.masonry.api"
 
 [tool.poetry.build]
 script = "build.py"
 generate-setup-file = false
 
 [tool.poetry.dependencies]
 python = ">=3.9,<3.12"
-cython = "==3.0.0b3"
-aiodns = "^3.0.0"
-aiohttp = "^3.8.4"
-click = "^8.1.3"
+cython = "==3.0.0"
+click = "^8.1.5"
 frozendict = "^2.3.8"
 fsspec = ">=2022.5.0"
-msgspec = "^0.15.1"
-numpy = "^1.24.3"
-pandas = "^2.0.2"
+msgspec = "^0.17.0"
+numpy = "^1.25.1"
+pandas = "^2.0.3"
 psutil = "^5.9.5"
 pyarrow = "^12.0.1"
 pytz = "^2023.3.0"
 toml = "^0.10.2"
 tqdm = "^4.65.0"
 uvloop = {version = "^0.17.0", markers = "sys_platform != 'win32'"}
 hiredis = {version = "^2.2.3", optional = true}
-# ibapi = {git = "https://github.com/nautechsystems/ibapi.git", optional = true}
-ib_insync = {version = "^0.9.85", optional = true}
-redis = {version = "^4.5.5", optional = true}
+redis = {version = "^4.6.0", optional = true}
 docker = {version = "^6.1.3", optional = true}
-betfair_parser = {version = "0.2.6", optional = true}  # Pinned for stability
+nautilus_ibapi = {version = "==1019.1", optional = true}
+ib_insync = {version = "^0.9.86", optional = true}
+betfair_parser = {version = "==0.4.6", optional = true}
 
 [tool.poetry.extras]
 betfair = ["betfair_parser"]
 docker = ["docker"]
-ib = ["ib_insync"]
+ib = ["nautilus_ibapi", "ib_insync"]
 redis = ["hiredis", "redis"]
 
 [tool.poetry.group.dev]
 optional = true
 
 [tool.poetry.group.dev.dependencies]
-black = "^23.3.0"
-mypy = "^1.3.0"
+black = "^23.7.0"
+docformatter = "^1.7.5"
+mypy = "^1.4.1"
 pre-commit = "^3.3.3"
-ruff = "^0.0.272"
-types-pytz = "^2023.3.0"
-types-redis = "^4.5.5"
-types-requests = "^2.29.0"
+ruff = "^0.0.280"
+types-pytz = "^2023.3"
+types-redis = "^4.6"
+types-requests = "^2.31"
 types-toml = "^0.10.2"
 
 [tool.poetry.group.test]
 optional = true
 
 [tool.poetry.group.test.dependencies]
 coverage = "^7.2.7"
-pytest = "^7.3.2"
+pytest = "^7.4.0"
 pytest-aiohttp = "^1.0.4"
-pytest-asyncio = "^0.21.0"
+pytest-asyncio = "^0.21.1"
 pytest-benchmark = "^4.0.0"
-pytest-cov = "4.0.0"
+pytest-cov = "^4.1.0"
 pytest-mock = "^3.11.1"
 pytest-xdist = { version = "^3.3.1", extras = ["psutil"] }
 
 [tool.poetry.group.docs]
 optional = true
 
 [tool.poetry.group.docs.dependencies]
@@ -107,17 +106,14 @@
 myst-parser = "^0.18.1"
 sphinx_comments = "^0.0.3"
 sphinx_copybutton = "^0.5.0"
 sphinx-external-toc = "^0.3.1"
 sphinx-material = "^0.0.35"
 sphinx_togglebutton = "^0.3.0"
 
-##########################################################
-# Formatter configs                                      #
-##########################################################
 [tool.isort]
 py_version = "39"
 skip_glob = ["**/core/rust/*"]
 combine_as_imports = true
 line_length = 100
 ensure_newline_before_comments = true
 force_single_line = true
@@ -128,17 +124,22 @@
 use_parentheses = true
 filter_files = true
 
 [tool.black]
 target_version = ["py39", "py310", "py311"]
 line_length = 100
 
-##########################################################
-# Linter configs                                         #
-##########################################################
+[tool.docformatter]
+black = true
+make-summary-multi-line = true
+pre-summary-new-line = true
+blank = true
+recursive = true
+in-place = true
+
 [tool.ruff]
 target-version = "py39"
 line-length = 150  # Reduce to 100
 select = [
     "C4",
     "E",
     "F",
@@ -156,23 +157,22 @@
     "Q",
     "I",
     "RSE",
     "TID",
     # "SIM",
     # "ARG",
     # "ERA",
-    # "PD",
+    "PD",
     # "PGH",
     # "PLW",
     "NPY",
     "RUF",
 ]
 
 ignore = [
-    "E741",  # Ambiguous variable name (single char)
     "D100",  # Missing docstring in public module  **fix**
     "D101",
     "D102",  # Missing docstring in public method  **fix**
     "D103",  # Missing docstring in public function  **fix**
     "D104",  # Missing docstring in public package  **fix**
     "D107",
     "D105",
@@ -180,14 +180,17 @@
     "D203",  # 1 blank line required before class docstring (optional style)
     "D205",  # 1 blank line required between summary line and description (optional style)
     "D212",  # Multi-line docstring summary should start at the first line (optional style)
     "D400",  # First line should end with a period (not always a first line)
     "D413",  # Missing blank line after last section ('Parameters')
     "D415",  # First line should end with a period, question mark, or exclamation point (not always a first line)
     "D416",  # Section name should end with a colon ('Warnings:', not 'Warnings') (incorrect?)
+    "E741",  # Ambiguous variable name (single char)
+    "PD901", # `df` is a bad variable name. Be kinder to your future self
+    "RUF012",  # Mutable class attributes should be annotated with `typing.ClassVar`
     "S101",  # Use of assert detected (OK in test suite)
     "S105",  # Use of hardcoded password (spurious)
     "S106",  # Use of hardcoded password (spurious)
     "S113",  # Probable use of requests call without timeout **fix**
 ]
 
 # Allow autofix for all enabled rules (when `--fix`) is provided
@@ -239,30 +242,24 @@
 force-single-line = true
 single-line-exclusions = ["typing"]
 lines-after-imports = 2
 
 [tool.ruff.mccabe]
 max-complexity = 10
 
-##########################################################
-# Static analysis configs                                #
-##########################################################
 [tool.mypy]
 python_version = "3.9"
 disallow_incomplete_defs = true
 explicit_package_bases = true
 ignore_missing_imports = true
 namespace_packages = true
 warn_no_return = true
 warn_unused_configs = true
 warn_unused_ignores = true
 
-##########################################################
-# Test configs                                           #
-##########################################################
 [tool.pytest.ini_options]
 testpaths = ["tests"]
 addopts = "-ra --new-first --failed-first --doctest-modules --doctest-glob=\"*.pyx\""
 asyncio_mode = "strict"
 filterwarnings = [
     "ignore::UserWarning",
     "ignore::DeprecationWarning",
```

### Comparing `nautilus_trader-1.175.0/PKG-INFO` & `nautilus_trader-1.176.0/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: nautilus-trader
-Version: 1.175.0
+Version: 1.176.0
 Summary: A high-performance algorithmic trading platform and event-driven backtester
 Home-page: https://nautilustrader.io
 License: LGPL-3.0-or-later
 Author: Nautech Systems
 Author-email: info@nautechsystems.io
 Requires-Python: >=3.9,<3.12
 Classifier: Development Status :: 4 - Beta
@@ -22,31 +22,30 @@
 Classifier: Topic :: Scientific/Engineering
 Classifier: Topic :: Software Development :: Libraries
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Provides-Extra: betfair
 Provides-Extra: docker
 Provides-Extra: ib
 Provides-Extra: redis
-Requires-Dist: aiodns (>=3.0.0,<4.0.0)
-Requires-Dist: aiohttp (>=3.8.4,<4.0.0)
-Requires-Dist: betfair_parser (==0.2.6) ; extra == "betfair"
-Requires-Dist: click (>=8.1.3,<9.0.0)
-Requires-Dist: cython (==3.0.0b3)
+Requires-Dist: betfair_parser (==0.4.6) ; extra == "betfair"
+Requires-Dist: click (>=8.1.5,<9.0.0)
+Requires-Dist: cython (==3.0.0)
 Requires-Dist: docker (>=6.1.3,<7.0.0) ; extra == "docker"
 Requires-Dist: frozendict (>=2.3.8,<3.0.0)
 Requires-Dist: fsspec (>=2022.5.0)
 Requires-Dist: hiredis (>=2.2.3,<3.0.0) ; extra == "redis"
-Requires-Dist: ib_insync (>=0.9.85,<0.10.0) ; extra == "ib"
-Requires-Dist: msgspec (>=0.15.1,<0.16.0)
-Requires-Dist: numpy (>=1.24.3,<2.0.0)
-Requires-Dist: pandas (>=2.0.2,<3.0.0)
+Requires-Dist: ib_insync (>=0.9.86,<0.10.0) ; extra == "ib"
+Requires-Dist: msgspec (>=0.17.0,<0.18.0)
+Requires-Dist: nautilus_ibapi (==1019.1) ; extra == "ib"
+Requires-Dist: numpy (>=1.25.1,<2.0.0)
+Requires-Dist: pandas (>=2.0.3,<3.0.0)
 Requires-Dist: psutil (>=5.9.5,<6.0.0)
 Requires-Dist: pyarrow (>=12.0.1,<13.0.0)
 Requires-Dist: pytz (>=2023.3.0,<2024.0.0)
-Requires-Dist: redis (>=4.5.5,<5.0.0) ; extra == "redis"
+Requires-Dist: redis (>=4.6.0,<5.0.0) ; extra == "redis"
 Requires-Dist: toml (>=0.10.2,<0.11.0)
 Requires-Dist: tqdm (>=4.65.0,<5.0.0)
 Requires-Dist: uvloop (>=0.17.0,<0.18.0) ; sys_platform != "win32"
 Project-URL: Repository, https://github.com/nautechsystems/nautilus_trader
 Description-Content-Type: text/markdown
 
 # <img src="https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/nautilus-trader-logo.png" width="500">
@@ -62,18 +61,18 @@
 | Branch    | Version                                                                                                                                             | Status                                                                                                                                                                                            |
 | :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
 | `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json)  | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml)  |
 | `develop` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fdevelop%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=develop)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 
 | Platform           | Rust    | Python |
 | :----------------- | :------ | :----- |
-| `Linux (x86_64)`   | 1.70.0+ | 3.9+   |
-| `macOS (x86_64)`   | 1.70.0+ | 3.9+   |
-| `macOS (arm64)`    | 1.70.0+ | 3.9+   |
-| `Windows (x86_64)` | 1.70.0+ | 3.9+   |
+| `Linux (x86_64)`   | 1.71.0+ | 3.9+   |
+| `macOS (x86_64)`   | 1.71.0+ | 3.9+   |
+| `macOS (arm64)`    | 1.71.0+ | 3.9+   |
+| `Windows (x86_64)` | 1.71.0+ | 3.9+   |
 
 - **Website:** https://nautilustrader.io
 - **Docs:** https://docs.nautilustrader.io
 - **Support:** [support@nautilustrader.io](mailto:support@nautilustrader.io)
 
 ## Introduction
 
@@ -360,30 +359,34 @@
         # Create the indicators for the strategy
         self.fast_ema = ExponentialMovingAverage(config.fast_ema_period)
         self.slow_ema = ExponentialMovingAverage(config.slow_ema_period)
 
         self.instrument: Optional[Instrument] = None  # Initialized in on_start
 
     def on_start(self) -> None:
-        """Actions to be performed on strategy start."""
+        """
+        Actions to be performed on strategy start.
+        """
         # Get instrument
         self.instrument = self.cache.instrument(self.instrument_id)
 
         # Register the indicators for updating
         self.register_indicator_for_bars(self.bar_type, self.fast_ema)
         self.register_indicator_for_bars(self.bar_type, self.slow_ema)
 
         # Get historical data
         self.request_bars(self.bar_type)
 
         # Subscribe to live data
         self.subscribe_bars(self.bar_type)
 
     def on_bar(self, bar: Bar) -> None:
-        """Actions to be performed when the strategy receives a bar."""
+        """
+        Actions to be performed when the strategy receives a bar.
+        """
         # BUY LOGIC
         if self.fast_ema.value >= self.slow_ema.value:
             if self.portfolio.is_flat(self.instrument_id):
                 self.buy()
             elif self.portfolio.is_net_short(self.instrument_id):
                 self.close_all_positions(self.instrument_id)
                 self.buy()
@@ -392,44 +395,52 @@
             if self.portfolio.is_flat(self.instrument_id):
                 self.sell()
             elif self.portfolio.is_net_long(self.instrument_id):
                 self.close_all_positions(self.instrument_id)
                 self.sell()
 
     def buy(self) -> None:
-        """Users simple buy method (example)."""
+        """
+        Users simple buy method (example).
+        """
         order: MarketOrder = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.BUY,
             quantity=self.instrument.make_qty(self.trade_size),
         )
 
         self.submit_order(order)
 
     def sell(self) -> None:
-        """Users simple sell method (example)."""
+        """
+        Users simple sell method (example).
+        """
         order: MarketOrder = self.order_factory.market(
             instrument_id=self.instrument_id,
             order_side=OrderSide.SELL,
             quantity=self.instrument.make_qty(self.trade_size),
         )
 
         self.submit_order(order)
 
     def on_stop(self) -> None:
-        """Actions to be performed when the strategy is stopped."""
+        """
+        Actions to be performed when the strategy is stopped.
+        """
         # Cleanup orders and positions
         self.cancel_all_orders(self.instrument_id)
         self.close_all_positions(self.instrument_id)
 
         # Unsubscribe from data
         self.unsubscribe_bars(self.bar_type)
 
     def on_reset(self) -> None:
-        """Actions to be performed when the strategy is reset."""
+        """
+        Actions to be performed when the strategy is reset.
+        """
         # Reset indicators here
         self.fast_ema.reset()
         self.slow_ema.reset()
 
 ```
 
 ## Development
```

