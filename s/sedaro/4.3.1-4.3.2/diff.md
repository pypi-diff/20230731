# Comparing `tmp/sedaro-4.3.1.tar.gz` & `tmp/sedaro-4.3.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "sedaro-4.3.1.tar", last modified: Sat Jul  8 03:41:31 2023, max compression
+gzip compressed data, was "sedaro-4.3.2.tar", last modified: Mon Jul 31 18:43:48 2023, max compression
```

## Comparing `sedaro-4.3.1.tar` & `sedaro-4.3.2.tar`

### file list

```diff
@@ -1,294 +1,330 @@
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.380080 sedaro-4.3.1/
--rw-r--r--   0 sedaro     (501) staff       (20)    34889 2023-02-08 20:29:31.000000 sedaro-4.3.1/LICENSE
--rw-r--r--   0 sedaro     (501) staff       (20)    14297 2023-07-08 03:41:31.379234 sedaro-4.3.1/PKG-INFO
--rw-r--r--   0 sedaro     (501) staff       (20)    13705 2023-07-08 02:55:05.000000 sedaro-4.3.1/README.md
--rw-r--r--   0 sedaro     (501) staff       (20)      859 2023-07-08 03:40:55.000000 sedaro-4.3.1/pyproject.toml
--rw-r--r--   0 sedaro     (501) staff       (20)       38 2023-07-08 03:41:31.380175 sedaro-4.3.1/setup.cfg
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.937256 sedaro-4.3.1/src/
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.948228 sedaro-4.3.1/src/sedaro/
--rw-r--r--   0 sedaro     (501) staff       (20)      104 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/__init__.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.970952 sedaro-4.3.1/src/sedaro/branches/
--rw-r--r--   0 sedaro     (501) staff       (20)      126 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/branches/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9505 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/branches/agent_template_branch.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.973206 sedaro-4.3.1/src/sedaro/branches/blocks/
--rw-r--r--   0 sedaro     (501) staff       (20)       59 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/branches/blocks/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7124 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/branches/blocks/block.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5480 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/branches/blocks/block_type.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3844 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/branches/branch.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.975437 sedaro-4.3.1/src/sedaro/branches/scenario_branch/
--rw-r--r--   0 sedaro     (501) staff       (20)       44 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/branches/scenario_branch/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)     1803 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro/branches/scenario_branch/scenario_branch.py
--rw-r--r--   0 sedaro     (501) staff       (20)    20627 2023-07-08 02:54:54.000000 sedaro-4.3.1/src/sedaro/branches/scenario_branch/sim_client.py
--rw-r--r--   0 sedaro     (501) staff       (20)     1043 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/exceptions.py
--rw-r--r--   0 sedaro     (501) staff       (20)     2067 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/plain_request.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.981097 sedaro-4.3.1/src/sedaro/results/
--rw-r--r--   0 sedaro     (501) staff       (20)      155 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/results/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5261 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/results/agent.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3643 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/results/block.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6539 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/results/series.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5053 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/results/simulation_result.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3573 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/results/utils.py
--rw-r--r--   0 sedaro     (501) staff       (20)     2788 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/sedaro_api_client.py
--rw-r--r--   0 sedaro     (501) staff       (20)      611 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/settings.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4109 2023-06-21 16:29:29.000000 sedaro-4.3.1/src/sedaro/utils.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.968790 sedaro-4.3.1/src/sedaro.egg-info/
--rw-r--r--   0 sedaro     (501) staff       (20)    14297 2023-07-08 03:41:30.000000 sedaro-4.3.1/src/sedaro.egg-info/PKG-INFO
--rw-r--r--   0 sedaro     (501) staff       (20)    13950 2023-07-08 03:41:30.000000 sedaro-4.3.1/src/sedaro.egg-info/SOURCES.txt
--rw-r--r--   0 sedaro     (501) staff       (20)        1 2023-07-08 03:41:30.000000 sedaro-4.3.1/src/sedaro.egg-info/dependency_links.txt
--rw-r--r--   0 sedaro     (501) staff       (20)      152 2023-07-08 03:41:30.000000 sedaro-4.3.1/src/sedaro.egg-info/requires.txt
--rw-r--r--   0 sedaro     (501) staff       (20)       26 2023-07-08 03:41:30.000000 sedaro-4.3.1/src/sedaro.egg-info/top_level.txt
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.986475 sedaro-4.3.1/src/sedaro_base_client/
--rw-r--r--   0 sedaro     (501) staff       (20)     2658 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    60391 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/api_client.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.988768 sedaro-4.3.1/src/sedaro_base_client/apis/
--rw-r--r--   0 sedaro     (501) staff       (20)      214 2023-07-05 22:43:29.000000 sedaro-4.3.1/src/sedaro_base_client/apis/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3467 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/path_to_api.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:30.996212 sedaro-4.3.1/src/sedaro_base_client/apis/paths/
--rw-r--r--   0 sedaro     (501) staff       (20)      245 2023-07-05 22:43:29.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)      102 2023-07-05 22:43:25.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/data_id.py
--rw-r--r--   0 sedaro     (501) staff       (20)      430 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/models_branches_branch_id.py
--rw-r--r--   0 sedaro     (501) staff       (20)      159 2023-07-05 22:43:29.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/models_branches_branch_id_template.py
--rw-r--r--   0 sedaro     (501) staff       (20)      154 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/models_branches_branch_idcommits_.py
--rw-r--r--   0 sedaro     (501) staff       (20)      155 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/models_branches_branch_idcommitted_.py
--rw-r--r--   0 sedaro     (501) staff       (20)      147 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/models_branches_branch_idsaved_.py
--rw-r--r--   0 sedaro     (501) staff       (20)      159 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/models_branches_branch_idshare_auth_.py
--rw-r--r--   0 sedaro     (501) staff       (20)      200 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/models_branches_current_branch_id_merge_incoming_branch_id.py
--rw-r--r--   0 sedaro     (501) staff       (20)      271 2023-07-05 22:43:28.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/simulations_branches_branch_id_control_.py
--rw-r--r--   0 sedaro     (501) staff       (20)      294 2023-07-05 22:43:28.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/simulations_branches_branch_id_control_job_id.py
--rw-r--r--   0 sedaro     (501) staff       (20)      350 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id.py
--rw-r--r--   0 sedaro     (501) staff       (20)      890 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/tag_to_api.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.017227 sedaro-4.3.1/src/sedaro_base_client/apis/tags/
--rw-r--r--   0 sedaro     (501) staff       (20)      409 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/tags/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3293 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/tags/branches_api.py
--rw-r--r--   0 sedaro     (501) staff       (20)     2352 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/tags/data_api.py
--rw-r--r--   0 sedaro     (501) staff       (20)     2563 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/tags/externals_api.py
--rw-r--r--   0 sedaro     (501) staff       (20)     2772 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/tags/jobs_api.py
--rw-r--r--   0 sedaro     (501) staff       (20)     2396 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/apis/tags/templates_api.py
--rw-r--r--   0 sedaro     (501) staff       (20)    17209 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/configuration.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6389 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/exceptions.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.324971 sedaro-4.3.1/src/sedaro_base_client/model/
--rw-r--r--   0 sedaro     (501) staff       (20)      352 2023-07-05 22:43:29.000000 sedaro-4.3.1/src/sedaro_base_client/model/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10393 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/agent.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7905 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/agent_group.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4437 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angle_base299.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4671 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angle_field_of_view31.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4672 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angle_field_of_view36.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4672 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angle_field_of_view37.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4605 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angle_sensors20.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4605 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angle_sensors51.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4605 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angle_sensors56.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4774 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angular_velocity_base299.py
--rw-r--r--   0 sedaro     (501) staff       (20)    37694 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angular_velocity_sensor.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4942 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/angular_velocity_sensors82.py
--rw-r--r--   0 sedaro     (501) staff       (20)    33550 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/antenna.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12236 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/averaging_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)    22759 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/battery.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12480 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/battery_cell.py
--rw-r--r--   0 sedaro     (501) staff       (20)    38669 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/battery_pack.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12471 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/body_frame_vector.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3021 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/body_frame_vector_types.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10990 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/body_in_fov_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5175 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_create.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5959 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_delete_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5897 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_merge.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5342 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_merge_conflicts_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)    18154 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)    15642 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_scenario_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5142 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_update.py
--rw-r--r--   0 sedaro     (501) staff       (20)    15640 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_vehicle_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4372 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/branch_verify_password.py
--rw-r--r--   0 sedaro     (501) staff       (20)    17977 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/bus_regulator.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3557 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/categories.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3986 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/celestial_pointing_directions.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14984 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/celestial_target.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9408 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/celestial_vector.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9707 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/circular_field_of_view.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7874 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/classical_orbital_elements.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5840 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/clock_config.py
--rw-r--r--   0 sedaro     (501) staff       (20)    31100 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/component.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3076 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/component_parameters.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12472 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/component_to_scalar_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13991 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/compound_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3064 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/compound_operators.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3486 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/condition_relationship.py
--rw-r--r--   0 sedaro     (501) staff       (20)     2987 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/configuration_types.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5422 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/conflicts_obj.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4513 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/constant_power_params.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4439 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/constant_resistance_params.py
--rw-r--r--   0 sedaro     (501) staff       (20)    40733 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/cooler.py
--rw-r--r--   0 sedaro     (501) staff       (20)    15830 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/cooperative_transmit_interface.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6432 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/crud_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7143 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/data_bus.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10686 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/data_interface.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10472 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/data_mode.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4359 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/data_service_response.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4840 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/data_set.py
--rw-r--r--   0 sedaro     (501) staff       (20)    11664 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/data_storage.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4676 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/data_type.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4771 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/deleted_entity.py
--rw-r--r--   0 sedaro     (501) staff       (20)    39694 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/direction_sensor.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5640 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/distance_sensors70.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5686 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/duration_load70.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5708 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode18.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5708 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode19.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5708 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode20.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5708 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode28.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5708 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode29.py
--rw-r--r--   0 sedaro     (501) staff       (20)    17995 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/ekf_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3023 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/eps_output_types.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6274 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/equatorial_circular_reference_orbit.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5981 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/external_state_set_request.py
--rw-r--r--   0 sedaro     (501) staff       (20)    23565 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/fixed_surface.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7706 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/frame_vector_base299.py
--rw-r--r--   0 sedaro     (501) staff       (20)     8870 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/fuel_reservoir.py
--rw-r--r--   0 sedaro     (501) staff       (20)    42035 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/fully_reg_det_power_processor.py
--rw-r--r--   0 sedaro     (501) staff       (20)     8034 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/fully_reg_det_topology_params.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5595 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/geostationary_reference_orbit.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7080 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/geostationary_transfer_reference_orbit.py
--rw-r--r--   0 sedaro     (501) staff       (20)    17995 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/gps_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13475 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/ground_target.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3831 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/group_rollers.py
--rw-r--r--   0 sedaro     (501) staff       (20)    39215 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/heater.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5265 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/http_validation_error.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3360 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/initial_state_def_type.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3027 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/input_types.py
--rw-r--r--   0 sedaro     (501) staff       (20)    11222 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/internal_data_interface.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6259 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/iss_reference_orbit.py
--rw-r--r--   0 sedaro     (501) staff       (20)    33566 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/laser_comm_module.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12434 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/load_state.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4524 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/local_pointing_directions.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10173 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/local_vector.py
--rw-r--r--   0 sedaro     (501) staff       (20)    16046 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/lock_pointing_mode.py
--rw-r--r--   0 sedaro     (501) staff       (20)    43259 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/magnetorquer.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14972 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/max_align_pointing_mode.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12988 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/mekf_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4336 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/message_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)    32922 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/modem.py
--rw-r--r--   0 sedaro     (501) staff       (20)    22510 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/operational_mode.py
--rw-r--r--   0 sedaro     (501) staff       (20)    40511 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/optical_attitude_sensor.py
--rw-r--r--   0 sedaro     (501) staff       (20)    17905 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/orbit.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7725 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/orbital_elements_data.py
--rw-r--r--   0 sedaro     (501) staff       (20)    11564 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/passive_pointing_mode.py
--rw-r--r--   0 sedaro     (501) staff       (20)    15822 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/passive_transmit_interface.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13986 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/per_round_external_state.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14645 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/pid_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6960 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/polar_circular_reference_orbit.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3982 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/polynomial_ephemeris_body.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9169 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/position_base299.py
--rw-r--r--   0 sedaro     (501) staff       (20)    37675 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/position_sensor.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14782 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/power_load.py
--rw-r--r--   0 sedaro     (501) staff       (20)    42013 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/power_processor.py
--rw-r--r--   0 sedaro     (501) staff       (20)    42035 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/quasi_reg_det_power_processor.py
--rw-r--r--   0 sedaro     (501) staff       (20)     8114 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/quasi_reg_det_topology_params.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9425 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/quaternion_base299.py
--rw-r--r--   0 sedaro     (501) staff       (20)    44079 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/reaction_wheel.py
--rw-r--r--   0 sedaro     (501) staff       (20)    15806 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/receive_interface.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13193 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/rectangular_field_of_view.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14832 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/resistance_load.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10717 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/same_target_multi_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3955 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/satellite.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3830 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/satellite_parameters.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13436 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/satellite_to_satellite_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    11721 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/satellite_to_scalar_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14187 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/satellite_to_target_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10023 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/scenario_template_crud.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12738 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/scenario_template_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4594 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/scenario_template_update.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3105 2023-07-08 02:54:44.000000 sedaro-4.3.1/src/sedaro_base_client/model/side_categories.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9967 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/simulation_job.py
--rw-r--r--   0 sedaro     (501) staff       (20)    43542 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/single_conv_hybrid_power_processor.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6234 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/single_conv_hybrid_topology_params.py
--rw-r--r--   0 sedaro     (501) staff       (20)    43538 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/single_conv_mppt_power_processor.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5205 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/single_conv_mppt_topology_params.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12524 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/sliding_mode_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)    15521 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/solar_array.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9432 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/solar_cell.py
--rw-r--r--   0 sedaro     (501) staff       (20)    46839 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/solar_panel.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12826 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/space_target.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5254 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/spherical_angles.py
--rw-r--r--   0 sedaro     (501) staff       (20)    39229 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/spherical_fuel_tank.py
--rw-r--r--   0 sedaro     (501) staff       (20)    40706 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/spherocylinder_fuel_tank.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13992 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/spontaneous_external_state.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5212 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/state_vector.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5899 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/static_thrust_control_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3571 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/statuses.py
--rw-r--r--   0 sedaro     (501) staff       (20)     8883 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/subsystem.py
--rw-r--r--   0 sedaro     (501) staff       (20)     6855 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/sun_synchronous_circular_orbit.py
--rw-r--r--   0 sedaro     (501) staff       (20)    29616 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/sun_tracking_surface.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14716 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/surface_material.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12052 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_group.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12900 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_group_in_fov_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    22349 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_group_to_satellite_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    20542 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_group_to_scalar_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    22894 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_group_to_target_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7181 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_group_vector.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7683 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_in_fov_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4397 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_parameters.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12380 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_to_scalar_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14766 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_to_target_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7223 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/target_vector.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10432 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/temp_controller_state.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5199 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/temperature_base299.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4919 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/template_crud_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)    22185 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/thermal_interface.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12726 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/thermal_interface_material.py
--rw-r--r--   0 sedaro     (501) staff       (20)    38414 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/thruster.py
--rw-r--r--   0 sedaro     (501) staff       (20)     9223 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/time_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)     4258 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/tle.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12102 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/triad_algorithm.py
--rw-r--r--   0 sedaro     (501) staff       (20)    43532 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/two_conv_mppt_power_processor.py
--rw-r--r--   0 sedaro     (501) staff       (20)     8082 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/two_conv_mppt_topology_params.py
--rw-r--r--   0 sedaro     (501) staff       (20)     3166 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/types.py
--rw-r--r--   0 sedaro     (501) staff       (20)     8452 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/validation_error.py
--rw-r--r--   0 sedaro     (501) staff       (20)     5168 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/vector.py
--rw-r--r--   0 sedaro     (501) staff       (20)     7787 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/vector_in_fov_condition.py
--rw-r--r--   0 sedaro     (501) staff       (20)    36586 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/vector_sensor.py
--rw-r--r--   0 sedaro     (501) staff       (20)    30272 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/vector_tracking_surface.py
--rw-r--r--   0 sedaro     (501) staff       (20)    20930 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/vehicle_template_crud.py
--rw-r--r--   0 sedaro     (501) staff       (20)    73902 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/vehicle_template_res.py
--rw-r--r--   0 sedaro     (501) staff       (20)    65758 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/model/vehicle_template_update.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.326443 sedaro-4.3.1/src/sedaro_base_client/models/
--rw-r--r--   0 sedaro     (501) staff       (20)    13788 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/models/__init__.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.327358 sedaro-4.3.1/src/sedaro_base_client/paths/
--rw-r--r--   0 sedaro     (501) staff       (20)     1244 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/paths/__init__.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.329237 sedaro-4.3.1/src/sedaro_base_client/paths/data_id/
--rw-r--r--   0 sedaro     (501) staff       (20)      309 2023-07-05 22:43:25.000000 sedaro-4.3.1/src/sedaro_base_client/paths/data_id/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13227 2023-07-05 22:43:25.000000 sedaro-4.3.1/src/sedaro_base_client/paths/data_id/get.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.334368 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/
--rw-r--r--   0 sedaro     (501) staff       (20)      345 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10272 2023-07-05 22:43:21.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/delete.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10153 2023-07-05 22:43:21.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/get.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14210 2023-07-05 22:43:22.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/patch.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14214 2023-07-05 22:43:20.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/post.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.336396 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id_template/
--rw-r--r--   0 sedaro     (501) staff       (20)      363 2023-07-05 22:43:29.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id_template/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    18004 2023-07-05 22:43:29.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id_template/patch.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.339545 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommits_/
--rw-r--r--   0 sedaro     (501) staff       (20)      361 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommits_/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12511 2023-07-05 22:43:20.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommits_/post.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.342106 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommitted_/
--rw-r--r--   0 sedaro     (501) staff       (20)      365 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommitted_/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10325 2023-07-05 22:43:21.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommitted_/get.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.346274 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idsaved_/
--rw-r--r--   0 sedaro     (501) staff       (20)      357 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idsaved_/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10285 2023-07-05 22:43:22.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idsaved_/get.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.366507 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idshare_auth_/
--rw-r--r--   0 sedaro     (501) staff       (20)      366 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idshare_auth_/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14418 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idshare_auth_/post.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.369173 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/
--rw-r--r--   0 sedaro     (501) staff       (20)      411 2023-07-05 22:43:23.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    16249 2023-07-05 22:43:22.000000 sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/post.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.372592 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/
--rw-r--r--   0 sedaro     (501) staff       (20)      373 2023-07-05 22:43:28.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    14785 2023-07-05 22:43:27.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/get.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10289 2023-07-05 22:43:27.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/post.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.375726 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/
--rw-r--r--   0 sedaro     (501) staff       (20)      385 2023-07-05 22:43:28.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10611 2023-07-05 22:43:28.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/delete.py
--rw-r--r--   0 sedaro     (501) staff       (20)    10530 2023-07-05 22:43:27.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/get.py
-drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-08 03:41:31.378201 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/
--rw-r--r--   0 sedaro     (501) staff       (20)      427 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/__init__.py
--rw-r--r--   0 sedaro     (501) staff       (20)    13881 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/get.py
--rw-r--r--   0 sedaro     (501) staff       (20)    15793 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/patch.py
--rw-r--r--   0 sedaro     (501) staff       (20)    12546 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/rest.py
--rw-r--r--   0 sedaro     (501) staff       (20)    99533 2023-07-08 02:54:45.000000 sedaro-4.3.1/src/sedaro_base_client/schemas.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.959610 sedaro-4.3.2/
+-rw-r--r--   0 sedaro     (501) staff       (20)    34889 2023-02-08 20:29:31.000000 sedaro-4.3.2/LICENSE
+-rw-r--r--   0 sedaro     (501) staff       (20)    15131 2023-07-31 18:43:48.958544 sedaro-4.3.2/PKG-INFO
+-rw-r--r--   0 sedaro     (501) staff       (20)    14539 2023-07-28 02:13:35.000000 sedaro-4.3.2/README.md
+-rw-r--r--   0 sedaro     (501) staff       (20)      859 2023-07-31 18:43:09.000000 sedaro-4.3.2/pyproject.toml
+-rw-r--r--   0 sedaro     (501) staff       (20)       38 2023-07-31 18:43:48.959863 sedaro-4.3.2/setup.cfg
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.297400 sedaro-4.3.2/src/
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.316868 sedaro-4.3.2/src/sedaro/
+-rw-r--r--   0 sedaro     (501) staff       (20)      104 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/__init__.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.342142 sedaro-4.3.2/src/sedaro/branches/
+-rw-r--r--   0 sedaro     (501) staff       (20)      126 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/branches/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     9505 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/branches/agent_template_branch.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.345228 sedaro-4.3.2/src/sedaro/branches/blocks/
+-rw-r--r--   0 sedaro     (501) staff       (20)       59 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/branches/blocks/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7124 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/branches/blocks/block.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5480 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/branches/blocks/block_type.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4491 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/branches/branch.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.347634 sedaro-4.3.2/src/sedaro/branches/scenario_branch/
+-rw-r--r--   0 sedaro     (501) staff       (20)       44 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/branches/scenario_branch/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     1800 2023-07-28 02:13:35.000000 sedaro-4.3.2/src/sedaro/branches/scenario_branch/scenario_branch.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    24609 2023-07-31 16:50:33.000000 sedaro-4.3.2/src/sedaro/branches/scenario_branch/sim_client.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     1043 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/exceptions.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2067 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/plain_request.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.353022 sedaro-4.3.2/src/sedaro/results/
+-rw-r--r--   0 sedaro     (501) staff       (20)      155 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/results/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5261 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/results/agent.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3643 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/results/block.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     6539 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/results/series.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5053 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/results/simulation_result.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3573 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/results/utils.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2788 2023-07-27 22:14:10.000000 sedaro-4.3.2/src/sedaro/sedaro_api_client.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      611 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/settings.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4109 2023-07-27 21:51:49.000000 sedaro-4.3.2/src/sedaro/utils.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.321431 sedaro-4.3.2/src/sedaro.egg-info/
+-rw-r--r--   0 sedaro     (501) staff       (20)    15131 2023-07-31 18:43:47.000000 sedaro-4.3.2/src/sedaro.egg-info/PKG-INFO
+-rw-r--r--   0 sedaro     (501) staff       (20)    15868 2023-07-31 18:43:47.000000 sedaro-4.3.2/src/sedaro.egg-info/SOURCES.txt
+-rw-r--r--   0 sedaro     (501) staff       (20)        1 2023-07-31 18:43:47.000000 sedaro-4.3.2/src/sedaro.egg-info/dependency_links.txt
+-rw-r--r--   0 sedaro     (501) staff       (20)      152 2023-07-31 18:43:47.000000 sedaro-4.3.2/src/sedaro.egg-info/requires.txt
+-rw-r--r--   0 sedaro     (501) staff       (20)       26 2023-07-31 18:43:47.000000 sedaro-4.3.2/src/sedaro.egg-info/top_level.txt
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.359737 sedaro-4.3.2/src/sedaro_base_client/
+-rw-r--r--   0 sedaro     (501) staff       (20)     2215 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    59948 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/api_client.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.366770 sedaro-4.3.2/src/sedaro_base_client/apis/
+-rw-r--r--   0 sedaro     (501) staff       (20)      214 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/apis/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4757 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/apis/path_to_api.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.407655 sedaro-4.3.2/src/sedaro_base_client/apis/paths/
+-rw-r--r--   0 sedaro     (501) staff       (20)      245 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      102 2023-07-31 02:05:51.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/data_id.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      430 2023-07-31 02:05:50.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      152 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id_changes_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      155 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id_commits_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      156 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id_committed_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      150 2023-07-31 02:05:50.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id_export_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      148 2023-07-31 02:05:50.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id_saved_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      160 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id_share_auth_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      159 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_branch_id_template.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      200 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_branches_current_branch_id_merge_incoming_branch_id.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      130 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_repositories_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      143 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_repositories__import.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      367 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/models_repositories_repository_id.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      271 2023-07-31 02:05:54.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/simulations_branches_branch_id_control_.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      294 2023-07-31 02:05:54.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/simulations_branches_branch_id_control_job_id.py
+-rw-r--r--   0 sedaro     (501) staff       (20)      350 2023-07-31 02:05:52.000000 sedaro-4.3.2/src/sedaro_base_client/apis/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     1062 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tag_to_api.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:47.417830 sedaro-4.3.2/src/sedaro_base_client/apis/tags/
+-rw-r--r--   0 sedaro     (501) staff       (20)      443 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tags/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3075 2023-07-31 02:05:50.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tags/branches_api.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     1909 2023-07-31 02:05:51.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tags/data_api.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2120 2023-07-31 02:05:53.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tags/externals_api.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2329 2023-07-31 02:05:54.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tags/jobs_api.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2361 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tags/repositories_api.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     1953 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/apis/tags/templates_api.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    16766 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/configuration.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5946 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/exceptions.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.847464 sedaro-4.3.2/src/sedaro_base_client/model/
+-rw-r--r--   0 sedaro     (501) staff       (20)      352 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/model/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     9950 2023-07-31 02:02:05.000000 sedaro-4.3.2/src/sedaro_base_client/model/agent.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7462 2023-07-31 02:02:07.000000 sedaro-4.3.2/src/sedaro_base_client/model/agent_group.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3994 2023-07-31 02:02:07.000000 sedaro-4.3.2/src/sedaro_base_client/model/angle_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4228 2023-07-31 02:02:08.000000 sedaro-4.3.2/src/sedaro_base_client/model/angle_field_of_view30.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4229 2023-07-31 02:02:08.000000 sedaro-4.3.2/src/sedaro_base_client/model/angle_field_of_view35.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4229 2023-07-31 02:02:08.000000 sedaro-4.3.2/src/sedaro_base_client/model/angle_field_of_view36.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4162 2023-07-31 02:02:09.000000 sedaro-4.3.2/src/sedaro_base_client/model/angle_sensors20.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4162 2023-07-31 02:02:09.000000 sedaro-4.3.2/src/sedaro_base_client/model/angle_sensors51.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4162 2023-07-31 02:02:11.000000 sedaro-4.3.2/src/sedaro_base_client/model/angle_sensors56.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4331 2023-07-31 02:02:12.000000 sedaro-4.3.2/src/sedaro_base_client/model/angular_velocity_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    39268 2023-07-31 02:02:13.000000 sedaro-4.3.2/src/sedaro_base_client/model/angular_velocity_sensor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4499 2023-07-31 02:02:16.000000 sedaro-4.3.2/src/sedaro_base_client/model/angular_velocity_sensors84.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    35124 2023-07-31 02:02:18.000000 sedaro-4.3.2/src/sedaro_base_client/model/antenna.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11793 2023-07-31 02:02:24.000000 sedaro-4.3.2/src/sedaro_base_client/model/averaging_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4064 2023-07-31 02:02:24.000000 sedaro-4.3.2/src/sedaro_base_client/model/base_dissipations.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    23126 2023-07-31 02:02:25.000000 sedaro-4.3.2/src/sedaro_base_client/model/battery.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12037 2023-07-31 02:02:26.000000 sedaro-4.3.2/src/sedaro_base_client/model/battery_cell.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    41060 2023-07-31 02:02:28.000000 sedaro-4.3.2/src/sedaro_base_client/model/battery_pack.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5540 2023-07-31 02:02:34.000000 sedaro-4.3.2/src/sedaro_base_client/model/battery_pack_dissipations.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12028 2023-07-31 02:02:36.000000 sedaro-4.3.2/src/sedaro_base_client/model/body_frame_vector.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2578 2023-07-31 02:02:40.000000 sedaro-4.3.2/src/sedaro_base_client/model/body_frame_vector_types.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10547 2023-07-31 02:02:42.000000 sedaro-4.3.2/src/sedaro_base_client/model/body_in_fov_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8373 2023-07-31 02:02:44.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_changes_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4732 2023-07-31 02:02:44.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_create.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5454 2023-07-31 02:02:45.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_merge.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4899 2023-07-31 02:02:46.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_merge_conflicts_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11496 2023-07-31 02:02:47.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8984 2023-07-31 02:02:49.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_scenario_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4699 2023-07-31 02:03:12.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_update.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8982 2023-07-31 02:03:56.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_vehicle_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3929 2023-07-31 02:04:02.000000 sedaro-4.3.2/src/sedaro_base_client/model/branch_verify_password.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    20095 2023-07-31 02:04:05.000000 sedaro-4.3.2/src/sedaro_base_client/model/bus_regulator.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3114 2023-07-31 02:04:08.000000 sedaro-4.3.2/src/sedaro_base_client/model/categories.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3543 2023-07-31 02:04:08.000000 sedaro-4.3.2/src/sedaro_base_client/model/celestial_pointing_directions.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    25121 2023-07-31 02:04:09.000000 sedaro-4.3.2/src/sedaro_base_client/model/celestial_target.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12437 2023-07-31 02:04:12.000000 sedaro-4.3.2/src/sedaro_base_client/model/celestial_vector.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     9264 2023-07-31 02:04:13.000000 sedaro-4.3.2/src/sedaro_base_client/model/circular_field_of_view.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7431 2023-07-31 02:04:13.000000 sedaro-4.3.2/src/sedaro_base_client/model/classical_orbital_elements.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5984 2023-07-31 02:04:14.000000 sedaro-4.3.2/src/sedaro_base_client/model/clock_config.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    32674 2023-07-31 02:04:15.000000 sedaro-4.3.2/src/sedaro_base_client/model/component.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4885 2023-07-31 02:04:16.000000 sedaro-4.3.2/src/sedaro_base_client/model/component_dissipations.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2633 2023-07-31 02:04:16.000000 sedaro-4.3.2/src/sedaro_base_client/model/component_parameters.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12029 2023-07-31 02:04:17.000000 sedaro-4.3.2/src/sedaro_base_client/model/component_to_scalar_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13548 2023-07-31 02:04:18.000000 sedaro-4.3.2/src/sedaro_base_client/model/compound_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2621 2023-07-31 02:04:18.000000 sedaro-4.3.2/src/sedaro_base_client/model/compound_operators.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3043 2023-07-31 02:04:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/condition_relationship.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2544 2023-07-31 02:04:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/configuration_types.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4979 2023-07-31 02:04:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/conflicts_obj.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4070 2023-07-31 02:04:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/constant_power_params.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3996 2023-07-31 02:04:20.000000 sedaro-4.3.2/src/sedaro_base_client/model/constant_resistance_params.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    42307 2023-07-31 02:04:21.000000 sedaro-4.3.2/src/sedaro_base_client/model/cooler.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    15387 2023-07-31 02:04:22.000000 sedaro-4.3.2/src/sedaro_base_client/model/cooperative_transmit_interface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5989 2023-07-31 02:04:23.000000 sedaro-4.3.2/src/sedaro_base_client/model/crud_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     6700 2023-07-31 02:04:23.000000 sedaro-4.3.2/src/sedaro_base_client/model/data_bus.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10243 2023-07-31 02:04:24.000000 sedaro-4.3.2/src/sedaro_base_client/model/data_interface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10029 2023-07-31 02:04:24.000000 sedaro-4.3.2/src/sedaro_base_client/model/data_mode.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3916 2023-07-31 02:04:25.000000 sedaro-4.3.2/src/sedaro_base_client/model/data_service_response.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4397 2023-07-31 02:04:25.000000 sedaro-4.3.2/src/sedaro_base_client/model/data_set.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12735 2023-07-31 02:04:25.000000 sedaro-4.3.2/src/sedaro_base_client/model/data_storage.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4233 2023-07-31 02:04:26.000000 sedaro-4.3.2/src/sedaro_base_client/model/data_type.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4328 2023-07-31 02:04:26.000000 sedaro-4.3.2/src/sedaro_base_client/model/deleted_entity.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    41268 2023-07-31 02:04:27.000000 sedaro-4.3.2/src/sedaro_base_client/model/direction_sensor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5029 2023-07-31 02:04:28.000000 sedaro-4.3.2/src/sedaro_base_client/model/distance_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5197 2023-07-31 02:04:28.000000 sedaro-4.3.2/src/sedaro_base_client/model/distance_sensors72.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5081 2023-07-31 02:04:28.000000 sedaro-4.3.2/src/sedaro_base_client/model/duration_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5243 2023-07-31 02:04:28.000000 sedaro-4.3.2/src/sedaro_base_client/model/duration_load69.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5265 2023-07-31 02:04:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode18.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5265 2023-07-31 02:04:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode20.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5265 2023-07-31 02:04:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode22.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5265 2023-07-31 02:04:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode31.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5265 2023-07-31 02:04:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode33.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    17552 2023-07-31 02:04:30.000000 sedaro-4.3.2/src/sedaro_base_client/model/ekf_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5516 2023-07-31 02:04:31.000000 sedaro-4.3.2/src/sedaro_base_client/model/entity_delete_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2580 2023-07-31 02:04:31.000000 sedaro-4.3.2/src/sedaro_base_client/model/eps_output_types.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5831 2023-07-31 02:04:31.000000 sedaro-4.3.2/src/sedaro_base_client/model/equatorial_circular_reference_orbit.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5538 2023-07-31 02:04:31.000000 sedaro-4.3.2/src/sedaro_base_client/model/external_state_set_request.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    23122 2023-07-31 02:04:31.000000 sedaro-4.3.2/src/sedaro_base_client/model/fixed_surface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7263 2023-07-31 02:04:32.000000 sedaro-4.3.2/src/sedaro_base_client/model/frame_vector_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10075 2023-07-31 02:04:32.000000 sedaro-4.3.2/src/sedaro_base_client/model/fuel_reservoir.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    43609 2023-07-31 02:04:33.000000 sedaro-4.3.2/src/sedaro_base_client/model/fully_reg_det_power_processor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7591 2023-07-31 02:04:35.000000 sedaro-4.3.2/src/sedaro_base_client/model/fully_reg_det_topology_params.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5152 2023-07-31 02:04:35.000000 sedaro-4.3.2/src/sedaro_base_client/model/geostationary_reference_orbit.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     6637 2023-07-31 02:04:35.000000 sedaro-4.3.2/src/sedaro_base_client/model/geostationary_transfer_reference_orbit.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    17552 2023-07-31 02:04:35.000000 sedaro-4.3.2/src/sedaro_base_client/model/gps_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    35126 2023-07-31 02:04:36.000000 sedaro-4.3.2/src/sedaro_base_client/model/ground_target.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3388 2023-07-31 02:04:38.000000 sedaro-4.3.2/src/sedaro_base_client/model/group_rollers.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    40789 2023-07-31 02:04:38.000000 sedaro-4.3.2/src/sedaro_base_client/model/heater.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4822 2023-07-31 02:04:38.000000 sedaro-4.3.2/src/sedaro_base_client/model/http_validation_error.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2817 2023-07-31 02:04:39.000000 sedaro-4.3.2/src/sedaro_base_client/model/initial_state_def_type.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2584 2023-07-31 02:04:39.000000 sedaro-4.3.2/src/sedaro_base_client/model/input_types.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10779 2023-07-31 02:04:40.000000 sedaro-4.3.2/src/sedaro_base_client/model/internal_data_interface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5816 2023-07-31 02:04:40.000000 sedaro-4.3.2/src/sedaro_base_client/model/iss_reference_orbit.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    35140 2023-07-31 02:04:41.000000 sedaro-4.3.2/src/sedaro_base_client/model/laser_comm_module.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13725 2023-07-31 02:04:42.000000 sedaro-4.3.2/src/sedaro_base_client/model/load_state.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3961 2023-07-31 02:04:43.000000 sedaro-4.3.2/src/sedaro_base_client/model/local_pointing_directions.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13986 2023-07-31 02:04:43.000000 sedaro-4.3.2/src/sedaro_base_client/model/local_vector.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    15603 2023-07-31 02:04:44.000000 sedaro-4.3.2/src/sedaro_base_client/model/lock_pointing_mode.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    44833 2023-07-31 02:04:45.000000 sedaro-4.3.2/src/sedaro_base_client/model/magnetorquer.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14529 2023-07-31 02:04:46.000000 sedaro-4.3.2/src/sedaro_base_client/model/max_align_pointing_mode.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12545 2023-07-31 02:04:46.000000 sedaro-4.3.2/src/sedaro_base_client/model/mekf_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3893 2023-07-31 02:04:47.000000 sedaro-4.3.2/src/sedaro_base_client/model/message_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    34496 2023-07-31 02:04:47.000000 sedaro-4.3.2/src/sedaro_base_client/model/modem.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    22067 2023-07-31 02:04:48.000000 sedaro-4.3.2/src/sedaro_base_client/model/operational_mode.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    42085 2023-07-31 02:04:49.000000 sedaro-4.3.2/src/sedaro_base_client/model/optical_attitude_sensor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    20459 2023-07-31 02:04:50.000000 sedaro-4.3.2/src/sedaro_base_client/model/orbit.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7282 2023-07-31 02:04:51.000000 sedaro-4.3.2/src/sedaro_base_client/model/orbital_elements_data.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5688 2023-07-31 02:04:51.000000 sedaro-4.3.2/src/sedaro_base_client/model/panel_dissipations.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11121 2023-07-31 02:04:51.000000 sedaro-4.3.2/src/sedaro_base_client/model/passive_pointing_mode.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    15379 2023-07-31 02:04:52.000000 sedaro-4.3.2/src/sedaro_base_client/model/passive_transmit_interface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13543 2023-07-31 02:04:53.000000 sedaro-4.3.2/src/sedaro_base_client/model/per_round_external_state.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14202 2023-07-31 02:04:53.000000 sedaro-4.3.2/src/sedaro_base_client/model/pid_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     6517 2023-07-31 02:04:54.000000 sedaro-4.3.2/src/sedaro_base_client/model/polar_circular_reference_orbit.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3539 2023-07-31 02:04:54.000000 sedaro-4.3.2/src/sedaro_base_client/model/polynomial_ephemeris_body.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11706 2023-07-31 02:04:54.000000 sedaro-4.3.2/src/sedaro_base_client/model/position_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    39249 2023-07-31 02:04:55.000000 sedaro-4.3.2/src/sedaro_base_client/model/position_sensor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    16161 2023-07-31 02:04:57.000000 sedaro-4.3.2/src/sedaro_base_client/model/power_load.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    43587 2023-07-31 02:04:58.000000 sedaro-4.3.2/src/sedaro_base_client/model/power_processor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     6539 2023-07-31 02:04:59.000000 sedaro-4.3.2/src/sedaro_base_client/model/processor_dissipations.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    43609 2023-07-31 02:04:59.000000 sedaro-4.3.2/src/sedaro_base_client/model/quasi_reg_det_power_processor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7671 2023-07-31 02:05:01.000000 sedaro-4.3.2/src/sedaro_base_client/model/quasi_reg_det_topology_params.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8982 2023-07-31 02:05:01.000000 sedaro-4.3.2/src/sedaro_base_client/model/quaternion_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    45653 2023-07-31 02:05:02.000000 sedaro-4.3.2/src/sedaro_base_client/model/reaction_wheel.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    15363 2023-07-31 02:05:03.000000 sedaro-4.3.2/src/sedaro_base_client/model/receive_interface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12750 2023-07-31 02:05:03.000000 sedaro-4.3.2/src/sedaro_base_client/model/rectangular_field_of_view.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5831 2023-07-31 02:05:03.000000 sedaro-4.3.2/src/sedaro_base_client/model/repo_create_req.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4442 2023-07-31 02:05:04.000000 sedaro-4.3.2/src/sedaro_base_client/model/repo_import_req.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8993 2023-07-31 02:05:04.000000 sedaro-4.3.2/src/sedaro_base_client/model/repo_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5275 2023-07-31 02:05:04.000000 sedaro-4.3.2/src/sedaro_base_client/model/repo_update_req.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    16186 2023-07-31 02:05:04.000000 sedaro-4.3.2/src/sedaro_base_client/model/resistance_load.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10274 2023-07-31 02:05:05.000000 sedaro-4.3.2/src/sedaro_base_client/model/same_target_multi_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3387 2023-07-31 02:05:05.000000 sedaro-4.3.2/src/sedaro_base_client/model/satellite_parameters.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12993 2023-07-31 02:05:05.000000 sedaro-4.3.2/src/sedaro_base_client/model/satellite_to_satellite_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11278 2023-07-31 02:05:06.000000 sedaro-4.3.2/src/sedaro_base_client/model/satellite_to_scalar_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13744 2023-07-31 02:05:06.000000 sedaro-4.3.2/src/sedaro_base_client/model/satellite_to_target_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8567 2023-07-31 02:05:06.000000 sedaro-4.3.2/src/sedaro_base_client/model/scenario_template.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12281 2023-07-31 02:05:07.000000 sedaro-4.3.2/src/sedaro_base_client/model/scenario_template_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4120 2023-07-31 02:05:07.000000 sedaro-4.3.2/src/sedaro_base_client/model/scenario_template_root.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     9586 2023-07-31 02:05:07.000000 sedaro-4.3.2/src/sedaro_base_client/model/scenario_template_update_interface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2662 2023-07-31 02:05:08.000000 sedaro-4.3.2/src/sedaro_base_client/model/side_categories.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     9524 2023-07-31 02:05:08.000000 sedaro-4.3.2/src/sedaro_base_client/model/simulation_job.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    45116 2023-07-31 02:05:09.000000 sedaro-4.3.2/src/sedaro_base_client/model/single_conv_hybrid_power_processor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5791 2023-07-31 02:05:10.000000 sedaro-4.3.2/src/sedaro_base_client/model/single_conv_hybrid_topology_params.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    45112 2023-07-31 02:05:10.000000 sedaro-4.3.2/src/sedaro_base_client/model/single_conv_mppt_power_processor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4762 2023-07-31 02:05:11.000000 sedaro-4.3.2/src/sedaro_base_client/model/single_conv_mppt_topology_params.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12081 2023-07-31 02:05:11.000000 sedaro-4.3.2/src/sedaro_base_client/model/sliding_mode_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    15078 2023-07-31 02:05:12.000000 sedaro-4.3.2/src/sedaro_base_client/model/solar_array.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8989 2023-07-31 02:05:12.000000 sedaro-4.3.2/src/sedaro_base_client/model/solar_cell.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    48401 2023-07-31 02:05:13.000000 sedaro-4.3.2/src/sedaro_base_client/model/solar_panel.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    32667 2023-07-31 02:05:14.000000 sedaro-4.3.2/src/sedaro_base_client/model/space_target.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4811 2023-07-31 02:05:15.000000 sedaro-4.3.2/src/sedaro_base_client/model/spherical_angles.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    40803 2023-07-31 02:05:15.000000 sedaro-4.3.2/src/sedaro_base_client/model/spherical_fuel_tank.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    42280 2023-07-31 02:05:17.000000 sedaro-4.3.2/src/sedaro_base_client/model/spherocylinder_fuel_tank.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13549 2023-07-31 02:05:18.000000 sedaro-4.3.2/src/sedaro_base_client/model/spontaneous_external_state.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4769 2023-07-31 02:05:18.000000 sedaro-4.3.2/src/sedaro_base_client/model/state_vector.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     5456 2023-07-31 02:05:18.000000 sedaro-4.3.2/src/sedaro_base_client/model/static_thrust_control_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3128 2023-07-31 02:05:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/statuses.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11001 2023-07-31 02:05:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/subsystem.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     6412 2023-07-31 02:05:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/sun_synchronous_circular_orbit.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    29173 2023-07-31 02:05:19.000000 sedaro-4.3.2/src/sedaro_base_client/model/sun_tracking_surface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14273 2023-07-31 02:05:20.000000 sedaro-4.3.2/src/sedaro_base_client/model/surface_material.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11609 2023-07-31 02:05:21.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_group.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12457 2023-07-31 02:05:21.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_group_in_fov_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    21906 2023-07-31 02:05:22.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_group_to_satellite_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    20099 2023-07-31 02:05:22.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_group_to_scalar_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    22451 2023-07-31 02:05:23.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_group_to_target_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10211 2023-07-31 02:05:24.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_group_vector.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7240 2023-07-31 02:05:24.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_in_fov_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3954 2023-07-31 02:05:24.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_parameters.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11937 2023-07-31 02:05:25.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_to_scalar_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14323 2023-07-31 02:05:25.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_to_target_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10253 2023-07-31 02:05:25.000000 sedaro-4.3.2/src/sedaro_base_client/model/target_vector.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     9989 2023-07-31 02:05:26.000000 sedaro-4.3.2/src/sedaro_base_client/model/temp_controller_state.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4756 2023-07-31 02:05:26.000000 sedaro-4.3.2/src/sedaro_base_client/model/temperature_base306.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4476 2023-07-31 02:05:26.000000 sedaro-4.3.2/src/sedaro_base_client/model/template_crud_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    21742 2023-07-31 02:05:27.000000 sedaro-4.3.2/src/sedaro_base_client/model/thermal_interface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12283 2023-07-31 02:05:27.000000 sedaro-4.3.2/src/sedaro_base_client/model/thermal_interface_material.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    39988 2023-07-31 02:05:28.000000 sedaro-4.3.2/src/sedaro_base_client/model/thruster.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8780 2023-07-31 02:05:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/time_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     3815 2023-07-31 02:05:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/tle.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    11659 2023-07-31 02:05:29.000000 sedaro-4.3.2/src/sedaro_base_client/model/triad_algorithm.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    45106 2023-07-31 02:05:30.000000 sedaro-4.3.2/src/sedaro_base_client/model/two_conv_mppt_power_processor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7639 2023-07-31 02:05:31.000000 sedaro-4.3.2/src/sedaro_base_client/model/two_conv_mppt_topology_params.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     2723 2023-07-31 02:05:31.000000 sedaro-4.3.2/src/sedaro_base_client/model/types.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     8009 2023-07-31 02:05:32.000000 sedaro-4.3.2/src/sedaro_base_client/model/validation_error.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     4725 2023-07-31 02:05:32.000000 sedaro-4.3.2/src/sedaro_base_client/model/vector.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     7344 2023-07-31 02:05:32.000000 sedaro-4.3.2/src/sedaro_base_client/model/vector_in_fov_condition.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    38160 2023-07-31 02:05:33.000000 sedaro-4.3.2/src/sedaro_base_client/model/vector_sensor.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    29829 2023-07-31 02:05:34.000000 sedaro-4.3.2/src/sedaro_base_client/model/vector_tracking_surface.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    70286 2023-07-31 02:05:35.000000 sedaro-4.3.2/src/sedaro_base_client/model/vehicle_template.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    73999 2023-07-31 02:05:38.000000 sedaro-4.3.2/src/sedaro_base_client/model/vehicle_template_res.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    65847 2023-07-31 02:05:41.000000 sedaro-4.3.2/src/sedaro_base_client/model/vehicle_template_root.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    20389 2023-07-31 02:05:43.000000 sedaro-4.3.2/src/sedaro_base_client/model/vehicle_template_update_interface.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.849266 sedaro-4.3.2/src/sedaro_base_client/models/
+-rw-r--r--   0 sedaro     (501) staff       (20)    14776 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/models/__init__.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.850704 sedaro-4.3.2/src/sedaro_base_client/paths/
+-rw-r--r--   0 sedaro     (501) staff       (20)     1604 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/paths/__init__.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.854303 sedaro-4.3.2/src/sedaro_base_client/paths/data_id/
+-rw-r--r--   0 sedaro     (501) staff       (20)      309 2023-07-31 02:05:51.000000 sedaro-4.3.2/src/sedaro_base_client/paths/data_id/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13227 2023-07-31 02:05:51.000000 sedaro-4.3.2/src/sedaro_base_client/paths/data_id/get.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.863818 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/
+-rw-r--r--   0 sedaro     (501) staff       (20)      345 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10272 2023-07-31 02:05:45.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/delete.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10153 2023-07-31 02:05:45.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/get.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14210 2023-07-31 02:05:47.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/patch.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14214 2023-07-31 02:05:44.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/post.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.867977 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_changes_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      363 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_changes_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10314 2023-07-31 02:05:45.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_changes_/get.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.871729 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_commits_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      363 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_commits_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12511 2023-07-31 02:05:44.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_commits_/post.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.891436 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_committed_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      367 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_committed_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10325 2023-07-31 02:05:46.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_committed_/get.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.897851 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_export_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      361 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_export_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)     9952 2023-07-31 02:05:45.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_export_/get.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.900761 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_saved_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      359 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_saved_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10285 2023-07-31 02:05:46.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_saved_/get.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.903838 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_share_auth_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      368 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_share_auth_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14418 2023-07-31 02:05:48.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_share_auth_/post.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.906578 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_template/
+-rw-r--r--   0 sedaro     (501) staff       (20)      363 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_template/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    18071 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_template/patch.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.911028 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/
+-rw-r--r--   0 sedaro     (501) staff       (20)      411 2023-07-31 02:05:49.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    16249 2023-07-31 02:05:46.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/post.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.917208 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      335 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12039 2023-07-31 02:05:55.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_/post.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.920543 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories__import/
+-rw-r--r--   0 sedaro     (501) staff       (20)      349 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories__import/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12237 2023-07-31 02:05:55.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories__import/post.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.943740 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_repository_id/
+-rw-r--r--   0 sedaro     (501) staff       (20)      361 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_repository_id/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10280 2023-07-31 02:05:55.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_repository_id/delete.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10201 2023-07-31 02:05:55.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_repository_id/get.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14262 2023-07-31 02:05:56.000000 sedaro-4.3.2/src/sedaro_base_client/paths/models_repositories_repository_id/patch.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.948849 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/
+-rw-r--r--   0 sedaro     (501) staff       (20)      373 2023-07-31 02:05:54.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    14785 2023-07-31 02:05:53.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/get.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10289 2023-07-31 02:05:54.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/post.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.953167 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/
+-rw-r--r--   0 sedaro     (501) staff       (20)      385 2023-07-31 02:05:54.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10611 2023-07-31 02:05:54.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/delete.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    10530 2023-07-31 02:05:53.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/get.py
+drwxr-xr-x   0 sedaro     (501) staff       (20)        0 2023-07-31 18:43:48.956928 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/
+-rw-r--r--   0 sedaro     (501) staff       (20)      427 2023-07-31 02:05:52.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/__init__.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    13881 2023-07-31 02:05:52.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/get.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    15793 2023-07-31 02:05:52.000000 sedaro-4.3.2/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/patch.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    12103 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/rest.py
+-rw-r--r--   0 sedaro     (501) staff       (20)    99090 2023-07-31 02:05:57.000000 sedaro-4.3.2/src/sedaro_base_client/schemas.py
```

### Comparing `sedaro-4.3.1/LICENSE` & `sedaro-4.3.2/LICENSE`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/PKG-INFO` & `sedaro-4.3.2/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sedaro
-Version: 4.3.1
+Version: 4.3.2
 Summary: A python client to interact with the Sedaro API.
 Author-email: Sedaro <support@sedarotech.com>
 Project-URL: Homepage, https://github.com/sedaro/sedaro-python
 Project-URL: Bug Tracker, https://github.com/sedaro/sedaro-python/issues
 Classifier: Programming Language :: Python :: 3.8
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
@@ -172,14 +172,22 @@
 
 The `crud` method is also available for performing operations on multiple Sedaro blocks and/or root at the same time using kwargs as follows:
 
 - `root`: update fields on the root by passing a dictionary
 - `blocks`: create/update 1+ blocks by passing a list of dictionaries. If an `id` is present, the corresponding block will be updated. If an `id` isn't present, a new block will be created. The `type` is always required.
 - `delete`: delete 1+ blocks by passing a list of their block `id`s.
 
+In this method, relationship fields can point at existing `BlockID`'s or "ref id"s. A "ref id" is similar to a
+json "reference" and is used as follows:
+
+- It is any string starting with `'$'`.
+- It must be in the `id` field of a single `Block` dictionary created in this transaction.
+- It can be referenced in any relationship field on root or any `Block` dictionary in this transaction.
+- All instances of the "ref id" will be resolved to the corresponding created `Block`'s id.
+
 ```py
 branch.crud(
     root={ "field": "value" }, # update fields on root
     blocks=[
         { "id": "NXKzb4gSdLyThwudHSR4k", "type": "Modem", "field": "value" }, # update block
         { "type": "SolarCell",  "field": "value", ... }, # create block
     ],
@@ -282,14 +290,24 @@
   streams=selected_streams,
   axisOrder='TIME_MINOR'
 )
 ```
 
 See doc string in the `results_plain` for details on use of the arguments.
 
+## Bulk Download
+
+Use the following method to download larger datasets more efficiently. See the doc string for details on use of the arguments.
+
+```py
+sim.download()
+```
+
+This will produce a ZIP archive called `data.zip` in your working directory. Inside the ZIP archive, there will be one JSON file for each Agent, with the name `<agent UUID>.json`.
+
 ## Send Requests
 
 Use the built-in method to send custom requests to the host. See [OpenAPI Specification](https://sedaro.github.io/openapi/) for documentation on resource paths and body params.
 
 Through the `request` property, you can access `get`, `post`, `put`, `patch`, and `delete` methods.
 
 ```py
```

### Comparing `sedaro-4.3.1/README.md` & `sedaro-4.3.2/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -157,14 +157,22 @@
 
 The `crud` method is also available for performing operations on multiple Sedaro blocks and/or root at the same time using kwargs as follows:
 
 - `root`: update fields on the root by passing a dictionary
 - `blocks`: create/update 1+ blocks by passing a list of dictionaries. If an `id` is present, the corresponding block will be updated. If an `id` isn't present, a new block will be created. The `type` is always required.
 - `delete`: delete 1+ blocks by passing a list of their block `id`s.
 
+In this method, relationship fields can point at existing `BlockID`'s or "ref id"s. A "ref id" is similar to a
+json "reference" and is used as follows:
+
+- It is any string starting with `'$'`.
+- It must be in the `id` field of a single `Block` dictionary created in this transaction.
+- It can be referenced in any relationship field on root or any `Block` dictionary in this transaction.
+- All instances of the "ref id" will be resolved to the corresponding created `Block`'s id.
+
 ```py
 branch.crud(
     root={ "field": "value" }, # update fields on root
     blocks=[
         { "id": "NXKzb4gSdLyThwudHSR4k", "type": "Modem", "field": "value" }, # update block
         { "type": "SolarCell",  "field": "value", ... }, # create block
     ],
@@ -267,14 +275,24 @@
   streams=selected_streams,
   axisOrder='TIME_MINOR'
 )
 ```
 
 See doc string in the `results_plain` for details on use of the arguments.
 
+## Bulk Download
+
+Use the following method to download larger datasets more efficiently. See the doc string for details on use of the arguments.
+
+```py
+sim.download()
+```
+
+This will produce a ZIP archive called `data.zip` in your working directory. Inside the ZIP archive, there will be one JSON file for each Agent, with the name `<agent UUID>.json`.
+
 ## Send Requests
 
 Use the built-in method to send custom requests to the host. See [OpenAPI Specification](https://sedaro.github.io/openapi/) for documentation on resource paths and body params.
 
 Through the `request` property, you can access `get`, `post`, `put`, `patch`, and `delete` methods.
 
 ```py
```

### Comparing `sedaro-4.3.1/pyproject.toml` & `sedaro-4.3.2/pyproject.toml`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 [build-system]
 requires = [ "setuptools>=61.0",]
 build-backend = "setuptools.build_meta"
 
 [project]
 name = "sedaro"
-version = "4.3.1"
+version = "4.3.2"
 description = "A python client to interact with the Sedaro API."
 readme = "README.md"
 requires-python = ">=3.8"
 classifiers = [ "Programming Language :: Python :: 3.8", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: OS Independent", "Topic :: Software Development",]
 dependencies = [ "certifi >= 14.5.14", "frozendict ~= 2.3.4", "python-dateutil ~= 2.7.0", "setuptools >= 21.0.0", "typing_extensions ~= 4.3.0", "urllib3 ~= 1.26.7", "pydash >= 5.1.1", "scipy >= 1.10.1", "numpy",]
 [[project.authors]]
 name = "Sedaro"
```

### Comparing `sedaro-4.3.1/src/sedaro/branches/agent_template_branch.py` & `sedaro-4.3.2/src/sedaro/branches/agent_template_branch.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/branches/blocks/block.py` & `sedaro-4.3.2/src/sedaro/branches/blocks/block.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/branches/blocks/block_type.py` & `sedaro-4.3.2/src/sedaro/branches/blocks/block_type.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/branches/branch.py` & `sedaro-4.3.2/src/sedaro/branches/branch.py`

 * *Files 23% similar despite different names*

```diff
@@ -44,20 +44,28 @@
         *,
         root: 'Dict[str, Any]' = None,
         blocks: 'List[Dict]' = None,
         delete: 'List[str]' = None
     ) -> 'dict':
         """Method to perform multiple CRUD operations at the same time.
 
+        In this method, relationship fields can point at existing `BlockID`'s or "ref id"s. A "ref id" is similar to a
+        json "reference" and is used as follows:
+        - It is any string starting with `'$'`.
+        - It must be in the `id` field of a single `Block` dictionary created in this transaction.
+        - It can be referenced in any relationship field on root or any `Block` dictionary in this transaction.
+        - All instances of the "ref id" will be resolved to the corresponding created `Block`'s id.
+
         Args:
             root (dict, optional): a `dict` of field/value pairs to update on the `root` of the branch template this\
                 method is called on. Defaults to `None`.
-            blocks (list, optional): a `list` of Block dictionaries. If there is an `id` in the `dict`, updates an\
-                existing Block, otherwise creates a new Block. Defaults to `None`.
-            delete (list, optional): a list of `id`s of Blocks to be deleted. Defaults to `None`.
+            blocks (list, optional): a `list` of `Block` dictionaries. `Block` dictionaries with no `id` or a "ref id"\
+                will be created, otherwise they should have an `id` field referencing an existing block and the\
+                dictionary will be used to update the `Block`. Defaults to `None`.
+            delete (list, optional): a list of `id`s of `Block`s to be deleted. Defaults to `None`.
 
         Raises:
             SedaroApiException: if there is an error in the response
 
         Returns:
             dict: the response dictionary from the request
         """
```

### Comparing `sedaro-4.3.1/src/sedaro/branches/scenario_branch/scenario_branch.py` & `sedaro-4.3.2/src/sedaro/branches/scenario_branch/scenario_branch.py`

 * *Files 0% similar despite different names*

```diff
@@ -23,15 +23,15 @@
     @property
     def simulation(self) -> 'Simulation':
         """A `Simulation` instance to interact with the simulation connected to this scenario branch.
 
         Returns:
             Simulation: a `Simulation`
         """
-        return Simulation(self._sedaro, self.id)
+        return Simulation(self._sedaro, self)
 
     # ==============================================================================================================
     # For intellisense
     # ==============================================================================================================
 
     # SCENARIO
     Agent: BlockType
```

### Comparing `sedaro-4.3.1/src/sedaro/branches/scenario_branch/sim_client.py` & `sedaro-4.3.2/src/sedaro/branches/scenario_branch/sim_client.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,48 +1,59 @@
 import time
 from contextlib import contextmanager
 from typing import (TYPE_CHECKING, Any, Dict, Generator, List, Optional, Tuple,
                     Union)
+import concurrent.futures
+import json
+import math
+import os
+import pathlib
+import tempfile
+from threading import Lock
+import traceback
+from typing import Dict, List, Optional, Tuple
+from zipfile import ZipFile, ZIP_DEFLATED
 
-from sedaro_base_client.apis.tags import jobs_api
-from sedaro_base_client.apis.tags import externals_api
 import numpy as np
+from sedaro_base_client.apis.tags import externals_api, jobs_api
 
 from ...exceptions import NoSimResultsError, SedaroApiException
 from ...results import SimulationResult
 from ...settings import COMMON_API_KWARGS
 from ...utils import body_from_res, parse_urllib_response, progress_bar
 
 if TYPE_CHECKING:
+    from ...branches import ScenarioBranch
     from ...sedaro_api_client import SedaroApiClient
 
 
 def serdes(v):
     if type(v) is dict and 'ndarray' in v:
         return np.array(v['ndarray'])
     if type(v) is np.ndarray:
         return {'ndarray': v.tolist()}
     if type(v) is dict:
         return {k: serdes(v) for k, v in v.items()}
-    if type(v) is list:
+    if type(v) in {list, tuple}:
         return [serdes(v) for v in v]
     return v
 
 
 class Simulation:
     """A client to interact with the Sedaro API simulation (jobs) routes"""
 
-    def __init__(self, sedaro: 'SedaroApiClient', branch_id: int):
+    def __init__(self, sedaro: 'SedaroApiClient', branch: 'ScenarioBranch'):
         """Instantiate a Sedaro `Simulation` instance
 
         Args:
             sedaro (`SedaroApiClient`): the `SedaroApiClient`
             branch_id (`int`): id of the desired Sedaro Scenario Branch to interact with its simulations (jobs).
         """
-        self.__branch_id = branch_id
+        self.__branch = branch
+        self.__branch_id = branch.id
         self.__sedaro = sedaro
 
     @contextmanager
     def __jobs_client(self) -> Generator['jobs_api.JobsApi', Any, None]:
         with self.__sedaro.api_client() as api:
             yield jobs_api.JobsApi(api)
 
@@ -103,15 +114,15 @@
                         'branchId': self.__branch_id,
                         'jobId': job_id
                     },
                     **COMMON_API_KWARGS
                 )
                 return SimulationHandle(body_from_res(res), self)
 
-    def terminate(self, job_id: int = None) -> 'SimulationHandle':
+    def terminate(self, job_id: int = None) -> None:
         """Terminate latest running simulation job corresponding to the respective Sedaro Scenario Branch id. If a
         `job_id` is provided, that simulation job will be terminated rather than the latest.
 
         Args:
             job_id (`int`, optional): id of the simulation (job) to terminate.
 
         Raises:
@@ -120,23 +131,21 @@
         Returns:
             SimulationHandle
         """
         if job_id is None:
             job_id = self.status()['id']
 
         with self.__jobs_client() as jobs:
-
             jobs.terminate_simulation(
                 path_params={
                     'branchId': self.__branch_id,
                     'jobId': job_id
                 },
                 **COMMON_API_KWARGS
             )
-        return SimulationHandle(None, self)
 
     def results_plain(
         self,
         *,
         id: str = None,
         start: float = None,
         stop: float = None,
@@ -282,14 +291,100 @@
         while job['status'] in options:
             progress_bar(job['progress']['percentComplete'])
             job = self.status()
             time.sleep(retry_interval)
 
         return self.results(streams=streams or [])
 
+    def __download(self, p):
+        agents, id, dirname, progress, progress_lock = p
+        MAX_ATTEMPTS = 3
+        for agent in agents:
+            attempts = MAX_ATTEMPTS
+            while attempts > 0:
+                agentData = self.results_plain(
+                    id=id,
+                    limit=None,
+                    streams=[(agent,)],
+                )
+                if 'series' in agentData:
+                    break
+                else:
+                    print('Data retrieval failed. Retrying...')
+                    attempts -= 1
+            else:
+                raise Exception(
+                    f"Data retrieval for agent {agent} failed after {MAX_ATTEMPTS} attempts")
+            with open(f'{dirname}/{agent}.json', 'w') as fd:
+                progress_lock.acquire()
+                try:
+                    progress['count'] += 1
+                    progress_bar(
+                        (float(progress['count'] / progress['total'])) * 100.0)
+                finally:
+                    progress_lock.release()
+                json.dump(agentData, fd, indent=2)
+        return agents
+
+    def download(self, data_array_id: str = None, filename: str = 'sedaro.zip', agent_ids: List[str] = None, overwrite: bool = False):
+        if not overwrite and pathlib.Path(filename).exists():
+            raise FileExistsError(
+                f'The file {filename} already exists. Please delete it or provide a different filename via the `filename` argument.')
+
+        # create temp directory in which to build zip
+        archive = ZipFile(filename, 'w')
+        with tempfile.TemporaryDirectory() as dirname:
+            try:
+                # Eventually this should be updated to get the Agents from the model snapshot saved alongside the
+                # data in case the model changes prior to download.
+                agent_ids = agent_ids or self.__branch.Agent.get_all_ids()
+                if not data_array_id:
+                    data_array_id = self.status()['dataArray']
+
+                # get data for one agent at a time
+                MAX_CHUNKS = 4
+                if len(agent_ids) < MAX_CHUNKS:
+                    NUM_CHUNKS = len(agent_ids)
+                else:
+                    NUM_CHUNKS = MAX_CHUNKS
+                chunks = []
+                for _ in range(NUM_CHUNKS):
+                    chunks.append([])
+                for i in range(len(agent_ids)):
+                    chunks[i % NUM_CHUNKS].append(agent_ids[i])
+                progress = {'count': 0, 'total': len(agent_ids)}
+                progress_bar(
+                    (float(progress['count'] / progress['total'])) * 100.0)
+
+                with concurrent.futures.ThreadPoolExecutor(max_workers=NUM_CHUNKS) as executor:
+                    shared = (data_array_id, dirname, progress, Lock())
+                    done = executor.map(
+                        self.__download,
+                        [(c, *shared) for c in chunks]
+                    )
+                print(f'\nBuilding {filename}...')
+                for chunk in done:
+                    for agent in chunk:
+                        archive.write(f'{dirname}/{agent}.json',
+                                      f'{agent}.json', ZIP_DEFLATED)
+
+                # save zip file
+                archive.close()
+                print(f'Done. Created: {filename}')
+                print('See https://sedaro.github.io/openapi/#tag/Data for details on the data format of each individual JSON file in the archive.')
+
+            except Exception:
+                try:
+                    archive.close()
+                except Exception:
+                    pass
+                if pathlib.Path(filename).exists():
+                    os.remove(filename)
+                raise Exception("Unable to download data and build archive.")
+
 
 class SimulationJob:
     def __init__(self, job: Union[dict, None]): self.__job = job
     def get(self, key, default=None): return self.__job.get(key, default)
 
     def __getitem__(self, key):
         if self.__job:
@@ -321,26 +416,23 @@
 
         Raises:
             NoSimResultsError: if no simulation has been started and `err_if_empty` set to `True`
 
         Returns:
             SimulationHandle (self)
         """
-        self.__job = self.__sim_client.status(
-            self.__job['id'], err_if_empty=err_if_empty)
-        return self
+        return (self := self.__sim_client.status(self.__job['id'], err_if_empty=err_if_empty))
 
     def terminate(self):
         """Terminate the running simulation.
 
         Returns:
             SimulationHandle (self)
         """
         self.__sim_client.terminate(self.__job['id'])
-        self.__job = SimulationJob(None)
         return self
 
     def results_plain(
         self,
         start: float = None,
         stop: float = None,
         binWidth: float = None,
@@ -472,14 +564,14 @@
         with self.__sim_client.externals_client() as externals_client:
             response = externals_client.put_external(
                 path_params={
                     'jobId': self.__job['id'],
                     'agentId': agent_id,
                     'externalStateBlockId': external_state_id,
                 },
-                body=(
-                    {'values': [serdes(v) for v in values]} |
-                    ({'timestamp': timestamp} if timestamp is not None else {})
-                ),
+                body=({
+                    **{'values': [serdes(v) for v in values]},
+                    **({'timestamp': timestamp} if timestamp is not None else {})
+                }),
                 **COMMON_API_KWARGS,
             )
         return tuple(serdes(v) for v in body_from_res(response))
```

### Comparing `sedaro-4.3.1/src/sedaro/exceptions.py` & `sedaro-4.3.2/src/sedaro/exceptions.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/plain_request.py` & `sedaro-4.3.2/src/sedaro/plain_request.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/results/agent.py` & `sedaro-4.3.2/src/sedaro/results/agent.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/results/block.py` & `sedaro-4.3.2/src/sedaro/results/block.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/results/series.py` & `sedaro-4.3.2/src/sedaro/results/series.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/results/simulation_result.py` & `sedaro-4.3.2/src/sedaro/results/simulation_result.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/results/utils.py` & `sedaro-4.3.2/src/sedaro/results/utils.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/sedaro_api_client.py` & `sedaro-4.3.2/src/sedaro/sedaro_api_client.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/settings.py` & `sedaro-4.3.2/src/sedaro/settings.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro/utils.py` & `sedaro-4.3.2/src/sedaro/utils.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro.egg-info/PKG-INFO` & `sedaro-4.3.2/src/sedaro.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sedaro
-Version: 4.3.1
+Version: 4.3.2
 Summary: A python client to interact with the Sedaro API.
 Author-email: Sedaro <support@sedarotech.com>
 Project-URL: Homepage, https://github.com/sedaro/sedaro-python
 Project-URL: Bug Tracker, https://github.com/sedaro/sedaro-python/issues
 Classifier: Programming Language :: Python :: 3.8
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
@@ -172,14 +172,22 @@
 
 The `crud` method is also available for performing operations on multiple Sedaro blocks and/or root at the same time using kwargs as follows:
 
 - `root`: update fields on the root by passing a dictionary
 - `blocks`: create/update 1+ blocks by passing a list of dictionaries. If an `id` is present, the corresponding block will be updated. If an `id` isn't present, a new block will be created. The `type` is always required.
 - `delete`: delete 1+ blocks by passing a list of their block `id`s.
 
+In this method, relationship fields can point at existing `BlockID`'s or "ref id"s. A "ref id" is similar to a
+json "reference" and is used as follows:
+
+- It is any string starting with `'$'`.
+- It must be in the `id` field of a single `Block` dictionary created in this transaction.
+- It can be referenced in any relationship field on root or any `Block` dictionary in this transaction.
+- All instances of the "ref id" will be resolved to the corresponding created `Block`'s id.
+
 ```py
 branch.crud(
     root={ "field": "value" }, # update fields on root
     blocks=[
         { "id": "NXKzb4gSdLyThwudHSR4k", "type": "Modem", "field": "value" }, # update block
         { "type": "SolarCell",  "field": "value", ... }, # create block
     ],
@@ -282,14 +290,24 @@
   streams=selected_streams,
   axisOrder='TIME_MINOR'
 )
 ```
 
 See doc string in the `results_plain` for details on use of the arguments.
 
+## Bulk Download
+
+Use the following method to download larger datasets more efficiently. See the doc string for details on use of the arguments.
+
+```py
+sim.download()
+```
+
+This will produce a ZIP archive called `data.zip` in your working directory. Inside the ZIP archive, there will be one JSON file for each Agent, with the name `<agent UUID>.json`.
+
 ## Send Requests
 
 Use the built-in method to send custom requests to the host. See [OpenAPI Specification](https://sedaro.github.io/openapi/) for documentation on resource paths and body params.
 
 Through the `request` property, you can access `get`, `post`, `put`, `patch`, and `delete` methods.
 
 ```py
```

### Comparing `sedaro-4.3.1/src/sedaro.egg-info/SOURCES.txt` & `sedaro-4.3.2/src/sedaro.egg-info/SOURCES.txt`

 * *Files 8% similar despite different names*

```diff
@@ -35,52 +35,60 @@
 src/sedaro_base_client/schemas.py
 src/sedaro_base_client/apis/__init__.py
 src/sedaro_base_client/apis/path_to_api.py
 src/sedaro_base_client/apis/tag_to_api.py
 src/sedaro_base_client/apis/paths/__init__.py
 src/sedaro_base_client/apis/paths/data_id.py
 src/sedaro_base_client/apis/paths/models_branches_branch_id.py
+src/sedaro_base_client/apis/paths/models_branches_branch_id_changes_.py
+src/sedaro_base_client/apis/paths/models_branches_branch_id_commits_.py
+src/sedaro_base_client/apis/paths/models_branches_branch_id_committed_.py
+src/sedaro_base_client/apis/paths/models_branches_branch_id_export_.py
+src/sedaro_base_client/apis/paths/models_branches_branch_id_saved_.py
+src/sedaro_base_client/apis/paths/models_branches_branch_id_share_auth_.py
 src/sedaro_base_client/apis/paths/models_branches_branch_id_template.py
-src/sedaro_base_client/apis/paths/models_branches_branch_idcommits_.py
-src/sedaro_base_client/apis/paths/models_branches_branch_idcommitted_.py
-src/sedaro_base_client/apis/paths/models_branches_branch_idsaved_.py
-src/sedaro_base_client/apis/paths/models_branches_branch_idshare_auth_.py
 src/sedaro_base_client/apis/paths/models_branches_current_branch_id_merge_incoming_branch_id.py
+src/sedaro_base_client/apis/paths/models_repositories_.py
+src/sedaro_base_client/apis/paths/models_repositories__import.py
+src/sedaro_base_client/apis/paths/models_repositories_repository_id.py
 src/sedaro_base_client/apis/paths/simulations_branches_branch_id_control_.py
 src/sedaro_base_client/apis/paths/simulations_branches_branch_id_control_job_id.py
 src/sedaro_base_client/apis/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id.py
 src/sedaro_base_client/apis/tags/__init__.py
 src/sedaro_base_client/apis/tags/branches_api.py
 src/sedaro_base_client/apis/tags/data_api.py
 src/sedaro_base_client/apis/tags/externals_api.py
 src/sedaro_base_client/apis/tags/jobs_api.py
+src/sedaro_base_client/apis/tags/repositories_api.py
 src/sedaro_base_client/apis/tags/templates_api.py
 src/sedaro_base_client/model/__init__.py
 src/sedaro_base_client/model/agent.py
 src/sedaro_base_client/model/agent_group.py
-src/sedaro_base_client/model/angle_base299.py
-src/sedaro_base_client/model/angle_field_of_view31.py
+src/sedaro_base_client/model/angle_base306.py
+src/sedaro_base_client/model/angle_field_of_view30.py
+src/sedaro_base_client/model/angle_field_of_view35.py
 src/sedaro_base_client/model/angle_field_of_view36.py
-src/sedaro_base_client/model/angle_field_of_view37.py
 src/sedaro_base_client/model/angle_sensors20.py
 src/sedaro_base_client/model/angle_sensors51.py
 src/sedaro_base_client/model/angle_sensors56.py
-src/sedaro_base_client/model/angular_velocity_base299.py
+src/sedaro_base_client/model/angular_velocity_base306.py
 src/sedaro_base_client/model/angular_velocity_sensor.py
-src/sedaro_base_client/model/angular_velocity_sensors82.py
+src/sedaro_base_client/model/angular_velocity_sensors84.py
 src/sedaro_base_client/model/antenna.py
 src/sedaro_base_client/model/averaging_algorithm.py
+src/sedaro_base_client/model/base_dissipations.py
 src/sedaro_base_client/model/battery.py
 src/sedaro_base_client/model/battery_cell.py
 src/sedaro_base_client/model/battery_pack.py
+src/sedaro_base_client/model/battery_pack_dissipations.py
 src/sedaro_base_client/model/body_frame_vector.py
 src/sedaro_base_client/model/body_frame_vector_types.py
 src/sedaro_base_client/model/body_in_fov_condition.py
+src/sedaro_base_client/model/branch_changes_res.py
 src/sedaro_base_client/model/branch_create.py
-src/sedaro_base_client/model/branch_delete_res.py
 src/sedaro_base_client/model/branch_merge.py
 src/sedaro_base_client/model/branch_merge_conflicts_res.py
 src/sedaro_base_client/model/branch_res.py
 src/sedaro_base_client/model/branch_scenario_res.py
 src/sedaro_base_client/model/branch_update.py
 src/sedaro_base_client/model/branch_vehicle_res.py
 src/sedaro_base_client/model/branch_verify_password.py
@@ -89,14 +97,15 @@
 src/sedaro_base_client/model/celestial_pointing_directions.py
 src/sedaro_base_client/model/celestial_target.py
 src/sedaro_base_client/model/celestial_vector.py
 src/sedaro_base_client/model/circular_field_of_view.py
 src/sedaro_base_client/model/classical_orbital_elements.py
 src/sedaro_base_client/model/clock_config.py
 src/sedaro_base_client/model/component.py
+src/sedaro_base_client/model/component_dissipations.py
 src/sedaro_base_client/model/component_parameters.py
 src/sedaro_base_client/model/component_to_scalar_condition.py
 src/sedaro_base_client/model/compound_condition.py
 src/sedaro_base_client/model/compound_operators.py
 src/sedaro_base_client/model/condition_relationship.py
 src/sedaro_base_client/model/configuration_types.py
 src/sedaro_base_client/model/conflicts_obj.py
@@ -110,27 +119,30 @@
 src/sedaro_base_client/model/data_mode.py
 src/sedaro_base_client/model/data_service_response.py
 src/sedaro_base_client/model/data_set.py
 src/sedaro_base_client/model/data_storage.py
 src/sedaro_base_client/model/data_type.py
 src/sedaro_base_client/model/deleted_entity.py
 src/sedaro_base_client/model/direction_sensor.py
-src/sedaro_base_client/model/distance_sensors70.py
-src/sedaro_base_client/model/duration_load70.py
+src/sedaro_base_client/model/distance_base306.py
+src/sedaro_base_client/model/distance_sensors72.py
+src/sedaro_base_client/model/duration_base306.py
+src/sedaro_base_client/model/duration_load69.py
 src/sedaro_base_client/model/duration_operational_mode18.py
-src/sedaro_base_client/model/duration_operational_mode19.py
 src/sedaro_base_client/model/duration_operational_mode20.py
-src/sedaro_base_client/model/duration_operational_mode28.py
-src/sedaro_base_client/model/duration_operational_mode29.py
+src/sedaro_base_client/model/duration_operational_mode22.py
+src/sedaro_base_client/model/duration_operational_mode31.py
+src/sedaro_base_client/model/duration_operational_mode33.py
 src/sedaro_base_client/model/ekf_algorithm.py
+src/sedaro_base_client/model/entity_delete_res.py
 src/sedaro_base_client/model/eps_output_types.py
 src/sedaro_base_client/model/equatorial_circular_reference_orbit.py
 src/sedaro_base_client/model/external_state_set_request.py
 src/sedaro_base_client/model/fixed_surface.py
-src/sedaro_base_client/model/frame_vector_base299.py
+src/sedaro_base_client/model/frame_vector_base306.py
 src/sedaro_base_client/model/fuel_reservoir.py
 src/sedaro_base_client/model/fully_reg_det_power_processor.py
 src/sedaro_base_client/model/fully_reg_det_topology_params.py
 src/sedaro_base_client/model/geostationary_reference_orbit.py
 src/sedaro_base_client/model/geostationary_transfer_reference_orbit.py
 src/sedaro_base_client/model/gps_algorithm.py
 src/sedaro_base_client/model/ground_target.py
@@ -151,40 +163,46 @@
 src/sedaro_base_client/model/mekf_algorithm.py
 src/sedaro_base_client/model/message_res.py
 src/sedaro_base_client/model/modem.py
 src/sedaro_base_client/model/operational_mode.py
 src/sedaro_base_client/model/optical_attitude_sensor.py
 src/sedaro_base_client/model/orbit.py
 src/sedaro_base_client/model/orbital_elements_data.py
+src/sedaro_base_client/model/panel_dissipations.py
 src/sedaro_base_client/model/passive_pointing_mode.py
 src/sedaro_base_client/model/passive_transmit_interface.py
 src/sedaro_base_client/model/per_round_external_state.py
 src/sedaro_base_client/model/pid_algorithm.py
 src/sedaro_base_client/model/polar_circular_reference_orbit.py
 src/sedaro_base_client/model/polynomial_ephemeris_body.py
-src/sedaro_base_client/model/position_base299.py
+src/sedaro_base_client/model/position_base306.py
 src/sedaro_base_client/model/position_sensor.py
 src/sedaro_base_client/model/power_load.py
 src/sedaro_base_client/model/power_processor.py
+src/sedaro_base_client/model/processor_dissipations.py
 src/sedaro_base_client/model/quasi_reg_det_power_processor.py
 src/sedaro_base_client/model/quasi_reg_det_topology_params.py
-src/sedaro_base_client/model/quaternion_base299.py
+src/sedaro_base_client/model/quaternion_base306.py
 src/sedaro_base_client/model/reaction_wheel.py
 src/sedaro_base_client/model/receive_interface.py
 src/sedaro_base_client/model/rectangular_field_of_view.py
+src/sedaro_base_client/model/repo_create_req.py
+src/sedaro_base_client/model/repo_import_req.py
+src/sedaro_base_client/model/repo_res.py
+src/sedaro_base_client/model/repo_update_req.py
 src/sedaro_base_client/model/resistance_load.py
 src/sedaro_base_client/model/same_target_multi_condition.py
-src/sedaro_base_client/model/satellite.py
 src/sedaro_base_client/model/satellite_parameters.py
 src/sedaro_base_client/model/satellite_to_satellite_condition.py
 src/sedaro_base_client/model/satellite_to_scalar_condition.py
 src/sedaro_base_client/model/satellite_to_target_condition.py
-src/sedaro_base_client/model/scenario_template_crud.py
+src/sedaro_base_client/model/scenario_template.py
 src/sedaro_base_client/model/scenario_template_res.py
-src/sedaro_base_client/model/scenario_template_update.py
+src/sedaro_base_client/model/scenario_template_root.py
+src/sedaro_base_client/model/scenario_template_update_interface.py
 src/sedaro_base_client/model/side_categories.py
 src/sedaro_base_client/model/simulation_job.py
 src/sedaro_base_client/model/single_conv_hybrid_power_processor.py
 src/sedaro_base_client/model/single_conv_hybrid_topology_params.py
 src/sedaro_base_client/model/single_conv_mppt_power_processor.py
 src/sedaro_base_client/model/single_conv_mppt_topology_params.py
 src/sedaro_base_client/model/sliding_mode_algorithm.py
@@ -211,15 +229,15 @@
 src/sedaro_base_client/model/target_group_vector.py
 src/sedaro_base_client/model/target_in_fov_condition.py
 src/sedaro_base_client/model/target_parameters.py
 src/sedaro_base_client/model/target_to_scalar_condition.py
 src/sedaro_base_client/model/target_to_target_condition.py
 src/sedaro_base_client/model/target_vector.py
 src/sedaro_base_client/model/temp_controller_state.py
-src/sedaro_base_client/model/temperature_base299.py
+src/sedaro_base_client/model/temperature_base306.py
 src/sedaro_base_client/model/template_crud_res.py
 src/sedaro_base_client/model/thermal_interface.py
 src/sedaro_base_client/model/thermal_interface_material.py
 src/sedaro_base_client/model/thruster.py
 src/sedaro_base_client/model/time_condition.py
 src/sedaro_base_client/model/tle.py
 src/sedaro_base_client/model/triad_algorithm.py
@@ -227,38 +245,51 @@
 src/sedaro_base_client/model/two_conv_mppt_topology_params.py
 src/sedaro_base_client/model/types.py
 src/sedaro_base_client/model/validation_error.py
 src/sedaro_base_client/model/vector.py
 src/sedaro_base_client/model/vector_in_fov_condition.py
 src/sedaro_base_client/model/vector_sensor.py
 src/sedaro_base_client/model/vector_tracking_surface.py
-src/sedaro_base_client/model/vehicle_template_crud.py
+src/sedaro_base_client/model/vehicle_template.py
 src/sedaro_base_client/model/vehicle_template_res.py
-src/sedaro_base_client/model/vehicle_template_update.py
+src/sedaro_base_client/model/vehicle_template_root.py
+src/sedaro_base_client/model/vehicle_template_update_interface.py
 src/sedaro_base_client/models/__init__.py
 src/sedaro_base_client/paths/__init__.py
 src/sedaro_base_client/paths/data_id/__init__.py
 src/sedaro_base_client/paths/data_id/get.py
 src/sedaro_base_client/paths/models_branches_branch_id/__init__.py
 src/sedaro_base_client/paths/models_branches_branch_id/delete.py
 src/sedaro_base_client/paths/models_branches_branch_id/get.py
 src/sedaro_base_client/paths/models_branches_branch_id/patch.py
 src/sedaro_base_client/paths/models_branches_branch_id/post.py
+src/sedaro_base_client/paths/models_branches_branch_id_changes_/__init__.py
+src/sedaro_base_client/paths/models_branches_branch_id_changes_/get.py
+src/sedaro_base_client/paths/models_branches_branch_id_commits_/__init__.py
+src/sedaro_base_client/paths/models_branches_branch_id_commits_/post.py
+src/sedaro_base_client/paths/models_branches_branch_id_committed_/__init__.py
+src/sedaro_base_client/paths/models_branches_branch_id_committed_/get.py
+src/sedaro_base_client/paths/models_branches_branch_id_export_/__init__.py
+src/sedaro_base_client/paths/models_branches_branch_id_export_/get.py
+src/sedaro_base_client/paths/models_branches_branch_id_saved_/__init__.py
+src/sedaro_base_client/paths/models_branches_branch_id_saved_/get.py
+src/sedaro_base_client/paths/models_branches_branch_id_share_auth_/__init__.py
+src/sedaro_base_client/paths/models_branches_branch_id_share_auth_/post.py
 src/sedaro_base_client/paths/models_branches_branch_id_template/__init__.py
 src/sedaro_base_client/paths/models_branches_branch_id_template/patch.py
-src/sedaro_base_client/paths/models_branches_branch_idcommits_/__init__.py
-src/sedaro_base_client/paths/models_branches_branch_idcommits_/post.py
-src/sedaro_base_client/paths/models_branches_branch_idcommitted_/__init__.py
-src/sedaro_base_client/paths/models_branches_branch_idcommitted_/get.py
-src/sedaro_base_client/paths/models_branches_branch_idsaved_/__init__.py
-src/sedaro_base_client/paths/models_branches_branch_idsaved_/get.py
-src/sedaro_base_client/paths/models_branches_branch_idshare_auth_/__init__.py
-src/sedaro_base_client/paths/models_branches_branch_idshare_auth_/post.py
 src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/__init__.py
 src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/post.py
+src/sedaro_base_client/paths/models_repositories_/__init__.py
+src/sedaro_base_client/paths/models_repositories_/post.py
+src/sedaro_base_client/paths/models_repositories__import/__init__.py
+src/sedaro_base_client/paths/models_repositories__import/post.py
+src/sedaro_base_client/paths/models_repositories_repository_id/__init__.py
+src/sedaro_base_client/paths/models_repositories_repository_id/delete.py
+src/sedaro_base_client/paths/models_repositories_repository_id/get.py
+src/sedaro_base_client/paths/models_repositories_repository_id/patch.py
 src/sedaro_base_client/paths/simulations_branches_branch_id_control_/__init__.py
 src/sedaro_base_client/paths/simulations_branches_branch_id_control_/get.py
 src/sedaro_base_client/paths/simulations_branches_branch_id_control_/post.py
 src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/__init__.py
 src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/delete.py
 src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/get.py
 src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/__init__.py
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/__init__.py` & `sedaro-4.3.2/src/sedaro_base_client/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 # coding: utf-8
 
 # flake8: noqa
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 __version__ = "1.0.0"
 
 # import ApiClient
 from sedaro_base_client.api_client import ApiClient
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/api_client.py` & `sedaro-4.3.2/src/sedaro_base_client/api_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # coding: utf-8
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from dataclasses import dataclass
 from decimal import Decimal
 import enum
 import email
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/apis/path_to_api.py` & `sedaro-4.3.2/src/sedaro_base_client/apis/path_to_api.py`

 * *Files 19% similar despite different names*

```diff
@@ -2,46 +2,61 @@
 
 from sedaro_base_client.paths import PathValues
 from sedaro_base_client.apis.paths.models_branches_branch_id_template import ModelsBranchesBranchIdTemplate
 from sedaro_base_client.apis.paths.simulations_branches_branch_id_control_ import SimulationsBranchesBranchIdControl
 from sedaro_base_client.apis.paths.simulations_branches_branch_id_control_job_id import SimulationsBranchesBranchIdControlJobId
 from sedaro_base_client.apis.paths.simulations_jobs_job_id_externals_agent_id_external_state_block_id import SimulationsJobsJobIdExternalsAgentIdExternalStateBlockId
 from sedaro_base_client.apis.paths.data_id import DataId
+from sedaro_base_client.apis.paths.models_repositories_ import ModelsRepositories
+from sedaro_base_client.apis.paths.models_repositories_repository_id import ModelsRepositoriesRepositoryId
+from sedaro_base_client.apis.paths.models_repositories__import import ModelsRepositoriesImport
 from sedaro_base_client.apis.paths.models_branches_branch_id import ModelsBranchesBranchId
-from sedaro_base_client.apis.paths.models_branches_branch_idshare_auth_ import ModelsBranchesBranchIdshareAuth
-from sedaro_base_client.apis.paths.models_branches_branch_idcommits_ import ModelsBranchesBranchIdcommits
+from sedaro_base_client.apis.paths.models_branches_branch_id_share_auth_ import ModelsBranchesBranchIdShareAuth
+from sedaro_base_client.apis.paths.models_branches_branch_id_commits_ import ModelsBranchesBranchIdCommits
 from sedaro_base_client.apis.paths.models_branches_current_branch_id_merge_incoming_branch_id import ModelsBranchesCurrentBranchIdMergeIncomingBranchId
-from sedaro_base_client.apis.paths.models_branches_branch_idcommitted_ import ModelsBranchesBranchIdcommitted
-from sedaro_base_client.apis.paths.models_branches_branch_idsaved_ import ModelsBranchesBranchIdsaved
+from sedaro_base_client.apis.paths.models_branches_branch_id_committed_ import ModelsBranchesBranchIdCommitted
+from sedaro_base_client.apis.paths.models_branches_branch_id_saved_ import ModelsBranchesBranchIdSaved
+from sedaro_base_client.apis.paths.models_branches_branch_id_changes_ import ModelsBranchesBranchIdChanges
+from sedaro_base_client.apis.paths.models_branches_branch_id_export_ import ModelsBranchesBranchIdExport
 
 PathToApi = typing_extensions.TypedDict(
     'PathToApi',
     {
         PathValues.MODELS_BRANCHES_BRANCH_ID_TEMPLATE: ModelsBranchesBranchIdTemplate,
         PathValues.SIMULATIONS_BRANCHES_BRANCH_ID_CONTROL_: SimulationsBranchesBranchIdControl,
         PathValues.SIMULATIONS_BRANCHES_BRANCH_ID_CONTROL_JOB_ID: SimulationsBranchesBranchIdControlJobId,
         PathValues.SIMULATIONS_JOBS_JOB_ID_EXTERNALS_AGENT_ID_EXTERNAL_STATE_BLOCK_ID: SimulationsJobsJobIdExternalsAgentIdExternalStateBlockId,
         PathValues.DATA_ID: DataId,
+        PathValues.MODELS_REPOSITORIES_: ModelsRepositories,
+        PathValues.MODELS_REPOSITORIES_REPOSITORY_ID: ModelsRepositoriesRepositoryId,
+        PathValues.MODELS_REPOSITORIES__IMPORT: ModelsRepositoriesImport,
         PathValues.MODELS_BRANCHES_BRANCH_ID: ModelsBranchesBranchId,
-        PathValues.MODELS_BRANCHES_BRANCH_IDSHAREAUTH_: ModelsBranchesBranchIdshareAuth,
-        PathValues.MODELS_BRANCHES_BRANCH_IDCOMMITS_: ModelsBranchesBranchIdcommits,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_SHAREAUTH_: ModelsBranchesBranchIdShareAuth,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_COMMITS_: ModelsBranchesBranchIdCommits,
         PathValues.MODELS_BRANCHES_CURRENT_BRANCH_ID_MERGE_INCOMING_BRANCH_ID: ModelsBranchesCurrentBranchIdMergeIncomingBranchId,
-        PathValues.MODELS_BRANCHES_BRANCH_IDCOMMITTED_: ModelsBranchesBranchIdcommitted,
-        PathValues.MODELS_BRANCHES_BRANCH_IDSAVED_: ModelsBranchesBranchIdsaved,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_COMMITTED_: ModelsBranchesBranchIdCommitted,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_SAVED_: ModelsBranchesBranchIdSaved,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_CHANGES_: ModelsBranchesBranchIdChanges,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_EXPORT_: ModelsBranchesBranchIdExport,
     }
 )
 
 path_to_api = PathToApi(
     {
         PathValues.MODELS_BRANCHES_BRANCH_ID_TEMPLATE: ModelsBranchesBranchIdTemplate,
         PathValues.SIMULATIONS_BRANCHES_BRANCH_ID_CONTROL_: SimulationsBranchesBranchIdControl,
         PathValues.SIMULATIONS_BRANCHES_BRANCH_ID_CONTROL_JOB_ID: SimulationsBranchesBranchIdControlJobId,
         PathValues.SIMULATIONS_JOBS_JOB_ID_EXTERNALS_AGENT_ID_EXTERNAL_STATE_BLOCK_ID: SimulationsJobsJobIdExternalsAgentIdExternalStateBlockId,
         PathValues.DATA_ID: DataId,
+        PathValues.MODELS_REPOSITORIES_: ModelsRepositories,
+        PathValues.MODELS_REPOSITORIES_REPOSITORY_ID: ModelsRepositoriesRepositoryId,
+        PathValues.MODELS_REPOSITORIES__IMPORT: ModelsRepositoriesImport,
         PathValues.MODELS_BRANCHES_BRANCH_ID: ModelsBranchesBranchId,
-        PathValues.MODELS_BRANCHES_BRANCH_IDSHAREAUTH_: ModelsBranchesBranchIdshareAuth,
-        PathValues.MODELS_BRANCHES_BRANCH_IDCOMMITS_: ModelsBranchesBranchIdcommits,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_SHAREAUTH_: ModelsBranchesBranchIdShareAuth,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_COMMITS_: ModelsBranchesBranchIdCommits,
         PathValues.MODELS_BRANCHES_CURRENT_BRANCH_ID_MERGE_INCOMING_BRANCH_ID: ModelsBranchesCurrentBranchIdMergeIncomingBranchId,
-        PathValues.MODELS_BRANCHES_BRANCH_IDCOMMITTED_: ModelsBranchesBranchIdcommitted,
-        PathValues.MODELS_BRANCHES_BRANCH_IDSAVED_: ModelsBranchesBranchIdsaved,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_COMMITTED_: ModelsBranchesBranchIdCommitted,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_SAVED_: ModelsBranchesBranchIdSaved,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_CHANGES_: ModelsBranchesBranchIdChanges,
+        PathValues.MODELS_BRANCHES_BRANCH_ID_EXPORT_: ModelsBranchesBranchIdExport,
     }
 )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/apis/tag_to_api.py` & `sedaro-4.3.2/src/sedaro_base_client/apis/tag_to_api.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,28 +2,31 @@
 
 from sedaro_base_client.apis.tags import TagValues
 from sedaro_base_client.apis.tags.branches_api import BranchesApi
 from sedaro_base_client.apis.tags.data_api import DataApi
 from sedaro_base_client.apis.tags.templates_api import TemplatesApi
 from sedaro_base_client.apis.tags.externals_api import ExternalsApi
 from sedaro_base_client.apis.tags.jobs_api import JobsApi
+from sedaro_base_client.apis.tags.repositories_api import RepositoriesApi
 
 TagToApi = typing_extensions.TypedDict(
     'TagToApi',
     {
         TagValues.BRANCHES: BranchesApi,
         TagValues.DATA: DataApi,
         TagValues.TEMPLATES: TemplatesApi,
         TagValues.EXTERNALS: ExternalsApi,
         TagValues.JOBS: JobsApi,
+        TagValues.REPOSITORIES: RepositoriesApi,
     }
 )
 
 tag_to_api = TagToApi(
     {
         TagValues.BRANCHES: BranchesApi,
         TagValues.DATA: DataApi,
         TagValues.TEMPLATES: TemplatesApi,
         TagValues.EXTERNALS: ExternalsApi,
         TagValues.JOBS: JobsApi,
+        TagValues.REPOSITORIES: RepositoriesApi,
     }
 )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/apis/tags/branches_api.py` & `sedaro-4.3.2/src/sedaro_base_client/apis/tags/branches_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,34 +1,38 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
-from sedaro_base_client.paths.models_branches_branch_idcommits_.post import CommitToBranch
+from sedaro_base_client.paths.models_branches_branch_id_commits_.post import CommitToBranch
 from sedaro_base_client.paths.models_branches_branch_id.post import CreateBranch
 from sedaro_base_client.paths.models_branches_branch_id.delete import DeleteBranch
+from sedaro_base_client.paths.models_branches_branch_id_export_.get import ExportBranch
 from sedaro_base_client.paths.models_branches_branch_id.get import GetBranch
-from sedaro_base_client.paths.models_branches_branch_idcommitted_.get import GetCommittedBranchData
-from sedaro_base_client.paths.models_branches_branch_idsaved_.get import GetSavedBranchData
+from sedaro_base_client.paths.models_branches_branch_id_changes_.get import GetBranchChanges
+from sedaro_base_client.paths.models_branches_branch_id_committed_.get import GetCommittedBranchData
+from sedaro_base_client.paths.models_branches_branch_id_saved_.get import GetSavedBranchData
 from sedaro_base_client.paths.models_branches_current_branch_id_merge_incoming_branch_id.post import MergeBranches
 from sedaro_base_client.paths.models_branches_branch_id.patch import UpdateBranch
-from sedaro_base_client.paths.models_branches_branch_idshare_auth_.post import VerifyBranchPassword
+from sedaro_base_client.paths.models_branches_branch_id_share_auth_.post import VerifyBranchPassword
 
 
 class BranchesApi(
     CommitToBranch,
     CreateBranch,
     DeleteBranch,
+    ExportBranch,
     GetBranch,
+    GetBranchChanges,
     GetCommittedBranchData,
     GetSavedBranchData,
     MergeBranches,
     UpdateBranch,
     VerifyBranchPassword,
 ):
     """NOTE: This class is auto generated by OpenAPI Generator
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/apis/tags/data_api.py` & `sedaro-4.3.2/src/sedaro_base_client/apis/tags/externals_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,23 +1,25 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
-from sedaro_base_client.paths.data_id.get import GetData
+from sedaro_base_client.paths.simulations_jobs_job_id_externals_agent_id_external_state_block_id.get import GetExternal
+from sedaro_base_client.paths.simulations_jobs_job_id_externals_agent_id_external_state_block_id.patch import PutExternal
 
 
-class DataApi(
-    GetData,
+class ExternalsApi(
+    GetExternal,
+    PutExternal,
 ):
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
     pass
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/apis/tags/externals_api.py` & `sedaro-4.3.2/src/sedaro_base_client/apis/tags/templates_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,25 +1,23 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
-from sedaro_base_client.paths.simulations_jobs_job_id_externals_agent_id_external_state_block_id.get import GetExternal
-from sedaro_base_client.paths.simulations_jobs_job_id_externals_agent_id_external_state_block_id.patch import PutExternal
+from sedaro_base_client.paths.models_branches_branch_id_template.patch import CrudTemplate
 
 
-class ExternalsApi(
-    GetExternal,
-    PutExternal,
+class TemplatesApi(
+    CrudTemplate,
 ):
     """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
     pass
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/apis/tags/jobs_api.py` & `sedaro-4.3.2/src/sedaro_base_client/apis/tags/jobs_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from sedaro_base_client.paths.simulations_branches_branch_id_control_job_id.get import GetSimulation
 from sedaro_base_client.paths.simulations_branches_branch_id_control_.get import GetSimulations
 from sedaro_base_client.paths.simulations_branches_branch_id_control_.post import StartSimulation
 from sedaro_base_client.paths.simulations_branches_branch_id_control_job_id.delete import TerminateSimulation
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/apis/tags/templates_api.py` & `sedaro-4.3.2/src/sedaro_base_client/model/component_parameters.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,23 +1,51 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
-from sedaro_base_client.paths.models_branches_branch_id_template.patch import CrudTemplate
-
-
-class TemplatesApi(
-    CrudTemplate,
+from datetime import date, datetime  # noqa: F401
+import decimal  # noqa: F401
+import functools  # noqa: F401
+import io  # noqa: F401
+import re  # noqa: F401
+import typing  # noqa: F401
+import typing_extensions  # noqa: F401
+import uuid  # noqa: F401
+
+import frozendict  # noqa: F401
+
+from sedaro_base_client import schemas  # noqa: F401
+
+
+class ComponentParameters(
+    schemas.EnumBase,
+    schemas.StrSchema
 ):
-    """NOTE: This class is auto generated by OpenAPI Generator
+    """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
+
+    An enumeration.
     """
-    pass
+
+
+    class MetaOapg:
+        enum_value_to_name = {
+            "DATA_STORAGE_FILL_PERCENT": "DATA_STORAGE_FILL_PERCENT",
+            "TEMPERATURE": "TEMPERATURE",
+        }
+    
+    @schemas.classproperty
+    def DATA_STORAGE_FILL_PERCENT(cls):
+        return cls("DATA_STORAGE_FILL_PERCENT")
+    
+    @schemas.classproperty
+    def TEMPERATURE(cls):
+        return cls("TEMPERATURE")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/configuration.py` & `sedaro-4.3.2/src/sedaro_base_client/configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 import copy
 import logging
 import multiprocessing
 import sys
@@ -355,15 +355,15 @@
         """Gets the essential information for debugging.
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 4.3.1\n"\
+               "Version of the API: 4.3.2\n"\
                "SDK Package Version: 1.0.0".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/exceptions.py` & `sedaro-4.3.2/src/sedaro_base_client/exceptions.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 import dataclasses
 import typing
 
 from urllib3._collections import HTTPHeaderDict
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/agent.py` & `sedaro-4.3.2/src/sedaro_base_client/model/agent.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/agent_group.py` & `sedaro-4.3.2/src/sedaro_base_client/model/agent_group.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angle_base299.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angle_base306.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,61 +19,61 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngleBase299(
+class AngleBase306(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
-            rad = schemas.NumberSchema
             deg = schemas.NumberSchema
+            rad = schemas.NumberSchema
             __annotations__ = {
-                "rad": rad,
                 "deg": deg,
+                "rad": rad,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngleBase299':
+    ) -> 'AngleBase306':
         return super().__new__(
             cls,
             *_args,
-            rad=rad,
             deg=deg,
+            rad=rad,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angle_field_of_view31.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angle_field_of_view35.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,70 +19,70 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngleFieldOfView31(
+class AngleFieldOfView35(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
+            deg = schemas.NumberSchema
             
             
             class rad(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_maximum = 3.141592653589793
+                    inclusive_maximum = 1.5707963267948966
                     inclusive_minimum = 0.0
-            deg = schemas.NumberSchema
             __annotations__ = {
-                "rad": rad,
                 "deg": deg,
+                "rad": rad,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngleFieldOfView31':
+    ) -> 'AngleFieldOfView35':
         return super().__new__(
             cls,
             *_args,
-            rad=rad,
             deg=deg,
+            rad=rad,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angle_field_of_view36.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angular_velocity_sensors84.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,70 +19,75 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngleFieldOfView36(
+class AngularVelocitySensors84(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             
             
-            class rad(
+            class rad_s(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_maximum = 1.5707963267948966
                     inclusive_minimum = 0.0
-            deg = schemas.NumberSchema
+            rpm = schemas.NumberSchema
+            deg_s = schemas.NumberSchema
             __annotations__ = {
-                "rad": rad,
-                "deg": deg,
+                "rad/s": rad_s,
+                "rpm": rpm,
+                "deg/s": deg_s,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    def __getitem__(self, name: typing_extensions.Literal["rad/s"]) -> MetaOapg.properties.rad_s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    def __getitem__(self, name: typing_extensions.Literal["rpm"]) -> MetaOapg.properties.rpm: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["deg/s"]) -> MetaOapg.properties.deg_s: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["rpm"], typing_extensions.Literal["deg/s"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["rad/s"]) -> typing.Union[MetaOapg.properties.rad_s, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["rpm"]) -> typing.Union[MetaOapg.properties.rpm, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["deg/s"]) -> typing.Union[MetaOapg.properties.deg_s, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["rpm"], typing_extensions.Literal["deg/s"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        rpm: typing.Union[MetaOapg.properties.rpm, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngleFieldOfView36':
+    ) -> 'AngularVelocitySensors84':
         return super().__new__(
             cls,
             *_args,
-            rad=rad,
-            deg=deg,
+            rpm=rpm,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angle_field_of_view37.py` & `sedaro-4.3.2/src/sedaro_base_client/model/http_validation_error.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,70 +19,87 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngleFieldOfView37(
+class HTTPValidationError(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             
             
-            class rad(
-                schemas.NumberSchema
+            class detail(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_maximum = 1.5707963267948966
-                    inclusive_minimum = 0.0
-            deg = schemas.NumberSchema
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ValidationError']:
+                        return ValidationError
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple['ValidationError'], typing.List['ValidationError']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'detail':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ValidationError':
+                    return super().__getitem__(i)
             __annotations__ = {
-                "rad": rad,
-                "deg": deg,
+                "detail": detail,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    def __getitem__(self, name: typing_extensions.Literal["detail"]) -> MetaOapg.properties.detail: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["detail", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["detail"]) -> typing.Union[MetaOapg.properties.detail, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["detail", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        detail: typing.Union[MetaOapg.properties.detail, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngleFieldOfView37':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'HTTPValidationError':
         return super().__new__(
             cls,
             *_args,
-            rad=rad,
-            deg=deg,
+            detail=detail,
             _configuration=_configuration,
+            **kwargs,
         )
+
+from sedaro_base_client.model.validation_error import ValidationError
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angle_sensors20.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_verify_password.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,69 +19,65 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngleSensors20(
+class BranchVerifyPassword(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
+        required = {
+            "password",
+        }
         
         class properties:
-            
-            
-            class rad(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_minimum = 0.0
-            deg = schemas.NumberSchema
+            password = schemas.StrSchema
             __annotations__ = {
-                "rad": rad,
-                "deg": deg,
+                "password": password,
             }
-        additional_properties = schemas.NotAnyTypeSchema
+    
+    password: MetaOapg.properties.password
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    def __getitem__(self, name: typing_extensions.Literal["password"]) -> MetaOapg.properties.password: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["password", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["password"]) -> MetaOapg.properties.password: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["password", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        password: typing.Union[MetaOapg.properties.password, str, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngleSensors20':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'BranchVerifyPassword':
         return super().__new__(
             cls,
             *_args,
-            rad=rad,
-            deg=deg,
+            password=password,
             _configuration=_configuration,
+            **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angle_sensors51.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angle_sensors51.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -32,56 +32,56 @@
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
+            deg = schemas.NumberSchema
             
             
             class rad(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
-            deg = schemas.NumberSchema
             __annotations__ = {
-                "rad": rad,
                 "deg": deg,
+                "rad": rad,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'AngleSensors51':
         return super().__new__(
             cls,
             *_args,
-            rad=rad,
             deg=deg,
+            rad=rad,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angle_sensors56.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angle_sensors20.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,69 +19,69 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngleSensors56(
+class AngleSensors20(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
+            deg = schemas.NumberSchema
             
             
             class rad(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
-            deg = schemas.NumberSchema
             __annotations__ = {
-                "rad": rad,
                 "deg": deg,
+                "rad": rad,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad"], typing_extensions.Literal["deg"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngleSensors56':
+    ) -> 'AngleSensors20':
         return super().__new__(
             cls,
             *_args,
-            rad=rad,
             deg=deg,
+            rad=rad,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angular_velocity_base299.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angular_velocity_base306.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,67 +19,67 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngularVelocityBase299(
+class AngularVelocityBase306(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             rad_s = schemas.NumberSchema
-            deg_s = schemas.NumberSchema
             rpm = schemas.NumberSchema
+            deg_s = schemas.NumberSchema
             __annotations__ = {
                 "rad/s": rad_s,
-                "deg/s": deg_s,
                 "rpm": rpm,
+                "deg/s": deg_s,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["rad/s"]) -> MetaOapg.properties.rad_s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg/s"]) -> MetaOapg.properties.deg_s: ...
+    def __getitem__(self, name: typing_extensions.Literal["rpm"]) -> MetaOapg.properties.rpm: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rpm"]) -> MetaOapg.properties.rpm: ...
+    def __getitem__(self, name: typing_extensions.Literal["deg/s"]) -> MetaOapg.properties.deg_s: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["deg/s"], typing_extensions.Literal["rpm"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["rpm"], typing_extensions.Literal["deg/s"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["rad/s"]) -> typing.Union[MetaOapg.properties.rad_s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg/s"]) -> typing.Union[MetaOapg.properties.deg_s, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["rpm"]) -> typing.Union[MetaOapg.properties.rpm, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rpm"]) -> typing.Union[MetaOapg.properties.rpm, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["deg/s"]) -> typing.Union[MetaOapg.properties.deg_s, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["deg/s"], typing_extensions.Literal["rpm"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["rpm"], typing_extensions.Literal["deg/s"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         rpm: typing.Union[MetaOapg.properties.rpm, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngularVelocityBase299':
+    ) -> 'AngularVelocityBase306':
         return super().__new__(
             cls,
             *_args,
             rpm=rpm,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angular_velocity_sensor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angular_velocity_sensor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -67,15 +67,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            AngularVelocitySensors82,
+                            AngularVelocitySensors84,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -122,15 +122,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -158,15 +158,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -290,41 +290,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -346,15 +345,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -373,58 +372,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class conditions(
                 schemas.ListSchema
             ):
             
             
@@ -679,21 +706,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         conditions: typing.Union[MetaOapg.properties.conditions, list, tuple, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
         measurement: typing.Union[MetaOapg.properties.measurement, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'AngularVelocitySensor':
         return super().__new__(
             cls,
@@ -723,9 +750,10 @@
             writeRate=writeRate,
             conditions=conditions,
             fieldOfView=fieldOfView,
             measurement=measurement,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.angular_velocity_sensors82 import AngularVelocitySensors82
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.angular_velocity_sensors84 import AngularVelocitySensors84
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/angular_velocity_sensors82.py` & `sedaro-4.3.2/src/sedaro_base_client/model/temperature_base306.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,75 +19,79 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AngularVelocitySensors82(
+class TemperatureBase306(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             
             
-            class rad_s(
+            class degK(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
-            deg_s = schemas.NumberSchema
-            rpm = schemas.NumberSchema
+            degF = schemas.NumberSchema
+            degC = schemas.NumberSchema
             __annotations__ = {
-                "rad/s": rad_s,
-                "deg/s": deg_s,
-                "rpm": rpm,
+                "degK": degK,
+                "degF": degF,
+                "degC": degC,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rad/s"]) -> MetaOapg.properties.rad_s: ...
+    def __getitem__(self, name: typing_extensions.Literal["degK"]) -> MetaOapg.properties.degK: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["deg/s"]) -> MetaOapg.properties.deg_s: ...
+    def __getitem__(self, name: typing_extensions.Literal["degF"]) -> MetaOapg.properties.degF: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rpm"]) -> MetaOapg.properties.rpm: ...
+    def __getitem__(self, name: typing_extensions.Literal["degC"]) -> MetaOapg.properties.degC: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["deg/s"], typing_extensions.Literal["rpm"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["degK"], typing_extensions.Literal["degF"], typing_extensions.Literal["degC"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rad/s"]) -> typing.Union[MetaOapg.properties.rad_s, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["degK"]) -> typing.Union[MetaOapg.properties.degK, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["deg/s"]) -> typing.Union[MetaOapg.properties.deg_s, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["degF"]) -> typing.Union[MetaOapg.properties.degF, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rpm"]) -> typing.Union[MetaOapg.properties.rpm, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["degC"]) -> typing.Union[MetaOapg.properties.degC, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["rad/s"], typing_extensions.Literal["deg/s"], typing_extensions.Literal["rpm"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["degK"], typing_extensions.Literal["degF"], typing_extensions.Literal["degC"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        rpm: typing.Union[MetaOapg.properties.rpm, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        degK: typing.Union[MetaOapg.properties.degK, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        degF: typing.Union[MetaOapg.properties.degF, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        degC: typing.Union[MetaOapg.properties.degC, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AngularVelocitySensors82':
+    ) -> 'TemperatureBase306':
         return super().__new__(
             cls,
             *_args,
-            rpm=rpm,
+            degK=degK,
+            degF=degF,
+            degC=degC,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/antenna.py` & `sedaro-4.3.2/src/sedaro_base_client/model/antenna.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -85,15 +85,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -253,41 +253,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -309,15 +308,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -336,58 +335,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             fieldOfView = schemas.StrSchema
             
             
             class externalInterfaces(
                 schemas.ListSchema
             ):
             
@@ -603,21 +630,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
         externalInterfaces: typing.Union[MetaOapg.properties.externalInterfaces, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'Antenna':
         return super().__new__(
             cls,
             *_args,
@@ -644,8 +671,9 @@
             readRate=readRate,
             writeRate=writeRate,
             fieldOfView=fieldOfView,
             externalInterfaces=externalInterfaces,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/averaging_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/mekf_algorithm.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class AveragingAlgorithm(
+class MekfAlgorithm(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -140,22 +140,24 @@
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
+            covariance = schemas.AnyTypeSchema
             __annotations__ = {
                 "name": name,
                 "id": id,
                 "rate": rate,
                 "attitudeSolution": attitudeSolution,
                 "angularVelocitySolution": angularVelocitySolution,
                 "opticalAttitudeSensors": opticalAttitudeSensors,
                 "angularVelocitySensors": angularVelocitySensors,
+                "covariance": covariance,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
@@ -174,15 +176,18 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["opticalAttitudeSensors"]) -> MetaOapg.properties.opticalAttitudeSensors: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> MetaOapg.properties.angularVelocitySensors: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["covariance"]) -> MetaOapg.properties.covariance: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], typing_extensions.Literal["covariance"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
@@ -199,34 +204,39 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["opticalAttitudeSensors"]) -> typing.Union[MetaOapg.properties.opticalAttitudeSensors, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> typing.Union[MetaOapg.properties.angularVelocitySensors, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["covariance"]) -> typing.Union[MetaOapg.properties.covariance, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], typing_extensions.Literal["covariance"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         rate: typing.Union[MetaOapg.properties.rate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySolution: typing.Union[MetaOapg.properties.angularVelocitySolution, list, tuple, schemas.Unset] = schemas.unset,
         opticalAttitudeSensors: typing.Union[MetaOapg.properties.opticalAttitudeSensors, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySensors: typing.Union[MetaOapg.properties.angularVelocitySensors, list, tuple, schemas.Unset] = schemas.unset,
+        covariance: typing.Union[MetaOapg.properties.covariance, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'AveragingAlgorithm':
+    ) -> 'MekfAlgorithm':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
             rate=rate,
             attitudeSolution=attitudeSolution,
             angularVelocitySolution=angularVelocitySolution,
             opticalAttitudeSensors=opticalAttitudeSensors,
             angularVelocitySensors=angularVelocitySensors,
+            covariance=covariance,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/battery.py` & `sedaro-4.3.2/src/sedaro_base_client/model/battery.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -166,15 +166,42 @@
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_maximum = 1.0
                     inclusive_minimum = 0.0
-            curve = schemas.AnyTypeSchema
+            
+            
+            class curve(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_items = 2
+                    min_items = 2
+                    
+                    @staticmethod
+                    def items() -> typing.Type['Items']:
+                        return Items
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple['Items'], typing.List['Items']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'curve':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'Items':
+                    return super().__getitem__(i)
             idealMaxChargeCurrent = schemas.NumberSchema
             maxChargeCurrent = schemas.NumberSchema
             maxChargeVoltage = schemas.NumberSchema
             maxChargePower = schemas.NumberSchema
             idealMaxDischargeCurrent = schemas.NumberSchema
             esr = schemas.NumberSchema
             capacity = schemas.NumberSchema
@@ -367,15 +394,15 @@
         minSocOverride: typing.Union[MetaOapg.properties.minSocOverride, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
         packs: typing.Union[MetaOapg.properties.packs, list, tuple, schemas.Unset] = schemas.unset,
         current: typing.Union[MetaOapg.properties.current, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         voltage: typing.Union[MetaOapg.properties.voltage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         power: typing.Union[MetaOapg.properties.power, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         soc: typing.Union[MetaOapg.properties.soc, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        curve: typing.Union[MetaOapg.properties.curve, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        curve: typing.Union[MetaOapg.properties.curve, list, tuple, schemas.Unset] = schemas.unset,
         idealMaxChargeCurrent: typing.Union[MetaOapg.properties.idealMaxChargeCurrent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         maxChargeCurrent: typing.Union[MetaOapg.properties.maxChargeCurrent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         maxChargeVoltage: typing.Union[MetaOapg.properties.maxChargeVoltage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         maxChargePower: typing.Union[MetaOapg.properties.maxChargePower, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         idealMaxDischargeCurrent: typing.Union[MetaOapg.properties.idealMaxDischargeCurrent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         esr: typing.Union[MetaOapg.properties.esr, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         capacity: typing.Union[MetaOapg.properties.capacity, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
@@ -408,7 +435,8 @@
             capacity=capacity,
             minSoc=minSoc,
             voc=voc,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.configuration_types import ConfigurationTypes
+from sedaro_base_client.model.items import Items
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/battery_cell.py` & `sedaro-4.3.2/src/sedaro_base_client/model/battery_cell.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/battery_pack.py` & `sedaro-4.3.2/src/sedaro_base_client/model/battery_pack.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -105,15 +105,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -141,15 +141,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -273,41 +273,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            BatteryPackDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -329,15 +328,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -356,61 +355,116 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             cell = schemas.StrSchema
             battery = schemas.StrSchema
-            curve = schemas.AnyTypeSchema
+            
+            
+            class curve(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_items = 2
+                    min_items = 2
+                    
+                    @staticmethod
+                    def items() -> typing.Type['Items']:
+                        return Items
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple['Items'], typing.List['Items']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'curve':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'Items':
+                    return super().__getitem__(i)
             idealMaxChargeCurrent = schemas.NumberSchema
             idealMaxDischargeCurrent = schemas.NumberSchema
             
             
             class minSoc(
                 schemas.NumberSchema
             ):
@@ -684,24 +738,24 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         cell: typing.Union[MetaOapg.properties.cell, str, schemas.Unset] = schemas.unset,
         battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
-        curve: typing.Union[MetaOapg.properties.curve, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        curve: typing.Union[MetaOapg.properties.curve, list, tuple, schemas.Unset] = schemas.unset,
         idealMaxChargeCurrent: typing.Union[MetaOapg.properties.idealMaxChargeCurrent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         idealMaxDischargeCurrent: typing.Union[MetaOapg.properties.idealMaxDischargeCurrent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         minSoc: typing.Union[MetaOapg.properties.minSoc, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         esr: typing.Union[MetaOapg.properties.esr, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         capacity: typing.Union[MetaOapg.properties.capacity, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         current: typing.Union[MetaOapg.properties.current, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
@@ -741,8 +795,10 @@
             minSoc=minSoc,
             esr=esr,
             capacity=capacity,
             current=current,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.battery_pack_dissipations import BatteryPackDissipations
+from sedaro_base_client.model.items import Items
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/body_frame_vector.py` & `sedaro-4.3.2/src/sedaro_base_client/model/body_frame_vector.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/body_frame_vector_types.py` & `sedaro-4.3.2/src/sedaro_base_client/model/body_frame_vector_types.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/body_in_fov_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_to_scalar_condition.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class BodyInFovCondition(
+class TargetToScalarCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -35,14 +35,15 @@
     """
 
 
     class MetaOapg:
         required = {
             "scalar",
             "name",
+            "targetParam",
             "relationship",
         }
         
         class properties:
             
             
             class name(
@@ -85,121 +86,148 @@
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             scalar = schemas.AnyTypeSchema
+            
+            
+            class targetParam(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            TargetParameters,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'targetParam':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             id = schemas.StrSchema
             terminator = schemas.BoolSchema
             compliance = schemas.BoolSchema
-            fieldOfView = schemas.StrSchema
             targetA = schemas.StrSchema
-            negate = schemas.BoolSchema
             __annotations__ = {
                 "name": name,
                 "relationship": relationship,
                 "scalar": scalar,
+                "targetParam": targetParam,
                 "id": id,
                 "terminator": terminator,
                 "compliance": compliance,
-                "fieldOfView": fieldOfView,
                 "targetA": targetA,
-                "negate": negate,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     scalar: MetaOapg.properties.scalar
     name: MetaOapg.properties.name
+    targetParam: MetaOapg.properties.targetParam
     relationship: MetaOapg.properties.relationship
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
+    
+    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["negate"]) -> MetaOapg.properties.negate: ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["targetA"], typing_extensions.Literal["negate"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["negate"]) -> typing.Union[MetaOapg.properties.negate, schemas.Unset]: ...
-    
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["targetA"], typing_extensions.Literal["negate"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         scalar: typing.Union[MetaOapg.properties.scalar, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
+        targetParam: typing.Union[MetaOapg.properties.targetParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
         compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
-        fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
         targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
-        negate: typing.Union[MetaOapg.properties.negate, bool, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'BodyInFovCondition':
+    ) -> 'TargetToScalarCondition':
         return super().__new__(
             cls,
             *_args,
             scalar=scalar,
             name=name,
+            targetParam=targetParam,
             relationship=relationship,
             id=id,
             terminator=terminator,
             compliance=compliance,
-            fieldOfView=fieldOfView,
             targetA=targetA,
-            negate=negate,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.condition_relationship import ConditionRelationship
+from sedaro_base_client.model.target_parameters import TargetParameters
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_create.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_create.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_delete_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/entity_delete_res.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class BranchDeleteRes(
+class EntityDeleteRes(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
@@ -105,15 +105,15 @@
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         message: typing.Union[MetaOapg.properties.message, str, ],
         deletedEntities: typing.Union[MetaOapg.properties.deletedEntities, list, tuple, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'BranchDeleteRes':
+    ) -> 'EntityDeleteRes':
         return super().__new__(
             cls,
             *_args,
             message=message,
             deletedEntities=deletedEntities,
             _configuration=_configuration,
             **kwargs,
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_merge.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_merge.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_merge_conflicts_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_merge_conflicts_res.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/bus_regulator.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,352 +19,377 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class BranchRes(
+class BusRegulator(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
+
+    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "dataSchema",
-            "mission",
-            "dateCreated",
-            "data",
+            "efficiency",
             "name",
-            "numSimulations",
-            "dateModified",
-            "id",
-            "repository",
-            "user",
+            "inputType",
+            "maxOutputPower",
+            "voltage",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 32
-            id = schemas.IntSchema
-            dateCreated = schemas.DateTimeSchema
-            dateModified = schemas.DateTimeSchema
+                    max_length = 100
             
             
-            class repository(
+            class inputType(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            InputTypes,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'repository':
+                ) -> 'inputType':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            voltage = schemas.NumberSchema
             
             
-            class mission(
-                schemas.ComposedSchema,
+            class maxOutputPower(
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def any_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            cls.any_of_0,
-                            cls.any_of_1,
-                        ]
+                    inclusive_minimum = 0.0
+            
+            
+            class efficiency(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_maximum = 1.0
+            id = schemas.StrSchema
+            inRegulator = schemas.StrSchema
+            powerProcessor = schemas.StrSchema
             
             
+            class outRegulators(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'mission':
+                ) -> 'outRegulators':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             
-            class user(
-                schemas.ComposedSchema,
+            
+            class loads(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def any_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            cls.any_of_0,
-                            cls.any_of_1,
-                        ]
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'loads':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class dynamicallyLoadedComponents(
+                schemas.ListSchema
+            ):
             
             
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'user':
+                ) -> 'dynamicallyLoadedComponents':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
-            numSimulations = schemas.IntSchema
-            dataSchema = schemas.DictSchema
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             
             
-            class data(
+            class dissipations(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            VehicleTemplateRes,
-                            ScenarioTemplateRes,
+                            BaseDissipations,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'data':
+                ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class description(
-                schemas.StrSchema
+            class outputPowers(
+                schemas.DictSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 300
+                    additional_properties = schemas.NumberSchema
+                
+                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    # dict_instance[name] accessor
+                    return super().__getitem__(name)
+                
+                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    return super().get_item_oapg(name)
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                ) -> 'outputPowers':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             __annotations__ = {
                 "name": name,
+                "inputType": inputType,
+                "voltage": voltage,
+                "maxOutputPower": maxOutputPower,
+                "efficiency": efficiency,
                 "id": id,
-                "dateCreated": dateCreated,
-                "dateModified": dateModified,
-                "repository": repository,
-                "mission": mission,
-                "user": user,
-                "numSimulations": numSimulations,
-                "dataSchema": dataSchema,
-                "data": data,
-                "description": description,
+                "inRegulator": inRegulator,
+                "powerProcessor": powerProcessor,
+                "outRegulators": outRegulators,
+                "loads": loads,
+                "dynamicallyLoadedComponents": dynamicallyLoadedComponents,
+                "dissipations": dissipations,
+                "outputPowers": outputPowers,
             }
+        additional_properties = schemas.NotAnyTypeSchema
     
-    dataSchema: MetaOapg.properties.dataSchema
-    mission: MetaOapg.properties.mission
-    dateCreated: MetaOapg.properties.dateCreated
-    data: MetaOapg.properties.data
+    efficiency: MetaOapg.properties.efficiency
     name: MetaOapg.properties.name
-    numSimulations: MetaOapg.properties.numSimulations
-    dateModified: MetaOapg.properties.dateModified
-    id: MetaOapg.properties.id
-    repository: MetaOapg.properties.repository
-    user: MetaOapg.properties.user
+    inputType: MetaOapg.properties.inputType
+    maxOutputPower: MetaOapg.properties.maxOutputPower
+    voltage: MetaOapg.properties.voltage
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["efficiency"]) -> MetaOapg.properties.efficiency: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputType"]) -> MetaOapg.properties.inputType: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
+    def __getitem__(self, name: typing_extensions.Literal["maxOutputPower"]) -> MetaOapg.properties.maxOutputPower: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
+    def __getitem__(self, name: typing_extensions.Literal["voltage"]) -> MetaOapg.properties.voltage: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["mission"]) -> MetaOapg.properties.mission: ...
+    def __getitem__(self, name: typing_extensions.Literal["inRegulator"]) -> MetaOapg.properties.inRegulator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["numSimulations"]) -> MetaOapg.properties.numSimulations: ...
+    def __getitem__(self, name: typing_extensions.Literal["outRegulators"]) -> MetaOapg.properties.outRegulators: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dataSchema"]) -> MetaOapg.properties.dataSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["loads"]) -> MetaOapg.properties.loads: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def __getitem__(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> MetaOapg.properties.dynamicallyLoadedComponents: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
+    def __getitem__(self, name: typing_extensions.Literal["dissipations"]) -> MetaOapg.properties.dissipations: ...
     
     @typing.overload
-    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["outputPowers"]) -> MetaOapg.properties.outputPowers: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "mission", "user", "numSimulations", "dataSchema", "data", "description", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["efficiency"], typing_extensions.Literal["name"], typing_extensions.Literal["inputType"], typing_extensions.Literal["maxOutputPower"], typing_extensions.Literal["voltage"], typing_extensions.Literal["id"], typing_extensions.Literal["inRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["outRegulators"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["outputPowers"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["efficiency"]) -> MetaOapg.properties.efficiency: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputType"]) -> MetaOapg.properties.inputType: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["maxOutputPower"]) -> MetaOapg.properties.maxOutputPower: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["voltage"]) -> MetaOapg.properties.voltage: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["mission"]) -> MetaOapg.properties.mission: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inRegulator"]) -> typing.Union[MetaOapg.properties.inRegulator, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["numSimulations"]) -> MetaOapg.properties.numSimulations: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["outRegulators"]) -> typing.Union[MetaOapg.properties.outRegulators, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dataSchema"]) -> MetaOapg.properties.dataSchema: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["loads"]) -> typing.Union[MetaOapg.properties.loads, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dissipations"]) -> typing.Union[MetaOapg.properties.dissipations, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["outputPowers"]) -> typing.Union[MetaOapg.properties.outputPowers, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "mission", "user", "numSimulations", "dataSchema", "data", "description", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["efficiency"], typing_extensions.Literal["name"], typing_extensions.Literal["inputType"], typing_extensions.Literal["maxOutputPower"], typing_extensions.Literal["voltage"], typing_extensions.Literal["id"], typing_extensions.Literal["inRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["outRegulators"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["outputPowers"], ]):
         return super().get_item_oapg(name)
-    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        dataSchema: typing.Union[MetaOapg.properties.dataSchema, dict, frozendict.frozendict, ],
-        mission: typing.Union[MetaOapg.properties.mission, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        dateCreated: typing.Union[MetaOapg.properties.dateCreated, str, datetime, ],
-        data: typing.Union[MetaOapg.properties.data, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        efficiency: typing.Union[MetaOapg.properties.efficiency, decimal.Decimal, int, float, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        numSimulations: typing.Union[MetaOapg.properties.numSimulations, decimal.Decimal, int, ],
-        dateModified: typing.Union[MetaOapg.properties.dateModified, str, datetime, ],
-        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, ],
-        repository: typing.Union[MetaOapg.properties.repository, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        user: typing.Union[MetaOapg.properties.user, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
+        inputType: typing.Union[MetaOapg.properties.inputType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        maxOutputPower: typing.Union[MetaOapg.properties.maxOutputPower, decimal.Decimal, int, float, ],
+        voltage: typing.Union[MetaOapg.properties.voltage, decimal.Decimal, int, float, ],
+        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        inRegulator: typing.Union[MetaOapg.properties.inRegulator, str, schemas.Unset] = schemas.unset,
+        powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
+        outRegulators: typing.Union[MetaOapg.properties.outRegulators, list, tuple, schemas.Unset] = schemas.unset,
+        loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
+        dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        outputPowers: typing.Union[MetaOapg.properties.outputPowers, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'BranchRes':
+    ) -> 'BusRegulator':
         return super().__new__(
             cls,
             *_args,
-            dataSchema=dataSchema,
-            mission=mission,
-            dateCreated=dateCreated,
-            data=data,
+            efficiency=efficiency,
             name=name,
-            numSimulations=numSimulations,
-            dateModified=dateModified,
+            inputType=inputType,
+            maxOutputPower=maxOutputPower,
+            voltage=voltage,
             id=id,
-            repository=repository,
-            user=user,
-            description=description,
+            inRegulator=inRegulator,
+            powerProcessor=powerProcessor,
+            outRegulators=outRegulators,
+            loads=loads,
+            dynamicallyLoadedComponents=dynamicallyLoadedComponents,
+            dissipations=dissipations,
+            outputPowers=outputPowers,
             _configuration=_configuration,
-            **kwargs,
         )
 
-from sedaro_base_client.model.scenario_template_res import ScenarioTemplateRes
-from sedaro_base_client.model.vehicle_template_res import VehicleTemplateRes
+from sedaro_base_client.model.base_dissipations import BaseDissipations
+from sedaro_base_client.model.input_types import InputTypes
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_scenario_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/satellite_to_target_condition.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,301 +19,249 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class BranchScenarioRes(
+class SatelliteToTargetCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
+
+    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "dataSchema",
-            "mission",
-            "dateCreated",
             "name",
-            "numSimulations",
-            "dateModified",
-            "id",
-            "repository",
-            "user",
+            "targetParam",
+            "relationship",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 32
-            id = schemas.IntSchema
-            dateCreated = schemas.DateTimeSchema
-            dateModified = schemas.DateTimeSchema
+                    max_length = 100
             
             
-            class repository(
+            class relationship(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ConditionRelationship,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'repository':
+                ) -> 'relationship':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class mission(
+            class targetParam(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            TargetParameters,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'mission':
+                ) -> 'targetParam':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            id = schemas.StrSchema
+            terminator = schemas.BoolSchema
+            compliance = schemas.BoolSchema
             
             
-            class user(
+            class satParam(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            SatelliteParameters,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'user':
+                ) -> 'satParam':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            numSimulations = schemas.IntSchema
-            dataSchema = schemas.DictSchema
-            
-            
-            class description(
-                schemas.StrSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_length = 300
+            targetA = schemas.StrSchema
             __annotations__ = {
                 "name": name,
+                "relationship": relationship,
+                "targetParam": targetParam,
                 "id": id,
-                "dateCreated": dateCreated,
-                "dateModified": dateModified,
-                "repository": repository,
-                "mission": mission,
-                "user": user,
-                "numSimulations": numSimulations,
-                "dataSchema": dataSchema,
-                "description": description,
+                "terminator": terminator,
+                "compliance": compliance,
+                "satParam": satParam,
+                "targetA": targetA,
             }
+        additional_properties = schemas.NotAnyTypeSchema
     
-    dataSchema: MetaOapg.properties.dataSchema
-    mission: MetaOapg.properties.mission
-    dateCreated: MetaOapg.properties.dateCreated
     name: MetaOapg.properties.name
-    numSimulations: MetaOapg.properties.numSimulations
-    dateModified: MetaOapg.properties.dateModified
-    id: MetaOapg.properties.id
-    repository: MetaOapg.properties.repository
-    user: MetaOapg.properties.user
+    targetParam: MetaOapg.properties.targetParam
+    relationship: MetaOapg.properties.relationship
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
+    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["mission"]) -> MetaOapg.properties.mission: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["numSimulations"]) -> MetaOapg.properties.numSimulations: ...
+    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dataSchema"]) -> MetaOapg.properties.dataSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
+    def __getitem__(self, name: typing_extensions.Literal["satParam"]) -> MetaOapg.properties.satParam: ...
     
     @typing.overload
-    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "mission", "user", "numSimulations", "dataSchema", "description", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["satParam"], typing_extensions.Literal["targetA"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["mission"]) -> MetaOapg.properties.mission: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["numSimulations"]) -> MetaOapg.properties.numSimulations: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["satParam"]) -> typing.Union[MetaOapg.properties.satParam, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dataSchema"]) -> MetaOapg.properties.dataSchema: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
-    
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "mission", "user", "numSimulations", "dataSchema", "description", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["satParam"], typing_extensions.Literal["targetA"], ]):
         return super().get_item_oapg(name)
-    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        dataSchema: typing.Union[MetaOapg.properties.dataSchema, dict, frozendict.frozendict, ],
-        mission: typing.Union[MetaOapg.properties.mission, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        dateCreated: typing.Union[MetaOapg.properties.dateCreated, str, datetime, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        numSimulations: typing.Union[MetaOapg.properties.numSimulations, decimal.Decimal, int, ],
-        dateModified: typing.Union[MetaOapg.properties.dateModified, str, datetime, ],
-        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, ],
-        repository: typing.Union[MetaOapg.properties.repository, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        user: typing.Union[MetaOapg.properties.user, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
+        targetParam: typing.Union[MetaOapg.properties.targetParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
+        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
+        satParam: typing.Union[MetaOapg.properties.satParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'BranchScenarioRes':
+    ) -> 'SatelliteToTargetCondition':
         return super().__new__(
             cls,
             *_args,
-            dataSchema=dataSchema,
-            mission=mission,
-            dateCreated=dateCreated,
             name=name,
-            numSimulations=numSimulations,
-            dateModified=dateModified,
+            targetParam=targetParam,
+            relationship=relationship,
             id=id,
-            repository=repository,
-            user=user,
-            description=description,
+            terminator=terminator,
+            compliance=compliance,
+            satParam=satParam,
+            targetA=targetA,
             _configuration=_configuration,
-            **kwargs,
         )
+
+from sedaro_base_client.model.condition_relationship import ConditionRelationship
+from sedaro_base_client.model.satellite_parameters import SatelliteParameters
+from sedaro_base_client.model.target_parameters import TargetParameters
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_update.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_update.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_vehicle_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_to_target_condition.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,301 +19,260 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class BranchVehicleRes(
+class TargetToTargetCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
+
+    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "dataSchema",
-            "mission",
-            "dateCreated",
+            "targetAParam",
             "name",
-            "numSimulations",
-            "dateModified",
-            "id",
-            "repository",
-            "user",
+            "relationship",
+            "targetBParam",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 32
-            id = schemas.IntSchema
-            dateCreated = schemas.DateTimeSchema
-            dateModified = schemas.DateTimeSchema
+                    max_length = 100
             
             
-            class repository(
+            class relationship(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ConditionRelationship,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'repository':
+                ) -> 'relationship':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class mission(
+            class targetAParam(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            TargetParameters,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'mission':
+                ) -> 'targetAParam':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class user(
+            class targetBParam(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.DictSchema
-                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            TargetParameters,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'user':
+                ) -> 'targetBParam':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            numSimulations = schemas.IntSchema
-            dataSchema = schemas.DictSchema
-            
-            
-            class description(
-                schemas.StrSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_length = 300
+            id = schemas.StrSchema
+            terminator = schemas.BoolSchema
+            compliance = schemas.BoolSchema
+            targetA = schemas.StrSchema
+            targetB = schemas.StrSchema
             __annotations__ = {
                 "name": name,
+                "relationship": relationship,
+                "targetAParam": targetAParam,
+                "targetBParam": targetBParam,
                 "id": id,
-                "dateCreated": dateCreated,
-                "dateModified": dateModified,
-                "repository": repository,
-                "mission": mission,
-                "user": user,
-                "numSimulations": numSimulations,
-                "dataSchema": dataSchema,
-                "description": description,
+                "terminator": terminator,
+                "compliance": compliance,
+                "targetA": targetA,
+                "targetB": targetB,
             }
+        additional_properties = schemas.NotAnyTypeSchema
     
-    dataSchema: MetaOapg.properties.dataSchema
-    mission: MetaOapg.properties.mission
-    dateCreated: MetaOapg.properties.dateCreated
+    targetAParam: MetaOapg.properties.targetAParam
     name: MetaOapg.properties.name
-    numSimulations: MetaOapg.properties.numSimulations
-    dateModified: MetaOapg.properties.dateModified
-    id: MetaOapg.properties.id
-    repository: MetaOapg.properties.repository
-    user: MetaOapg.properties.user
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    relationship: MetaOapg.properties.relationship
+    targetBParam: MetaOapg.properties.targetBParam
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetAParam"]) -> MetaOapg.properties.targetAParam: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
+    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["mission"]) -> MetaOapg.properties.mission: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetBParam"]) -> MetaOapg.properties.targetBParam: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["numSimulations"]) -> MetaOapg.properties.numSimulations: ...
+    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dataSchema"]) -> MetaOapg.properties.dataSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
     
     @typing.overload
-    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetB"]) -> MetaOapg.properties.targetB: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "mission", "user", "numSimulations", "dataSchema", "description", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["targetAParam"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["targetBParam"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], typing_extensions.Literal["targetB"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetAParam"]) -> MetaOapg.properties.targetAParam: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["mission"]) -> MetaOapg.properties.mission: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetBParam"]) -> MetaOapg.properties.targetBParam: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["numSimulations"]) -> MetaOapg.properties.numSimulations: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dataSchema"]) -> MetaOapg.properties.dataSchema: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetB"]) -> typing.Union[MetaOapg.properties.targetB, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "mission", "user", "numSimulations", "dataSchema", "description", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["targetAParam"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["targetBParam"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], typing_extensions.Literal["targetB"], ]):
         return super().get_item_oapg(name)
-    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        dataSchema: typing.Union[MetaOapg.properties.dataSchema, dict, frozendict.frozendict, ],
-        mission: typing.Union[MetaOapg.properties.mission, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        dateCreated: typing.Union[MetaOapg.properties.dateCreated, str, datetime, ],
+        targetAParam: typing.Union[MetaOapg.properties.targetAParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        numSimulations: typing.Union[MetaOapg.properties.numSimulations, decimal.Decimal, int, ],
-        dateModified: typing.Union[MetaOapg.properties.dateModified, str, datetime, ],
-        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, ],
-        repository: typing.Union[MetaOapg.properties.repository, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        user: typing.Union[MetaOapg.properties.user, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
+        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        targetBParam: typing.Union[MetaOapg.properties.targetBParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
+        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
+        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
+        targetB: typing.Union[MetaOapg.properties.targetB, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'BranchVehicleRes':
+    ) -> 'TargetToTargetCondition':
         return super().__new__(
             cls,
             *_args,
-            dataSchema=dataSchema,
-            mission=mission,
-            dateCreated=dateCreated,
+            targetAParam=targetAParam,
             name=name,
-            numSimulations=numSimulations,
-            dateModified=dateModified,
+            relationship=relationship,
+            targetBParam=targetBParam,
             id=id,
-            repository=repository,
-            user=user,
-            description=description,
+            terminator=terminator,
+            compliance=compliance,
+            targetA=targetA,
+            targetB=targetB,
             _configuration=_configuration,
-            **kwargs,
         )
+
+from sedaro_base_client.model.condition_relationship import ConditionRelationship
+from sedaro_base_client.model.target_parameters import TargetParameters
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/branch_verify_password.py` & `sedaro-4.3.2/src/sedaro_base_client/model/constant_power_params.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,65 +19,73 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class BranchVerifyPassword(
+class ConstantPowerParams(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
-            "password",
+            "power",
         }
         
         class properties:
-            password = schemas.StrSchema
+            
+            
+            class power(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
             __annotations__ = {
-                "password": password,
+                "power": power,
             }
     
-    password: MetaOapg.properties.password
+    power: MetaOapg.properties.power
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["password"]) -> MetaOapg.properties.password: ...
+    def __getitem__(self, name: typing_extensions.Literal["power"]) -> MetaOapg.properties.power: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["password", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["power", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["password"]) -> MetaOapg.properties.password: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["power"]) -> MetaOapg.properties.power: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["password", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["power", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        password: typing.Union[MetaOapg.properties.password, str, ],
+        power: typing.Union[MetaOapg.properties.power, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'BranchVerifyPassword':
+    ) -> 'ConstantPowerParams':
         return super().__new__(
             cls,
             *_args,
-            password=password,
+            power=power,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/bus_regulator.py` & `sedaro-4.3.2/src/sedaro_base_client/model/orbit.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,48 +19,36 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class BusRegulator(
+class Orbit(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "efficiency",
-            "name",
-            "inputType",
-            "maxOutputPower",
-            "voltage",
+            "initialStateDefType",
+            "initialStateDefParams",
         }
         
         class properties:
             
             
-            class name(
-                schemas.StrSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_length = 100
-            
-            
-            class inputType(
+            class initialStateDefType(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -70,280 +58,319 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            InputTypes,
+                            InitialStateDefType,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'inputType':
+                ) -> 'initialStateDefType':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            voltage = schemas.NumberSchema
-            
-            
-            class maxOutputPower(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_minimum = 0.0
             
             
-            class efficiency(
-                schemas.NumberSchema
+            class initialStateDefParams(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    inclusive_maximum = 1.0
-            id = schemas.StrSchema
-            inRegulator = schemas.StrSchema
-            powerProcessor = schemas.StrSchema
-            
-            
-            class outRegulators(
-                schemas.ListSchema
-            ):
-            
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def any_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            StateVector,
+                            ClassicalOrbitalElements,
+                            Tle,
+                            IssReferenceOrbit,
+                            GeostationaryReferenceOrbit,
+                            GeostationaryTransferReferenceOrbit,
+                            PolarCircularReferenceOrbit,
+                            EquatorialCircularReferenceOrbit,
+                            SunSynchronousCircularOrbit,
+                        ]
             
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'outRegulators':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'initialStateDefParams':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            id = schemas.StrSchema
             
             
-            class loads(
-                schemas.ListSchema
+            class orbitalElements(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            OrbitalElementsData,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'loads':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'orbitalElements':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            period = schemas.NumberSchema
+            semiLatusRectum = schemas.NumberSchema
+            radiusPerigee = schemas.NumberSchema
             
             
-            class dynamicallyLoadedComponents(
-                schemas.ListSchema
+            class shadow(
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    inclusive_maximum = 1.0
+                    inclusive_minimum = 0.0
             
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'dynamicallyLoadedComponents':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            class beta(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_maximum = 1.5707963267948966
+                    inclusive_minimum = -1.5707963267948966
             
             
-            class outputPowers(
-                schemas.DictSchema
+            class magneticFieldVector(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    additional_properties = schemas.NumberSchema
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            FrameVectorBase306,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
-                ) -> 'outputPowers':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'magneticFieldVector':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            atmosphericDensity = schemas.NumberSchema
+            
+            
+            class lst(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_maximum = 360.0
+                    inclusive_minimum = -360.0
             __annotations__ = {
-                "name": name,
-                "inputType": inputType,
-                "voltage": voltage,
-                "maxOutputPower": maxOutputPower,
-                "efficiency": efficiency,
+                "initialStateDefType": initialStateDefType,
+                "initialStateDefParams": initialStateDefParams,
                 "id": id,
-                "inRegulator": inRegulator,
-                "powerProcessor": powerProcessor,
-                "outRegulators": outRegulators,
-                "loads": loads,
-                "dynamicallyLoadedComponents": dynamicallyLoadedComponents,
-                "outputPowers": outputPowers,
+                "orbitalElements": orbitalElements,
+                "period": period,
+                "semiLatusRectum": semiLatusRectum,
+                "radiusPerigee": radiusPerigee,
+                "shadow": shadow,
+                "beta": beta,
+                "magneticFieldVector": magneticFieldVector,
+                "atmosphericDensity": atmosphericDensity,
+                "lst": lst,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    efficiency: MetaOapg.properties.efficiency
-    name: MetaOapg.properties.name
-    inputType: MetaOapg.properties.inputType
-    maxOutputPower: MetaOapg.properties.maxOutputPower
-    voltage: MetaOapg.properties.voltage
+    initialStateDefType: MetaOapg.properties.initialStateDefType
+    initialStateDefParams: MetaOapg.properties.initialStateDefParams
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["efficiency"]) -> MetaOapg.properties.efficiency: ...
+    def __getitem__(self, name: typing_extensions.Literal["initialStateDefType"]) -> MetaOapg.properties.initialStateDefType: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["initialStateDefParams"]) -> MetaOapg.properties.initialStateDefParams: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputType"]) -> MetaOapg.properties.inputType: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["maxOutputPower"]) -> MetaOapg.properties.maxOutputPower: ...
+    def __getitem__(self, name: typing_extensions.Literal["orbitalElements"]) -> MetaOapg.properties.orbitalElements: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["voltage"]) -> MetaOapg.properties.voltage: ...
+    def __getitem__(self, name: typing_extensions.Literal["period"]) -> MetaOapg.properties.period: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["semiLatusRectum"]) -> MetaOapg.properties.semiLatusRectum: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inRegulator"]) -> MetaOapg.properties.inRegulator: ...
+    def __getitem__(self, name: typing_extensions.Literal["radiusPerigee"]) -> MetaOapg.properties.radiusPerigee: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
+    def __getitem__(self, name: typing_extensions.Literal["shadow"]) -> MetaOapg.properties.shadow: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["outRegulators"]) -> MetaOapg.properties.outRegulators: ...
+    def __getitem__(self, name: typing_extensions.Literal["beta"]) -> MetaOapg.properties.beta: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["loads"]) -> MetaOapg.properties.loads: ...
+    def __getitem__(self, name: typing_extensions.Literal["magneticFieldVector"]) -> MetaOapg.properties.magneticFieldVector: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> MetaOapg.properties.dynamicallyLoadedComponents: ...
+    def __getitem__(self, name: typing_extensions.Literal["atmosphericDensity"]) -> MetaOapg.properties.atmosphericDensity: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["outputPowers"]) -> MetaOapg.properties.outputPowers: ...
+    def __getitem__(self, name: typing_extensions.Literal["lst"]) -> MetaOapg.properties.lst: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["efficiency"], typing_extensions.Literal["name"], typing_extensions.Literal["inputType"], typing_extensions.Literal["maxOutputPower"], typing_extensions.Literal["voltage"], typing_extensions.Literal["id"], typing_extensions.Literal["inRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["outRegulators"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["outputPowers"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialStateDefType"], typing_extensions.Literal["initialStateDefParams"], typing_extensions.Literal["id"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["period"], typing_extensions.Literal["semiLatusRectum"], typing_extensions.Literal["radiusPerigee"], typing_extensions.Literal["shadow"], typing_extensions.Literal["beta"], typing_extensions.Literal["magneticFieldVector"], typing_extensions.Literal["atmosphericDensity"], typing_extensions.Literal["lst"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["efficiency"]) -> MetaOapg.properties.efficiency: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["initialStateDefType"]) -> MetaOapg.properties.initialStateDefType: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["initialStateDefParams"]) -> MetaOapg.properties.initialStateDefParams: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputType"]) -> MetaOapg.properties.inputType: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["maxOutputPower"]) -> MetaOapg.properties.maxOutputPower: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["orbitalElements"]) -> typing.Union[MetaOapg.properties.orbitalElements, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["voltage"]) -> MetaOapg.properties.voltage: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["period"]) -> typing.Union[MetaOapg.properties.period, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["semiLatusRectum"]) -> typing.Union[MetaOapg.properties.semiLatusRectum, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inRegulator"]) -> typing.Union[MetaOapg.properties.inRegulator, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["radiusPerigee"]) -> typing.Union[MetaOapg.properties.radiusPerigee, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["shadow"]) -> typing.Union[MetaOapg.properties.shadow, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["outRegulators"]) -> typing.Union[MetaOapg.properties.outRegulators, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["beta"]) -> typing.Union[MetaOapg.properties.beta, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["loads"]) -> typing.Union[MetaOapg.properties.loads, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["magneticFieldVector"]) -> typing.Union[MetaOapg.properties.magneticFieldVector, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["atmosphericDensity"]) -> typing.Union[MetaOapg.properties.atmosphericDensity, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["outputPowers"]) -> typing.Union[MetaOapg.properties.outputPowers, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["lst"]) -> typing.Union[MetaOapg.properties.lst, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["efficiency"], typing_extensions.Literal["name"], typing_extensions.Literal["inputType"], typing_extensions.Literal["maxOutputPower"], typing_extensions.Literal["voltage"], typing_extensions.Literal["id"], typing_extensions.Literal["inRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["outRegulators"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["outputPowers"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialStateDefType"], typing_extensions.Literal["initialStateDefParams"], typing_extensions.Literal["id"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["period"], typing_extensions.Literal["semiLatusRectum"], typing_extensions.Literal["radiusPerigee"], typing_extensions.Literal["shadow"], typing_extensions.Literal["beta"], typing_extensions.Literal["magneticFieldVector"], typing_extensions.Literal["atmosphericDensity"], typing_extensions.Literal["lst"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        efficiency: typing.Union[MetaOapg.properties.efficiency, decimal.Decimal, int, float, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
-        inputType: typing.Union[MetaOapg.properties.inputType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        maxOutputPower: typing.Union[MetaOapg.properties.maxOutputPower, decimal.Decimal, int, float, ],
-        voltage: typing.Union[MetaOapg.properties.voltage, decimal.Decimal, int, float, ],
+        initialStateDefType: typing.Union[MetaOapg.properties.initialStateDefType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        initialStateDefParams: typing.Union[MetaOapg.properties.initialStateDefParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        inRegulator: typing.Union[MetaOapg.properties.inRegulator, str, schemas.Unset] = schemas.unset,
-        powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
-        outRegulators: typing.Union[MetaOapg.properties.outRegulators, list, tuple, schemas.Unset] = schemas.unset,
-        loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
-        dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
-        outputPowers: typing.Union[MetaOapg.properties.outputPowers, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        orbitalElements: typing.Union[MetaOapg.properties.orbitalElements, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        period: typing.Union[MetaOapg.properties.period, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        semiLatusRectum: typing.Union[MetaOapg.properties.semiLatusRectum, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        radiusPerigee: typing.Union[MetaOapg.properties.radiusPerigee, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        shadow: typing.Union[MetaOapg.properties.shadow, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        beta: typing.Union[MetaOapg.properties.beta, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        magneticFieldVector: typing.Union[MetaOapg.properties.magneticFieldVector, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        atmosphericDensity: typing.Union[MetaOapg.properties.atmosphericDensity, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        lst: typing.Union[MetaOapg.properties.lst, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'BusRegulator':
+    ) -> 'Orbit':
         return super().__new__(
             cls,
             *_args,
-            efficiency=efficiency,
-            name=name,
-            inputType=inputType,
-            maxOutputPower=maxOutputPower,
-            voltage=voltage,
+            initialStateDefType=initialStateDefType,
+            initialStateDefParams=initialStateDefParams,
             id=id,
-            inRegulator=inRegulator,
-            powerProcessor=powerProcessor,
-            outRegulators=outRegulators,
-            loads=loads,
-            dynamicallyLoadedComponents=dynamicallyLoadedComponents,
-            outputPowers=outputPowers,
+            orbitalElements=orbitalElements,
+            period=period,
+            semiLatusRectum=semiLatusRectum,
+            radiusPerigee=radiusPerigee,
+            shadow=shadow,
+            beta=beta,
+            magneticFieldVector=magneticFieldVector,
+            atmosphericDensity=atmosphericDensity,
+            lst=lst,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.input_types import InputTypes
+from sedaro_base_client.model.classical_orbital_elements import ClassicalOrbitalElements
+from sedaro_base_client.model.equatorial_circular_reference_orbit import EquatorialCircularReferenceOrbit
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
+from sedaro_base_client.model.geostationary_reference_orbit import GeostationaryReferenceOrbit
+from sedaro_base_client.model.geostationary_transfer_reference_orbit import GeostationaryTransferReferenceOrbit
+from sedaro_base_client.model.initial_state_def_type import InitialStateDefType
+from sedaro_base_client.model.iss_reference_orbit import IssReferenceOrbit
+from sedaro_base_client.model.orbital_elements_data import OrbitalElementsData
+from sedaro_base_client.model.polar_circular_reference_orbit import PolarCircularReferenceOrbit
+from sedaro_base_client.model.state_vector import StateVector
+from sedaro_base_client.model.sun_synchronous_circular_orbit import SunSynchronousCircularOrbit
+from sedaro_base_client.model.tle import Tle
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/categories.py` & `sedaro-4.3.2/src/sedaro_base_client/model/categories.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/celestial_pointing_directions.py` & `sedaro-4.3.2/src/sedaro_base_client/model/satellite_parameters.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,78 +19,68 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class CelestialPointingDirections(
+class SatelliteParameters(
     schemas.EnumBase,
     schemas.StrSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     An enumeration.
     """
 
 
     class MetaOapg:
         enum_value_to_name = {
-            "SUN": "SUN",
-            "MOON": "MOON",
-            "EARTH": "EARTH",
-            "MERCURY": "MERCURY",
-            "VENUS": "VENUS",
-            "MARS": "MARS",
-            "JUPITER": "JUPITER",
-            "SATURN": "SATURN",
-            "URANUS": "URANUS",
-            "NEPTUNE": "NEPTUNE",
-            "PLUTO": "PLUTO",
+            "SHADOW": "SHADOW",
+            "BETA": "BETA",
+            "MEAN_ANOM": "MEAN_ANOM",
+            "TRUE_ANOM": "TRUE_ANOM",
+            "LAT": "LAT",
+            "LON": "LON",
+            "ALT": "ALT",
+            "LOCAL_SIDEREAL_TIME": "LOCAL_SIDEREAL_TIME",
+            "BATTERY_SOC": "BATTERY_SOC",
         }
     
     @schemas.classproperty
-    def SUN(cls):
-        return cls("SUN")
+    def SHADOW(cls):
+        return cls("SHADOW")
     
     @schemas.classproperty
-    def MOON(cls):
-        return cls("MOON")
+    def BETA(cls):
+        return cls("BETA")
     
     @schemas.classproperty
-    def EARTH(cls):
-        return cls("EARTH")
+    def MEAN_ANOM(cls):
+        return cls("MEAN_ANOM")
     
     @schemas.classproperty
-    def MERCURY(cls):
-        return cls("MERCURY")
+    def TRUE_ANOM(cls):
+        return cls("TRUE_ANOM")
     
     @schemas.classproperty
-    def VENUS(cls):
-        return cls("VENUS")
+    def LAT(cls):
+        return cls("LAT")
     
     @schemas.classproperty
-    def MARS(cls):
-        return cls("MARS")
+    def LON(cls):
+        return cls("LON")
     
     @schemas.classproperty
-    def JUPITER(cls):
-        return cls("JUPITER")
+    def ALT(cls):
+        return cls("ALT")
     
     @schemas.classproperty
-    def SATURN(cls):
-        return cls("SATURN")
+    def LOCAL_SIDEREAL_TIME(cls):
+        return cls("LOCAL_SIDEREAL_TIME")
     
     @schemas.classproperty
-    def URANUS(cls):
-        return cls("URANUS")
-    
-    @schemas.classproperty
-    def NEPTUNE(cls):
-        return cls("NEPTUNE")
-    
-    @schemas.classproperty
-    def PLUTO(cls):
-        return cls("PLUTO")
+    def BATTERY_SOC(cls):
+        return cls("BATTERY_SOC")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/celestial_target.py` & `sedaro-4.3.2/src/sedaro_base_client/model/max_align_pointing_mode.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class CelestialTarget(
+class MaxAlignPointingMode(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -47,231 +47,212 @@
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
             id = schemas.StrSchema
-            rel_agentId = schemas.StrSchema
-            shadow = schemas.BoolSchema
-            lst = schemas.NumberSchema
-            position = schemas.AnyTypeSchema
-        
-            @staticmethod
-            def lat() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def lon() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def alt() -> typing.Type['AngleBase299']:
-                return AngleBase299
-            range = schemas.NumberSchema
-            lineOfSight = schemas.BoolSchema
-            relativePosition = schemas.AnyTypeSchema
-        
-            @staticmethod
-            def azimuth() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def elevation() -> typing.Type['AngleBase299']:
-                return AngleBase299
+            odAlgorithm = schemas.StrSchema
+            adAlgorithm = schemas.StrSchema
+            tcAlgorithm = schemas.StrSchema
             
             
-            class polynomialEphemerisBody(
-                schemas.ComposedSchema,
+            class reactionWheelCommands(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            PolynomialEphemerisBody,
-                        ]
+                    items = schemas.NumberSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'reactionWheelCommands':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class magnetorquerCommands(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'polynomialEphemerisBody':
+                ) -> 'magnetorquerCommands':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            commandedAttitude = schemas.AnyTypeSchema
+            commandedAngularRates = schemas.AnyTypeSchema
+            lockBodyFrameVector = schemas.StrSchema
+            lockVector = schemas.StrSchema
+            acAlgorithm = schemas.StrSchema
+            maxAlignBodyFrameVector = schemas.StrSchema
+            maxAlignVector = schemas.StrSchema
             __annotations__ = {
                 "name": name,
                 "id": id,
-                "rel_agentId": rel_agentId,
-                "shadow": shadow,
-                "lst": lst,
-                "position": position,
-                "lat": lat,
-                "lon": lon,
-                "alt": alt,
-                "range": range,
-                "lineOfSight": lineOfSight,
-                "relativePosition": relativePosition,
-                "azimuth": azimuth,
-                "elevation": elevation,
-                "polynomialEphemerisBody": polynomialEphemerisBody,
+                "odAlgorithm": odAlgorithm,
+                "adAlgorithm": adAlgorithm,
+                "tcAlgorithm": tcAlgorithm,
+                "reactionWheelCommands": reactionWheelCommands,
+                "magnetorquerCommands": magnetorquerCommands,
+                "commandedAttitude": commandedAttitude,
+                "commandedAngularRates": commandedAngularRates,
+                "lockBodyFrameVector": lockBodyFrameVector,
+                "lockVector": lockVector,
+                "acAlgorithm": acAlgorithm,
+                "maxAlignBodyFrameVector": maxAlignBodyFrameVector,
+                "maxAlignVector": maxAlignVector,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rel_agentId"]) -> MetaOapg.properties.rel_agentId: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["shadow"]) -> MetaOapg.properties.shadow: ...
+    def __getitem__(self, name: typing_extensions.Literal["odAlgorithm"]) -> MetaOapg.properties.odAlgorithm: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lst"]) -> MetaOapg.properties.lst: ...
+    def __getitem__(self, name: typing_extensions.Literal["adAlgorithm"]) -> MetaOapg.properties.adAlgorithm: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["position"]) -> MetaOapg.properties.position: ...
+    def __getitem__(self, name: typing_extensions.Literal["tcAlgorithm"]) -> MetaOapg.properties.tcAlgorithm: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lat"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["reactionWheelCommands"]) -> MetaOapg.properties.reactionWheelCommands: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lon"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["magnetorquerCommands"]) -> MetaOapg.properties.magnetorquerCommands: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["commandedAttitude"]) -> MetaOapg.properties.commandedAttitude: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["range"]) -> MetaOapg.properties.range: ...
+    def __getitem__(self, name: typing_extensions.Literal["commandedAngularRates"]) -> MetaOapg.properties.commandedAngularRates: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lineOfSight"]) -> MetaOapg.properties.lineOfSight: ...
+    def __getitem__(self, name: typing_extensions.Literal["lockBodyFrameVector"]) -> MetaOapg.properties.lockBodyFrameVector: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relativePosition"]) -> MetaOapg.properties.relativePosition: ...
+    def __getitem__(self, name: typing_extensions.Literal["lockVector"]) -> MetaOapg.properties.lockVector: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["azimuth"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["acAlgorithm"]) -> MetaOapg.properties.acAlgorithm: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["elevation"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["maxAlignBodyFrameVector"]) -> MetaOapg.properties.maxAlignBodyFrameVector: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["polynomialEphemerisBody"]) -> MetaOapg.properties.polynomialEphemerisBody: ...
+    def __getitem__(self, name: typing_extensions.Literal["maxAlignVector"]) -> MetaOapg.properties.maxAlignVector: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rel_agentId"], typing_extensions.Literal["shadow"], typing_extensions.Literal["lst"], typing_extensions.Literal["position"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["azimuth"], typing_extensions.Literal["elevation"], typing_extensions.Literal["polynomialEphemerisBody"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["odAlgorithm"], typing_extensions.Literal["adAlgorithm"], typing_extensions.Literal["tcAlgorithm"], typing_extensions.Literal["reactionWheelCommands"], typing_extensions.Literal["magnetorquerCommands"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lockBodyFrameVector"], typing_extensions.Literal["lockVector"], typing_extensions.Literal["acAlgorithm"], typing_extensions.Literal["maxAlignBodyFrameVector"], typing_extensions.Literal["maxAlignVector"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rel_agentId"]) -> typing.Union[MetaOapg.properties.rel_agentId, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["odAlgorithm"]) -> typing.Union[MetaOapg.properties.odAlgorithm, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["shadow"]) -> typing.Union[MetaOapg.properties.shadow, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["adAlgorithm"]) -> typing.Union[MetaOapg.properties.adAlgorithm, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lst"]) -> typing.Union[MetaOapg.properties.lst, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["tcAlgorithm"]) -> typing.Union[MetaOapg.properties.tcAlgorithm, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union[MetaOapg.properties.position, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["reactionWheelCommands"]) -> typing.Union[MetaOapg.properties.reactionWheelCommands, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lat"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["magnetorquerCommands"]) -> typing.Union[MetaOapg.properties.magnetorquerCommands, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lon"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["commandedAttitude"]) -> typing.Union[MetaOapg.properties.commandedAttitude, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["commandedAngularRates"]) -> typing.Union[MetaOapg.properties.commandedAngularRates, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["range"]) -> typing.Union[MetaOapg.properties.range, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["lockBodyFrameVector"]) -> typing.Union[MetaOapg.properties.lockBodyFrameVector, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lineOfSight"]) -> typing.Union[MetaOapg.properties.lineOfSight, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["lockVector"]) -> typing.Union[MetaOapg.properties.lockVector, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relativePosition"]) -> typing.Union[MetaOapg.properties.relativePosition, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["acAlgorithm"]) -> typing.Union[MetaOapg.properties.acAlgorithm, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["azimuth"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["maxAlignBodyFrameVector"]) -> typing.Union[MetaOapg.properties.maxAlignBodyFrameVector, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["elevation"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["maxAlignVector"]) -> typing.Union[MetaOapg.properties.maxAlignVector, schemas.Unset]: ...
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["polynomialEphemerisBody"]) -> typing.Union[MetaOapg.properties.polynomialEphemerisBody, schemas.Unset]: ...
-    
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rel_agentId"], typing_extensions.Literal["shadow"], typing_extensions.Literal["lst"], typing_extensions.Literal["position"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["azimuth"], typing_extensions.Literal["elevation"], typing_extensions.Literal["polynomialEphemerisBody"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["odAlgorithm"], typing_extensions.Literal["adAlgorithm"], typing_extensions.Literal["tcAlgorithm"], typing_extensions.Literal["reactionWheelCommands"], typing_extensions.Literal["magnetorquerCommands"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lockBodyFrameVector"], typing_extensions.Literal["lockVector"], typing_extensions.Literal["acAlgorithm"], typing_extensions.Literal["maxAlignBodyFrameVector"], typing_extensions.Literal["maxAlignVector"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        rel_agentId: typing.Union[MetaOapg.properties.rel_agentId, str, schemas.Unset] = schemas.unset,
-        shadow: typing.Union[MetaOapg.properties.shadow, bool, schemas.Unset] = schemas.unset,
-        lst: typing.Union[MetaOapg.properties.lst, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        position: typing.Union[MetaOapg.properties.position, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        lat: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        lon: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        alt: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        range: typing.Union[MetaOapg.properties.range, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        lineOfSight: typing.Union[MetaOapg.properties.lineOfSight, bool, schemas.Unset] = schemas.unset,
-        relativePosition: typing.Union[MetaOapg.properties.relativePosition, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        azimuth: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        elevation: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        polynomialEphemerisBody: typing.Union[MetaOapg.properties.polynomialEphemerisBody, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        odAlgorithm: typing.Union[MetaOapg.properties.odAlgorithm, str, schemas.Unset] = schemas.unset,
+        adAlgorithm: typing.Union[MetaOapg.properties.adAlgorithm, str, schemas.Unset] = schemas.unset,
+        tcAlgorithm: typing.Union[MetaOapg.properties.tcAlgorithm, str, schemas.Unset] = schemas.unset,
+        reactionWheelCommands: typing.Union[MetaOapg.properties.reactionWheelCommands, list, tuple, schemas.Unset] = schemas.unset,
+        magnetorquerCommands: typing.Union[MetaOapg.properties.magnetorquerCommands, list, tuple, schemas.Unset] = schemas.unset,
+        commandedAttitude: typing.Union[MetaOapg.properties.commandedAttitude, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        commandedAngularRates: typing.Union[MetaOapg.properties.commandedAngularRates, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        lockBodyFrameVector: typing.Union[MetaOapg.properties.lockBodyFrameVector, str, schemas.Unset] = schemas.unset,
+        lockVector: typing.Union[MetaOapg.properties.lockVector, str, schemas.Unset] = schemas.unset,
+        acAlgorithm: typing.Union[MetaOapg.properties.acAlgorithm, str, schemas.Unset] = schemas.unset,
+        maxAlignBodyFrameVector: typing.Union[MetaOapg.properties.maxAlignBodyFrameVector, str, schemas.Unset] = schemas.unset,
+        maxAlignVector: typing.Union[MetaOapg.properties.maxAlignVector, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CelestialTarget':
+    ) -> 'MaxAlignPointingMode':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
-            rel_agentId=rel_agentId,
-            shadow=shadow,
-            lst=lst,
-            position=position,
-            lat=lat,
-            lon=lon,
-            alt=alt,
-            range=range,
-            lineOfSight=lineOfSight,
-            relativePosition=relativePosition,
-            azimuth=azimuth,
-            elevation=elevation,
-            polynomialEphemerisBody=polynomialEphemerisBody,
+            odAlgorithm=odAlgorithm,
+            adAlgorithm=adAlgorithm,
+            tcAlgorithm=tcAlgorithm,
+            reactionWheelCommands=reactionWheelCommands,
+            magnetorquerCommands=magnetorquerCommands,
+            commandedAttitude=commandedAttitude,
+            commandedAngularRates=commandedAngularRates,
+            lockBodyFrameVector=lockBodyFrameVector,
+            lockVector=lockVector,
+            acAlgorithm=acAlgorithm,
+            maxAlignBodyFrameVector=maxAlignBodyFrameVector,
+            maxAlignVector=maxAlignVector,
             _configuration=_configuration,
         )
-
-from sedaro_base_client.model.angle_base299 import AngleBase299
-from sedaro_base_client.model.polynomial_ephemeris_body import PolynomialEphemerisBody
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/celestial_vector.py` & `sedaro-4.3.2/src/sedaro_base_client/model/circular_field_of_view.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,37 +19,45 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class CelestialVector(
+class CircularFieldOfView(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
+            "halfAngle",
             "name",
-            "celestialPointingDirection",
         }
         
         class properties:
-            name = schemas.StrSchema
             
             
-            class celestialPointingDirection(
+            class name(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 100
+            
+            
+            class halfAngle(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -59,107 +67,119 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            CelestialPointingDirections,
+                            AngleFieldOfView30,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'celestialPointingDirection':
+                ) -> 'halfAngle':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             id = schemas.StrSchema
-            truth = schemas.AnyTypeSchema
-            estimate = schemas.AnyTypeSchema
-            eclipsed = schemas.BoolSchema
+            boresightBodyFrameVector = schemas.StrSchema
+            
+            
+            class sensors(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'sensors':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             __annotations__ = {
                 "name": name,
-                "celestialPointingDirection": celestialPointingDirection,
+                "halfAngle": halfAngle,
                 "id": id,
-                "truth": truth,
-                "estimate": estimate,
-                "eclipsed": eclipsed,
+                "boresightBodyFrameVector": boresightBodyFrameVector,
+                "sensors": sensors,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
+    halfAngle: MetaOapg.properties.halfAngle
     name: MetaOapg.properties.name
-    celestialPointingDirection: MetaOapg.properties.celestialPointingDirection
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["halfAngle"]) -> MetaOapg.properties.halfAngle: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["celestialPointingDirection"]) -> MetaOapg.properties.celestialPointingDirection: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["truth"]) -> MetaOapg.properties.truth: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["estimate"]) -> MetaOapg.properties.estimate: ...
+    def __getitem__(self, name: typing_extensions.Literal["boresightBodyFrameVector"]) -> MetaOapg.properties.boresightBodyFrameVector: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["eclipsed"]) -> MetaOapg.properties.eclipsed: ...
+    def __getitem__(self, name: typing_extensions.Literal["sensors"]) -> MetaOapg.properties.sensors: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["celestialPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["halfAngle"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["boresightBodyFrameVector"], typing_extensions.Literal["sensors"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["halfAngle"]) -> MetaOapg.properties.halfAngle: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["celestialPointingDirection"]) -> MetaOapg.properties.celestialPointingDirection: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["truth"]) -> typing.Union[MetaOapg.properties.truth, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["estimate"]) -> typing.Union[MetaOapg.properties.estimate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["boresightBodyFrameVector"]) -> typing.Union[MetaOapg.properties.boresightBodyFrameVector, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["eclipsed"]) -> typing.Union[MetaOapg.properties.eclipsed, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["sensors"]) -> typing.Union[MetaOapg.properties.sensors, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["celestialPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["halfAngle"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["boresightBodyFrameVector"], typing_extensions.Literal["sensors"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
+        halfAngle: typing.Union[MetaOapg.properties.halfAngle, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        celestialPointingDirection: typing.Union[MetaOapg.properties.celestialPointingDirection, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        truth: typing.Union[MetaOapg.properties.truth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        estimate: typing.Union[MetaOapg.properties.estimate, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        eclipsed: typing.Union[MetaOapg.properties.eclipsed, bool, schemas.Unset] = schemas.unset,
+        boresightBodyFrameVector: typing.Union[MetaOapg.properties.boresightBodyFrameVector, str, schemas.Unset] = schemas.unset,
+        sensors: typing.Union[MetaOapg.properties.sensors, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CelestialVector':
+    ) -> 'CircularFieldOfView':
         return super().__new__(
             cls,
             *_args,
+            halfAngle=halfAngle,
             name=name,
-            celestialPointingDirection=celestialPointingDirection,
             id=id,
-            truth=truth,
-            estimate=estimate,
-            eclipsed=eclipsed,
+            boresightBodyFrameVector=boresightBodyFrameVector,
+            sensors=sensors,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.celestial_pointing_directions import CelestialPointingDirections
+from sedaro_base_client.model.angle_field_of_view30 import AngleFieldOfView30
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/circular_field_of_view.py` & `sedaro-4.3.2/src/sedaro_base_client/model/temp_controller_state.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,29 +19,29 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class CircularFieldOfView(
+class TempControllerState(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "halfAngle",
+            "constantTemperature",
             "name",
         }
         
         class properties:
             
             
             class name(
@@ -49,15 +49,15 @@
             ):
             
             
                 class MetaOapg:
                     max_length = 100
             
             
-            class halfAngle(
+            class constantTemperature(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -67,119 +67,129 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            AngleFieldOfView31,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'halfAngle':
+                ) -> 'constantTemperature':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             id = schemas.StrSchema
-            boresightBodyFrameVector = schemas.StrSchema
+            tempController = schemas.StrSchema
             
             
-            class sensors(
+            class operationalModes(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'sensors':
+                ) -> 'operationalModes':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
+            active = schemas.BoolSchema
             __annotations__ = {
                 "name": name,
-                "halfAngle": halfAngle,
+                "constantTemperature": constantTemperature,
                 "id": id,
-                "boresightBodyFrameVector": boresightBodyFrameVector,
-                "sensors": sensors,
+                "tempController": tempController,
+                "operationalModes": operationalModes,
+                "active": active,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    halfAngle: MetaOapg.properties.halfAngle
+    constantTemperature: MetaOapg.properties.constantTemperature
     name: MetaOapg.properties.name
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["halfAngle"]) -> MetaOapg.properties.halfAngle: ...
+    def __getitem__(self, name: typing_extensions.Literal["constantTemperature"]) -> MetaOapg.properties.constantTemperature: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["boresightBodyFrameVector"]) -> MetaOapg.properties.boresightBodyFrameVector: ...
+    def __getitem__(self, name: typing_extensions.Literal["tempController"]) -> MetaOapg.properties.tempController: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["sensors"]) -> MetaOapg.properties.sensors: ...
+    def __getitem__(self, name: typing_extensions.Literal["operationalModes"]) -> MetaOapg.properties.operationalModes: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["halfAngle"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["boresightBodyFrameVector"], typing_extensions.Literal["sensors"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["constantTemperature"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["tempController"], typing_extensions.Literal["operationalModes"], typing_extensions.Literal["active"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["halfAngle"]) -> MetaOapg.properties.halfAngle: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["constantTemperature"]) -> MetaOapg.properties.constantTemperature: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["boresightBodyFrameVector"]) -> typing.Union[MetaOapg.properties.boresightBodyFrameVector, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["tempController"]) -> typing.Union[MetaOapg.properties.tempController, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["operationalModes"]) -> typing.Union[MetaOapg.properties.operationalModes, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["sensors"]) -> typing.Union[MetaOapg.properties.sensors, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["active"]) -> typing.Union[MetaOapg.properties.active, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["halfAngle"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["boresightBodyFrameVector"], typing_extensions.Literal["sensors"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["constantTemperature"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["tempController"], typing_extensions.Literal["operationalModes"], typing_extensions.Literal["active"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        halfAngle: typing.Union[MetaOapg.properties.halfAngle, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        constantTemperature: typing.Union[MetaOapg.properties.constantTemperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        boresightBodyFrameVector: typing.Union[MetaOapg.properties.boresightBodyFrameVector, str, schemas.Unset] = schemas.unset,
-        sensors: typing.Union[MetaOapg.properties.sensors, list, tuple, schemas.Unset] = schemas.unset,
+        tempController: typing.Union[MetaOapg.properties.tempController, str, schemas.Unset] = schemas.unset,
+        operationalModes: typing.Union[MetaOapg.properties.operationalModes, list, tuple, schemas.Unset] = schemas.unset,
+        active: typing.Union[MetaOapg.properties.active, bool, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CircularFieldOfView':
+    ) -> 'TempControllerState':
         return super().__new__(
             cls,
             *_args,
-            halfAngle=halfAngle,
+            constantTemperature=constantTemperature,
             name=name,
             id=id,
-            boresightBodyFrameVector=boresightBodyFrameVector,
-            sensors=sensors,
+            tempController=tempController,
+            operationalModes=operationalModes,
+            active=active,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.angle_field_of_view31 import AngleFieldOfView31
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/classical_orbital_elements.py` & `sedaro-4.3.2/src/sedaro_base_client/model/classical_orbital_elements.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/clock_config.py` & `sedaro-4.3.2/src/sedaro_base_client/model/duration_load69.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,90 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ClockConfig(
+class DurationLoad69(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
-        required = {
-            "startTime",
-            "stopTime",
-        }
         
         class properties:
-            startTime = schemas.NumberSchema
-            stopTime = schemas.NumberSchema
-            id = schemas.StrSchema
-            realTime = schemas.BoolSchema
+            s = schemas.NumberSchema
+            
+            
+            class day(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            min = schemas.NumberSchema
+            hour = schemas.NumberSchema
             __annotations__ = {
-                "startTime": startTime,
-                "stopTime": stopTime,
-                "id": id,
-                "realTime": realTime,
+                "s": s,
+                "day": day,
+                "min": min,
+                "hour": hour,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    startTime: MetaOapg.properties.startTime
-    stopTime: MetaOapg.properties.stopTime
-    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["startTime"]) -> MetaOapg.properties.startTime: ...
+    def __getitem__(self, name: typing_extensions.Literal["s"]) -> MetaOapg.properties.s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stopTime"]) -> MetaOapg.properties.stopTime: ...
+    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["min"]) -> MetaOapg.properties.min: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["realTime"]) -> MetaOapg.properties.realTime: ...
+    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["startTime"], typing_extensions.Literal["stopTime"], typing_extensions.Literal["id"], typing_extensions.Literal["realTime"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["startTime"]) -> MetaOapg.properties.startTime: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["s"]) -> typing.Union[MetaOapg.properties.s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stopTime"]) -> MetaOapg.properties.stopTime: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["min"]) -> typing.Union[MetaOapg.properties.min, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["realTime"]) -> typing.Union[MetaOapg.properties.realTime, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["startTime"], typing_extensions.Literal["stopTime"], typing_extensions.Literal["id"], typing_extensions.Literal["realTime"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        startTime: typing.Union[MetaOapg.properties.startTime, decimal.Decimal, int, float, ],
-        stopTime: typing.Union[MetaOapg.properties.stopTime, decimal.Decimal, int, float, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        realTime: typing.Union[MetaOapg.properties.realTime, bool, schemas.Unset] = schemas.unset,
+        s: typing.Union[MetaOapg.properties.s, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        day: typing.Union[MetaOapg.properties.day, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ClockConfig':
+    ) -> 'DurationLoad69':
         return super().__new__(
             cls,
             *_args,
-            startTime=startTime,
-            stopTime=stopTime,
-            id=id,
-            realTime=realTime,
+            s=s,
+            day=day,
+            min=min,
+            hour=hour,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/component.py` & `sedaro-4.3.2/src/sedaro_base_client/model/component.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -85,15 +85,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -253,41 +253,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -309,15 +308,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -336,58 +335,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             __annotations__ = {
                 "name": name,
                 "id": id,
                 "partNumber": partNumber,
                 "manufacturer": manufacturer,
                 "hotTempRating": hotTempRating,
                 "coldTempRating": coldTempRating,
@@ -565,21 +592,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'Component':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
@@ -602,8 +629,9 @@
             temperature=temperature,
             storage=storage,
             readRate=readRate,
             writeRate=writeRate,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/component_parameters.py` & `sedaro-4.3.2/src/sedaro_base_client/model/eps_output_types.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,33 +19,33 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ComponentParameters(
+class EpsOutputTypes(
     schemas.EnumBase,
     schemas.StrSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     An enumeration.
     """
 
 
     class MetaOapg:
         enum_value_to_name = {
-            "DATA_STORAGE_FILL_PERCENT": "DATA_STORAGE_FILL_PERCENT",
-            "TEMPERATURE": "TEMPERATURE",
+            "CORE_OUTPUT": "CORE_OUTPUT",
+            "BUS_REGULATOR": "BUS_REGULATOR",
         }
     
     @schemas.classproperty
-    def DATA_STORAGE_FILL_PERCENT(cls):
-        return cls("DATA_STORAGE_FILL_PERCENT")
+    def CORE_OUTPUT(cls):
+        return cls("CORE_OUTPUT")
     
     @schemas.classproperty
-    def TEMPERATURE(cls):
-        return cls("TEMPERATURE")
+    def BUS_REGULATOR(cls):
+        return cls("BUS_REGULATOR")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/component_to_scalar_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/component_to_scalar_condition.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/compound_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/compound_condition.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/compound_operators.py` & `sedaro-4.3.2/src/sedaro_base_client/model/compound_operators.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/condition_relationship.py` & `sedaro-4.3.2/src/sedaro_base_client/model/local_pointing_directions.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,53 +19,83 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ConditionRelationship(
+class LocalPointingDirections(
     schemas.EnumBase,
     schemas.StrSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     An enumeration.
     """
 
 
     class MetaOapg:
         enum_value_to_name = {
-            "GREATER": "GREATER",
-            "LESS": "LESS",
-            "GREATER_EQUAL": "GREATER_EQUAL",
-            "LESS_EQUAL": "LESS_EQUAL",
-            "EQUAL": "EQUAL",
-            "NOT_EQUAL": "NOT_EQUAL",
+            "NADIR": "NADIR",
+            "ZENITH": "ZENITH",
+            "CROSS_TRACK_POS": "CROSS_TRACK_POS",
+            "CROSS_TRACK_NEG": "CROSS_TRACK_NEG",
+            "ALONG_TRACK_POS": "ALONG_TRACK_POS",
+            "ALONG_TRACK_NEG": "ALONG_TRACK_NEG",
+            "RAM": "RAM",
+            "ANTI_RAM": "ANTI_RAM",
+            "MAGNETIC_FIELD": "MAGNETIC_FIELD",
+            "ECI_COORDINATES": "ECI_COORDINATES",
+            "ENU_COORDINATES": "ENU_COORDINATES",
+            "LVLH_COORDINATES": "LVLH_COORDINATES",
         }
     
     @schemas.classproperty
-    def GREATER(cls):
-        return cls("GREATER")
+    def NADIR(cls):
+        return cls("NADIR")
     
     @schemas.classproperty
-    def LESS(cls):
-        return cls("LESS")
+    def ZENITH(cls):
+        return cls("ZENITH")
     
     @schemas.classproperty
-    def GREATER_EQUAL(cls):
-        return cls("GREATER_EQUAL")
+    def CROSS_TRACK_POS(cls):
+        return cls("CROSS_TRACK_POS")
     
     @schemas.classproperty
-    def LESS_EQUAL(cls):
-        return cls("LESS_EQUAL")
+    def CROSS_TRACK_NEG(cls):
+        return cls("CROSS_TRACK_NEG")
     
     @schemas.classproperty
-    def EQUAL(cls):
-        return cls("EQUAL")
+    def ALONG_TRACK_POS(cls):
+        return cls("ALONG_TRACK_POS")
     
     @schemas.classproperty
-    def NOT_EQUAL(cls):
-        return cls("NOT_EQUAL")
+    def ALONG_TRACK_NEG(cls):
+        return cls("ALONG_TRACK_NEG")
+    
+    @schemas.classproperty
+    def RAM(cls):
+        return cls("RAM")
+    
+    @schemas.classproperty
+    def ANTI_RAM(cls):
+        return cls("ANTI_RAM")
+    
+    @schemas.classproperty
+    def MAGNETIC_FIELD(cls):
+        return cls("MAGNETIC_FIELD")
+    
+    @schemas.classproperty
+    def ECI_COORDINATES(cls):
+        return cls("ECI_COORDINATES")
+    
+    @schemas.classproperty
+    def ENU_COORDINATES(cls):
+        return cls("ENU_COORDINATES")
+    
+    @schemas.classproperty
+    def LVLH_COORDINATES(cls):
+        return cls("LVLH_COORDINATES")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/configuration_types.py` & `sedaro-4.3.2/src/sedaro_base_client/model/types.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,33 +19,38 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ConfigurationTypes(
+class Types(
     schemas.EnumBase,
     schemas.StrSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     An enumeration.
     """
 
 
     class MetaOapg:
         enum_value_to_name = {
-            "SERIES": "SERIES",
-            "PARALLEL": "PARALLEL",
+            "SpaceTarget": "SPACE_TARGET",
+            "CelestialTarget": "CELESTIAL_TARGET",
+            "GroundTarget": "GROUND_TARGET",
         }
     
     @schemas.classproperty
-    def SERIES(cls):
-        return cls("SERIES")
+    def SPACE_TARGET(cls):
+        return cls("SpaceTarget")
     
     @schemas.classproperty
-    def PARALLEL(cls):
-        return cls("PARALLEL")
+    def CELESTIAL_TARGET(cls):
+        return cls("CelestialTarget")
+    
+    @schemas.classproperty
+    def GROUND_TARGET(cls):
+        return cls("GroundTarget")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/conflicts_obj.py` & `sedaro-4.3.2/src/sedaro_base_client/model/conflicts_obj.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/constant_power_params.py` & `sedaro-4.3.2/src/sedaro_base_client/model/vector.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,73 +19,87 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ConstantPowerParams(
+class Vector(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
-            "power",
+            "vector",
         }
         
         class properties:
             
             
-            class power(
-                schemas.NumberSchema
+            class vector(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0.0
+                    items = schemas.NumberSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'vector':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             __annotations__ = {
-                "power": power,
+                "vector": vector,
             }
     
-    power: MetaOapg.properties.power
+    vector: MetaOapg.properties.vector
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["power"]) -> MetaOapg.properties.power: ...
+    def __getitem__(self, name: typing_extensions.Literal["vector"]) -> MetaOapg.properties.vector: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["power", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["vector", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["power"]) -> MetaOapg.properties.power: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["vector"]) -> MetaOapg.properties.vector: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["power", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["vector", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        power: typing.Union[MetaOapg.properties.power, decimal.Decimal, int, float, ],
+        vector: typing.Union[MetaOapg.properties.vector, list, tuple, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ConstantPowerParams':
+    ) -> 'Vector':
         return super().__new__(
             cls,
             *_args,
-            power=power,
+            vector=vector,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/constant_resistance_params.py` & `sedaro-4.3.2/src/sedaro_base_client/model/constant_resistance_params.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/cooler.py` & `sedaro-4.3.2/src/sedaro_base_client/model/cooler.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -87,15 +87,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -123,15 +123,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -255,41 +255,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -311,15 +310,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -338,63 +337,114 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             busRegulator = schemas.StrSchema
             powerProcessor = schemas.StrSchema
             controlledComponent = schemas.StrSchema
             
             
+            class tempControllerStates(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'tempControllerStates':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
             class regHeatFlowRate(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
@@ -414,15 +464,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -432,37 +482,14 @@
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class tempControllerStates(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'tempControllerStates':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
-            
             class efficiency(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_maximum = 1.0
@@ -490,17 +517,17 @@
                 "temperature": temperature,
                 "storage": storage,
                 "readRate": readRate,
                 "writeRate": writeRate,
                 "busRegulator": busRegulator,
                 "powerProcessor": powerProcessor,
                 "controlledComponent": controlledComponent,
+                "tempControllerStates": tempControllerStates,
                 "regHeatFlowRate": regHeatFlowRate,
                 "commandedTemperature": commandedTemperature,
-                "tempControllerStates": tempControllerStates,
                 "efficiency": efficiency,
                 "sinkHeatFlowRate": sinkHeatFlowRate,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
     onRegHeatFlowRate: MetaOapg.properties.onRegHeatFlowRate
@@ -580,29 +607,29 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["controlledComponent"]) -> MetaOapg.properties.controlledComponent: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> MetaOapg.properties.regHeatFlowRate: ...
+    def __getitem__(self, name: typing_extensions.Literal["tempControllerStates"]) -> MetaOapg.properties.tempControllerStates: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["commandedTemperature"]) -> MetaOapg.properties.commandedTemperature: ...
+    def __getitem__(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> MetaOapg.properties.regHeatFlowRate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["tempControllerStates"]) -> MetaOapg.properties.tempControllerStates: ...
+    def __getitem__(self, name: typing_extensions.Literal["commandedTemperature"]) -> MetaOapg.properties.commandedTemperature: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["efficiency"]) -> MetaOapg.properties.efficiency: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["sinkHeatFlowRate"]) -> MetaOapg.properties.sinkHeatFlowRate: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], typing_extensions.Literal["tempControllerStates"], typing_extensions.Literal["efficiency"], typing_extensions.Literal["sinkHeatFlowRate"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["tempControllerStates"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], typing_extensions.Literal["efficiency"], typing_extensions.Literal["sinkHeatFlowRate"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
@@ -677,29 +704,29 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["controlledComponent"]) -> typing.Union[MetaOapg.properties.controlledComponent, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> typing.Union[MetaOapg.properties.regHeatFlowRate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["tempControllerStates"]) -> typing.Union[MetaOapg.properties.tempControllerStates, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["commandedTemperature"]) -> typing.Union[MetaOapg.properties.commandedTemperature, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> typing.Union[MetaOapg.properties.regHeatFlowRate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["tempControllerStates"]) -> typing.Union[MetaOapg.properties.tempControllerStates, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["commandedTemperature"]) -> typing.Union[MetaOapg.properties.commandedTemperature, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["efficiency"]) -> typing.Union[MetaOapg.properties.efficiency, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["sinkHeatFlowRate"]) -> typing.Union[MetaOapg.properties.sinkHeatFlowRate, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], typing_extensions.Literal["tempControllerStates"], typing_extensions.Literal["efficiency"], typing_extensions.Literal["sinkHeatFlowRate"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["tempControllerStates"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], typing_extensions.Literal["efficiency"], typing_extensions.Literal["sinkHeatFlowRate"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         onRegHeatFlowRate: typing.Union[MetaOapg.properties.onRegHeatFlowRate, decimal.Decimal, int, float, ],
@@ -713,27 +740,27 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         busRegulator: typing.Union[MetaOapg.properties.busRegulator, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
         controlledComponent: typing.Union[MetaOapg.properties.controlledComponent, str, schemas.Unset] = schemas.unset,
+        tempControllerStates: typing.Union[MetaOapg.properties.tempControllerStates, list, tuple, schemas.Unset] = schemas.unset,
         regHeatFlowRate: typing.Union[MetaOapg.properties.regHeatFlowRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         commandedTemperature: typing.Union[MetaOapg.properties.commandedTemperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        tempControllerStates: typing.Union[MetaOapg.properties.tempControllerStates, list, tuple, schemas.Unset] = schemas.unset,
         efficiency: typing.Union[MetaOapg.properties.efficiency, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         sinkHeatFlowRate: typing.Union[MetaOapg.properties.sinkHeatFlowRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'Cooler':
         return super().__new__(
             cls,
             *_args,
@@ -759,16 +786,17 @@
             temperature=temperature,
             storage=storage,
             readRate=readRate,
             writeRate=writeRate,
             busRegulator=busRegulator,
             powerProcessor=powerProcessor,
             controlledComponent=controlledComponent,
+            tempControllerStates=tempControllerStates,
             regHeatFlowRate=regHeatFlowRate,
             commandedTemperature=commandedTemperature,
-            tempControllerStates=tempControllerStates,
             efficiency=efficiency,
             sinkHeatFlowRate=sinkHeatFlowRate,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/cooperative_transmit_interface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/cooperative_transmit_interface.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -89,17 +89,17 @@
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
             isActive = schemas.BoolSchema
             targetInFov = schemas.BoolSchema
             linkLatency = schemas.NumberSchema
+            linkTarget = schemas.StrSchema
             modem = schemas.StrSchema
             directedEnergyDevice = schemas.StrSchema
-            linkTarget = schemas.StrSchema
             linkTargetGroup = schemas.StrSchema
             canLink = schemas.BoolSchema
             activeLinkTarget = schemas.StrSchema
             __annotations__ = {
                 "name": name,
                 "onBitRate": onBitRate,
                 "alwaysActive": alwaysActive,
@@ -108,17 +108,17 @@
                 "opModes": opModes,
                 "source": source,
                 "sink": sink,
                 "bitRate": bitRate,
                 "isActive": isActive,
                 "targetInFov": targetInFov,
                 "linkLatency": linkLatency,
+                "linkTarget": linkTarget,
                 "modem": modem,
                 "directedEnergyDevice": directedEnergyDevice,
-                "linkTarget": linkTarget,
                 "linkTargetGroup": linkTargetGroup,
                 "canLink": canLink,
                 "activeLinkTarget": activeLinkTarget,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     onBitRate: MetaOapg.properties.onBitRate
@@ -158,32 +158,32 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["targetInFov"]) -> MetaOapg.properties.targetInFov: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["linkLatency"]) -> MetaOapg.properties.linkLatency: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["modem"]) -> MetaOapg.properties.modem: ...
+    def __getitem__(self, name: typing_extensions.Literal["linkTarget"]) -> MetaOapg.properties.linkTarget: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> MetaOapg.properties.directedEnergyDevice: ...
+    def __getitem__(self, name: typing_extensions.Literal["modem"]) -> MetaOapg.properties.modem: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["linkTarget"]) -> MetaOapg.properties.linkTarget: ...
+    def __getitem__(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> MetaOapg.properties.directedEnergyDevice: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["linkTargetGroup"]) -> MetaOapg.properties.linkTargetGroup: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["canLink"]) -> MetaOapg.properties.canLink: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["activeLinkTarget"]) -> MetaOapg.properties.activeLinkTarget: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["onBitRate"]) -> MetaOapg.properties.onBitRate: ...
     
     @typing.overload
@@ -216,32 +216,32 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["targetInFov"]) -> typing.Union[MetaOapg.properties.targetInFov, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["linkLatency"]) -> typing.Union[MetaOapg.properties.linkLatency, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["modem"]) -> typing.Union[MetaOapg.properties.modem, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["linkTarget"]) -> typing.Union[MetaOapg.properties.linkTarget, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> typing.Union[MetaOapg.properties.directedEnergyDevice, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["modem"]) -> typing.Union[MetaOapg.properties.modem, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["linkTarget"]) -> typing.Union[MetaOapg.properties.linkTarget, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> typing.Union[MetaOapg.properties.directedEnergyDevice, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["linkTargetGroup"]) -> typing.Union[MetaOapg.properties.linkTargetGroup, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["canLink"]) -> typing.Union[MetaOapg.properties.canLink, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["activeLinkTarget"]) -> typing.Union[MetaOapg.properties.activeLinkTarget, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         onBitRate: typing.Union[MetaOapg.properties.onBitRate, decimal.Decimal, int, float, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
@@ -251,17 +251,17 @@
         opModes: typing.Union[MetaOapg.properties.opModes, list, tuple, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         sink: typing.Union[MetaOapg.properties.sink, str, schemas.Unset] = schemas.unset,
         bitRate: typing.Union[MetaOapg.properties.bitRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         isActive: typing.Union[MetaOapg.properties.isActive, bool, schemas.Unset] = schemas.unset,
         targetInFov: typing.Union[MetaOapg.properties.targetInFov, bool, schemas.Unset] = schemas.unset,
         linkLatency: typing.Union[MetaOapg.properties.linkLatency, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        linkTarget: typing.Union[MetaOapg.properties.linkTarget, str, schemas.Unset] = schemas.unset,
         modem: typing.Union[MetaOapg.properties.modem, str, schemas.Unset] = schemas.unset,
         directedEnergyDevice: typing.Union[MetaOapg.properties.directedEnergyDevice, str, schemas.Unset] = schemas.unset,
-        linkTarget: typing.Union[MetaOapg.properties.linkTarget, str, schemas.Unset] = schemas.unset,
         linkTargetGroup: typing.Union[MetaOapg.properties.linkTargetGroup, str, schemas.Unset] = schemas.unset,
         canLink: typing.Union[MetaOapg.properties.canLink, bool, schemas.Unset] = schemas.unset,
         activeLinkTarget: typing.Union[MetaOapg.properties.activeLinkTarget, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'CooperativeTransmitInterface':
         return super().__new__(
             cls,
@@ -274,15 +274,15 @@
             opModes=opModes,
             source=source,
             sink=sink,
             bitRate=bitRate,
             isActive=isActive,
             targetInFov=targetInFov,
             linkLatency=linkLatency,
+            linkTarget=linkTarget,
             modem=modem,
             directedEnergyDevice=directedEnergyDevice,
-            linkTarget=linkTarget,
             linkTargetGroup=linkTargetGroup,
             canLink=canLink,
             activeLinkTarget=activeLinkTarget,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/crud_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/crud_res.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/data_bus.py` & `sedaro-4.3.2/src/sedaro_base_client/model/data_bus.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/data_interface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/data_interface.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/data_mode.py` & `sedaro-4.3.2/src/sedaro_base_client/model/data_mode.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/data_service_response.py` & `sedaro-4.3.2/src/sedaro_base_client/model/data_service_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/data_set.py` & `sedaro-4.3.2/src/sedaro_base_client/model/data_set.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/data_storage.py` & `sedaro-4.3.2/src/sedaro_base_client/model/data_storage.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -50,73 +50,101 @@
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
             capacity = schemas.IntSchema
-            maxBitRateRead = schemas.IntSchema
-            maxBitRateWrite = schemas.IntSchema
+            maxBitRateRead = schemas.NumberSchema
+            maxBitRateWrite = schemas.NumberSchema
             id = schemas.StrSchema
             component = schemas.StrSchema
             
             
             class usage(
                 schemas.DictSchema
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'usage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class fillPercent(
                 schemas.NumberSchema
             ):
             
             
@@ -209,22 +237,22 @@
     def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["maxBitRateRead"], typing_extensions.Literal["maxBitRateWrite"], typing_extensions.Literal["capacity"], typing_extensions.Literal["id"], typing_extensions.Literal["component"], typing_extensions.Literal["usage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["fillPercent"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        maxBitRateRead: typing.Union[MetaOapg.properties.maxBitRateRead, decimal.Decimal, int, ],
-        maxBitRateWrite: typing.Union[MetaOapg.properties.maxBitRateWrite, decimal.Decimal, int, ],
+        maxBitRateRead: typing.Union[MetaOapg.properties.maxBitRateRead, decimal.Decimal, int, float, ],
+        maxBitRateWrite: typing.Union[MetaOapg.properties.maxBitRateWrite, decimal.Decimal, int, float, ],
         capacity: typing.Union[MetaOapg.properties.capacity, decimal.Decimal, int, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         component: typing.Union[MetaOapg.properties.component, str, schemas.Unset] = schemas.unset,
         usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         fillPercent: typing.Union[MetaOapg.properties.fillPercent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'DataStorage':
         return super().__new__(
             cls,
             *_args,
             name=name,
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/data_type.py` & `sedaro-4.3.2/src/sedaro_base_client/model/component_dissipations.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,76 +19,93 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DataType(
+class ComponentDissipations(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "name",
+            "internalLoads",
+            "total",
         }
         
         class properties:
             
             
-            class name(
-                schemas.StrSchema
+            class total(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            
+            
+            class internalLoads(
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            id = schemas.StrSchema
+                    inclusive_minimum = 0.0
             __annotations__ = {
-                "name": name,
-                "id": id,
+                "total": total,
+                "internalLoads": internalLoads,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    name: MetaOapg.properties.name
+    internalLoads: MetaOapg.properties.internalLoads
+    total: MetaOapg.properties.total
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], ]):
+    @typing.overload
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        internalLoads: typing.Union[MetaOapg.properties.internalLoads, decimal.Decimal, int, float, ],
+        total: typing.Union[MetaOapg.properties.total, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DataType':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'ComponentDissipations':
         return super().__new__(
             cls,
             *_args,
-            name=name,
-            id=id,
+            internalLoads=internalLoads,
+            total=total,
             _configuration=_configuration,
+            **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/deleted_entity.py` & `sedaro-4.3.2/src/sedaro_base_client/model/deleted_entity.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/direction_sensor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/direction_sensor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -122,15 +122,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -158,15 +158,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -290,41 +290,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -346,15 +345,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -373,58 +372,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class conditions(
                 schemas.ListSchema
             ):
             
             
@@ -717,21 +744,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         conditions: typing.Union[MetaOapg.properties.conditions, list, tuple, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
         referenceVector: typing.Union[MetaOapg.properties.referenceVector, str, schemas.Unset] = schemas.unset,
         truth: typing.Union[MetaOapg.properties.truth, list, tuple, schemas.Unset] = schemas.unset,
         measurement: typing.Union[MetaOapg.properties.measurement, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'DirectionSensor':
@@ -766,8 +793,9 @@
             referenceVector=referenceVector,
             truth=truth,
             measurement=measurement,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.angle_sensors20 import AngleSensors20
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/distance_sensors70.py` & `sedaro-4.3.2/src/sedaro_base_client/model/distance_sensors72.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,89 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DistanceSensors70(
+class DistanceSensors72(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
-            cm = schemas.NumberSchema
+            m = schemas.NumberSchema
             mm = schemas.NumberSchema
             
             
             class km(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
-            m = schemas.NumberSchema
+            cm = schemas.NumberSchema
             __annotations__ = {
-                "cm": cm,
+                "m": m,
                 "mm": mm,
                 "km": km,
-                "m": m,
+                "cm": cm,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["cm"]) -> MetaOapg.properties.cm: ...
+    def __getitem__(self, name: typing_extensions.Literal["m"]) -> MetaOapg.properties.m: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["mm"]) -> MetaOapg.properties.mm: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["km"]) -> MetaOapg.properties.km: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["m"]) -> MetaOapg.properties.m: ...
+    def __getitem__(self, name: typing_extensions.Literal["cm"]) -> MetaOapg.properties.cm: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["cm"], typing_extensions.Literal["mm"], typing_extensions.Literal["km"], typing_extensions.Literal["m"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["m"], typing_extensions.Literal["mm"], typing_extensions.Literal["km"], typing_extensions.Literal["cm"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["cm"]) -> typing.Union[MetaOapg.properties.cm, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["m"]) -> typing.Union[MetaOapg.properties.m, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["mm"]) -> typing.Union[MetaOapg.properties.mm, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["km"]) -> typing.Union[MetaOapg.properties.km, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["m"]) -> typing.Union[MetaOapg.properties.m, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["cm"]) -> typing.Union[MetaOapg.properties.cm, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["cm"], typing_extensions.Literal["mm"], typing_extensions.Literal["km"], typing_extensions.Literal["m"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["m"], typing_extensions.Literal["mm"], typing_extensions.Literal["km"], typing_extensions.Literal["cm"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        cm: typing.Union[MetaOapg.properties.cm, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        m: typing.Union[MetaOapg.properties.m, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         mm: typing.Union[MetaOapg.properties.mm, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         km: typing.Union[MetaOapg.properties.km, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        m: typing.Union[MetaOapg.properties.m, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        cm: typing.Union[MetaOapg.properties.cm, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DistanceSensors70':
+    ) -> 'DistanceSensors72':
         return super().__new__(
             cls,
             *_args,
-            cm=cm,
+            m=m,
             mm=mm,
             km=km,
-            m=m,
+            cm=cm,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/duration_load70.py` & `sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode20.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,89 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DurationLoad70(
+class DurationOperationalMode20(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             s = schemas.NumberSchema
-            hour = schemas.NumberSchema
-            min = schemas.NumberSchema
             
             
             class day(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
+            min = schemas.NumberSchema
+            hour = schemas.NumberSchema
             __annotations__ = {
                 "s": s,
-                "hour": hour,
-                "min": min,
                 "day": day,
+                "min": min,
+                "hour": hour,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["s"]) -> MetaOapg.properties.s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
+    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["min"]) -> MetaOapg.properties.min: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
+    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["s"]) -> typing.Union[MetaOapg.properties.s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["min"]) -> typing.Union[MetaOapg.properties.min, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         s: typing.Union[MetaOapg.properties.s, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         day: typing.Union[MetaOapg.properties.day, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DurationLoad70':
+    ) -> 'DurationOperationalMode20':
         return super().__new__(
             cls,
             *_args,
             s=s,
-            hour=hour,
-            min=min,
             day=day,
+            min=min,
+            hour=hour,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode18.py` & `sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode31.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,89 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DurationOperationalMode18(
+class DurationOperationalMode31(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             s = schemas.NumberSchema
-            hour = schemas.NumberSchema
-            min = schemas.NumberSchema
             
             
             class day(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
+            min = schemas.NumberSchema
+            hour = schemas.NumberSchema
             __annotations__ = {
                 "s": s,
-                "hour": hour,
-                "min": min,
                 "day": day,
+                "min": min,
+                "hour": hour,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["s"]) -> MetaOapg.properties.s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
+    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["min"]) -> MetaOapg.properties.min: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
+    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["s"]) -> typing.Union[MetaOapg.properties.s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["min"]) -> typing.Union[MetaOapg.properties.min, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         s: typing.Union[MetaOapg.properties.s, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         day: typing.Union[MetaOapg.properties.day, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DurationOperationalMode18':
+    ) -> 'DurationOperationalMode31':
         return super().__new__(
             cls,
             *_args,
             s=s,
-            hour=hour,
-            min=min,
             day=day,
+            min=min,
+            hour=hour,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode19.py` & `sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode33.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,89 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DurationOperationalMode19(
+class DurationOperationalMode33(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             s = schemas.NumberSchema
-            hour = schemas.NumberSchema
-            min = schemas.NumberSchema
             
             
             class day(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
+            min = schemas.NumberSchema
+            hour = schemas.NumberSchema
             __annotations__ = {
                 "s": s,
-                "hour": hour,
-                "min": min,
                 "day": day,
+                "min": min,
+                "hour": hour,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["s"]) -> MetaOapg.properties.s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
+    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["min"]) -> MetaOapg.properties.min: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
+    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["s"]) -> typing.Union[MetaOapg.properties.s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["min"]) -> typing.Union[MetaOapg.properties.min, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         s: typing.Union[MetaOapg.properties.s, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         day: typing.Union[MetaOapg.properties.day, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DurationOperationalMode19':
+    ) -> 'DurationOperationalMode33':
         return super().__new__(
             cls,
             *_args,
             s=s,
-            hour=hour,
-            min=min,
             day=day,
+            min=min,
+            hour=hour,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode20.py` & `sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode18.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,89 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DurationOperationalMode20(
+class DurationOperationalMode18(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             s = schemas.NumberSchema
-            hour = schemas.NumberSchema
-            min = schemas.NumberSchema
             
             
             class day(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
+            min = schemas.NumberSchema
+            hour = schemas.NumberSchema
             __annotations__ = {
                 "s": s,
-                "hour": hour,
-                "min": min,
                 "day": day,
+                "min": min,
+                "hour": hour,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["s"]) -> MetaOapg.properties.s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
+    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["min"]) -> MetaOapg.properties.min: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
+    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["s"]) -> typing.Union[MetaOapg.properties.s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["min"]) -> typing.Union[MetaOapg.properties.min, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         s: typing.Union[MetaOapg.properties.s, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         day: typing.Union[MetaOapg.properties.day, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DurationOperationalMode20':
+    ) -> 'DurationOperationalMode18':
         return super().__new__(
             cls,
             *_args,
             s=s,
-            hour=hour,
-            min=min,
             day=day,
+            min=min,
+            hour=hour,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode28.py` & `sedaro-4.3.2/src/sedaro_base_client/model/duration_operational_mode22.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,89 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DurationOperationalMode28(
+class DurationOperationalMode22(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             s = schemas.NumberSchema
-            hour = schemas.NumberSchema
-            min = schemas.NumberSchema
             
             
             class day(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
+            min = schemas.NumberSchema
+            hour = schemas.NumberSchema
             __annotations__ = {
                 "s": s,
-                "hour": hour,
-                "min": min,
                 "day": day,
+                "min": min,
+                "hour": hour,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["s"]) -> MetaOapg.properties.s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
+    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["min"]) -> MetaOapg.properties.min: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
+    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["s"]) -> typing.Union[MetaOapg.properties.s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["min"]) -> typing.Union[MetaOapg.properties.min, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["day"], typing_extensions.Literal["min"], typing_extensions.Literal["hour"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         s: typing.Union[MetaOapg.properties.s, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         day: typing.Union[MetaOapg.properties.day, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DurationOperationalMode28':
+    ) -> 'DurationOperationalMode22':
         return super().__new__(
             cls,
             *_args,
             s=s,
-            hour=hour,
-            min=min,
             day=day,
+            min=min,
+            hour=hour,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/duration_operational_mode29.py` & `sedaro-4.3.2/src/sedaro_base_client/model/external_state_set_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,89 +19,92 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class DurationOperationalMode29(
+class ExternalStateSetRequest(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
-            s = schemas.NumberSchema
-            hour = schemas.NumberSchema
-            min = schemas.NumberSchema
             
             
-            class day(
-                schemas.NumberSchema
+            class values(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0.0
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'values':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            timestamp = schemas.NumberSchema
             __annotations__ = {
-                "s": s,
-                "hour": hour,
-                "min": min,
-                "day": day,
+                "values": values,
+                "timestamp": timestamp,
             }
-        additional_properties = schemas.NotAnyTypeSchema
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["s"]) -> MetaOapg.properties.s: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["hour"]) -> MetaOapg.properties.hour: ...
+    def __getitem__(self, name: typing_extensions.Literal["values"]) -> MetaOapg.properties.values: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["min"]) -> MetaOapg.properties.min: ...
+    def __getitem__(self, name: typing_extensions.Literal["timestamp"]) -> MetaOapg.properties.timestamp: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["day"]) -> MetaOapg.properties.day: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["values", "timestamp", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["s"]) -> typing.Union[MetaOapg.properties.s, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["hour"]) -> typing.Union[MetaOapg.properties.hour, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["values"]) -> typing.Union[MetaOapg.properties.values, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["min"]) -> typing.Union[MetaOapg.properties.min, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["timestamp"]) -> typing.Union[MetaOapg.properties.timestamp, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["day"]) -> typing.Union[MetaOapg.properties.day, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["s"], typing_extensions.Literal["hour"], typing_extensions.Literal["min"], typing_extensions.Literal["day"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["values", "timestamp", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        s: typing.Union[MetaOapg.properties.s, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        hour: typing.Union[MetaOapg.properties.hour, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        min: typing.Union[MetaOapg.properties.min, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        day: typing.Union[MetaOapg.properties.day, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        values: typing.Union[MetaOapg.properties.values, list, tuple, schemas.Unset] = schemas.unset,
+        timestamp: typing.Union[MetaOapg.properties.timestamp, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'DurationOperationalMode29':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'ExternalStateSetRequest':
         return super().__new__(
             cls,
             *_args,
-            s=s,
-            hour=hour,
-            min=min,
-            day=day,
+            values=values,
+            timestamp=timestamp,
             _configuration=_configuration,
+            **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/ekf_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/ekf_algorithm.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/equatorial_circular_reference_orbit.py` & `sedaro-4.3.2/src/sedaro_base_client/model/equatorial_circular_reference_orbit.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/external_state_set_request.py` & `sedaro-4.3.2/src/sedaro_base_client/model/battery_pack_dissipations.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,92 +19,113 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ExternalStateSetRequest(
+class BatteryPackDissipations(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
+        required = {
+            "internalLoads",
+            "total",
+            "esr",
+        }
         
         class properties:
             
             
-            class values(
-                schemas.ListSchema
+            class total(
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    inclusive_minimum = 0.0
             
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'values':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            timestamp = schemas.NumberSchema
+            
+            class internalLoads(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            
+            
+            class esr(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
             __annotations__ = {
-                "values": values,
-                "timestamp": timestamp,
+                "total": total,
+                "internalLoads": internalLoads,
+                "esr": esr,
             }
     
+    internalLoads: MetaOapg.properties.internalLoads
+    total: MetaOapg.properties.total
+    esr: MetaOapg.properties.esr
+    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["values"]) -> MetaOapg.properties.values: ...
+    def __getitem__(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["timestamp"]) -> MetaOapg.properties.timestamp: ...
+    def __getitem__(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["esr"]) -> MetaOapg.properties.esr: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["values", "timestamp", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", "esr", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["values"]) -> typing.Union[MetaOapg.properties.values, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["timestamp"]) -> typing.Union[MetaOapg.properties.timestamp, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["esr"]) -> MetaOapg.properties.esr: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["values", "timestamp", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", "esr", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        values: typing.Union[MetaOapg.properties.values, list, tuple, schemas.Unset] = schemas.unset,
-        timestamp: typing.Union[MetaOapg.properties.timestamp, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        internalLoads: typing.Union[MetaOapg.properties.internalLoads, decimal.Decimal, int, float, ],
+        total: typing.Union[MetaOapg.properties.total, decimal.Decimal, int, float, ],
+        esr: typing.Union[MetaOapg.properties.esr, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ExternalStateSetRequest':
+    ) -> 'BatteryPackDissipations':
         return super().__new__(
             cls,
             *_args,
-            values=values,
-            timestamp=timestamp,
+            internalLoads=internalLoads,
+            total=total,
+            esr=esr,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/fixed_surface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/fixed_surface.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -104,15 +104,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            FrameVectorBase299,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -140,15 +140,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            FrameVectorBase299,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -181,15 +181,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -405,9 +405,9 @@
             heatFlowRate=heatFlowRate,
             temperature=temperature,
             hotMargin=hotMargin,
             coldMargin=coldMargin,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.frame_vector_base299 import FrameVectorBase299
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/frame_vector_base299.py` & `sedaro-4.3.2/src/sedaro_base_client/model/quaternion_base306.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,143 +19,177 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class FrameVectorBase299(
+class QuaternionBase306(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         
         class properties:
             
             
-            class body(
+            class body_eci(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 3
-                    min_items = 3
+                    max_items = 4
+                    min_items = 4
                     items = schemas.NumberSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'body':
+                ) -> 'body_eci':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class eci(
+            class eci_body(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 3
-                    min_items = 3
+                    max_items = 4
+                    min_items = 4
                     items = schemas.NumberSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'eci':
+                ) -> 'eci_body':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class ecef(
+            class ecef_body(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 3
-                    min_items = 3
+                    max_items = 4
+                    min_items = 4
                     items = schemas.NumberSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'ecef':
+                ) -> 'ecef_body':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class body_ecef(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_items = 4
+                    min_items = 4
+                    items = schemas.NumberSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'body_ecef':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             __annotations__ = {
-                "body": body,
-                "eci": eci,
-                "ecef": ecef,
+                "body_eci": body_eci,
+                "eci_body": eci_body,
+                "ecef_body": ecef_body,
+                "body_ecef": body_ecef,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["body"]) -> MetaOapg.properties.body: ...
+    def __getitem__(self, name: typing_extensions.Literal["body_eci"]) -> MetaOapg.properties.body_eci: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["eci_body"]) -> MetaOapg.properties.eci_body: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["eci"]) -> MetaOapg.properties.eci: ...
+    def __getitem__(self, name: typing_extensions.Literal["ecef_body"]) -> MetaOapg.properties.ecef_body: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["ecef"]) -> MetaOapg.properties.ecef: ...
+    def __getitem__(self, name: typing_extensions.Literal["body_ecef"]) -> MetaOapg.properties.body_ecef: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["body"], typing_extensions.Literal["eci"], typing_extensions.Literal["ecef"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["body_eci"], typing_extensions.Literal["eci_body"], typing_extensions.Literal["ecef_body"], typing_extensions.Literal["body_ecef"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["body"]) -> typing.Union[MetaOapg.properties.body, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["body_eci"]) -> typing.Union[MetaOapg.properties.body_eci, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["eci_body"]) -> typing.Union[MetaOapg.properties.eci_body, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["eci"]) -> typing.Union[MetaOapg.properties.eci, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["ecef_body"]) -> typing.Union[MetaOapg.properties.ecef_body, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["ecef"]) -> typing.Union[MetaOapg.properties.ecef, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["body_ecef"]) -> typing.Union[MetaOapg.properties.body_ecef, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["body"], typing_extensions.Literal["eci"], typing_extensions.Literal["ecef"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["body_eci"], typing_extensions.Literal["eci_body"], typing_extensions.Literal["ecef_body"], typing_extensions.Literal["body_ecef"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        body: typing.Union[MetaOapg.properties.body, list, tuple, schemas.Unset] = schemas.unset,
-        eci: typing.Union[MetaOapg.properties.eci, list, tuple, schemas.Unset] = schemas.unset,
-        ecef: typing.Union[MetaOapg.properties.ecef, list, tuple, schemas.Unset] = schemas.unset,
+        body_eci: typing.Union[MetaOapg.properties.body_eci, list, tuple, schemas.Unset] = schemas.unset,
+        eci_body: typing.Union[MetaOapg.properties.eci_body, list, tuple, schemas.Unset] = schemas.unset,
+        ecef_body: typing.Union[MetaOapg.properties.ecef_body, list, tuple, schemas.Unset] = schemas.unset,
+        body_ecef: typing.Union[MetaOapg.properties.body_ecef, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'FrameVectorBase299':
+    ) -> 'QuaternionBase306':
         return super().__new__(
             cls,
             *_args,
-            body=body,
-            eci=eci,
-            ecef=ecef,
+            body_eci=body_eci,
+            eci_body=eci_body,
+            ecef_body=ecef_body,
+            body_ecef=body_ecef,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/fuel_reservoir.py` & `sedaro-4.3.2/src/sedaro_base_client/model/time_condition.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,158 +19,157 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class FuelReservoir(
+class TimeCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
+            "scalar",
             "name",
+            "relationship",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
-            id = schemas.StrSchema
             
             
-            class fuelTanks(
-                schemas.ListSchema
+            class relationship(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'fuelTanks':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
-            
-            class thrusters(
-                schemas.ListSchema
-            ):
-            
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ConditionRelationship,
+                        ]
             
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'thrusters':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'relationship':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
-            
-            class flowRate(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_minimum = 0.0
+            scalar = schemas.AnyTypeSchema
+            id = schemas.StrSchema
+            terminator = schemas.BoolSchema
+            compliance = schemas.BoolSchema
             __annotations__ = {
                 "name": name,
+                "relationship": relationship,
+                "scalar": scalar,
                 "id": id,
-                "fuelTanks": fuelTanks,
-                "thrusters": thrusters,
-                "flowRate": flowRate,
+                "terminator": terminator,
+                "compliance": compliance,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
+    scalar: MetaOapg.properties.scalar
     name: MetaOapg.properties.name
+    relationship: MetaOapg.properties.relationship
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["fuelTanks"]) -> MetaOapg.properties.fuelTanks: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["thrusters"]) -> MetaOapg.properties.thrusters: ...
+    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["flowRate"]) -> MetaOapg.properties.flowRate: ...
+    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["fuelTanks"], typing_extensions.Literal["thrusters"], typing_extensions.Literal["flowRate"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["fuelTanks"]) -> typing.Union[MetaOapg.properties.fuelTanks, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["thrusters"]) -> typing.Union[MetaOapg.properties.thrusters, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["flowRate"]) -> typing.Union[MetaOapg.properties.flowRate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["fuelTanks"], typing_extensions.Literal["thrusters"], typing_extensions.Literal["flowRate"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
+        scalar: typing.Union[MetaOapg.properties.scalar, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
+        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        fuelTanks: typing.Union[MetaOapg.properties.fuelTanks, list, tuple, schemas.Unset] = schemas.unset,
-        thrusters: typing.Union[MetaOapg.properties.thrusters, list, tuple, schemas.Unset] = schemas.unset,
-        flowRate: typing.Union[MetaOapg.properties.flowRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
+        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'FuelReservoir':
+    ) -> 'TimeCondition':
         return super().__new__(
             cls,
             *_args,
+            scalar=scalar,
             name=name,
+            relationship=relationship,
             id=id,
-            fuelTanks=fuelTanks,
-            thrusters=thrusters,
-            flowRate=flowRate,
+            terminator=terminator,
+            compliance=compliance,
             _configuration=_configuration,
         )
+
+from sedaro_base_client.model.condition_relationship import ConditionRelationship
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/fully_reg_det_power_processor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/power_processor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class FullyRegDetPowerProcessor(
+class PowerProcessor(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -85,15 +85,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -253,41 +253,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProcessorDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -309,15 +308,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -336,58 +335,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class topologyParams(
                 schemas.ComposedSchema,
             ):
             
             
@@ -740,29 +767,29 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         topologyParams: typing.Union[MetaOapg.properties.topologyParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
         dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
         battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
         busRegulators: typing.Union[MetaOapg.properties.busRegulators, list, tuple, schemas.Unset] = schemas.unset,
         solarArrays: typing.Union[MetaOapg.properties.solarArrays, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'FullyRegDetPowerProcessor':
+    ) -> 'PowerProcessor':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
             partNumber=partNumber,
             manufacturer=manufacturer,
@@ -790,12 +817,13 @@
             battery=battery,
             busRegulators=busRegulators,
             solarArrays=solarArrays,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
+from sedaro_base_client.model.processor_dissipations import ProcessorDissipations
 from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
 from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
 from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
 from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/fully_reg_det_topology_params.py` & `sedaro-4.3.2/src/sedaro_base_client/model/fully_reg_det_topology_params.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/geostationary_reference_orbit.py` & `sedaro-4.3.2/src/sedaro_base_client/model/iss_reference_orbit.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,101 +19,122 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class GeostationaryReferenceOrbit(
+class IssReferenceOrbit(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
             "initialRefOrbit",
-            "lon",
+            "nu",
+            "raan",
         }
         
         class properties:
             
             
             class initialRefOrbit(
                 schemas.EnumBase,
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     enum_value_to_name = {
-                        "GEOSTAT": "GEOSTAT",
+                        "ISS": "ISS",
                     }
                 
                 @schemas.classproperty
-                def GEOSTAT(cls):
-                    return cls("GEOSTAT")
+                def ISS(cls):
+                    return cls("ISS")
             
             
-            class lon(
+            class raan(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_maximum = 360.0
+                    inclusive_minimum = -360.0
+            
+            
+            class nu(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_maximum = 360.0
                     inclusive_minimum = -360.0
             __annotations__ = {
                 "initialRefOrbit": initialRefOrbit,
-                "lon": lon,
+                "raan": raan,
+                "nu": nu,
             }
     
     initialRefOrbit: MetaOapg.properties.initialRefOrbit
-    lon: MetaOapg.properties.lon
+    nu: MetaOapg.properties.nu
+    raan: MetaOapg.properties.raan
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lon"]) -> MetaOapg.properties.lon: ...
+    def __getitem__(self, name: typing_extensions.Literal["raan"]) -> MetaOapg.properties.raan: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "lon", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lon"]) -> MetaOapg.properties.lon: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["raan"]) -> MetaOapg.properties.raan: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "lon", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         initialRefOrbit: typing.Union[MetaOapg.properties.initialRefOrbit, str, ],
-        lon: typing.Union[MetaOapg.properties.lon, decimal.Decimal, int, float, ],
+        nu: typing.Union[MetaOapg.properties.nu, decimal.Decimal, int, float, ],
+        raan: typing.Union[MetaOapg.properties.raan, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'GeostationaryReferenceOrbit':
+    ) -> 'IssReferenceOrbit':
         return super().__new__(
             cls,
             *_args,
             initialRefOrbit=initialRefOrbit,
-            lon=lon,
+            nu=nu,
+            raan=raan,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/geostationary_transfer_reference_orbit.py` & `sedaro-4.3.2/src/sedaro_base_client/model/sun_synchronous_circular_orbit.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,142 +19,133 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class GeostationaryTransferReferenceOrbit(
+class SunSynchronousCircularOrbit(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
             "initialRefOrbit",
             "nu",
-            "altPerigee",
-            "om",
+            "alt",
+            "mltAscNode",
         }
         
         class properties:
             
             
             class initialRefOrbit(
                 schemas.EnumBase,
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     enum_value_to_name = {
-                        "GEOSTAT_TRANSFER": "GEOSTAT_TRANSFER",
+                        "SUN_SYNC_CIRC": "SUN_SYNC_CIRC",
                     }
                 
                 @schemas.classproperty
-                def GEOSTAT_TRANSFER(cls):
-                    return cls("GEOSTAT_TRANSFER")
-            
-            
-            class om(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_maximum = 360.0
-                    inclusive_minimum = -360.0
+                def SUN_SYNC_CIRC(cls):
+                    return cls("SUN_SYNC_CIRC")
+            mltAscNode = schemas.NumberSchema
             
             
             class nu(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_maximum = 360.0
                     inclusive_minimum = -360.0
             
             
-            class altPerigee(
+            class alt(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 100.0
             __annotations__ = {
                 "initialRefOrbit": initialRefOrbit,
-                "om": om,
+                "mltAscNode": mltAscNode,
                 "nu": nu,
-                "altPerigee": altPerigee,
+                "alt": alt,
             }
     
     initialRefOrbit: MetaOapg.properties.initialRefOrbit
     nu: MetaOapg.properties.nu
-    altPerigee: MetaOapg.properties.altPerigee
-    om: MetaOapg.properties.om
+    alt: MetaOapg.properties.alt
+    mltAscNode: MetaOapg.properties.mltAscNode
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["om"]) -> MetaOapg.properties.om: ...
+    def __getitem__(self, name: typing_extensions.Literal["mltAscNode"]) -> MetaOapg.properties.mltAscNode: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["altPerigee"]) -> MetaOapg.properties.altPerigee: ...
+    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "om", "nu", "altPerigee", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "mltAscNode", "nu", "alt", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["om"]) -> MetaOapg.properties.om: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["mltAscNode"]) -> MetaOapg.properties.mltAscNode: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["altPerigee"]) -> MetaOapg.properties.altPerigee: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "om", "nu", "altPerigee", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "mltAscNode", "nu", "alt", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         initialRefOrbit: typing.Union[MetaOapg.properties.initialRefOrbit, str, ],
         nu: typing.Union[MetaOapg.properties.nu, decimal.Decimal, int, float, ],
-        altPerigee: typing.Union[MetaOapg.properties.altPerigee, decimal.Decimal, int, float, ],
-        om: typing.Union[MetaOapg.properties.om, decimal.Decimal, int, float, ],
+        alt: typing.Union[MetaOapg.properties.alt, decimal.Decimal, int, float, ],
+        mltAscNode: typing.Union[MetaOapg.properties.mltAscNode, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'GeostationaryTransferReferenceOrbit':
+    ) -> 'SunSynchronousCircularOrbit':
         return super().__new__(
             cls,
             *_args,
             initialRefOrbit=initialRefOrbit,
             nu=nu,
-            altPerigee=altPerigee,
-            om=om,
+            alt=alt,
+            mltAscNode=mltAscNode,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/gps_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/gps_algorithm.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/ground_target.py` & `sedaro-4.3.2/src/sedaro_base_client/model/scenario_template_res.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,239 +19,223 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class GroundTarget(
+class ScenarioTemplateRes(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
+    Class for ScenarioTemplate with meta attributes
     """
 
 
     class MetaOapg:
-        required = {
-            "name",
-        }
         
         class properties:
             
             
-            class name(
-                schemas.StrSchema
+            class blocks(
+                schemas.DictSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            id = schemas.StrSchema
-            rel_agentId = schemas.StrSchema
-            shadow = schemas.BoolSchema
-            lst = schemas.NumberSchema
-            position = schemas.AnyTypeSchema
-        
-            @staticmethod
-            def lat() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def lon() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def alt() -> typing.Type['AngleBase299']:
-                return AngleBase299
-            range = schemas.NumberSchema
-            lineOfSight = schemas.BoolSchema
-            relativePosition = schemas.AnyTypeSchema
-        
-            @staticmethod
-            def azimuth() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def elevation() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def solarAz() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def solarEl() -> typing.Type['AngleBase299']:
-                return AngleBase299
+                    additional_properties = schemas.DictSchema
+                
+                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    # dict_instance[name] accessor
+                    return super().__getitem__(name)
+                
+                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    return super().get_item_oapg(name)
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
+                ) -> 'blocks':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
+            
+            
+            class index(
+                schemas.DictSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    
+                    class additional_properties(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                _arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
+                
+                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    # dict_instance[name] accessor
+                    return super().__getitem__(name)
+                
+                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    return super().get_item_oapg(name)
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[MetaOapg.additional_properties, list, tuple, ],
+                ) -> 'index':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
+            clockConfig = schemas.StrSchema
+            seed = schemas.IntSchema
+            _relationships = schemas.DictSchema
+            _supers = schemas.DictSchema
+            _quantityKinds = schemas.DictSchema
+            
+            
+            class _blockNames(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> '_blockNames':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             __annotations__ = {
-                "name": name,
-                "id": id,
-                "rel_agentId": rel_agentId,
-                "shadow": shadow,
-                "lst": lst,
-                "position": position,
-                "lat": lat,
-                "lon": lon,
-                "alt": alt,
-                "range": range,
-                "lineOfSight": lineOfSight,
-                "relativePosition": relativePosition,
-                "azimuth": azimuth,
-                "elevation": elevation,
-                "solarAz": solarAz,
-                "solarEl": solarEl,
+                "blocks": blocks,
+                "index": index,
+                "clockConfig": clockConfig,
+                "seed": seed,
+                "_relationships": _relationships,
+                "_supers": _supers,
+                "_quantityKinds": _quantityKinds,
+                "_blockNames": _blockNames,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    name: MetaOapg.properties.name
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rel_agentId"]) -> MetaOapg.properties.rel_agentId: ...
+    def __getitem__(self, name: typing_extensions.Literal["index"]) -> MetaOapg.properties.index: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["shadow"]) -> MetaOapg.properties.shadow: ...
+    def __getitem__(self, name: typing_extensions.Literal["clockConfig"]) -> MetaOapg.properties.clockConfig: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lst"]) -> MetaOapg.properties.lst: ...
+    def __getitem__(self, name: typing_extensions.Literal["seed"]) -> MetaOapg.properties.seed: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["position"]) -> MetaOapg.properties.position: ...
+    def __getitem__(self, name: typing_extensions.Literal["_relationships"]) -> MetaOapg.properties._relationships: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lat"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["_supers"]) -> MetaOapg.properties._supers: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lon"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["_quantityKinds"]) -> MetaOapg.properties._quantityKinds: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["_blockNames"]) -> MetaOapg.properties._blockNames: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["range"]) -> MetaOapg.properties.range: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lineOfSight"]) -> MetaOapg.properties.lineOfSight: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relativePosition"]) -> MetaOapg.properties.relativePosition: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["azimuth"]) -> 'AngleBase299': ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["elevation"]) -> 'AngleBase299': ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["solarAz"]) -> 'AngleBase299': ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["solarEl"]) -> 'AngleBase299': ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rel_agentId"], typing_extensions.Literal["shadow"], typing_extensions.Literal["lst"], typing_extensions.Literal["position"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["azimuth"], typing_extensions.Literal["elevation"], typing_extensions.Literal["solarAz"], typing_extensions.Literal["solarEl"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["clockConfig"], typing_extensions.Literal["seed"], typing_extensions.Literal["_relationships"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_blockNames"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rel_agentId"]) -> typing.Union[MetaOapg.properties.rel_agentId, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["shadow"]) -> typing.Union[MetaOapg.properties.shadow, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lst"]) -> typing.Union[MetaOapg.properties.lst, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union[MetaOapg.properties.position, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["blocks"]) -> typing.Union[MetaOapg.properties.blocks, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lat"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["index"]) -> typing.Union[MetaOapg.properties.index, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lon"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["clockConfig"]) -> typing.Union[MetaOapg.properties.clockConfig, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["seed"]) -> typing.Union[MetaOapg.properties.seed, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["range"]) -> typing.Union[MetaOapg.properties.range, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["_relationships"]) -> typing.Union[MetaOapg.properties._relationships, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lineOfSight"]) -> typing.Union[MetaOapg.properties.lineOfSight, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["_supers"]) -> typing.Union[MetaOapg.properties._supers, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relativePosition"]) -> typing.Union[MetaOapg.properties.relativePosition, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["_quantityKinds"]) -> typing.Union[MetaOapg.properties._quantityKinds, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["azimuth"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["_blockNames"]) -> typing.Union[MetaOapg.properties._blockNames, schemas.Unset]: ...
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["elevation"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["solarAz"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["solarEl"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
-    
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rel_agentId"], typing_extensions.Literal["shadow"], typing_extensions.Literal["lst"], typing_extensions.Literal["position"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["azimuth"], typing_extensions.Literal["elevation"], typing_extensions.Literal["solarAz"], typing_extensions.Literal["solarEl"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["clockConfig"], typing_extensions.Literal["seed"], typing_extensions.Literal["_relationships"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_blockNames"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        rel_agentId: typing.Union[MetaOapg.properties.rel_agentId, str, schemas.Unset] = schemas.unset,
-        shadow: typing.Union[MetaOapg.properties.shadow, bool, schemas.Unset] = schemas.unset,
-        lst: typing.Union[MetaOapg.properties.lst, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        position: typing.Union[MetaOapg.properties.position, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        lat: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        lon: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        alt: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        range: typing.Union[MetaOapg.properties.range, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        lineOfSight: typing.Union[MetaOapg.properties.lineOfSight, bool, schemas.Unset] = schemas.unset,
-        relativePosition: typing.Union[MetaOapg.properties.relativePosition, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        azimuth: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        elevation: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        solarAz: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        solarEl: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
+        blocks: typing.Union[MetaOapg.properties.blocks, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        index: typing.Union[MetaOapg.properties.index, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        clockConfig: typing.Union[MetaOapg.properties.clockConfig, str, schemas.Unset] = schemas.unset,
+        seed: typing.Union[MetaOapg.properties.seed, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        _relationships: typing.Union[MetaOapg.properties._relationships, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        _supers: typing.Union[MetaOapg.properties._supers, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        _quantityKinds: typing.Union[MetaOapg.properties._quantityKinds, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        _blockNames: typing.Union[MetaOapg.properties._blockNames, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'GroundTarget':
+    ) -> 'ScenarioTemplateRes':
         return super().__new__(
             cls,
             *_args,
-            name=name,
-            id=id,
-            rel_agentId=rel_agentId,
-            shadow=shadow,
-            lst=lst,
-            position=position,
-            lat=lat,
-            lon=lon,
-            alt=alt,
-            range=range,
-            lineOfSight=lineOfSight,
-            relativePosition=relativePosition,
-            azimuth=azimuth,
-            elevation=elevation,
-            solarAz=solarAz,
-            solarEl=solarEl,
+            blocks=blocks,
+            index=index,
+            clockConfig=clockConfig,
+            seed=seed,
+            _relationships=_relationships,
+            _supers=_supers,
+            _quantityKinds=_quantityKinds,
+            _blockNames=_blockNames,
             _configuration=_configuration,
         )
-
-from sedaro_base_client.model.angle_base299 import AngleBase299
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/group_rollers.py` & `sedaro-4.3.2/src/sedaro_base_client/model/statuses.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,73 +19,58 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class GroupRollers(
+class Statuses(
     schemas.EnumBase,
     schemas.StrSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     An enumeration.
     """
 
 
     class MetaOapg:
         enum_value_to_name = {
-            "MAX": "MAX",
-            "MIN": "MIN",
-            "MEAN": "MEAN",
-            "MEDIAN": "MEDIAN",
-            "COUNT": "COUNT",
-            "ANY": "ANY",
-            "NOTANY": "NOTANY",
-            "ALL": "ALL",
-            "NOTALL": "NOTALL",
-            schemas.NoneClass.NONE: "NONE",
+            "PENDING": "PENDING",
+            "RUNNING": "RUNNING",
+            "PAUSED": "PAUSED",
+            "TERMINATED": "TERMINATED",
+            "FAILED": "FAILED",
+            "SUCCEEDED": "SUCCEEDED",
+            "ERROR": "ERROR",
         }
     
     @schemas.classproperty
-    def MAX(cls):
-        return cls("MAX")
+    def PENDING(cls):
+        return cls("PENDING")
     
     @schemas.classproperty
-    def MIN(cls):
-        return cls("MIN")
+    def RUNNING(cls):
+        return cls("RUNNING")
     
     @schemas.classproperty
-    def MEAN(cls):
-        return cls("MEAN")
+    def PAUSED(cls):
+        return cls("PAUSED")
     
     @schemas.classproperty
-    def MEDIAN(cls):
-        return cls("MEDIAN")
+    def TERMINATED(cls):
+        return cls("TERMINATED")
     
     @schemas.classproperty
-    def COUNT(cls):
-        return cls("COUNT")
+    def FAILED(cls):
+        return cls("FAILED")
     
     @schemas.classproperty
-    def ANY(cls):
-        return cls("ANY")
+    def SUCCEEDED(cls):
+        return cls("SUCCEEDED")
     
     @schemas.classproperty
-    def NOTANY(cls):
-        return cls("NOTANY")
-    
-    @schemas.classproperty
-    def ALL(cls):
-        return cls("ALL")
-    
-    @schemas.classproperty
-    def NOTALL(cls):
-        return cls("NOTALL")
-    
-    @schemas.classproperty
-    def NONE(cls):
-        return cls(None)
+    def ERROR(cls):
+        return cls("ERROR")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/heater.py` & `sedaro-4.3.2/src/sedaro_base_client/model/heater.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -87,15 +87,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -123,15 +123,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -255,41 +255,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -311,15 +310,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -338,63 +337,114 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             busRegulator = schemas.StrSchema
             powerProcessor = schemas.StrSchema
             controlledComponent = schemas.StrSchema
             
             
+            class tempControllerStates(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'tempControllerStates':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
             class regHeatFlowRate(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
@@ -414,15 +464,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -430,37 +480,14 @@
                 ) -> 'commandedTemperature':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            
-            
-            class tempControllerStates(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'tempControllerStates':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
             __annotations__ = {
                 "name": name,
                 "onRegHeatFlowRate": onRegHeatFlowRate,
                 "id": id,
                 "partNumber": partNumber,
                 "manufacturer": manufacturer,
                 "hotTempRating": hotTempRating,
@@ -480,17 +507,17 @@
                 "temperature": temperature,
                 "storage": storage,
                 "readRate": readRate,
                 "writeRate": writeRate,
                 "busRegulator": busRegulator,
                 "powerProcessor": powerProcessor,
                 "controlledComponent": controlledComponent,
+                "tempControllerStates": tempControllerStates,
                 "regHeatFlowRate": regHeatFlowRate,
                 "commandedTemperature": commandedTemperature,
-                "tempControllerStates": tempControllerStates,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
     onRegHeatFlowRate: MetaOapg.properties.onRegHeatFlowRate
     
     @typing.overload
@@ -568,23 +595,23 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["controlledComponent"]) -> MetaOapg.properties.controlledComponent: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> MetaOapg.properties.regHeatFlowRate: ...
+    def __getitem__(self, name: typing_extensions.Literal["tempControllerStates"]) -> MetaOapg.properties.tempControllerStates: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["commandedTemperature"]) -> MetaOapg.properties.commandedTemperature: ...
+    def __getitem__(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> MetaOapg.properties.regHeatFlowRate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["tempControllerStates"]) -> MetaOapg.properties.tempControllerStates: ...
+    def __getitem__(self, name: typing_extensions.Literal["commandedTemperature"]) -> MetaOapg.properties.commandedTemperature: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], typing_extensions.Literal["tempControllerStates"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["tempControllerStates"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
@@ -659,23 +686,23 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["controlledComponent"]) -> typing.Union[MetaOapg.properties.controlledComponent, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> typing.Union[MetaOapg.properties.regHeatFlowRate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["tempControllerStates"]) -> typing.Union[MetaOapg.properties.tempControllerStates, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["commandedTemperature"]) -> typing.Union[MetaOapg.properties.commandedTemperature, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["regHeatFlowRate"]) -> typing.Union[MetaOapg.properties.regHeatFlowRate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["tempControllerStates"]) -> typing.Union[MetaOapg.properties.tempControllerStates, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["commandedTemperature"]) -> typing.Union[MetaOapg.properties.commandedTemperature, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], typing_extensions.Literal["tempControllerStates"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["onRegHeatFlowRate"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["controlledComponent"], typing_extensions.Literal["tempControllerStates"], typing_extensions.Literal["regHeatFlowRate"], typing_extensions.Literal["commandedTemperature"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         onRegHeatFlowRate: typing.Union[MetaOapg.properties.onRegHeatFlowRate, decimal.Decimal, int, float, ],
@@ -689,27 +716,27 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         busRegulator: typing.Union[MetaOapg.properties.busRegulator, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
         controlledComponent: typing.Union[MetaOapg.properties.controlledComponent, str, schemas.Unset] = schemas.unset,
+        tempControllerStates: typing.Union[MetaOapg.properties.tempControllerStates, list, tuple, schemas.Unset] = schemas.unset,
         regHeatFlowRate: typing.Union[MetaOapg.properties.regHeatFlowRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         commandedTemperature: typing.Union[MetaOapg.properties.commandedTemperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        tempControllerStates: typing.Union[MetaOapg.properties.tempControllerStates, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'Heater':
         return super().__new__(
             cls,
             *_args,
             name=name,
             onRegHeatFlowRate=onRegHeatFlowRate,
@@ -733,14 +760,15 @@
             temperature=temperature,
             storage=storage,
             readRate=readRate,
             writeRate=writeRate,
             busRegulator=busRegulator,
             powerProcessor=powerProcessor,
             controlledComponent=controlledComponent,
+            tempControllerStates=tempControllerStates,
             regHeatFlowRate=regHeatFlowRate,
             commandedTemperature=commandedTemperature,
-            tempControllerStates=tempControllerStates,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/http_validation_error.py` & `sedaro-4.3.2/src/sedaro_base_client/model/state_vector.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,87 +19,87 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class HTTPValidationError(
+class StateVector(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
+        required = {
+            "stateEci",
+        }
         
         class properties:
             
             
-            class detail(
+            class stateEci(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['ValidationError']:
-                        return ValidationError
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple['ValidationError'], typing.List['ValidationError']],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'detail':
+                ) -> 'stateEci':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ValidationError':
+                def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             __annotations__ = {
-                "detail": detail,
+                "stateEci": stateEci,
             }
     
+    stateEci: MetaOapg.properties.stateEci
+    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["detail"]) -> MetaOapg.properties.detail: ...
+    def __getitem__(self, name: typing_extensions.Literal["stateEci"]) -> MetaOapg.properties.stateEci: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["detail", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["stateEci", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["detail"]) -> typing.Union[MetaOapg.properties.detail, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["stateEci"]) -> MetaOapg.properties.stateEci: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["detail", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["stateEci", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        detail: typing.Union[MetaOapg.properties.detail, list, tuple, schemas.Unset] = schemas.unset,
+        stateEci: typing.Union[MetaOapg.properties.stateEci, list, tuple, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'HTTPValidationError':
+    ) -> 'StateVector':
         return super().__new__(
             cls,
             *_args,
-            detail=detail,
+            stateEci=stateEci,
             _configuration=_configuration,
             **kwargs,
         )
-
-from sedaro_base_client.model.validation_error import ValidationError
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/initial_state_def_type.py` & `sedaro-4.3.2/src/sedaro_base_client/model/initial_state_def_type.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -38,15 +38,14 @@
 
     class MetaOapg:
         enum_value_to_name = {
             "ORBITAL_ELEMENTS": "ORBITAL_ELEMENTS",
             "REF_ORBIT": "REF_ORBIT",
             "ECI_STATE": "ECI_STATE",
             "TLE": "TLE",
-            "": "EMPTY",
         }
     
     @schemas.classproperty
     def ORBITAL_ELEMENTS(cls):
         return cls("ORBITAL_ELEMENTS")
     
     @schemas.classproperty
@@ -56,11 +55,7 @@
     @schemas.classproperty
     def ECI_STATE(cls):
         return cls("ECI_STATE")
     
     @schemas.classproperty
     def TLE(cls):
         return cls("TLE")
-    
-    @schemas.classproperty
-    def EMPTY(cls):
-        return cls("")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/input_types.py` & `sedaro-4.3.2/src/sedaro_base_client/model/input_types.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/internal_data_interface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/internal_data_interface.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/iss_reference_orbit.py` & `sedaro-4.3.2/src/sedaro_base_client/model/polar_circular_reference_orbit.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,48 +19,49 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class IssReferenceOrbit(
+class PolarCircularReferenceOrbit(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
             "initialRefOrbit",
             "nu",
+            "alt",
             "raan",
         }
         
         class properties:
             
             
             class initialRefOrbit(
                 schemas.EnumBase,
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     enum_value_to_name = {
-                        "ISS": "ISS",
+                        "POLAR_CIRC": "POLAR_CIRC",
                     }
                 
                 @schemas.classproperty
-                def ISS(cls):
-                    return cls("ISS")
+                def POLAR_CIRC(cls):
+                    return cls("POLAR_CIRC")
             
             
             class raan(
                 schemas.NumberSchema
             ):
             
             
@@ -73,68 +74,87 @@
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_maximum = 360.0
                     inclusive_minimum = -360.0
+            
+            
+            class alt(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 100.0
             __annotations__ = {
                 "initialRefOrbit": initialRefOrbit,
                 "raan": raan,
                 "nu": nu,
+                "alt": alt,
             }
     
     initialRefOrbit: MetaOapg.properties.initialRefOrbit
     nu: MetaOapg.properties.nu
+    alt: MetaOapg.properties.alt
     raan: MetaOapg.properties.raan
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["raan"]) -> MetaOapg.properties.raan: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
+    
+    @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", "alt", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["raan"]) -> MetaOapg.properties.raan: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", "alt", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         initialRefOrbit: typing.Union[MetaOapg.properties.initialRefOrbit, str, ],
         nu: typing.Union[MetaOapg.properties.nu, decimal.Decimal, int, float, ],
+        alt: typing.Union[MetaOapg.properties.alt, decimal.Decimal, int, float, ],
         raan: typing.Union[MetaOapg.properties.raan, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'IssReferenceOrbit':
+    ) -> 'PolarCircularReferenceOrbit':
         return super().__new__(
             cls,
             *_args,
             initialRefOrbit=initialRefOrbit,
             nu=nu,
+            alt=alt,
             raan=raan,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/laser_comm_module.py` & `sedaro-4.3.2/src/sedaro_base_client/model/laser_comm_module.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -85,15 +85,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -253,41 +253,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -309,15 +308,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -336,58 +335,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             fieldOfView = schemas.StrSchema
             
             
             class externalInterfaces(
                 schemas.ListSchema
             ):
             
@@ -603,21 +630,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
         externalInterfaces: typing.Union[MetaOapg.properties.externalInterfaces, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'LaserCommModule':
         return super().__new__(
             cls,
             *_args,
@@ -644,8 +671,9 @@
             readRate=readRate,
             writeRate=writeRate,
             fieldOfView=fieldOfView,
             externalInterfaces=externalInterfaces,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/load_state.py` & `sedaro-4.3.2/src/sedaro_base_client/model/load_state.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -109,20 +109,47 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             isActive = schemas.BoolSchema
             
             
             class timeSinceActive(
-                schemas.NumberSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0.0
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            DurationBase306,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'timeSinceActive':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             powerConsumed = schemas.NumberSchema
             powerDissipation = schemas.NumberSchema
             __annotations__ = {
                 "name": name,
                 "efficiency": efficiency,
                 "id": id,
                 "component": component,
@@ -211,15 +238,15 @@
         efficiency: typing.Union[MetaOapg.properties.efficiency, decimal.Decimal, int, float, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         component: typing.Union[MetaOapg.properties.component, str, schemas.Unset] = schemas.unset,
         operationalModes: typing.Union[MetaOapg.properties.operationalModes, list, tuple, schemas.Unset] = schemas.unset,
         loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
         isActive: typing.Union[MetaOapg.properties.isActive, bool, schemas.Unset] = schemas.unset,
-        timeSinceActive: typing.Union[MetaOapg.properties.timeSinceActive, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        timeSinceActive: typing.Union[MetaOapg.properties.timeSinceActive, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         powerDissipation: typing.Union[MetaOapg.properties.powerDissipation, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'LoadState':
         return super().__new__(
             cls,
             *_args,
@@ -231,7 +258,9 @@
             loads=loads,
             isActive=isActive,
             timeSinceActive=timeSinceActive,
             powerConsumed=powerConsumed,
             powerDissipation=powerDissipation,
             _configuration=_configuration,
         )
+
+from sedaro_base_client.model.duration_base306 import DurationBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/local_pointing_directions.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_parameters.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,88 +19,93 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class LocalPointingDirections(
+class TargetParameters(
     schemas.EnumBase,
     schemas.StrSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     An enumeration.
     """
 
 
     class MetaOapg:
         enum_value_to_name = {
-            "NADIR": "NADIR",
-            "ZENITH": "ZENITH",
-            "CROSS_TRACK_POS": "CROSS_TRACK_POS",
-            "CROSS_TRACK_NEG": "CROSS_TRACK_NEG",
-            "ALONG_TRACK_POS": "ALONG_TRACK_POS",
-            "ALONG_TRACK_NEG": "ALONG_TRACK_NEG",
-            "RAM": "RAM",
-            "ANTI_RAM": "ANTI_RAM",
-            "MAGNETIC_FIELD": "MAGNETIC_FIELD",
-            "ECI_COORDINATES": "ECI_COORDINATES",
-            "ENU_COORDINATES": "ENU_COORDINATES",
-            "LVLH_COORDINATES": "LVLH_COORDINATES",
-            schemas.NoneClass.NONE: "NONE",
+            "SHADOW": "SHADOW",
+            "BETA": "BETA",
+            "MEAN_ANOM": "MEAN_ANOM",
+            "TRUE_ANOM": "TRUE_ANOM",
+            "LAT": "LAT",
+            "LON": "LON",
+            "ALT": "ALT",
+            "LO_SIGHT": "LO_SIGHT",
+            "RANGE": "RANGE",
+            "SOLAR_AZ": "SOLAR_AZ",
+            "SOLAR_EL": "SOLAR_EL",
+            "SAT_AZ": "SAT_AZ",
+            "SAT_EL": "SAT_EL",
+            "LOCAL_SIDEREAL_TIME": "LOCAL_SIDEREAL_TIME",
         }
     
     @schemas.classproperty
-    def NADIR(cls):
-        return cls("NADIR")
+    def SHADOW(cls):
+        return cls("SHADOW")
     
     @schemas.classproperty
-    def ZENITH(cls):
-        return cls("ZENITH")
+    def BETA(cls):
+        return cls("BETA")
     
     @schemas.classproperty
-    def CROSS_TRACK_POS(cls):
-        return cls("CROSS_TRACK_POS")
+    def MEAN_ANOM(cls):
+        return cls("MEAN_ANOM")
     
     @schemas.classproperty
-    def CROSS_TRACK_NEG(cls):
-        return cls("CROSS_TRACK_NEG")
+    def TRUE_ANOM(cls):
+        return cls("TRUE_ANOM")
     
     @schemas.classproperty
-    def ALONG_TRACK_POS(cls):
-        return cls("ALONG_TRACK_POS")
+    def LAT(cls):
+        return cls("LAT")
     
     @schemas.classproperty
-    def ALONG_TRACK_NEG(cls):
-        return cls("ALONG_TRACK_NEG")
+    def LON(cls):
+        return cls("LON")
     
     @schemas.classproperty
-    def RAM(cls):
-        return cls("RAM")
+    def ALT(cls):
+        return cls("ALT")
     
     @schemas.classproperty
-    def ANTI_RAM(cls):
-        return cls("ANTI_RAM")
+    def LO_SIGHT(cls):
+        return cls("LO_SIGHT")
     
     @schemas.classproperty
-    def MAGNETIC_FIELD(cls):
-        return cls("MAGNETIC_FIELD")
+    def RANGE(cls):
+        return cls("RANGE")
     
     @schemas.classproperty
-    def ECI_COORDINATES(cls):
-        return cls("ECI_COORDINATES")
+    def SOLAR_AZ(cls):
+        return cls("SOLAR_AZ")
     
     @schemas.classproperty
-    def ENU_COORDINATES(cls):
-        return cls("ENU_COORDINATES")
+    def SOLAR_EL(cls):
+        return cls("SOLAR_EL")
     
     @schemas.classproperty
-    def LVLH_COORDINATES(cls):
-        return cls("LVLH_COORDINATES")
+    def SAT_AZ(cls):
+        return cls("SAT_AZ")
     
     @schemas.classproperty
-    def NONE(cls):
-        return cls(None)
+    def SAT_EL(cls):
+        return cls("SAT_EL")
+    
+    @schemas.classproperty
+    def LOCAL_SIDEREAL_TIME(cls):
+        return cls("LOCAL_SIDEREAL_TIME")
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/local_vector.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_vector.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,37 +19,37 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class LocalVector(
+class TargetVector(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
             "name",
-            "localPointingDirection",
         }
         
         class properties:
             name = schemas.StrSchema
+            id = schemas.StrSchema
             
             
-            class localPointingDirection(
+            class truth(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -59,117 +59,140 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            LocalPointingDirections,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'localPointingDirection':
+                ) -> 'truth':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
+            
+            
+            class estimate(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            FrameVectorBase306,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'estimate':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            id = schemas.StrSchema
-            truth = schemas.AnyTypeSchema
-            estimate = schemas.AnyTypeSchema
             eclipsed = schemas.BoolSchema
-            vectorCoordinates = schemas.AnyTypeSchema
+            referenceTarget = schemas.StrSchema
             __annotations__ = {
                 "name": name,
-                "localPointingDirection": localPointingDirection,
                 "id": id,
                 "truth": truth,
                 "estimate": estimate,
                 "eclipsed": eclipsed,
-                "vectorCoordinates": vectorCoordinates,
+                "referenceTarget": referenceTarget,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
-    localPointingDirection: MetaOapg.properties.localPointingDirection
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["localPointingDirection"]) -> MetaOapg.properties.localPointingDirection: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["truth"]) -> MetaOapg.properties.truth: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["estimate"]) -> MetaOapg.properties.estimate: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["eclipsed"]) -> MetaOapg.properties.eclipsed: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["vectorCoordinates"]) -> MetaOapg.properties.vectorCoordinates: ...
+    def __getitem__(self, name: typing_extensions.Literal["referenceTarget"]) -> MetaOapg.properties.referenceTarget: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["localPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["vectorCoordinates"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["referenceTarget"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["localPointingDirection"]) -> MetaOapg.properties.localPointingDirection: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["truth"]) -> typing.Union[MetaOapg.properties.truth, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["estimate"]) -> typing.Union[MetaOapg.properties.estimate, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["eclipsed"]) -> typing.Union[MetaOapg.properties.eclipsed, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["vectorCoordinates"]) -> typing.Union[MetaOapg.properties.vectorCoordinates, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["referenceTarget"]) -> typing.Union[MetaOapg.properties.referenceTarget, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["localPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["vectorCoordinates"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["referenceTarget"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        localPointingDirection: typing.Union[MetaOapg.properties.localPointingDirection, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         truth: typing.Union[MetaOapg.properties.truth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         estimate: typing.Union[MetaOapg.properties.estimate, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         eclipsed: typing.Union[MetaOapg.properties.eclipsed, bool, schemas.Unset] = schemas.unset,
-        vectorCoordinates: typing.Union[MetaOapg.properties.vectorCoordinates, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        referenceTarget: typing.Union[MetaOapg.properties.referenceTarget, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'LocalVector':
+    ) -> 'TargetVector':
         return super().__new__(
             cls,
             *_args,
             name=name,
-            localPointingDirection=localPointingDirection,
             id=id,
             truth=truth,
             estimate=estimate,
             eclipsed=eclipsed,
-            vectorCoordinates=vectorCoordinates,
+            referenceTarget=referenceTarget,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.local_pointing_directions import LocalPointingDirections
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/lock_pointing_mode.py` & `sedaro-4.3.2/src/sedaro_base_client/model/lock_pointing_mode.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            AngularVelocityBase299,
+                            AngularVelocityBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -278,8 +278,8 @@
             lockBodyFrameVector=lockBodyFrameVector,
             lockVector=lockVector,
             acAlgorithm=acAlgorithm,
             spinRate=spinRate,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.angular_velocity_base299 import AngularVelocityBase299
+from sedaro_base_client.model.angular_velocity_base306 import AngularVelocityBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/magnetorquer.py` & `sedaro-4.3.2/src/sedaro_base_client/model/magnetorquer.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -97,15 +97,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -133,15 +133,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -265,41 +265,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -321,15 +320,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -348,58 +347,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             busRegulator = schemas.StrSchema
             powerProcessor = schemas.StrSchema
             isFail = schemas.BoolSchema
             bodyFrameVector = schemas.StrSchema
             
             
             class torque(
@@ -758,21 +785,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         busRegulator: typing.Union[MetaOapg.properties.busRegulator, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
         isFail: typing.Union[MetaOapg.properties.isFail, bool, schemas.Unset] = schemas.unset,
         bodyFrameVector: typing.Union[MetaOapg.properties.bodyFrameVector, str, schemas.Unset] = schemas.unset,
         torque: typing.Union[MetaOapg.properties.torque, list, tuple, schemas.Unset] = schemas.unset,
         maxTorque: typing.Union[MetaOapg.properties.maxTorque, list, tuple, schemas.Unset] = schemas.unset,
         commandedTorqueMagnitude: typing.Union[MetaOapg.properties.commandedTorqueMagnitude, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
@@ -819,8 +846,9 @@
             estimatedMagneticFieldVector=estimatedMagneticFieldVector,
             pwmDutyCycle=pwmDutyCycle,
             magneticMoment=magneticMoment,
             magneticMomentMargin=magneticMomentMargin,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/max_align_pointing_mode.py` & `sedaro-4.3.2/src/sedaro_base_client/model/per_round_external_state.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,240 +19,240 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class MaxAlignPointingMode(
+class PerRoundExternalState(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "name",
+            "engineIndex",
         }
         
         class properties:
+            engineIndex = schemas.IntSchema
+            id = schemas.StrSchema
             
             
-            class name(
-                schemas.StrSchema
+            class consumed(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            id = schemas.StrSchema
-            odAlgorithm = schemas.StrSchema
-            adAlgorithm = schemas.StrSchema
-            tcAlgorithm = schemas.StrSchema
+                    
+                    
+                    class items(
+                        schemas.ComposedSchema,
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            any_of_0 = schemas.StrSchema
+                            any_of_1 = schemas.DictSchema
+                            
+                            @classmethod
+                            @functools.lru_cache()
+                            def any_of(cls):
+                                # we need this here to make our import statements work
+                                # we must store _composed_schemas in here so the code is only run
+                                # when we invoke this method. If we kept this at the class
+                                # level we would get an error because the class level
+                                # code would be run when this module is imported, and these composed
+                                # classes don't exist yet because their module has not finished
+                                # loading
+                                return [
+                                    cls.any_of_0,
+                                    cls.any_of_1,
+                                ]
+                    
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                        ) -> 'items':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'consumed':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             
             
-            class reactionWheelCommands(
+            class produced(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.NumberSchema
+                    
+                    
+                    class items(
+                        schemas.ComposedSchema,
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            any_of_0 = schemas.StrSchema
+                            any_of_1 = schemas.DictSchema
+                            
+                            @classmethod
+                            @functools.lru_cache()
+                            def any_of(cls):
+                                # we need this here to make our import statements work
+                                # we must store _composed_schemas in here so the code is only run
+                                # when we invoke this method. If we kept this at the class
+                                # level we would get an error because the class level
+                                # code would be run when this module is imported, and these composed
+                                # classes don't exist yet because their module has not finished
+                                # loading
+                                return [
+                                    cls.any_of_0,
+                                    cls.any_of_1,
+                                ]
+                    
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                        ) -> 'items':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'reactionWheelCommands':
+                ) -> 'produced':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class magnetorquerCommands(
+            class agents(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.NumberSchema
+                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'magnetorquerCommands':
+                ) -> 'agents':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            commandedAttitude = schemas.AnyTypeSchema
-            commandedAngularRates = schemas.AnyTypeSchema
-            lockBodyFrameVector = schemas.StrSchema
-            lockVector = schemas.StrSchema
-            acAlgorithm = schemas.StrSchema
-            maxAlignBodyFrameVector = schemas.StrSchema
-            maxAlignVector = schemas.StrSchema
             __annotations__ = {
-                "name": name,
+                "engineIndex": engineIndex,
                 "id": id,
-                "odAlgorithm": odAlgorithm,
-                "adAlgorithm": adAlgorithm,
-                "tcAlgorithm": tcAlgorithm,
-                "reactionWheelCommands": reactionWheelCommands,
-                "magnetorquerCommands": magnetorquerCommands,
-                "commandedAttitude": commandedAttitude,
-                "commandedAngularRates": commandedAngularRates,
-                "lockBodyFrameVector": lockBodyFrameVector,
-                "lockVector": lockVector,
-                "acAlgorithm": acAlgorithm,
-                "maxAlignBodyFrameVector": maxAlignBodyFrameVector,
-                "maxAlignVector": maxAlignVector,
+                "consumed": consumed,
+                "produced": produced,
+                "agents": agents,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    name: MetaOapg.properties.name
+    engineIndex: MetaOapg.properties.engineIndex
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["engineIndex"]) -> MetaOapg.properties.engineIndex: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["odAlgorithm"]) -> MetaOapg.properties.odAlgorithm: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["adAlgorithm"]) -> MetaOapg.properties.adAlgorithm: ...
+    def __getitem__(self, name: typing_extensions.Literal["consumed"]) -> MetaOapg.properties.consumed: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["tcAlgorithm"]) -> MetaOapg.properties.tcAlgorithm: ...
+    def __getitem__(self, name: typing_extensions.Literal["produced"]) -> MetaOapg.properties.produced: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["reactionWheelCommands"]) -> MetaOapg.properties.reactionWheelCommands: ...
+    def __getitem__(self, name: typing_extensions.Literal["agents"]) -> MetaOapg.properties.agents: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["magnetorquerCommands"]) -> MetaOapg.properties.magnetorquerCommands: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["commandedAttitude"]) -> MetaOapg.properties.commandedAttitude: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["commandedAngularRates"]) -> MetaOapg.properties.commandedAngularRates: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lockBodyFrameVector"]) -> MetaOapg.properties.lockBodyFrameVector: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lockVector"]) -> MetaOapg.properties.lockVector: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["acAlgorithm"]) -> MetaOapg.properties.acAlgorithm: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["maxAlignBodyFrameVector"]) -> MetaOapg.properties.maxAlignBodyFrameVector: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["maxAlignVector"]) -> MetaOapg.properties.maxAlignVector: ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["odAlgorithm"], typing_extensions.Literal["adAlgorithm"], typing_extensions.Literal["tcAlgorithm"], typing_extensions.Literal["reactionWheelCommands"], typing_extensions.Literal["magnetorquerCommands"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lockBodyFrameVector"], typing_extensions.Literal["lockVector"], typing_extensions.Literal["acAlgorithm"], typing_extensions.Literal["maxAlignBodyFrameVector"], typing_extensions.Literal["maxAlignVector"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["engineIndex"], typing_extensions.Literal["id"], typing_extensions.Literal["consumed"], typing_extensions.Literal["produced"], typing_extensions.Literal["agents"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["engineIndex"]) -> MetaOapg.properties.engineIndex: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["odAlgorithm"]) -> typing.Union[MetaOapg.properties.odAlgorithm, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["adAlgorithm"]) -> typing.Union[MetaOapg.properties.adAlgorithm, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["tcAlgorithm"]) -> typing.Union[MetaOapg.properties.tcAlgorithm, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["reactionWheelCommands"]) -> typing.Union[MetaOapg.properties.reactionWheelCommands, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["magnetorquerCommands"]) -> typing.Union[MetaOapg.properties.magnetorquerCommands, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["commandedAttitude"]) -> typing.Union[MetaOapg.properties.commandedAttitude, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["commandedAngularRates"]) -> typing.Union[MetaOapg.properties.commandedAngularRates, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lockBodyFrameVector"]) -> typing.Union[MetaOapg.properties.lockBodyFrameVector, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lockVector"]) -> typing.Union[MetaOapg.properties.lockVector, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["acAlgorithm"]) -> typing.Union[MetaOapg.properties.acAlgorithm, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["consumed"]) -> typing.Union[MetaOapg.properties.consumed, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["maxAlignBodyFrameVector"]) -> typing.Union[MetaOapg.properties.maxAlignBodyFrameVector, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["produced"]) -> typing.Union[MetaOapg.properties.produced, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["maxAlignVector"]) -> typing.Union[MetaOapg.properties.maxAlignVector, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["agents"]) -> typing.Union[MetaOapg.properties.agents, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["odAlgorithm"], typing_extensions.Literal["adAlgorithm"], typing_extensions.Literal["tcAlgorithm"], typing_extensions.Literal["reactionWheelCommands"], typing_extensions.Literal["magnetorquerCommands"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lockBodyFrameVector"], typing_extensions.Literal["lockVector"], typing_extensions.Literal["acAlgorithm"], typing_extensions.Literal["maxAlignBodyFrameVector"], typing_extensions.Literal["maxAlignVector"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["engineIndex"], typing_extensions.Literal["id"], typing_extensions.Literal["consumed"], typing_extensions.Literal["produced"], typing_extensions.Literal["agents"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
+        engineIndex: typing.Union[MetaOapg.properties.engineIndex, decimal.Decimal, int, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        odAlgorithm: typing.Union[MetaOapg.properties.odAlgorithm, str, schemas.Unset] = schemas.unset,
-        adAlgorithm: typing.Union[MetaOapg.properties.adAlgorithm, str, schemas.Unset] = schemas.unset,
-        tcAlgorithm: typing.Union[MetaOapg.properties.tcAlgorithm, str, schemas.Unset] = schemas.unset,
-        reactionWheelCommands: typing.Union[MetaOapg.properties.reactionWheelCommands, list, tuple, schemas.Unset] = schemas.unset,
-        magnetorquerCommands: typing.Union[MetaOapg.properties.magnetorquerCommands, list, tuple, schemas.Unset] = schemas.unset,
-        commandedAttitude: typing.Union[MetaOapg.properties.commandedAttitude, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        commandedAngularRates: typing.Union[MetaOapg.properties.commandedAngularRates, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        lockBodyFrameVector: typing.Union[MetaOapg.properties.lockBodyFrameVector, str, schemas.Unset] = schemas.unset,
-        lockVector: typing.Union[MetaOapg.properties.lockVector, str, schemas.Unset] = schemas.unset,
-        acAlgorithm: typing.Union[MetaOapg.properties.acAlgorithm, str, schemas.Unset] = schemas.unset,
-        maxAlignBodyFrameVector: typing.Union[MetaOapg.properties.maxAlignBodyFrameVector, str, schemas.Unset] = schemas.unset,
-        maxAlignVector: typing.Union[MetaOapg.properties.maxAlignVector, str, schemas.Unset] = schemas.unset,
+        consumed: typing.Union[MetaOapg.properties.consumed, list, tuple, schemas.Unset] = schemas.unset,
+        produced: typing.Union[MetaOapg.properties.produced, list, tuple, schemas.Unset] = schemas.unset,
+        agents: typing.Union[MetaOapg.properties.agents, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'MaxAlignPointingMode':
+    ) -> 'PerRoundExternalState':
         return super().__new__(
             cls,
             *_args,
-            name=name,
+            engineIndex=engineIndex,
             id=id,
-            odAlgorithm=odAlgorithm,
-            adAlgorithm=adAlgorithm,
-            tcAlgorithm=tcAlgorithm,
-            reactionWheelCommands=reactionWheelCommands,
-            magnetorquerCommands=magnetorquerCommands,
-            commandedAttitude=commandedAttitude,
-            commandedAngularRates=commandedAngularRates,
-            lockBodyFrameVector=lockBodyFrameVector,
-            lockVector=lockVector,
-            acAlgorithm=acAlgorithm,
-            maxAlignBodyFrameVector=maxAlignBodyFrameVector,
-            maxAlignVector=maxAlignVector,
+            consumed=consumed,
+            produced=produced,
+            agents=agents,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/mekf_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/averaging_algorithm.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class MekfAlgorithm(
+class AveragingAlgorithm(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -94,15 +94,14 @@
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            covariance = schemas.AnyTypeSchema
             
             
             class opticalAttitudeSensors(
                 schemas.ListSchema
             ):
             
             
@@ -147,15 +146,14 @@
                     return super().__getitem__(i)
             __annotations__ = {
                 "name": name,
                 "id": id,
                 "rate": rate,
                 "attitudeSolution": attitudeSolution,
                 "angularVelocitySolution": angularVelocitySolution,
-                "covariance": covariance,
                 "opticalAttitudeSensors": opticalAttitudeSensors,
                 "angularVelocitySensors": angularVelocitySensors,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
     
@@ -171,23 +169,20 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["attitudeSolution"]) -> MetaOapg.properties.attitudeSolution: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["angularVelocitySolution"]) -> MetaOapg.properties.angularVelocitySolution: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["covariance"]) -> MetaOapg.properties.covariance: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["opticalAttitudeSensors"]) -> MetaOapg.properties.opticalAttitudeSensors: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> MetaOapg.properties.angularVelocitySensors: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["covariance"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
@@ -199,44 +194,39 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["attitudeSolution"]) -> typing.Union[MetaOapg.properties.attitudeSolution, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["angularVelocitySolution"]) -> typing.Union[MetaOapg.properties.angularVelocitySolution, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["covariance"]) -> typing.Union[MetaOapg.properties.covariance, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["opticalAttitudeSensors"]) -> typing.Union[MetaOapg.properties.opticalAttitudeSensors, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> typing.Union[MetaOapg.properties.angularVelocitySensors, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["covariance"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["opticalAttitudeSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         rate: typing.Union[MetaOapg.properties.rate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySolution: typing.Union[MetaOapg.properties.angularVelocitySolution, list, tuple, schemas.Unset] = schemas.unset,
-        covariance: typing.Union[MetaOapg.properties.covariance, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         opticalAttitudeSensors: typing.Union[MetaOapg.properties.opticalAttitudeSensors, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySensors: typing.Union[MetaOapg.properties.angularVelocitySensors, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'MekfAlgorithm':
+    ) -> 'AveragingAlgorithm':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
             rate=rate,
             attitudeSolution=attitudeSolution,
             angularVelocitySolution=angularVelocitySolution,
-            covariance=covariance,
             opticalAttitudeSensors=opticalAttitudeSensors,
             angularVelocitySensors=angularVelocitySensors,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/message_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/message_res.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/modem.py` & `sedaro-4.3.2/src/sedaro_base_client/model/modem.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -85,15 +85,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -253,41 +253,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -309,15 +308,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -336,58 +335,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class externalInterfaces(
                 schemas.ListSchema
             ):
             
             
@@ -595,21 +622,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         externalInterfaces: typing.Union[MetaOapg.properties.externalInterfaces, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'Modem':
         return super().__new__(
             cls,
             *_args,
             name=name,
@@ -634,8 +661,9 @@
             storage=storage,
             readRate=readRate,
             writeRate=writeRate,
             externalInterfaces=externalInterfaces,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/operational_mode.py` & `sedaro-4.3.2/src/sedaro_base_client/model/operational_mode.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -113,15 +113,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            DurationOperationalMode19,
+                            DurationOperationalMode20,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -149,15 +149,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            DurationOperationalMode20,
+                            DurationOperationalMode22,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -210,15 +210,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            DurationOperationalMode28,
+                            DurationOperationalMode31,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -246,15 +246,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            DurationOperationalMode29,
+                            DurationOperationalMode33,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -397,11 +397,11 @@
             timeSinceActive=timeSinceActive,
             timeSinceInactive=timeSinceInactive,
             isActive=isActive,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.duration_operational_mode18 import DurationOperationalMode18
-from sedaro_base_client.model.duration_operational_mode19 import DurationOperationalMode19
 from sedaro_base_client.model.duration_operational_mode20 import DurationOperationalMode20
-from sedaro_base_client.model.duration_operational_mode28 import DurationOperationalMode28
-from sedaro_base_client.model.duration_operational_mode29 import DurationOperationalMode29
+from sedaro_base_client.model.duration_operational_mode22 import DurationOperationalMode22
+from sedaro_base_client.model.duration_operational_mode31 import DurationOperationalMode31
+from sedaro_base_client.model.duration_operational_mode33 import DurationOperationalMode33
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/optical_attitude_sensor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/optical_attitude_sensor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -159,15 +159,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -195,15 +195,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -327,41 +327,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -383,15 +382,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -410,58 +409,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class conditions(
                 schemas.ListSchema
             ):
             
             
@@ -725,21 +752,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         conditions: typing.Union[MetaOapg.properties.conditions, list, tuple, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
         measurement: typing.Union[MetaOapg.properties.measurement, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'OpticalAttitudeSensor':
         return super().__new__(
             cls,
@@ -772,8 +799,9 @@
             fieldOfView=fieldOfView,
             measurement=measurement,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.angle_sensors51 import AngleSensors51
 from sedaro_base_client.model.angle_sensors56 import AngleSensors56
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/orbit.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_group_to_scalar_condition.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,33 +19,47 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class Orbit(
+class TargetGroupToScalarCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
+        required = {
+            "tgParam",
+            "scalar",
+            "name",
+            "relationship",
+        }
         
         class properties:
-            id = schemas.StrSchema
             
             
-            class initialStateDefType(
+            class name(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 100
+            
+            
+            class relationship(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -55,269 +69,314 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            InitialStateDefType,
+                            ConditionRelationship,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'initialStateDefType':
+                ) -> 'relationship':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            scalar = schemas.AnyTypeSchema
             
             
-            class initialStateDefParams(
+            class tgParam(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            StateVector,
-                            ClassicalOrbitalElements,
-                            Tle,
-                            IssReferenceOrbit,
-                            GeostationaryReferenceOrbit,
-                            GeostationaryTransferReferenceOrbit,
-                            PolarCircularReferenceOrbit,
-                            EquatorialCircularReferenceOrbit,
-                            SunSynchronousCircularOrbit,
+                            TargetParameters,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'initialStateDefParams':
+                ) -> 'tgParam':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-        
-            @staticmethod
-            def orbitalElements() -> typing.Type['OrbitalElementsData']:
-                return OrbitalElementsData
-            period = schemas.NumberSchema
-            semiLatusRectum = schemas.NumberSchema
-            radiusPerigee = schemas.NumberSchema
+            id = schemas.StrSchema
+            terminator = schemas.BoolSchema
+            compliance = schemas.BoolSchema
+            targetGroup = schemas.StrSchema
+            isFilter = schemas.StrSchema
             
             
-            class shadow(
-                schemas.NumberSchema
+            class targetCompliance(
+                schemas.DictSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_maximum = 1.0
-                    inclusive_minimum = 0.0
+                    additional_properties = schemas.BoolSchema
+                
+                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    # dict_instance[name] accessor
+                    return super().__getitem__(name)
+                
+                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    return super().get_item_oapg(name)
             
-            
-            class beta(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_maximum = 1.5707963267948966
-                    inclusive_minimum = -1.5707963267948966
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[MetaOapg.additional_properties, bool, ],
+                ) -> 'targetCompliance':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             
             
-            class magneticFieldVector(
-                schemas.ListSchema
+            class countRelationship(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    items = schemas.NumberSchema
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ConditionRelationship,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'magneticFieldVector':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'countRelationship':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
+            countValue = schemas.IntSchema
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            atmosphericDensity = schemas.NumberSchema
             
-            
-            class lst(
-                schemas.NumberSchema
+            class groupRoller(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    inclusive_maximum = 360.0
-                    inclusive_minimum = -360.0
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            GroupRollers,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'groupRoller':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             __annotations__ = {
+                "name": name,
+                "relationship": relationship,
+                "scalar": scalar,
+                "tgParam": tgParam,
                 "id": id,
-                "initialStateDefType": initialStateDefType,
-                "initialStateDefParams": initialStateDefParams,
-                "orbitalElements": orbitalElements,
-                "period": period,
-                "semiLatusRectum": semiLatusRectum,
-                "radiusPerigee": radiusPerigee,
-                "shadow": shadow,
-                "beta": beta,
-                "magneticFieldVector": magneticFieldVector,
-                "atmosphericDensity": atmosphericDensity,
-                "lst": lst,
+                "terminator": terminator,
+                "compliance": compliance,
+                "targetGroup": targetGroup,
+                "isFilter": isFilter,
+                "targetCompliance": targetCompliance,
+                "countRelationship": countRelationship,
+                "countValue": countValue,
+                "groupRoller": groupRoller,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
+    tgParam: MetaOapg.properties.tgParam
+    scalar: MetaOapg.properties.scalar
+    name: MetaOapg.properties.name
+    relationship: MetaOapg.properties.relationship
+    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["tgParam"]) -> MetaOapg.properties.tgParam: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["initialStateDefType"]) -> MetaOapg.properties.initialStateDefType: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["initialStateDefParams"]) -> MetaOapg.properties.initialStateDefParams: ...
+    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["orbitalElements"]) -> 'OrbitalElementsData': ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["period"]) -> MetaOapg.properties.period: ...
+    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["semiLatusRectum"]) -> MetaOapg.properties.semiLatusRectum: ...
+    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["radiusPerigee"]) -> MetaOapg.properties.radiusPerigee: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetGroup"]) -> MetaOapg.properties.targetGroup: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["shadow"]) -> MetaOapg.properties.shadow: ...
+    def __getitem__(self, name: typing_extensions.Literal["isFilter"]) -> MetaOapg.properties.isFilter: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["beta"]) -> MetaOapg.properties.beta: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetCompliance"]) -> MetaOapg.properties.targetCompliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["magneticFieldVector"]) -> MetaOapg.properties.magneticFieldVector: ...
+    def __getitem__(self, name: typing_extensions.Literal["countRelationship"]) -> MetaOapg.properties.countRelationship: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["atmosphericDensity"]) -> MetaOapg.properties.atmosphericDensity: ...
+    def __getitem__(self, name: typing_extensions.Literal["countValue"]) -> MetaOapg.properties.countValue: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lst"]) -> MetaOapg.properties.lst: ...
+    def __getitem__(self, name: typing_extensions.Literal["groupRoller"]) -> MetaOapg.properties.groupRoller: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id"], typing_extensions.Literal["initialStateDefType"], typing_extensions.Literal["initialStateDefParams"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["period"], typing_extensions.Literal["semiLatusRectum"], typing_extensions.Literal["radiusPerigee"], typing_extensions.Literal["shadow"], typing_extensions.Literal["beta"], typing_extensions.Literal["magneticFieldVector"], typing_extensions.Literal["atmosphericDensity"], typing_extensions.Literal["lst"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["tgParam"]) -> MetaOapg.properties.tgParam: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["initialStateDefType"]) -> typing.Union[MetaOapg.properties.initialStateDefType, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["initialStateDefParams"]) -> typing.Union[MetaOapg.properties.initialStateDefParams, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["orbitalElements"]) -> typing.Union['OrbitalElementsData', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["period"]) -> typing.Union[MetaOapg.properties.period, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["semiLatusRectum"]) -> typing.Union[MetaOapg.properties.semiLatusRectum, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["radiusPerigee"]) -> typing.Union[MetaOapg.properties.radiusPerigee, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetGroup"]) -> typing.Union[MetaOapg.properties.targetGroup, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["shadow"]) -> typing.Union[MetaOapg.properties.shadow, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["isFilter"]) -> typing.Union[MetaOapg.properties.isFilter, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["beta"]) -> typing.Union[MetaOapg.properties.beta, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetCompliance"]) -> typing.Union[MetaOapg.properties.targetCompliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["magneticFieldVector"]) -> typing.Union[MetaOapg.properties.magneticFieldVector, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["countRelationship"]) -> typing.Union[MetaOapg.properties.countRelationship, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["atmosphericDensity"]) -> typing.Union[MetaOapg.properties.atmosphericDensity, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["countValue"]) -> typing.Union[MetaOapg.properties.countValue, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lst"]) -> typing.Union[MetaOapg.properties.lst, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["groupRoller"]) -> typing.Union[MetaOapg.properties.groupRoller, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id"], typing_extensions.Literal["initialStateDefType"], typing_extensions.Literal["initialStateDefParams"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["period"], typing_extensions.Literal["semiLatusRectum"], typing_extensions.Literal["radiusPerigee"], typing_extensions.Literal["shadow"], typing_extensions.Literal["beta"], typing_extensions.Literal["magneticFieldVector"], typing_extensions.Literal["atmosphericDensity"], typing_extensions.Literal["lst"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
+        tgParam: typing.Union[MetaOapg.properties.tgParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        scalar: typing.Union[MetaOapg.properties.scalar, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        initialStateDefType: typing.Union[MetaOapg.properties.initialStateDefType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        initialStateDefParams: typing.Union[MetaOapg.properties.initialStateDefParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        orbitalElements: typing.Union['OrbitalElementsData', schemas.Unset] = schemas.unset,
-        period: typing.Union[MetaOapg.properties.period, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        semiLatusRectum: typing.Union[MetaOapg.properties.semiLatusRectum, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        radiusPerigee: typing.Union[MetaOapg.properties.radiusPerigee, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        shadow: typing.Union[MetaOapg.properties.shadow, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        beta: typing.Union[MetaOapg.properties.beta, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        magneticFieldVector: typing.Union[MetaOapg.properties.magneticFieldVector, list, tuple, schemas.Unset] = schemas.unset,
-        atmosphericDensity: typing.Union[MetaOapg.properties.atmosphericDensity, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        lst: typing.Union[MetaOapg.properties.lst, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
+        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
+        targetGroup: typing.Union[MetaOapg.properties.targetGroup, str, schemas.Unset] = schemas.unset,
+        isFilter: typing.Union[MetaOapg.properties.isFilter, str, schemas.Unset] = schemas.unset,
+        targetCompliance: typing.Union[MetaOapg.properties.targetCompliance, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        countRelationship: typing.Union[MetaOapg.properties.countRelationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        countValue: typing.Union[MetaOapg.properties.countValue, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        groupRoller: typing.Union[MetaOapg.properties.groupRoller, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'Orbit':
+    ) -> 'TargetGroupToScalarCondition':
         return super().__new__(
             cls,
             *_args,
+            tgParam=tgParam,
+            scalar=scalar,
+            name=name,
+            relationship=relationship,
             id=id,
-            initialStateDefType=initialStateDefType,
-            initialStateDefParams=initialStateDefParams,
-            orbitalElements=orbitalElements,
-            period=period,
-            semiLatusRectum=semiLatusRectum,
-            radiusPerigee=radiusPerigee,
-            shadow=shadow,
-            beta=beta,
-            magneticFieldVector=magneticFieldVector,
-            atmosphericDensity=atmosphericDensity,
-            lst=lst,
+            terminator=terminator,
+            compliance=compliance,
+            targetGroup=targetGroup,
+            isFilter=isFilter,
+            targetCompliance=targetCompliance,
+            countRelationship=countRelationship,
+            countValue=countValue,
+            groupRoller=groupRoller,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.classical_orbital_elements import ClassicalOrbitalElements
-from sedaro_base_client.model.equatorial_circular_reference_orbit import EquatorialCircularReferenceOrbit
-from sedaro_base_client.model.geostationary_reference_orbit import GeostationaryReferenceOrbit
-from sedaro_base_client.model.geostationary_transfer_reference_orbit import GeostationaryTransferReferenceOrbit
-from sedaro_base_client.model.initial_state_def_type import InitialStateDefType
-from sedaro_base_client.model.iss_reference_orbit import IssReferenceOrbit
-from sedaro_base_client.model.orbital_elements_data import OrbitalElementsData
-from sedaro_base_client.model.polar_circular_reference_orbit import PolarCircularReferenceOrbit
-from sedaro_base_client.model.state_vector import StateVector
-from sedaro_base_client.model.sun_synchronous_circular_orbit import SunSynchronousCircularOrbit
-from sedaro_base_client.model.tle import Tle
+from sedaro_base_client.model.condition_relationship import ConditionRelationship
+from sedaro_base_client.model.group_rollers import GroupRollers
+from sedaro_base_client.model.target_parameters import TargetParameters
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/orbital_elements_data.py` & `sedaro-4.3.2/src/sedaro_base_client/model/orbital_elements_data.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/passive_pointing_mode.py` & `sedaro-4.3.2/src/sedaro_base_client/model/passive_pointing_mode.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/passive_transmit_interface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/passive_transmit_interface.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -89,17 +89,17 @@
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
             isActive = schemas.BoolSchema
             targetInFov = schemas.BoolSchema
             linkLatency = schemas.NumberSchema
+            linkTarget = schemas.StrSchema
             modem = schemas.StrSchema
             directedEnergyDevice = schemas.StrSchema
-            linkTarget = schemas.StrSchema
             linkTargetGroup = schemas.StrSchema
             canLink = schemas.BoolSchema
             activeLinkTarget = schemas.StrSchema
             __annotations__ = {
                 "name": name,
                 "onBitRate": onBitRate,
                 "alwaysActive": alwaysActive,
@@ -108,17 +108,17 @@
                 "opModes": opModes,
                 "source": source,
                 "sink": sink,
                 "bitRate": bitRate,
                 "isActive": isActive,
                 "targetInFov": targetInFov,
                 "linkLatency": linkLatency,
+                "linkTarget": linkTarget,
                 "modem": modem,
                 "directedEnergyDevice": directedEnergyDevice,
-                "linkTarget": linkTarget,
                 "linkTargetGroup": linkTargetGroup,
                 "canLink": canLink,
                 "activeLinkTarget": activeLinkTarget,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     onBitRate: MetaOapg.properties.onBitRate
@@ -158,32 +158,32 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["targetInFov"]) -> MetaOapg.properties.targetInFov: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["linkLatency"]) -> MetaOapg.properties.linkLatency: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["modem"]) -> MetaOapg.properties.modem: ...
+    def __getitem__(self, name: typing_extensions.Literal["linkTarget"]) -> MetaOapg.properties.linkTarget: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> MetaOapg.properties.directedEnergyDevice: ...
+    def __getitem__(self, name: typing_extensions.Literal["modem"]) -> MetaOapg.properties.modem: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["linkTarget"]) -> MetaOapg.properties.linkTarget: ...
+    def __getitem__(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> MetaOapg.properties.directedEnergyDevice: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["linkTargetGroup"]) -> MetaOapg.properties.linkTargetGroup: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["canLink"]) -> MetaOapg.properties.canLink: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["activeLinkTarget"]) -> MetaOapg.properties.activeLinkTarget: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["onBitRate"]) -> MetaOapg.properties.onBitRate: ...
     
     @typing.overload
@@ -216,32 +216,32 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["targetInFov"]) -> typing.Union[MetaOapg.properties.targetInFov, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["linkLatency"]) -> typing.Union[MetaOapg.properties.linkLatency, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["modem"]) -> typing.Union[MetaOapg.properties.modem, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["linkTarget"]) -> typing.Union[MetaOapg.properties.linkTarget, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> typing.Union[MetaOapg.properties.directedEnergyDevice, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["modem"]) -> typing.Union[MetaOapg.properties.modem, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["linkTarget"]) -> typing.Union[MetaOapg.properties.linkTarget, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> typing.Union[MetaOapg.properties.directedEnergyDevice, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["linkTargetGroup"]) -> typing.Union[MetaOapg.properties.linkTargetGroup, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["canLink"]) -> typing.Union[MetaOapg.properties.canLink, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["activeLinkTarget"]) -> typing.Union[MetaOapg.properties.activeLinkTarget, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         onBitRate: typing.Union[MetaOapg.properties.onBitRate, decimal.Decimal, int, float, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
@@ -251,17 +251,17 @@
         opModes: typing.Union[MetaOapg.properties.opModes, list, tuple, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         sink: typing.Union[MetaOapg.properties.sink, str, schemas.Unset] = schemas.unset,
         bitRate: typing.Union[MetaOapg.properties.bitRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         isActive: typing.Union[MetaOapg.properties.isActive, bool, schemas.Unset] = schemas.unset,
         targetInFov: typing.Union[MetaOapg.properties.targetInFov, bool, schemas.Unset] = schemas.unset,
         linkLatency: typing.Union[MetaOapg.properties.linkLatency, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        linkTarget: typing.Union[MetaOapg.properties.linkTarget, str, schemas.Unset] = schemas.unset,
         modem: typing.Union[MetaOapg.properties.modem, str, schemas.Unset] = schemas.unset,
         directedEnergyDevice: typing.Union[MetaOapg.properties.directedEnergyDevice, str, schemas.Unset] = schemas.unset,
-        linkTarget: typing.Union[MetaOapg.properties.linkTarget, str, schemas.Unset] = schemas.unset,
         linkTargetGroup: typing.Union[MetaOapg.properties.linkTargetGroup, str, schemas.Unset] = schemas.unset,
         canLink: typing.Union[MetaOapg.properties.canLink, bool, schemas.Unset] = schemas.unset,
         activeLinkTarget: typing.Union[MetaOapg.properties.activeLinkTarget, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'PassiveTransmitInterface':
         return super().__new__(
             cls,
@@ -274,15 +274,15 @@
             opModes=opModes,
             source=source,
             sink=sink,
             bitRate=bitRate,
             isActive=isActive,
             targetInFov=targetInFov,
             linkLatency=linkLatency,
+            linkTarget=linkTarget,
             modem=modem,
             directedEnergyDevice=directedEnergyDevice,
-            linkTarget=linkTarget,
             linkTargetGroup=linkTargetGroup,
             canLink=canLink,
             activeLinkTarget=activeLinkTarget,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/per_round_external_state.py` & `sedaro-4.3.2/src/sedaro_base_client/model/spontaneous_external_state.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class PerRoundExternalState(
+class SpontaneousExternalState(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -241,15 +241,15 @@
         *_args: typing.Union[dict, frozendict.frozendict, ],
         engineIndex: typing.Union[MetaOapg.properties.engineIndex, decimal.Decimal, int, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         consumed: typing.Union[MetaOapg.properties.consumed, list, tuple, schemas.Unset] = schemas.unset,
         produced: typing.Union[MetaOapg.properties.produced, list, tuple, schemas.Unset] = schemas.unset,
         agents: typing.Union[MetaOapg.properties.agents, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'PerRoundExternalState':
+    ) -> 'SpontaneousExternalState':
         return super().__new__(
             cls,
             *_args,
             engineIndex=engineIndex,
             id=id,
             consumed=consumed,
             produced=produced,
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/pid_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/pid_algorithm.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/polar_circular_reference_orbit.py` & `sedaro-4.3.2/src/sedaro_base_client/model/geostationary_transfer_reference_orbit.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,52 +19,52 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class PolarCircularReferenceOrbit(
+class GeostationaryTransferReferenceOrbit(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
             "initialRefOrbit",
             "nu",
-            "alt",
-            "raan",
+            "altPerigee",
+            "om",
         }
         
         class properties:
             
             
             class initialRefOrbit(
                 schemas.EnumBase,
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     enum_value_to_name = {
-                        "POLAR_CIRC": "POLAR_CIRC",
+                        "GEOSTAT_TRANSFER": "GEOSTAT_TRANSFER",
                     }
                 
                 @schemas.classproperty
-                def POLAR_CIRC(cls):
-                    return cls("POLAR_CIRC")
+                def GEOSTAT_TRANSFER(cls):
+                    return cls("GEOSTAT_TRANSFER")
             
             
-            class raan(
+            class om(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_maximum = 360.0
                     inclusive_minimum = -360.0
@@ -76,85 +76,85 @@
             
             
                 class MetaOapg:
                     inclusive_maximum = 360.0
                     inclusive_minimum = -360.0
             
             
-            class alt(
+            class altPerigee(
                 schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
                     inclusive_minimum = 100.0
             __annotations__ = {
                 "initialRefOrbit": initialRefOrbit,
-                "raan": raan,
+                "om": om,
                 "nu": nu,
-                "alt": alt,
+                "altPerigee": altPerigee,
             }
     
     initialRefOrbit: MetaOapg.properties.initialRefOrbit
     nu: MetaOapg.properties.nu
-    alt: MetaOapg.properties.alt
-    raan: MetaOapg.properties.raan
+    altPerigee: MetaOapg.properties.altPerigee
+    om: MetaOapg.properties.om
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["raan"]) -> MetaOapg.properties.raan: ...
+    def __getitem__(self, name: typing_extensions.Literal["om"]) -> MetaOapg.properties.om: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
+    def __getitem__(self, name: typing_extensions.Literal["altPerigee"]) -> MetaOapg.properties.altPerigee: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", "alt", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "om", "nu", "altPerigee", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["raan"]) -> MetaOapg.properties.raan: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["om"]) -> MetaOapg.properties.om: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["altPerigee"]) -> MetaOapg.properties.altPerigee: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "raan", "nu", "alt", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "om", "nu", "altPerigee", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         initialRefOrbit: typing.Union[MetaOapg.properties.initialRefOrbit, str, ],
         nu: typing.Union[MetaOapg.properties.nu, decimal.Decimal, int, float, ],
-        alt: typing.Union[MetaOapg.properties.alt, decimal.Decimal, int, float, ],
-        raan: typing.Union[MetaOapg.properties.raan, decimal.Decimal, int, float, ],
+        altPerigee: typing.Union[MetaOapg.properties.altPerigee, decimal.Decimal, int, float, ],
+        om: typing.Union[MetaOapg.properties.om, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'PolarCircularReferenceOrbit':
+    ) -> 'GeostationaryTransferReferenceOrbit':
         return super().__new__(
             cls,
             *_args,
             initialRefOrbit=initialRefOrbit,
             nu=nu,
-            alt=alt,
-            raan=raan,
+            altPerigee=altPerigee,
+            om=om,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/polynomial_ephemeris_body.py` & `sedaro-4.3.2/src/sedaro_base_client/model/tle.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,78 +19,65 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class PolynomialEphemerisBody(
-    schemas.EnumBase,
-    schemas.StrSchema
+class Tle(
+    schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    An enumeration.
     """
 
 
     class MetaOapg:
-        enum_value_to_name = {
-            "SUN": "SUN",
-            "MOON": "MOON",
-            "EARTH": "EARTH",
-            "MERCURY": "MERCURY",
-            "VENUS": "VENUS",
-            "MARS": "MARS",
-            "JUPITER": "JUPITER",
-            "SATURN": "SATURN",
-            "URANUS": "URANUS",
-            "NEPTUNE": "NEPTUNE",
-            "PLUTO": "PLUTO",
+        required = {
+            "tle",
         }
-    
-    @schemas.classproperty
-    def SUN(cls):
-        return cls("SUN")
-    
-    @schemas.classproperty
-    def MOON(cls):
-        return cls("MOON")
-    
-    @schemas.classproperty
-    def EARTH(cls):
-        return cls("EARTH")
-    
-    @schemas.classproperty
-    def MERCURY(cls):
-        return cls("MERCURY")
-    
-    @schemas.classproperty
-    def VENUS(cls):
-        return cls("VENUS")
-    
-    @schemas.classproperty
-    def MARS(cls):
-        return cls("MARS")
-    
-    @schemas.classproperty
-    def JUPITER(cls):
-        return cls("JUPITER")
-    
-    @schemas.classproperty
-    def SATURN(cls):
-        return cls("SATURN")
-    
-    @schemas.classproperty
-    def URANUS(cls):
-        return cls("URANUS")
-    
-    @schemas.classproperty
-    def NEPTUNE(cls):
-        return cls("NEPTUNE")
-    
-    @schemas.classproperty
-    def PLUTO(cls):
-        return cls("PLUTO")
+        
+        class properties:
+            tle = schemas.StrSchema
+            __annotations__ = {
+                "tle": tle,
+            }
+    
+    tle: MetaOapg.properties.tle
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["tle"]) -> MetaOapg.properties.tle: ...
+    
+    @typing.overload
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["tle", ], str]):
+        # dict_instance[name] accessor
+        return super().__getitem__(name)
+    
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["tle"]) -> MetaOapg.properties.tle: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["tle", ], str]):
+        return super().get_item_oapg(name)
+    
+
+    def __new__(
+        cls,
+        *_args: typing.Union[dict, frozendict.frozendict, ],
+        tle: typing.Union[MetaOapg.properties.tle, str, ],
+        _configuration: typing.Optional[schemas.Configuration] = None,
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'Tle':
+        return super().__new__(
+            cls,
+            *_args,
+            tle=tle,
+            _configuration=_configuration,
+            **kwargs,
+        )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/position_base299.py` & `sedaro-4.3.2/src/sedaro_base_client/model/scenario_template.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,177 +19,161 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class PositionBase299(
+class ScenarioTemplate(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
+
+    Class to inherit when creating a `Metamodel`
     """
 
 
     class MetaOapg:
         
         class properties:
             
             
-            class lla(
-                schemas.ListSchema
+            class blocks(
+                schemas.DictSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 3
-                    min_items = 3
-                    items = schemas.NumberSchema
+                    additional_properties = schemas.DictSchema
+                
+                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    # dict_instance[name] accessor
+                    return super().__getitem__(name)
+                
+                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'lla':
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
+                ) -> 'blocks':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
-            
-            class eci(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_items = 3
-                    min_items = 3
-                    items = schemas.NumberSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'eci':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
             
-            class llaDeg(
-                schemas.ListSchema
+            class index(
+                schemas.DictSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 3
-                    min_items = 3
-                    items = schemas.NumberSchema
+                    
+                    
+                    class additional_properties(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                _arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
+                
+                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    # dict_instance[name] accessor
+                    return super().__getitem__(name)
+                
+                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'llaDeg':
+                    **kwargs: typing.Union[MetaOapg.additional_properties, list, tuple, ],
+                ) -> 'index':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
-            
-            class ecef(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_items = 3
-                    min_items = 3
-                    items = schemas.NumberSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'ecef':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            clockConfig = schemas.StrSchema
+            seed = schemas.IntSchema
             __annotations__ = {
-                "lla": lla,
-                "eci": eci,
-                "llaDeg": llaDeg,
-                "ecef": ecef,
+                "blocks": blocks,
+                "index": index,
+                "clockConfig": clockConfig,
+                "seed": seed,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lla"]) -> MetaOapg.properties.lla: ...
+    def __getitem__(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["eci"]) -> MetaOapg.properties.eci: ...
+    def __getitem__(self, name: typing_extensions.Literal["index"]) -> MetaOapg.properties.index: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["llaDeg"]) -> MetaOapg.properties.llaDeg: ...
+    def __getitem__(self, name: typing_extensions.Literal["clockConfig"]) -> MetaOapg.properties.clockConfig: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["ecef"]) -> MetaOapg.properties.ecef: ...
+    def __getitem__(self, name: typing_extensions.Literal["seed"]) -> MetaOapg.properties.seed: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["lla"], typing_extensions.Literal["eci"], typing_extensions.Literal["llaDeg"], typing_extensions.Literal["ecef"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["clockConfig"], typing_extensions.Literal["seed"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lla"]) -> typing.Union[MetaOapg.properties.lla, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["blocks"]) -> typing.Union[MetaOapg.properties.blocks, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["eci"]) -> typing.Union[MetaOapg.properties.eci, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["index"]) -> typing.Union[MetaOapg.properties.index, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["llaDeg"]) -> typing.Union[MetaOapg.properties.llaDeg, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["clockConfig"]) -> typing.Union[MetaOapg.properties.clockConfig, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["ecef"]) -> typing.Union[MetaOapg.properties.ecef, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["seed"]) -> typing.Union[MetaOapg.properties.seed, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["lla"], typing_extensions.Literal["eci"], typing_extensions.Literal["llaDeg"], typing_extensions.Literal["ecef"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["clockConfig"], typing_extensions.Literal["seed"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        lla: typing.Union[MetaOapg.properties.lla, list, tuple, schemas.Unset] = schemas.unset,
-        eci: typing.Union[MetaOapg.properties.eci, list, tuple, schemas.Unset] = schemas.unset,
-        llaDeg: typing.Union[MetaOapg.properties.llaDeg, list, tuple, schemas.Unset] = schemas.unset,
-        ecef: typing.Union[MetaOapg.properties.ecef, list, tuple, schemas.Unset] = schemas.unset,
+        blocks: typing.Union[MetaOapg.properties.blocks, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        index: typing.Union[MetaOapg.properties.index, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        clockConfig: typing.Union[MetaOapg.properties.clockConfig, str, schemas.Unset] = schemas.unset,
+        seed: typing.Union[MetaOapg.properties.seed, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'PositionBase299':
+    ) -> 'ScenarioTemplate':
         return super().__new__(
             cls,
             *_args,
-            lla=lla,
-            eci=eci,
-            llaDeg=llaDeg,
-            ecef=ecef,
+            blocks=blocks,
+            index=index,
+            clockConfig=clockConfig,
+            seed=seed,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/position_sensor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/position_sensor.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -67,15 +67,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            DistanceSensors70,
+                            DistanceSensors72,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -122,15 +122,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -158,15 +158,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -290,41 +290,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -346,15 +345,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -373,58 +372,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class conditions(
                 schemas.ListSchema
             ):
             
             
@@ -679,21 +706,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         conditions: typing.Union[MetaOapg.properties.conditions, list, tuple, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
         measurement: typing.Union[MetaOapg.properties.measurement, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'PositionSensor':
         return super().__new__(
             cls,
@@ -723,9 +750,10 @@
             writeRate=writeRate,
             conditions=conditions,
             fieldOfView=fieldOfView,
             measurement=measurement,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.distance_sensors70 import DistanceSensors70
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.distance_sensors72 import DistanceSensors72
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/power_load.py` & `sedaro-4.3.2/src/sedaro_base_client/model/resistance_load.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class PowerLoad(
+class ResistanceLoad(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -84,18 +84,50 @@
                 ) -> 'epsOutputType':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-        
-            @staticmethod
-            def loadDefParams() -> typing.Type['ConstantPowerParams']:
-                return ConstantPowerParams
+            
+            
+            class loadDefParams(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ConstantResistanceParams,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'loadDefParams':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             id = schemas.StrSchema
             busRegulator = schemas.StrSchema
             powerProcessor = schemas.StrSchema
             loadState = schemas.StrSchema
             powerConsumed = schemas.NumberSchema
             isActive = schemas.BoolSchema
             
@@ -114,15 +146,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            DurationLoad70,
+                            DurationLoad69,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -155,20 +187,20 @@
                 "powerConsumed": powerConsumed,
                 "isActive": isActive,
                 "dutyCyclePeriod": dutyCyclePeriod,
                 "dutyCyclePercentage": dutyCyclePercentage,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    loadDefParams: 'ConstantPowerParams'
+    loadDefParams: MetaOapg.properties.loadDefParams
     name: MetaOapg.properties.name
     epsOutputType: MetaOapg.properties.epsOutputType
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["loadDefParams"]) -> 'ConstantPowerParams': ...
+    def __getitem__(self, name: typing_extensions.Literal["loadDefParams"]) -> MetaOapg.properties.loadDefParams: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["epsOutputType"]) -> MetaOapg.properties.epsOutputType: ...
     
@@ -197,15 +229,15 @@
     def __getitem__(self, name: typing_extensions.Literal["dutyCyclePercentage"]) -> MetaOapg.properties.dutyCyclePercentage: ...
     
     def __getitem__(self, name: typing.Union[typing_extensions.Literal["loadDefParams"], typing_extensions.Literal["name"], typing_extensions.Literal["epsOutputType"], typing_extensions.Literal["id"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["loadState"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["isActive"], typing_extensions.Literal["dutyCyclePeriod"], typing_extensions.Literal["dutyCyclePercentage"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["loadDefParams"]) -> 'ConstantPowerParams': ...
+    def get_item_oapg(self, name: typing_extensions.Literal["loadDefParams"]) -> MetaOapg.properties.loadDefParams: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["epsOutputType"]) -> MetaOapg.properties.epsOutputType: ...
     
@@ -235,27 +267,27 @@
     
     def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["loadDefParams"], typing_extensions.Literal["name"], typing_extensions.Literal["epsOutputType"], typing_extensions.Literal["id"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["loadState"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["isActive"], typing_extensions.Literal["dutyCyclePeriod"], typing_extensions.Literal["dutyCyclePercentage"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        loadDefParams: 'ConstantPowerParams',
+        loadDefParams: typing.Union[MetaOapg.properties.loadDefParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         epsOutputType: typing.Union[MetaOapg.properties.epsOutputType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         busRegulator: typing.Union[MetaOapg.properties.busRegulator, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
         loadState: typing.Union[MetaOapg.properties.loadState, str, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         isActive: typing.Union[MetaOapg.properties.isActive, bool, schemas.Unset] = schemas.unset,
         dutyCyclePeriod: typing.Union[MetaOapg.properties.dutyCyclePeriod, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         dutyCyclePercentage: typing.Union[MetaOapg.properties.dutyCyclePercentage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'PowerLoad':
+    ) -> 'ResistanceLoad':
         return super().__new__(
             cls,
             *_args,
             loadDefParams=loadDefParams,
             name=name,
             epsOutputType=epsOutputType,
             id=id,
@@ -265,10 +297,10 @@
             powerConsumed=powerConsumed,
             isActive=isActive,
             dutyCyclePeriod=dutyCyclePeriod,
             dutyCyclePercentage=dutyCyclePercentage,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.constant_power_params import ConstantPowerParams
-from sedaro_base_client.model.duration_load70 import DurationLoad70
+from sedaro_base_client.model.constant_resistance_params import ConstantResistanceParams
+from sedaro_base_client.model.duration_load69 import DurationLoad69
 from sedaro_base_client.model.eps_output_types import EpsOutputTypes
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/power_processor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/quasi_reg_det_power_processor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class PowerProcessor(
+class QuasiRegDetPowerProcessor(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -85,15 +85,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -253,41 +253,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProcessorDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -309,15 +308,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -336,58 +335,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class topologyParams(
                 schemas.ComposedSchema,
             ):
             
             
@@ -740,29 +767,29 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         topologyParams: typing.Union[MetaOapg.properties.topologyParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
         dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
         battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
         busRegulators: typing.Union[MetaOapg.properties.busRegulators, list, tuple, schemas.Unset] = schemas.unset,
         solarArrays: typing.Union[MetaOapg.properties.solarArrays, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'PowerProcessor':
+    ) -> 'QuasiRegDetPowerProcessor':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
             partNumber=partNumber,
             manufacturer=manufacturer,
@@ -790,12 +817,13 @@
             battery=battery,
             busRegulators=busRegulators,
             solarArrays=solarArrays,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
+from sedaro_base_client.model.processor_dissipations import ProcessorDissipations
 from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
 from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
 from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
 from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/quasi_reg_det_power_processor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/fully_reg_det_power_processor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class QuasiRegDetPowerProcessor(
+class FullyRegDetPowerProcessor(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -85,15 +85,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -121,15 +121,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -253,41 +253,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProcessorDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -309,15 +308,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -336,58 +335,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class topologyParams(
                 schemas.ComposedSchema,
             ):
             
             
@@ -740,29 +767,29 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         topologyParams: typing.Union[MetaOapg.properties.topologyParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
         dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
         battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
         busRegulators: typing.Union[MetaOapg.properties.busRegulators, list, tuple, schemas.Unset] = schemas.unset,
         solarArrays: typing.Union[MetaOapg.properties.solarArrays, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'QuasiRegDetPowerProcessor':
+    ) -> 'FullyRegDetPowerProcessor':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
             partNumber=partNumber,
             manufacturer=manufacturer,
@@ -790,12 +817,13 @@
             battery=battery,
             busRegulators=busRegulators,
             solarArrays=solarArrays,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
+from sedaro_base_client.model.processor_dissipations import ProcessorDissipations
 from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
 from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
 from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
 from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/quasi_reg_det_topology_params.py` & `sedaro-4.3.2/src/sedaro_base_client/model/quasi_reg_det_topology_params.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/quaternion_base299.py` & `sedaro-4.3.2/src/sedaro_base_client/model/fuel_reservoir.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,177 +19,195 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class QuaternionBase299(
+class FuelReservoir(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
+
+    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
+        required = {
+            "name",
+        }
         
         class properties:
             
             
-            class eci_body(
-                schemas.ListSchema
+            class name(
+                schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 4
-                    min_items = 4
-                    items = schemas.NumberSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'eci_body':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+                    max_length = 100
+            id = schemas.StrSchema
             
             
-            class body_eci(
+            class fuelTanks(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 4
-                    min_items = 4
-                    items = schemas.NumberSchema
+                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'body_eci':
+                ) -> 'fuelTanks':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class ecef_body(
+            class thrusters(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 4
-                    min_items = 4
-                    items = schemas.NumberSchema
+                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'ecef_body':
+                ) -> 'thrusters':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class body_ecef(
-                schemas.ListSchema
+            class flowRate(
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    max_items = 4
-                    min_items = 4
-                    items = schemas.NumberSchema
+                    inclusive_minimum = 0.0
             
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'body_ecef':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            class totalFuel(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            
+            
+            class fillPercent(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_maximum = 1.0
+                    inclusive_minimum = 0.0
             __annotations__ = {
-                "eci_body": eci_body,
-                "body_eci": body_eci,
-                "ecef_body": ecef_body,
-                "body_ecef": body_ecef,
+                "name": name,
+                "id": id,
+                "fuelTanks": fuelTanks,
+                "thrusters": thrusters,
+                "flowRate": flowRate,
+                "totalFuel": totalFuel,
+                "fillPercent": fillPercent,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
+    name: MetaOapg.properties.name
+    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["eci_body"]) -> MetaOapg.properties.eci_body: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["body_eci"]) -> MetaOapg.properties.body_eci: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["ecef_body"]) -> MetaOapg.properties.ecef_body: ...
+    def __getitem__(self, name: typing_extensions.Literal["fuelTanks"]) -> MetaOapg.properties.fuelTanks: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["body_ecef"]) -> MetaOapg.properties.body_ecef: ...
+    def __getitem__(self, name: typing_extensions.Literal["thrusters"]) -> MetaOapg.properties.thrusters: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["eci_body"], typing_extensions.Literal["body_eci"], typing_extensions.Literal["ecef_body"], typing_extensions.Literal["body_ecef"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["flowRate"]) -> MetaOapg.properties.flowRate: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["totalFuel"]) -> MetaOapg.properties.totalFuel: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["fillPercent"]) -> MetaOapg.properties.fillPercent: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["fuelTanks"], typing_extensions.Literal["thrusters"], typing_extensions.Literal["flowRate"], typing_extensions.Literal["totalFuel"], typing_extensions.Literal["fillPercent"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["eci_body"]) -> typing.Union[MetaOapg.properties.eci_body, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["fuelTanks"]) -> typing.Union[MetaOapg.properties.fuelTanks, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["thrusters"]) -> typing.Union[MetaOapg.properties.thrusters, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["body_eci"]) -> typing.Union[MetaOapg.properties.body_eci, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["flowRate"]) -> typing.Union[MetaOapg.properties.flowRate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["ecef_body"]) -> typing.Union[MetaOapg.properties.ecef_body, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["totalFuel"]) -> typing.Union[MetaOapg.properties.totalFuel, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["body_ecef"]) -> typing.Union[MetaOapg.properties.body_ecef, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["fillPercent"]) -> typing.Union[MetaOapg.properties.fillPercent, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["eci_body"], typing_extensions.Literal["body_eci"], typing_extensions.Literal["ecef_body"], typing_extensions.Literal["body_ecef"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["fuelTanks"], typing_extensions.Literal["thrusters"], typing_extensions.Literal["flowRate"], typing_extensions.Literal["totalFuel"], typing_extensions.Literal["fillPercent"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        eci_body: typing.Union[MetaOapg.properties.eci_body, list, tuple, schemas.Unset] = schemas.unset,
-        body_eci: typing.Union[MetaOapg.properties.body_eci, list, tuple, schemas.Unset] = schemas.unset,
-        ecef_body: typing.Union[MetaOapg.properties.ecef_body, list, tuple, schemas.Unset] = schemas.unset,
-        body_ecef: typing.Union[MetaOapg.properties.body_ecef, list, tuple, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        fuelTanks: typing.Union[MetaOapg.properties.fuelTanks, list, tuple, schemas.Unset] = schemas.unset,
+        thrusters: typing.Union[MetaOapg.properties.thrusters, list, tuple, schemas.Unset] = schemas.unset,
+        flowRate: typing.Union[MetaOapg.properties.flowRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        totalFuel: typing.Union[MetaOapg.properties.totalFuel, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        fillPercent: typing.Union[MetaOapg.properties.fillPercent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'QuaternionBase299':
+    ) -> 'FuelReservoir':
         return super().__new__(
             cls,
             *_args,
-            eci_body=eci_body,
-            body_eci=body_eci,
-            ecef_body=ecef_body,
-            body_ecef=body_ecef,
+            name=name,
+            id=id,
+            fuelTanks=fuelTanks,
+            thrusters=thrusters,
+            flowRate=flowRate,
+            totalFuel=totalFuel,
+            fillPercent=fillPercent,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/reaction_wheel.py` & `sedaro-4.3.2/src/sedaro_base_client/model/reaction_wheel.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -125,15 +125,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -161,15 +161,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -293,41 +293,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -349,15 +348,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -376,58 +375,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             busRegulator = schemas.StrSchema
             powerProcessor = schemas.StrSchema
             isFail = schemas.BoolSchema
             bodyFrameVector = schemas.StrSchema
             
             
             class torque(
@@ -789,21 +816,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         busRegulator: typing.Union[MetaOapg.properties.busRegulator, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
         isFail: typing.Union[MetaOapg.properties.isFail, bool, schemas.Unset] = schemas.unset,
         bodyFrameVector: typing.Union[MetaOapg.properties.bodyFrameVector, str, schemas.Unset] = schemas.unset,
         torque: typing.Union[MetaOapg.properties.torque, list, tuple, schemas.Unset] = schemas.unset,
         maxTorque: typing.Union[MetaOapg.properties.maxTorque, list, tuple, schemas.Unset] = schemas.unset,
         commandedTorqueMagnitude: typing.Union[MetaOapg.properties.commandedTorqueMagnitude, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
@@ -854,8 +881,9 @@
             momentum=momentum,
             speed=speed,
             torqueMargin=torqueMargin,
             momentumMargin=momentumMargin,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/receive_interface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/receive_interface.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -89,17 +89,17 @@
             
             
                 class MetaOapg:
                     inclusive_minimum = 0.0
             isActive = schemas.BoolSchema
             targetInFov = schemas.BoolSchema
             linkLatency = schemas.NumberSchema
+            linkTarget = schemas.StrSchema
             modem = schemas.StrSchema
             directedEnergyDevice = schemas.StrSchema
-            linkTarget = schemas.StrSchema
             linkTargetGroup = schemas.StrSchema
             canLink = schemas.BoolSchema
             activeLinkTarget = schemas.StrSchema
             __annotations__ = {
                 "name": name,
                 "onBitRate": onBitRate,
                 "alwaysActive": alwaysActive,
@@ -108,17 +108,17 @@
                 "opModes": opModes,
                 "source": source,
                 "sink": sink,
                 "bitRate": bitRate,
                 "isActive": isActive,
                 "targetInFov": targetInFov,
                 "linkLatency": linkLatency,
+                "linkTarget": linkTarget,
                 "modem": modem,
                 "directedEnergyDevice": directedEnergyDevice,
-                "linkTarget": linkTarget,
                 "linkTargetGroup": linkTargetGroup,
                 "canLink": canLink,
                 "activeLinkTarget": activeLinkTarget,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     onBitRate: MetaOapg.properties.onBitRate
@@ -158,32 +158,32 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["targetInFov"]) -> MetaOapg.properties.targetInFov: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["linkLatency"]) -> MetaOapg.properties.linkLatency: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["modem"]) -> MetaOapg.properties.modem: ...
+    def __getitem__(self, name: typing_extensions.Literal["linkTarget"]) -> MetaOapg.properties.linkTarget: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> MetaOapg.properties.directedEnergyDevice: ...
+    def __getitem__(self, name: typing_extensions.Literal["modem"]) -> MetaOapg.properties.modem: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["linkTarget"]) -> MetaOapg.properties.linkTarget: ...
+    def __getitem__(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> MetaOapg.properties.directedEnergyDevice: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["linkTargetGroup"]) -> MetaOapg.properties.linkTargetGroup: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["canLink"]) -> MetaOapg.properties.canLink: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["activeLinkTarget"]) -> MetaOapg.properties.activeLinkTarget: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["onBitRate"]) -> MetaOapg.properties.onBitRate: ...
     
     @typing.overload
@@ -216,32 +216,32 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["targetInFov"]) -> typing.Union[MetaOapg.properties.targetInFov, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["linkLatency"]) -> typing.Union[MetaOapg.properties.linkLatency, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["modem"]) -> typing.Union[MetaOapg.properties.modem, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["linkTarget"]) -> typing.Union[MetaOapg.properties.linkTarget, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> typing.Union[MetaOapg.properties.directedEnergyDevice, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["modem"]) -> typing.Union[MetaOapg.properties.modem, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["linkTarget"]) -> typing.Union[MetaOapg.properties.linkTarget, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["directedEnergyDevice"]) -> typing.Union[MetaOapg.properties.directedEnergyDevice, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["linkTargetGroup"]) -> typing.Union[MetaOapg.properties.linkTargetGroup, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["canLink"]) -> typing.Union[MetaOapg.properties.canLink, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["activeLinkTarget"]) -> typing.Union[MetaOapg.properties.activeLinkTarget, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["onBitRate"], typing_extensions.Literal["name"], typing_extensions.Literal["alwaysActive"], typing_extensions.Literal["id"], typing_extensions.Literal["dataType"], typing_extensions.Literal["opModes"], typing_extensions.Literal["source"], typing_extensions.Literal["sink"], typing_extensions.Literal["bitRate"], typing_extensions.Literal["isActive"], typing_extensions.Literal["targetInFov"], typing_extensions.Literal["linkLatency"], typing_extensions.Literal["linkTarget"], typing_extensions.Literal["modem"], typing_extensions.Literal["directedEnergyDevice"], typing_extensions.Literal["linkTargetGroup"], typing_extensions.Literal["canLink"], typing_extensions.Literal["activeLinkTarget"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         onBitRate: typing.Union[MetaOapg.properties.onBitRate, decimal.Decimal, int, float, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
@@ -251,17 +251,17 @@
         opModes: typing.Union[MetaOapg.properties.opModes, list, tuple, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         sink: typing.Union[MetaOapg.properties.sink, str, schemas.Unset] = schemas.unset,
         bitRate: typing.Union[MetaOapg.properties.bitRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         isActive: typing.Union[MetaOapg.properties.isActive, bool, schemas.Unset] = schemas.unset,
         targetInFov: typing.Union[MetaOapg.properties.targetInFov, bool, schemas.Unset] = schemas.unset,
         linkLatency: typing.Union[MetaOapg.properties.linkLatency, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        linkTarget: typing.Union[MetaOapg.properties.linkTarget, str, schemas.Unset] = schemas.unset,
         modem: typing.Union[MetaOapg.properties.modem, str, schemas.Unset] = schemas.unset,
         directedEnergyDevice: typing.Union[MetaOapg.properties.directedEnergyDevice, str, schemas.Unset] = schemas.unset,
-        linkTarget: typing.Union[MetaOapg.properties.linkTarget, str, schemas.Unset] = schemas.unset,
         linkTargetGroup: typing.Union[MetaOapg.properties.linkTargetGroup, str, schemas.Unset] = schemas.unset,
         canLink: typing.Union[MetaOapg.properties.canLink, bool, schemas.Unset] = schemas.unset,
         activeLinkTarget: typing.Union[MetaOapg.properties.activeLinkTarget, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'ReceiveInterface':
         return super().__new__(
             cls,
@@ -274,15 +274,15 @@
             opModes=opModes,
             source=source,
             sink=sink,
             bitRate=bitRate,
             isActive=isActive,
             targetInFov=targetInFov,
             linkLatency=linkLatency,
+            linkTarget=linkTarget,
             modem=modem,
             directedEnergyDevice=directedEnergyDevice,
-            linkTarget=linkTarget,
             linkTargetGroup=linkTargetGroup,
             canLink=canLink,
             activeLinkTarget=activeLinkTarget,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/rectangular_field_of_view.py` & `sedaro-4.3.2/src/sedaro_base_client/model/rectangular_field_of_view.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -68,15 +68,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            AngleFieldOfView36,
+                            AngleFieldOfView35,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -104,15 +104,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            AngleFieldOfView37,
+                            AngleFieldOfView36,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -235,9 +235,9 @@
             id=id,
             boresightBodyFrameVector=boresightBodyFrameVector,
             sensors=sensors,
             heightBodyFrameVector=heightBodyFrameVector,
             _configuration=_configuration,
         )
 
+from sedaro_base_client.model.angle_field_of_view35 import AngleFieldOfView35
 from sedaro_base_client.model.angle_field_of_view36 import AngleFieldOfView36
-from sedaro_base_client.model.angle_field_of_view37 import AngleFieldOfView37
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/resistance_load.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_group_in_fov_condition.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,92 +19,80 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ResistanceLoad(
+class TargetGroupInFovCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "loadDefParams",
             "name",
-            "epsOutputType",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
+            id = schemas.StrSchema
+            terminator = schemas.BoolSchema
+            compliance = schemas.BoolSchema
+            targetGroup = schemas.StrSchema
+            isFilter = schemas.StrSchema
             
             
-            class epsOutputType(
-                schemas.ComposedSchema,
+            class targetCompliance(
+                schemas.DictSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            EpsOutputTypes,
-                        ]
-            
+                    additional_properties = schemas.BoolSchema
+                
+                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    # dict_instance[name] accessor
+                    return super().__getitem__(name)
+                
+                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                    return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'epsOutputType':
+                    **kwargs: typing.Union[MetaOapg.additional_properties, bool, ],
+                ) -> 'targetCompliance':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-        
-            @staticmethod
-            def loadDefParams() -> typing.Type['ConstantResistanceParams']:
-                return ConstantResistanceParams
-            id = schemas.StrSchema
-            busRegulator = schemas.StrSchema
-            powerProcessor = schemas.StrSchema
-            loadState = schemas.StrSchema
-            powerConsumed = schemas.NumberSchema
-            isActive = schemas.BoolSchema
+            fieldOfView = schemas.StrSchema
+            countValue = schemas.IntSchema
             
             
-            class dutyCyclePeriod(
+            class countRelationship(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -114,161 +102,138 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            DurationLoad70,
+                            ConditionRelationship,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'dutyCyclePeriod':
+                ) -> 'countRelationship':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            
-            
-            class dutyCyclePercentage(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_maximum = 1.0
-                    inclusive_minimum = 0.0
             __annotations__ = {
                 "name": name,
-                "epsOutputType": epsOutputType,
-                "loadDefParams": loadDefParams,
                 "id": id,
-                "busRegulator": busRegulator,
-                "powerProcessor": powerProcessor,
-                "loadState": loadState,
-                "powerConsumed": powerConsumed,
-                "isActive": isActive,
-                "dutyCyclePeriod": dutyCyclePeriod,
-                "dutyCyclePercentage": dutyCyclePercentage,
+                "terminator": terminator,
+                "compliance": compliance,
+                "targetGroup": targetGroup,
+                "isFilter": isFilter,
+                "targetCompliance": targetCompliance,
+                "fieldOfView": fieldOfView,
+                "countValue": countValue,
+                "countRelationship": countRelationship,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    loadDefParams: 'ConstantResistanceParams'
     name: MetaOapg.properties.name
-    epsOutputType: MetaOapg.properties.epsOutputType
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["loadDefParams"]) -> 'ConstantResistanceParams': ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["epsOutputType"]) -> MetaOapg.properties.epsOutputType: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["busRegulator"]) -> MetaOapg.properties.busRegulator: ...
+    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetGroup"]) -> MetaOapg.properties.targetGroup: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["loadState"]) -> MetaOapg.properties.loadState: ...
+    def __getitem__(self, name: typing_extensions.Literal["isFilter"]) -> MetaOapg.properties.isFilter: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["powerConsumed"]) -> MetaOapg.properties.powerConsumed: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetCompliance"]) -> MetaOapg.properties.targetCompliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["isActive"]) -> MetaOapg.properties.isActive: ...
+    def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dutyCyclePeriod"]) -> MetaOapg.properties.dutyCyclePeriod: ...
+    def __getitem__(self, name: typing_extensions.Literal["countValue"]) -> MetaOapg.properties.countValue: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dutyCyclePercentage"]) -> MetaOapg.properties.dutyCyclePercentage: ...
+    def __getitem__(self, name: typing_extensions.Literal["countRelationship"]) -> MetaOapg.properties.countRelationship: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["loadDefParams"], typing_extensions.Literal["name"], typing_extensions.Literal["epsOutputType"], typing_extensions.Literal["id"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["loadState"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["isActive"], typing_extensions.Literal["dutyCyclePeriod"], typing_extensions.Literal["dutyCyclePercentage"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["countValue"], typing_extensions.Literal["countRelationship"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["loadDefParams"]) -> 'ConstantResistanceParams': ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["epsOutputType"]) -> MetaOapg.properties.epsOutputType: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["busRegulator"]) -> typing.Union[MetaOapg.properties.busRegulator, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetGroup"]) -> typing.Union[MetaOapg.properties.targetGroup, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["loadState"]) -> typing.Union[MetaOapg.properties.loadState, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["isFilter"]) -> typing.Union[MetaOapg.properties.isFilter, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["powerConsumed"]) -> typing.Union[MetaOapg.properties.powerConsumed, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetCompliance"]) -> typing.Union[MetaOapg.properties.targetCompliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["isActive"]) -> typing.Union[MetaOapg.properties.isActive, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dutyCyclePeriod"]) -> typing.Union[MetaOapg.properties.dutyCyclePeriod, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["countValue"]) -> typing.Union[MetaOapg.properties.countValue, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dutyCyclePercentage"]) -> typing.Union[MetaOapg.properties.dutyCyclePercentage, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["countRelationship"]) -> typing.Union[MetaOapg.properties.countRelationship, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["loadDefParams"], typing_extensions.Literal["name"], typing_extensions.Literal["epsOutputType"], typing_extensions.Literal["id"], typing_extensions.Literal["busRegulator"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["loadState"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["isActive"], typing_extensions.Literal["dutyCyclePeriod"], typing_extensions.Literal["dutyCyclePercentage"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["countValue"], typing_extensions.Literal["countRelationship"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        loadDefParams: 'ConstantResistanceParams',
         name: typing.Union[MetaOapg.properties.name, str, ],
-        epsOutputType: typing.Union[MetaOapg.properties.epsOutputType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        busRegulator: typing.Union[MetaOapg.properties.busRegulator, str, schemas.Unset] = schemas.unset,
-        powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
-        loadState: typing.Union[MetaOapg.properties.loadState, str, schemas.Unset] = schemas.unset,
-        powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        isActive: typing.Union[MetaOapg.properties.isActive, bool, schemas.Unset] = schemas.unset,
-        dutyCyclePeriod: typing.Union[MetaOapg.properties.dutyCyclePeriod, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        dutyCyclePercentage: typing.Union[MetaOapg.properties.dutyCyclePercentage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
+        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
+        targetGroup: typing.Union[MetaOapg.properties.targetGroup, str, schemas.Unset] = schemas.unset,
+        isFilter: typing.Union[MetaOapg.properties.isFilter, str, schemas.Unset] = schemas.unset,
+        targetCompliance: typing.Union[MetaOapg.properties.targetCompliance, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
+        countValue: typing.Union[MetaOapg.properties.countValue, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        countRelationship: typing.Union[MetaOapg.properties.countRelationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ResistanceLoad':
+    ) -> 'TargetGroupInFovCondition':
         return super().__new__(
             cls,
             *_args,
-            loadDefParams=loadDefParams,
             name=name,
-            epsOutputType=epsOutputType,
             id=id,
-            busRegulator=busRegulator,
-            powerProcessor=powerProcessor,
-            loadState=loadState,
-            powerConsumed=powerConsumed,
-            isActive=isActive,
-            dutyCyclePeriod=dutyCyclePeriod,
-            dutyCyclePercentage=dutyCyclePercentage,
+            terminator=terminator,
+            compliance=compliance,
+            targetGroup=targetGroup,
+            isFilter=isFilter,
+            targetCompliance=targetCompliance,
+            fieldOfView=fieldOfView,
+            countValue=countValue,
+            countRelationship=countRelationship,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.constant_resistance_params import ConstantResistanceParams
-from sedaro_base_client.model.duration_load70 import DurationLoad70
-from sedaro_base_client.model.eps_output_types import EpsOutputTypes
+from sedaro_base_client.model.condition_relationship import ConditionRelationship
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/same_target_multi_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/same_target_multi_condition.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/satellite.py` & `sedaro-4.3.2/src/sedaro_base_client/model/base_dissipations.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,53 +19,73 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class Satellite(
+class BaseDissipations(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
+        required = {
+            "total",
+        }
         
         class properties:
-            id = schemas.StrSchema
+            
+            
+            class total(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
             __annotations__ = {
-                "id": id,
+                "total": total,
             }
-        additional_properties = schemas.NotAnyTypeSchema
+    
+    total: MetaOapg.properties.total
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["total", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["total", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        total: typing.Union[MetaOapg.properties.total, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'Satellite':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'BaseDissipations':
         return super().__new__(
             cls,
             *_args,
-            id=id,
+            total=total,
             _configuration=_configuration,
+            **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/satellite_to_satellite_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/satellite_to_satellite_condition.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/satellite_to_scalar_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/satellite_to_scalar_condition.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/satellite_to_target_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/local_vector.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,46 +19,37 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class SatelliteToTargetCondition(
+class LocalVector(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
             "name",
-            "targetParam",
-            "relationship",
+            "localPointingDirection",
         }
         
         class properties:
+            name = schemas.StrSchema
             
             
-            class name(
-                schemas.StrSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_length = 100
-            
-            
-            class relationship(
+            class localPointingDirection(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -68,33 +59,34 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ConditionRelationship,
+                            LocalPointingDirections,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'relationship':
+                ) -> 'localPointingDirection':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            id = schemas.StrSchema
             
             
-            class targetParam(
+            class truth(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -104,36 +96,33 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TargetParameters,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'targetParam':
+                ) -> 'truth':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            id = schemas.StrSchema
-            terminator = schemas.BoolSchema
-            compliance = schemas.BoolSchema
             
             
-            class satParam(
+            class estimate(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -143,125 +132,139 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            SatelliteParameters,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'satParam':
+                ) -> 'estimate':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            targetA = schemas.StrSchema
+            eclipsed = schemas.BoolSchema
+            
+            
+            class vectorCoordinates(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_items = 3
+                    min_items = 3
+                    items = schemas.NumberSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'vectorCoordinates':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             __annotations__ = {
                 "name": name,
-                "relationship": relationship,
-                "targetParam": targetParam,
+                "localPointingDirection": localPointingDirection,
                 "id": id,
-                "terminator": terminator,
-                "compliance": compliance,
-                "satParam": satParam,
-                "targetA": targetA,
+                "truth": truth,
+                "estimate": estimate,
+                "eclipsed": eclipsed,
+                "vectorCoordinates": vectorCoordinates,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
-    targetParam: MetaOapg.properties.targetParam
-    relationship: MetaOapg.properties.relationship
+    localPointingDirection: MetaOapg.properties.localPointingDirection
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def __getitem__(self, name: typing_extensions.Literal["localPointingDirection"]) -> MetaOapg.properties.localPointingDirection: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
+    def __getitem__(self, name: typing_extensions.Literal["truth"]) -> MetaOapg.properties.truth: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["estimate"]) -> MetaOapg.properties.estimate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["satParam"]) -> MetaOapg.properties.satParam: ...
+    def __getitem__(self, name: typing_extensions.Literal["eclipsed"]) -> MetaOapg.properties.eclipsed: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
+    def __getitem__(self, name: typing_extensions.Literal["vectorCoordinates"]) -> MetaOapg.properties.vectorCoordinates: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["satParam"], typing_extensions.Literal["targetA"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["localPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["vectorCoordinates"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["localPointingDirection"]) -> MetaOapg.properties.localPointingDirection: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["truth"]) -> typing.Union[MetaOapg.properties.truth, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["estimate"]) -> typing.Union[MetaOapg.properties.estimate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["satParam"]) -> typing.Union[MetaOapg.properties.satParam, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["eclipsed"]) -> typing.Union[MetaOapg.properties.eclipsed, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["vectorCoordinates"]) -> typing.Union[MetaOapg.properties.vectorCoordinates, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["satParam"], typing_extensions.Literal["targetA"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["localPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["vectorCoordinates"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        targetParam: typing.Union[MetaOapg.properties.targetParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        localPointingDirection: typing.Union[MetaOapg.properties.localPointingDirection, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
-        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
-        satParam: typing.Union[MetaOapg.properties.satParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
+        truth: typing.Union[MetaOapg.properties.truth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        estimate: typing.Union[MetaOapg.properties.estimate, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        eclipsed: typing.Union[MetaOapg.properties.eclipsed, bool, schemas.Unset] = schemas.unset,
+        vectorCoordinates: typing.Union[MetaOapg.properties.vectorCoordinates, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'SatelliteToTargetCondition':
+    ) -> 'LocalVector':
         return super().__new__(
             cls,
             *_args,
             name=name,
-            targetParam=targetParam,
-            relationship=relationship,
+            localPointingDirection=localPointingDirection,
             id=id,
-            terminator=terminator,
-            compliance=compliance,
-            satParam=satParam,
-            targetA=targetA,
+            truth=truth,
+            estimate=estimate,
+            eclipsed=eclipsed,
+            vectorCoordinates=vectorCoordinates,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.condition_relationship import ConditionRelationship
-from sedaro_base_client.model.satellite_parameters import SatelliteParameters
-from sedaro_base_client.model.target_parameters import TargetParameters
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
+from sedaro_base_client.model.local_pointing_directions import LocalPointingDirections
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/scenario_template_crud.py` & `sedaro-4.3.2/src/sedaro_base_client/model/scenario_template_update_interface.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ScenarioTemplateCrud(
+class ScenarioTemplateUpdateInterface(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
@@ -39,16 +39,16 @@
             "root",
             "delete",
         }
         
         class properties:
         
             @staticmethod
-            def root() -> typing.Type['ScenarioTemplateUpdate']:
-                return ScenarioTemplateUpdate
+            def root() -> typing.Type['ScenarioTemplateRoot']:
+                return ScenarioTemplateRoot
             
             
             class blocks(
                 schemas.ListSchema
             ):
             
             
@@ -69,20 +69,20 @@
                                 # we must store _composed_schemas in here so the code is only run
                                 # when we invoke this method. If we kept this at the class
                                 # level we would get an error because the class level
                                 # code would be run when this module is imported, and these composed
                                 # classes don't exist yet because their module has not finished
                                 # loading
                                 return [
-                                    AgentGroup,
-                                    Agent,
-                                    SpontaneousExternalState,
-                                    Orbit,
                                     PerRoundExternalState,
+                                    SpontaneousExternalState,
                                     ClockConfig,
+                                    AgentGroup,
+                                    Orbit,
+                                    Agent,
                                 ]
                     
                     
                         def __new__(
                             cls,
                             *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                             _configuration: typing.Optional[schemas.Configuration] = None,
@@ -134,19 +134,19 @@
             __annotations__ = {
                 "root": root,
                 "blocks": blocks,
                 "delete": delete,
             }
     
     blocks: MetaOapg.properties.blocks
-    root: 'ScenarioTemplateUpdate'
+    root: 'ScenarioTemplateRoot'
     delete: MetaOapg.properties.delete
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["root"]) -> 'ScenarioTemplateUpdate': ...
+    def __getitem__(self, name: typing_extensions.Literal["root"]) -> 'ScenarioTemplateRoot': ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["delete"]) -> MetaOapg.properties.delete: ...
     
@@ -155,15 +155,15 @@
     
     def __getitem__(self, name: typing.Union[typing_extensions.Literal["root", "blocks", "delete", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["root"]) -> 'ScenarioTemplateUpdate': ...
+    def get_item_oapg(self, name: typing_extensions.Literal["root"]) -> 'ScenarioTemplateRoot': ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["delete"]) -> MetaOapg.properties.delete: ...
     
@@ -174,19 +174,19 @@
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         blocks: typing.Union[MetaOapg.properties.blocks, list, tuple, ],
-        root: 'ScenarioTemplateUpdate',
+        root: 'ScenarioTemplateRoot',
         delete: typing.Union[MetaOapg.properties.delete, list, tuple, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ScenarioTemplateCrud':
+    ) -> 'ScenarioTemplateUpdateInterface':
         return super().__new__(
             cls,
             *_args,
             blocks=blocks,
             root=root,
             delete=delete,
             _configuration=_configuration,
@@ -194,9 +194,9 @@
         )
 
 from sedaro_base_client.model.agent import Agent
 from sedaro_base_client.model.agent_group import AgentGroup
 from sedaro_base_client.model.clock_config import ClockConfig
 from sedaro_base_client.model.orbit import Orbit
 from sedaro_base_client.model.per_round_external_state import PerRoundExternalState
-from sedaro_base_client.model.scenario_template_update import ScenarioTemplateUpdate
+from sedaro_base_client.model.scenario_template_root import ScenarioTemplateRoot
 from sedaro_base_client.model.spontaneous_external_state import SpontaneousExternalState
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/scenario_template_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/triad_algorithm.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,223 +19,214 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ScenarioTemplateRes(
+class TriadAlgorithm(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
-    Class for ScenarioTemplate with meta attributes
+    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
+        required = {
+            "name",
+        }
         
         class properties:
             
             
-            class blocks(
-                schemas.DictSchema
+            class name(
+                schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    additional_properties = schemas.DictSchema
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    max_length = 100
+            id = schemas.StrSchema
+            rate = schemas.NumberSchema
+            
+            
+            class attitudeSolution(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.NumberSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'attitudeSolution':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class angularVelocitySolution(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
-                ) -> 'blocks':
+                ) -> 'angularVelocitySolution':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
             
-            class index(
-                schemas.DictSchema
+            class vectorSensors(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    
-                    class additional_properties(
-                        schemas.ListSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            items = schemas.StrSchema
-                    
-                        def __new__(
-                            cls,
-                            _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                        ) -> 'additional_properties':
-                            return super().__new__(
-                                cls,
-                                _arg,
-                                _configuration=_configuration,
-                            )
-                    
-                        def __getitem__(self, i: int) -> MetaOapg.items:
-                            return super().__getitem__(i)
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, list, tuple, ],
-                ) -> 'index':
+                ) -> 'vectorSensors':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
-            clockConfig = schemas.StrSchema
-            seed = schemas.IntSchema
-            _quantityKinds = schemas.DictSchema
-            _supers = schemas.DictSchema
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
             
             
-            class _block_names(
+            class angularVelocitySensors(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> '_block_names':
+                ) -> 'angularVelocitySensors':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            _relationships = schemas.DictSchema
             __annotations__ = {
-                "blocks": blocks,
-                "index": index,
-                "clockConfig": clockConfig,
-                "seed": seed,
-                "_quantityKinds": _quantityKinds,
-                "_supers": _supers,
-                "_block_names": _block_names,
-                "_relationships": _relationships,
+                "name": name,
+                "id": id,
+                "rate": rate,
+                "attitudeSolution": attitudeSolution,
+                "angularVelocitySolution": angularVelocitySolution,
+                "vectorSensors": vectorSensors,
+                "angularVelocitySensors": angularVelocitySensors,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
+    name: MetaOapg.properties.name
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["index"]) -> MetaOapg.properties.index: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["clockConfig"]) -> MetaOapg.properties.clockConfig: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["seed"]) -> MetaOapg.properties.seed: ...
+    def __getitem__(self, name: typing_extensions.Literal["rate"]) -> MetaOapg.properties.rate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["_quantityKinds"]) -> MetaOapg.properties._quantityKinds: ...
+    def __getitem__(self, name: typing_extensions.Literal["attitudeSolution"]) -> MetaOapg.properties.attitudeSolution: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["_supers"]) -> MetaOapg.properties._supers: ...
+    def __getitem__(self, name: typing_extensions.Literal["angularVelocitySolution"]) -> MetaOapg.properties.angularVelocitySolution: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["_block_names"]) -> MetaOapg.properties._block_names: ...
+    def __getitem__(self, name: typing_extensions.Literal["vectorSensors"]) -> MetaOapg.properties.vectorSensors: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["_relationships"]) -> MetaOapg.properties._relationships: ...
+    def __getitem__(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> MetaOapg.properties.angularVelocitySensors: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["clockConfig"], typing_extensions.Literal["seed"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_block_names"], typing_extensions.Literal["_relationships"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["vectorSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["blocks"]) -> typing.Union[MetaOapg.properties.blocks, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["index"]) -> typing.Union[MetaOapg.properties.index, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["clockConfig"]) -> typing.Union[MetaOapg.properties.clockConfig, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["seed"]) -> typing.Union[MetaOapg.properties.seed, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["rate"]) -> typing.Union[MetaOapg.properties.rate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["_quantityKinds"]) -> typing.Union[MetaOapg.properties._quantityKinds, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["attitudeSolution"]) -> typing.Union[MetaOapg.properties.attitudeSolution, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["_supers"]) -> typing.Union[MetaOapg.properties._supers, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["angularVelocitySolution"]) -> typing.Union[MetaOapg.properties.angularVelocitySolution, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["_block_names"]) -> typing.Union[MetaOapg.properties._block_names, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["vectorSensors"]) -> typing.Union[MetaOapg.properties.vectorSensors, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["_relationships"]) -> typing.Union[MetaOapg.properties._relationships, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> typing.Union[MetaOapg.properties.angularVelocitySensors, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["clockConfig"], typing_extensions.Literal["seed"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_block_names"], typing_extensions.Literal["_relationships"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["vectorSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        blocks: typing.Union[MetaOapg.properties.blocks, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        index: typing.Union[MetaOapg.properties.index, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        clockConfig: typing.Union[MetaOapg.properties.clockConfig, str, schemas.Unset] = schemas.unset,
-        seed: typing.Union[MetaOapg.properties.seed, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        _quantityKinds: typing.Union[MetaOapg.properties._quantityKinds, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        _supers: typing.Union[MetaOapg.properties._supers, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        _block_names: typing.Union[MetaOapg.properties._block_names, list, tuple, schemas.Unset] = schemas.unset,
-        _relationships: typing.Union[MetaOapg.properties._relationships, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        rate: typing.Union[MetaOapg.properties.rate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, list, tuple, schemas.Unset] = schemas.unset,
+        angularVelocitySolution: typing.Union[MetaOapg.properties.angularVelocitySolution, list, tuple, schemas.Unset] = schemas.unset,
+        vectorSensors: typing.Union[MetaOapg.properties.vectorSensors, list, tuple, schemas.Unset] = schemas.unset,
+        angularVelocitySensors: typing.Union[MetaOapg.properties.angularVelocitySensors, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ScenarioTemplateRes':
+    ) -> 'TriadAlgorithm':
         return super().__new__(
             cls,
             *_args,
-            blocks=blocks,
-            index=index,
-            clockConfig=clockConfig,
-            seed=seed,
-            _quantityKinds=_quantityKinds,
-            _supers=_supers,
-            _block_names=_block_names,
-            _relationships=_relationships,
+            name=name,
+            id=id,
+            rate=rate,
+            attitudeSolution=attitudeSolution,
+            angularVelocitySolution=angularVelocitySolution,
+            vectorSensors=vectorSensors,
+            angularVelocitySensors=angularVelocitySensors,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/scenario_template_update.py` & `sedaro-4.3.2/src/sedaro_base_client/model/scenario_template_root.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,23 +19,23 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ScenarioTemplateUpdate(
+class ScenarioTemplateRoot(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
-    Class for the updateable fields on ScenarioTemplate
+    Scenario Root Attributes
     """
 
 
     class MetaOapg:
         
         class properties:
             clockConfig = schemas.StrSchema
@@ -67,15 +67,15 @@
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         clockConfig: typing.Union[MetaOapg.properties.clockConfig, str, schemas.Unset] = schemas.unset,
         seed: typing.Union[MetaOapg.properties.seed, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ScenarioTemplateUpdate':
+    ) -> 'ScenarioTemplateRoot':
         return super().__new__(
             cls,
             *_args,
             clockConfig=clockConfig,
             seed=seed,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/side_categories.py` & `sedaro-4.3.2/src/sedaro_base_client/model/side_categories.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/simulation_job.py` & `sedaro-4.3.2/src/sedaro_base_client/model/simulation_job.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/single_conv_hybrid_power_processor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/single_conv_hybrid_power_processor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -87,15 +87,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -123,15 +123,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -255,41 +255,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProcessorDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -311,15 +310,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -338,58 +337,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class topologyParams(
                 schemas.ComposedSchema,
             ):
             
             
@@ -758,21 +785,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         topologyParams: typing.Union[MetaOapg.properties.topologyParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
         dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
         battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
         busRegulators: typing.Union[MetaOapg.properties.busRegulators, list, tuple, schemas.Unset] = schemas.unset,
         solarArrays: typing.Union[MetaOapg.properties.solarArrays, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
@@ -810,12 +837,13 @@
             battery=battery,
             busRegulators=busRegulators,
             solarArrays=solarArrays,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
+from sedaro_base_client.model.processor_dissipations import ProcessorDissipations
 from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
 from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
 from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
 from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/single_conv_hybrid_topology_params.py` & `sedaro-4.3.2/src/sedaro_base_client/model/single_conv_hybrid_topology_params.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/single_conv_mppt_power_processor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/single_conv_mppt_power_processor.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -87,15 +87,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -123,15 +123,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -255,41 +255,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProcessorDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -311,15 +310,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -338,58 +337,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class topologyParams(
                 schemas.ComposedSchema,
             ):
             
             
@@ -758,21 +785,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         topologyParams: typing.Union[MetaOapg.properties.topologyParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
         dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
         battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
         busRegulators: typing.Union[MetaOapg.properties.busRegulators, list, tuple, schemas.Unset] = schemas.unset,
         solarArrays: typing.Union[MetaOapg.properties.solarArrays, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
@@ -810,12 +837,13 @@
             battery=battery,
             busRegulators=busRegulators,
             solarArrays=solarArrays,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
+from sedaro_base_client.model.processor_dissipations import ProcessorDissipations
 from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
 from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
 from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
 from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/single_conv_mppt_topology_params.py` & `sedaro-4.3.2/src/sedaro_base_client/model/single_conv_mppt_topology_params.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/sliding_mode_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/sliding_mode_algorithm.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/solar_array.py` & `sedaro-4.3.2/src/sedaro_base_client/model/solar_array.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/solar_cell.py` & `sedaro-4.3.2/src/sedaro_base_client/model/solar_cell.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/solar_panel.py` & `sedaro-4.3.2/src/sedaro_base_client/model/solar_panel.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -115,15 +115,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -151,15 +151,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -283,41 +283,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            PanelDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -339,15 +338,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -366,58 +365,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             cell = schemas.StrSchema
             surface = schemas.StrSchema
             array = schemas.StrSchema
             idealMaxPowerVoltage = schemas.NumberSchema
             idealMaxPowerCurrent = schemas.NumberSchema
             idealOpenCircuitVoltage = schemas.NumberSchema
             idealShortCircuitCurrent = schemas.NumberSchema
@@ -783,21 +810,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         cell: typing.Union[MetaOapg.properties.cell, str, schemas.Unset] = schemas.unset,
         surface: typing.Union[MetaOapg.properties.surface, str, schemas.Unset] = schemas.unset,
         array: typing.Union[MetaOapg.properties.array, str, schemas.Unset] = schemas.unset,
         idealMaxPowerVoltage: typing.Union[MetaOapg.properties.idealMaxPowerVoltage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         idealMaxPowerCurrent: typing.Union[MetaOapg.properties.idealMaxPowerCurrent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         idealOpenCircuitVoltage: typing.Union[MetaOapg.properties.idealOpenCircuitVoltage, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         idealShortCircuitCurrent: typing.Union[MetaOapg.properties.idealShortCircuitCurrent, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
@@ -861,8 +888,9 @@
             maxPowerCurrent=maxPowerCurrent,
             openCircuitVoltage=openCircuitVoltage,
             power=power,
             utilization=utilization,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.panel_dissipations import PanelDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/space_target.py` & `sedaro-4.3.2/src/sedaro_base_client/model/thermal_interface_material.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,226 +19,232 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class SpaceTarget(
+class ThermalInterfaceMaterial(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
+            "hotTempRating",
+            "thickness",
             "name",
+            "coldTempRating",
+            "resistivity",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
+            resistivity = schemas.NumberSchema
+            thickness = schemas.NumberSchema
+            
+            
+            class hotTempRating(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            TemperatureBase306,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'hotTempRating':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
+            
+            
+            class coldTempRating(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            TemperatureBase306,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'coldTempRating':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             id = schemas.StrSchema
-            rel_agentId = schemas.StrSchema
-            shadow = schemas.BoolSchema
-            lst = schemas.NumberSchema
-            position = schemas.AnyTypeSchema
-        
-            @staticmethod
-            def lat() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def lon() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def alt() -> typing.Type['AngleBase299']:
-                return AngleBase299
-            range = schemas.NumberSchema
-            lineOfSight = schemas.BoolSchema
-            relativePosition = schemas.AnyTypeSchema
-        
-            @staticmethod
-            def azimuth() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def elevation() -> typing.Type['AngleBase299']:
-                return AngleBase299
-        
-            @staticmethod
-            def beta() -> typing.Type['AngleBase299']:
-                return AngleBase299
+            
+            
+            class partNumber(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 32
+            
+            
+            class manufacturer(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 32
             __annotations__ = {
                 "name": name,
+                "resistivity": resistivity,
+                "thickness": thickness,
+                "hotTempRating": hotTempRating,
+                "coldTempRating": coldTempRating,
                 "id": id,
-                "rel_agentId": rel_agentId,
-                "shadow": shadow,
-                "lst": lst,
-                "position": position,
-                "lat": lat,
-                "lon": lon,
-                "alt": alt,
-                "range": range,
-                "lineOfSight": lineOfSight,
-                "relativePosition": relativePosition,
-                "azimuth": azimuth,
-                "elevation": elevation,
-                "beta": beta,
+                "partNumber": partNumber,
+                "manufacturer": manufacturer,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
+    hotTempRating: MetaOapg.properties.hotTempRating
+    thickness: MetaOapg.properties.thickness
     name: MetaOapg.properties.name
+    coldTempRating: MetaOapg.properties.coldTempRating
+    resistivity: MetaOapg.properties.resistivity
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rel_agentId"]) -> MetaOapg.properties.rel_agentId: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["shadow"]) -> MetaOapg.properties.shadow: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lst"]) -> MetaOapg.properties.lst: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["position"]) -> MetaOapg.properties.position: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lat"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["hotTempRating"]) -> MetaOapg.properties.hotTempRating: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lon"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["thickness"]) -> MetaOapg.properties.thickness: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> 'AngleBase299': ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["range"]) -> MetaOapg.properties.range: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["lineOfSight"]) -> MetaOapg.properties.lineOfSight: ...
+    def __getitem__(self, name: typing_extensions.Literal["coldTempRating"]) -> MetaOapg.properties.coldTempRating: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relativePosition"]) -> MetaOapg.properties.relativePosition: ...
+    def __getitem__(self, name: typing_extensions.Literal["resistivity"]) -> MetaOapg.properties.resistivity: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["azimuth"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["elevation"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["partNumber"]) -> MetaOapg.properties.partNumber: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["beta"]) -> 'AngleBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["manufacturer"]) -> MetaOapg.properties.manufacturer: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rel_agentId"], typing_extensions.Literal["shadow"], typing_extensions.Literal["lst"], typing_extensions.Literal["position"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["azimuth"], typing_extensions.Literal["elevation"], typing_extensions.Literal["beta"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["thickness"], typing_extensions.Literal["name"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["resistivity"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rel_agentId"]) -> typing.Union[MetaOapg.properties.rel_agentId, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["shadow"]) -> typing.Union[MetaOapg.properties.shadow, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lst"]) -> typing.Union[MetaOapg.properties.lst, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union[MetaOapg.properties.position, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lat"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["hotTempRating"]) -> MetaOapg.properties.hotTempRating: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lon"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["thickness"]) -> MetaOapg.properties.thickness: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["range"]) -> typing.Union[MetaOapg.properties.range, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["lineOfSight"]) -> typing.Union[MetaOapg.properties.lineOfSight, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["coldTempRating"]) -> MetaOapg.properties.coldTempRating: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relativePosition"]) -> typing.Union[MetaOapg.properties.relativePosition, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["resistivity"]) -> MetaOapg.properties.resistivity: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["azimuth"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["elevation"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["partNumber"]) -> typing.Union[MetaOapg.properties.partNumber, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["beta"]) -> typing.Union['AngleBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["manufacturer"]) -> typing.Union[MetaOapg.properties.manufacturer, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rel_agentId"], typing_extensions.Literal["shadow"], typing_extensions.Literal["lst"], typing_extensions.Literal["position"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["azimuth"], typing_extensions.Literal["elevation"], typing_extensions.Literal["beta"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["thickness"], typing_extensions.Literal["name"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["resistivity"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
+        hotTempRating: typing.Union[MetaOapg.properties.hotTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        thickness: typing.Union[MetaOapg.properties.thickness, decimal.Decimal, int, float, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
+        coldTempRating: typing.Union[MetaOapg.properties.coldTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        resistivity: typing.Union[MetaOapg.properties.resistivity, decimal.Decimal, int, float, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        rel_agentId: typing.Union[MetaOapg.properties.rel_agentId, str, schemas.Unset] = schemas.unset,
-        shadow: typing.Union[MetaOapg.properties.shadow, bool, schemas.Unset] = schemas.unset,
-        lst: typing.Union[MetaOapg.properties.lst, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        position: typing.Union[MetaOapg.properties.position, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        lat: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        lon: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        alt: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        range: typing.Union[MetaOapg.properties.range, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        lineOfSight: typing.Union[MetaOapg.properties.lineOfSight, bool, schemas.Unset] = schemas.unset,
-        relativePosition: typing.Union[MetaOapg.properties.relativePosition, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        azimuth: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        elevation: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
-        beta: typing.Union['AngleBase299', schemas.Unset] = schemas.unset,
+        partNumber: typing.Union[MetaOapg.properties.partNumber, str, schemas.Unset] = schemas.unset,
+        manufacturer: typing.Union[MetaOapg.properties.manufacturer, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'SpaceTarget':
+    ) -> 'ThermalInterfaceMaterial':
         return super().__new__(
             cls,
             *_args,
+            hotTempRating=hotTempRating,
+            thickness=thickness,
             name=name,
+            coldTempRating=coldTempRating,
+            resistivity=resistivity,
             id=id,
-            rel_agentId=rel_agentId,
-            shadow=shadow,
-            lst=lst,
-            position=position,
-            lat=lat,
-            lon=lon,
-            alt=alt,
-            range=range,
-            lineOfSight=lineOfSight,
-            relativePosition=relativePosition,
-            azimuth=azimuth,
-            elevation=elevation,
-            beta=beta,
+            partNumber=partNumber,
+            manufacturer=manufacturer,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.angle_base299 import AngleBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/spherical_angles.py` & `sedaro-4.3.2/src/sedaro_base_client/model/spherical_angles.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/spherical_fuel_tank.py` & `sedaro-4.3.2/src/sedaro_base_client/model/spherical_fuel_tank.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -133,15 +133,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -169,15 +169,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -301,41 +301,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -357,15 +356,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -384,58 +383,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             reservoir = schemas.StrSchema
             
             
             class flowRate(
                 schemas.NumberSchema
             ):
             
@@ -736,21 +763,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         reservoir: typing.Union[MetaOapg.properties.reservoir, str, schemas.Unset] = schemas.unset,
         flowRate: typing.Union[MetaOapg.properties.flowRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         inertia: typing.Union[MetaOapg.properties.inertia, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'SphericalFuelTank':
         return super().__new__(
             cls,
@@ -784,8 +811,9 @@
             writeRate=writeRate,
             reservoir=reservoir,
             flowRate=flowRate,
             inertia=inertia,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/spherocylinder_fuel_tank.py` & `sedaro-4.3.2/src/sedaro_base_client/model/spherocylinder_fuel_tank.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -135,15 +135,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -171,15 +171,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -303,41 +303,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -359,15 +358,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -386,58 +385,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             reservoir = schemas.StrSchema
             
             
             class flowRate(
                 schemas.NumberSchema
             ):
             
@@ -755,21 +782,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         reservoir: typing.Union[MetaOapg.properties.reservoir, str, schemas.Unset] = schemas.unset,
         flowRate: typing.Union[MetaOapg.properties.flowRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         inertia: typing.Union[MetaOapg.properties.inertia, list, tuple, schemas.Unset] = schemas.unset,
         orientationVector: typing.Union[MetaOapg.properties.orientationVector, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'SpherocylinderFuelTank':
         return super().__new__(
@@ -806,8 +833,9 @@
             reservoir=reservoir,
             flowRate=flowRate,
             inertia=inertia,
             orientationVector=orientationVector,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/spontaneous_external_state.py` & `sedaro-4.3.2/src/sedaro_base_client/model/celestial_vector.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,240 +19,218 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class SpontaneousExternalState(
+class CelestialVector(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "engineIndex",
+            "name",
+            "celestialPointingDirection",
         }
         
         class properties:
-            engineIndex = schemas.IntSchema
-            id = schemas.StrSchema
+            name = schemas.StrSchema
             
             
-            class consumed(
-                schemas.ListSchema
+            class celestialPointingDirection(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class items(
-                        schemas.ComposedSchema,
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            any_of_0 = schemas.StrSchema
-                            any_of_1 = schemas.DictSchema
-                            
-                            @classmethod
-                            @functools.lru_cache()
-                            def any_of(cls):
-                                # we need this here to make our import statements work
-                                # we must store _composed_schemas in here so the code is only run
-                                # when we invoke this method. If we kept this at the class
-                                # level we would get an error because the class level
-                                # code would be run when this module is imported, and these composed
-                                # classes don't exist yet because their module has not finished
-                                # loading
-                                return [
-                                    cls.any_of_0,
-                                    cls.any_of_1,
-                                ]
-                    
-                    
-                        def __new__(
-                            cls,
-                            *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                        ) -> 'items':
-                            return super().__new__(
-                                cls,
-                                *_args,
-                                _configuration=_configuration,
-                                **kwargs,
-                            )
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            CelestialPointingDirections,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'consumed':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'celestialPointingDirection':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            id = schemas.StrSchema
             
             
-            class produced(
-                schemas.ListSchema
+            class truth(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class items(
-                        schemas.ComposedSchema,
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            any_of_0 = schemas.StrSchema
-                            any_of_1 = schemas.DictSchema
-                            
-                            @classmethod
-                            @functools.lru_cache()
-                            def any_of(cls):
-                                # we need this here to make our import statements work
-                                # we must store _composed_schemas in here so the code is only run
-                                # when we invoke this method. If we kept this at the class
-                                # level we would get an error because the class level
-                                # code would be run when this module is imported, and these composed
-                                # classes don't exist yet because their module has not finished
-                                # loading
-                                return [
-                                    cls.any_of_0,
-                                    cls.any_of_1,
-                                ]
-                    
-                    
-                        def __new__(
-                            cls,
-                            *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                        ) -> 'items':
-                            return super().__new__(
-                                cls,
-                                *_args,
-                                _configuration=_configuration,
-                                **kwargs,
-                            )
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            FrameVectorBase306,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'produced':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'truth':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
             
-            
-            class agents(
-                schemas.ListSchema
+            class estimate(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            FrameVectorBase306,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'agents':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'estimate':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            eclipsed = schemas.BoolSchema
             __annotations__ = {
-                "engineIndex": engineIndex,
+                "name": name,
+                "celestialPointingDirection": celestialPointingDirection,
                 "id": id,
-                "consumed": consumed,
-                "produced": produced,
-                "agents": agents,
+                "truth": truth,
+                "estimate": estimate,
+                "eclipsed": eclipsed,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    engineIndex: MetaOapg.properties.engineIndex
+    name: MetaOapg.properties.name
+    celestialPointingDirection: MetaOapg.properties.celestialPointingDirection
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["engineIndex"]) -> MetaOapg.properties.engineIndex: ...
+    def __getitem__(self, name: typing_extensions.Literal["celestialPointingDirection"]) -> MetaOapg.properties.celestialPointingDirection: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["consumed"]) -> MetaOapg.properties.consumed: ...
+    def __getitem__(self, name: typing_extensions.Literal["truth"]) -> MetaOapg.properties.truth: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["produced"]) -> MetaOapg.properties.produced: ...
+    def __getitem__(self, name: typing_extensions.Literal["estimate"]) -> MetaOapg.properties.estimate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["agents"]) -> MetaOapg.properties.agents: ...
+    def __getitem__(self, name: typing_extensions.Literal["eclipsed"]) -> MetaOapg.properties.eclipsed: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["engineIndex"], typing_extensions.Literal["id"], typing_extensions.Literal["consumed"], typing_extensions.Literal["produced"], typing_extensions.Literal["agents"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["celestialPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["engineIndex"]) -> MetaOapg.properties.engineIndex: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["celestialPointingDirection"]) -> MetaOapg.properties.celestialPointingDirection: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["consumed"]) -> typing.Union[MetaOapg.properties.consumed, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["truth"]) -> typing.Union[MetaOapg.properties.truth, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["produced"]) -> typing.Union[MetaOapg.properties.produced, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["estimate"]) -> typing.Union[MetaOapg.properties.estimate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["agents"]) -> typing.Union[MetaOapg.properties.agents, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["eclipsed"]) -> typing.Union[MetaOapg.properties.eclipsed, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["engineIndex"], typing_extensions.Literal["id"], typing_extensions.Literal["consumed"], typing_extensions.Literal["produced"], typing_extensions.Literal["agents"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["celestialPointingDirection"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        engineIndex: typing.Union[MetaOapg.properties.engineIndex, decimal.Decimal, int, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        celestialPointingDirection: typing.Union[MetaOapg.properties.celestialPointingDirection, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        consumed: typing.Union[MetaOapg.properties.consumed, list, tuple, schemas.Unset] = schemas.unset,
-        produced: typing.Union[MetaOapg.properties.produced, list, tuple, schemas.Unset] = schemas.unset,
-        agents: typing.Union[MetaOapg.properties.agents, list, tuple, schemas.Unset] = schemas.unset,
+        truth: typing.Union[MetaOapg.properties.truth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        estimate: typing.Union[MetaOapg.properties.estimate, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        eclipsed: typing.Union[MetaOapg.properties.eclipsed, bool, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'SpontaneousExternalState':
+    ) -> 'CelestialVector':
         return super().__new__(
             cls,
             *_args,
-            engineIndex=engineIndex,
+            name=name,
+            celestialPointingDirection=celestialPointingDirection,
             id=id,
-            consumed=consumed,
-            produced=produced,
-            agents=agents,
+            truth=truth,
+            estimate=estimate,
+            eclipsed=eclipsed,
             _configuration=_configuration,
         )
+
+from sedaro_base_client.model.celestial_pointing_directions import CelestialPointingDirections
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/state_vector.py` & `sedaro-4.3.2/src/sedaro_base_client/model/geostationary_reference_orbit.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,87 +19,101 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class StateVector(
+class GeostationaryReferenceOrbit(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
-            "stateEci",
+            "initialRefOrbit",
+            "lon",
         }
         
         class properties:
             
             
-            class stateEci(
-                schemas.ListSchema
+            class initialRefOrbit(
+                schemas.EnumBase,
+                schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.NumberSchema
+                    enum_value_to_name = {
+                        "GEOSTAT": "GEOSTAT",
+                    }
+                
+                @schemas.classproperty
+                def GEOSTAT(cls):
+                    return cls("GEOSTAT")
             
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'stateEci':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            class lon(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_maximum = 360.0
+                    inclusive_minimum = -360.0
             __annotations__ = {
-                "stateEci": stateEci,
+                "initialRefOrbit": initialRefOrbit,
+                "lon": lon,
             }
     
-    stateEci: MetaOapg.properties.stateEci
+    initialRefOrbit: MetaOapg.properties.initialRefOrbit
+    lon: MetaOapg.properties.lon
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stateEci"]) -> MetaOapg.properties.stateEci: ...
+    def __getitem__(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["lon"]) -> MetaOapg.properties.lon: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["stateEci", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "lon", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stateEci"]) -> MetaOapg.properties.stateEci: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["lon"]) -> MetaOapg.properties.lon: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["stateEci", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "lon", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        stateEci: typing.Union[MetaOapg.properties.stateEci, list, tuple, ],
+        initialRefOrbit: typing.Union[MetaOapg.properties.initialRefOrbit, str, ],
+        lon: typing.Union[MetaOapg.properties.lon, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'StateVector':
+    ) -> 'GeostationaryReferenceOrbit':
         return super().__new__(
             cls,
             *_args,
-            stateEci=stateEci,
+            initialRefOrbit=initialRefOrbit,
+            lon=lon,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/static_thrust_control_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/repo_create_req.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,96 +19,115 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class StaticThrustControlAlgorithm(
+class RepoCreateReq(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
+            "workspace",
+            "dataType",
             "name",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            id = schemas.StrSchema
-            rate = schemas.NumberSchema
-            thrusters = schemas.DictSchema
+                    max_length = 64
+            workspace = schemas.StrSchema
+            dataType = schemas.StrSchema
+            
+            
+            class description(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 1000
             __annotations__ = {
                 "name": name,
-                "id": id,
-                "rate": rate,
-                "thrusters": thrusters,
+                "workspace": workspace,
+                "dataType": dataType,
+                "description": description,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
+    workspace: MetaOapg.properties.workspace
+    dataType: MetaOapg.properties.dataType
     name: MetaOapg.properties.name
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["workspace"]) -> MetaOapg.properties.workspace: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["dataType"]) -> MetaOapg.properties.dataType: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rate"]) -> MetaOapg.properties.rate: ...
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["thrusters"]) -> MetaOapg.properties.thrusters: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["thrusters"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "workspace", "dataType", "description", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["workspace"]) -> MetaOapg.properties.workspace: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rate"]) -> typing.Union[MetaOapg.properties.rate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dataType"]) -> MetaOapg.properties.dataType: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["thrusters"]) -> typing.Union[MetaOapg.properties.thrusters, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["thrusters"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "workspace", "dataType", "description", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
+        workspace: typing.Union[MetaOapg.properties.workspace, str, ],
+        dataType: typing.Union[MetaOapg.properties.dataType, str, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        rate: typing.Union[MetaOapg.properties.rate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        thrusters: typing.Union[MetaOapg.properties.thrusters, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'StaticThrustControlAlgorithm':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'RepoCreateReq':
         return super().__new__(
             cls,
             *_args,
+            workspace=workspace,
+            dataType=dataType,
             name=name,
-            id=id,
-            rate=rate,
-            thrusters=thrusters,
+            description=description,
             _configuration=_configuration,
+            **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/statuses.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angle_sensors56.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,58 +19,69 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class Statuses(
-    schemas.EnumBase,
-    schemas.StrSchema
+class AngleSensors56(
+    schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    An enumeration.
     """
 
 
     class MetaOapg:
-        enum_value_to_name = {
-            "PENDING": "PENDING",
-            "RUNNING": "RUNNING",
-            "PAUSED": "PAUSED",
-            "TERMINATED": "TERMINATED",
-            "FAILED": "FAILED",
-            "SUCCEEDED": "SUCCEEDED",
-            "ERROR": "ERROR",
-        }
-    
-    @schemas.classproperty
-    def PENDING(cls):
-        return cls("PENDING")
-    
-    @schemas.classproperty
-    def RUNNING(cls):
-        return cls("RUNNING")
-    
-    @schemas.classproperty
-    def PAUSED(cls):
-        return cls("PAUSED")
-    
-    @schemas.classproperty
-    def TERMINATED(cls):
-        return cls("TERMINATED")
-    
-    @schemas.classproperty
-    def FAILED(cls):
-        return cls("FAILED")
-    
-    @schemas.classproperty
-    def SUCCEEDED(cls):
-        return cls("SUCCEEDED")
-    
-    @schemas.classproperty
-    def ERROR(cls):
-        return cls("ERROR")
+        
+        class properties:
+            deg = schemas.NumberSchema
+            
+            
+            class rad(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            __annotations__ = {
+                "deg": deg,
+                "rad": rad,
+            }
+        additional_properties = schemas.NotAnyTypeSchema
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
+        # dict_instance[name] accessor
+        return super().__getitem__(name)
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
+        return super().get_item_oapg(name)
+
+    def __new__(
+        cls,
+        *_args: typing.Union[dict, frozendict.frozendict, ],
+        deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        _configuration: typing.Optional[schemas.Configuration] = None,
+    ) -> 'AngleSensors56':
+        return super().__new__(
+            cls,
+            *_args,
+            deg=deg,
+            rad=rad,
+            _configuration=_configuration,
+        )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/subsystem.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_vehicle_res.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,155 +19,177 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class Subsystem(
+class BranchVehicleRes(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
+            "dateCreated",
             "name",
+            "dateModified",
+            "id",
+            "repository",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            id = schemas.StrSchema
+                    max_length = 32
+            id = schemas.IntSchema
+            dateCreated = schemas.DateTimeSchema
+            dateModified = schemas.DateTimeSchema
             
             
-            class category(
+            class repository(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.DictSchema
+                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            Categories,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'category':
+                ) -> 'repository':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class components(
-                schemas.ListSchema
+            class description(
+                schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'components':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+                    max_length = 300
             __annotations__ = {
                 "name": name,
                 "id": id,
-                "category": category,
-                "components": components,
+                "dateCreated": dateCreated,
+                "dateModified": dateModified,
+                "repository": repository,
+                "description": description,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
+    dateCreated: MetaOapg.properties.dateCreated
     name: MetaOapg.properties.name
+    dateModified: MetaOapg.properties.dateModified
+    id: MetaOapg.properties.id
+    repository: MetaOapg.properties.repository
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["category"]) -> MetaOapg.properties.category: ...
+    def __getitem__(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["components"]) -> MetaOapg.properties.components: ...
+    def __getitem__(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["category"], typing_extensions.Literal["components"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
+    
+    @typing.overload
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "description", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["category"]) -> typing.Union[MetaOapg.properties.category, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["components"]) -> typing.Union[MetaOapg.properties.components, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["category"], typing_extensions.Literal["components"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "description", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
+        dateCreated: typing.Union[MetaOapg.properties.dateCreated, str, datetime, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        category: typing.Union[MetaOapg.properties.category, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        components: typing.Union[MetaOapg.properties.components, list, tuple, schemas.Unset] = schemas.unset,
+        dateModified: typing.Union[MetaOapg.properties.dateModified, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, ],
+        repository: typing.Union[MetaOapg.properties.repository, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'Subsystem':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'BranchVehicleRes':
         return super().__new__(
             cls,
             *_args,
+            dateCreated=dateCreated,
             name=name,
+            dateModified=dateModified,
             id=id,
-            category=category,
-            components=components,
+            repository=repository,
+            description=description,
             _configuration=_configuration,
+            **kwargs,
         )
-
-from sedaro_base_client.model.categories import Categories
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/sun_synchronous_circular_orbit.py` & `sedaro-4.3.2/src/sedaro_base_client/model/validation_error.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,133 +19,149 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class SunSynchronousCircularOrbit(
+class ValidationError(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
-            "initialRefOrbit",
-            "nu",
-            "alt",
-            "mltAscNode",
+            "msg",
+            "loc",
+            "type",
         }
         
         class properties:
             
             
-            class initialRefOrbit(
-                schemas.EnumBase,
-                schemas.StrSchema
+            class loc(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    enum_value_to_name = {
-                        "SUN_SYNC_CIRC": "SUN_SYNC_CIRC",
-                    }
-                
-                @schemas.classproperty
-                def SUN_SYNC_CIRC(cls):
-                    return cls("SUN_SYNC_CIRC")
-            mltAscNode = schemas.NumberSchema
-            
-            
-            class nu(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_maximum = 360.0
-                    inclusive_minimum = -360.0
-            
-            
-            class alt(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_minimum = 100.0
+                    
+                    
+                    class items(
+                        schemas.ComposedSchema,
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            any_of_0 = schemas.StrSchema
+                            any_of_1 = schemas.IntSchema
+                            
+                            @classmethod
+                            @functools.lru_cache()
+                            def any_of(cls):
+                                # we need this here to make our import statements work
+                                # we must store _composed_schemas in here so the code is only run
+                                # when we invoke this method. If we kept this at the class
+                                # level we would get an error because the class level
+                                # code would be run when this module is imported, and these composed
+                                # classes don't exist yet because their module has not finished
+                                # loading
+                                return [
+                                    cls.any_of_0,
+                                    cls.any_of_1,
+                                ]
+                    
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                        ) -> 'items':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'loc':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            msg = schemas.StrSchema
+            type = schemas.StrSchema
             __annotations__ = {
-                "initialRefOrbit": initialRefOrbit,
-                "mltAscNode": mltAscNode,
-                "nu": nu,
-                "alt": alt,
+                "loc": loc,
+                "msg": msg,
+                "type": type,
             }
     
-    initialRefOrbit: MetaOapg.properties.initialRefOrbit
-    nu: MetaOapg.properties.nu
-    alt: MetaOapg.properties.alt
-    mltAscNode: MetaOapg.properties.mltAscNode
+    msg: MetaOapg.properties.msg
+    loc: MetaOapg.properties.loc
+    type: MetaOapg.properties.type
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
+    def __getitem__(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["mltAscNode"]) -> MetaOapg.properties.mltAscNode: ...
+    def __getitem__(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
+    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "mltAscNode", "nu", "alt", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["initialRefOrbit"]) -> MetaOapg.properties.initialRefOrbit: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["mltAscNode"]) -> MetaOapg.properties.mltAscNode: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["nu"]) -> MetaOapg.properties.nu: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["initialRefOrbit", "mltAscNode", "nu", "alt", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        initialRefOrbit: typing.Union[MetaOapg.properties.initialRefOrbit, str, ],
-        nu: typing.Union[MetaOapg.properties.nu, decimal.Decimal, int, float, ],
-        alt: typing.Union[MetaOapg.properties.alt, decimal.Decimal, int, float, ],
-        mltAscNode: typing.Union[MetaOapg.properties.mltAscNode, decimal.Decimal, int, float, ],
+        msg: typing.Union[MetaOapg.properties.msg, str, ],
+        loc: typing.Union[MetaOapg.properties.loc, list, tuple, ],
+        type: typing.Union[MetaOapg.properties.type, str, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SunSynchronousCircularOrbit':
+    ) -> 'ValidationError':
         return super().__new__(
             cls,
             *_args,
-            initialRefOrbit=initialRefOrbit,
-            nu=nu,
-            alt=alt,
-            mltAscNode=mltAscNode,
+            msg=msg,
+            loc=loc,
+            type=type,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/sun_tracking_surface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/sun_tracking_surface.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -104,15 +104,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            FrameVectorBase299,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -140,15 +140,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            FrameVectorBase299,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -181,15 +181,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -530,9 +530,9 @@
             refVector1=refVector1,
             refVector2=refVector2,
             vectorProjection=vectorProjection,
             articulationAngle=articulationAngle,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.frame_vector_base299 import FrameVectorBase299
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/surface_material.py` & `sedaro-4.3.2/src/sedaro_base_client/model/surface_material.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -119,15 +119,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -155,15 +155,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -279,8 +279,8 @@
             partNumber=partNumber,
             manufacturer=manufacturer,
             hotTempRating=hotTempRating,
             coldTempRating=coldTempRating,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_group.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_group.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_group_in_fov_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/body_in_fov_condition.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,79 +19,46 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetGroupInFovCondition(
+class BodyInFovCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
+            "scalar",
             "name",
+            "relationship",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
-            id = schemas.StrSchema
-            terminator = schemas.BoolSchema
-            compliance = schemas.BoolSchema
-            targetGroup = schemas.StrSchema
-            isFilter = schemas.StrSchema
-            
-            
-            class targetCompliance(
-                schemas.DictSchema
-            ):
-            
-            
-                class MetaOapg:
-                    additional_properties = schemas.BoolSchema
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
-            
-                def __new__(
-                    cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, bool, ],
-                ) -> 'targetCompliance':
-                    return super().__new__(
-                        cls,
-                        *_args,
-                        _configuration=_configuration,
-                        **kwargs,
-                    )
-            fieldOfView = schemas.StrSchema
             
             
-            class countRelationship(
+            class relationship(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -110,130 +77,129 @@
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'countRelationship':
+                ) -> 'relationship':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            countValue = schemas.IntSchema
+            scalar = schemas.AnyTypeSchema
+            id = schemas.StrSchema
+            terminator = schemas.BoolSchema
+            compliance = schemas.BoolSchema
+            fieldOfView = schemas.StrSchema
+            negate = schemas.BoolSchema
+            targetA = schemas.StrSchema
             __annotations__ = {
                 "name": name,
+                "relationship": relationship,
+                "scalar": scalar,
                 "id": id,
                 "terminator": terminator,
                 "compliance": compliance,
-                "targetGroup": targetGroup,
-                "isFilter": isFilter,
-                "targetCompliance": targetCompliance,
                 "fieldOfView": fieldOfView,
-                "countRelationship": countRelationship,
-                "countValue": countValue,
+                "negate": negate,
+                "targetA": targetA,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
+    scalar: MetaOapg.properties.scalar
     name: MetaOapg.properties.name
+    relationship: MetaOapg.properties.relationship
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetGroup"]) -> MetaOapg.properties.targetGroup: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["isFilter"]) -> MetaOapg.properties.isFilter: ...
+    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetCompliance"]) -> MetaOapg.properties.targetCompliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["countRelationship"]) -> MetaOapg.properties.countRelationship: ...
+    def __getitem__(self, name: typing_extensions.Literal["negate"]) -> MetaOapg.properties.negate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["countValue"]) -> MetaOapg.properties.countValue: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["negate"], typing_extensions.Literal["targetA"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetGroup"]) -> typing.Union[MetaOapg.properties.targetGroup, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["isFilter"]) -> typing.Union[MetaOapg.properties.isFilter, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetCompliance"]) -> typing.Union[MetaOapg.properties.targetCompliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["countRelationship"]) -> typing.Union[MetaOapg.properties.countRelationship, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["negate"]) -> typing.Union[MetaOapg.properties.negate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["countValue"]) -> typing.Union[MetaOapg.properties.countValue, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["negate"], typing_extensions.Literal["targetA"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
+        scalar: typing.Union[MetaOapg.properties.scalar, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
+        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
         compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
-        targetGroup: typing.Union[MetaOapg.properties.targetGroup, str, schemas.Unset] = schemas.unset,
-        isFilter: typing.Union[MetaOapg.properties.isFilter, str, schemas.Unset] = schemas.unset,
-        targetCompliance: typing.Union[MetaOapg.properties.targetCompliance, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
-        countRelationship: typing.Union[MetaOapg.properties.countRelationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        countValue: typing.Union[MetaOapg.properties.countValue, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        negate: typing.Union[MetaOapg.properties.negate, bool, schemas.Unset] = schemas.unset,
+        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TargetGroupInFovCondition':
+    ) -> 'BodyInFovCondition':
         return super().__new__(
             cls,
             *_args,
+            scalar=scalar,
             name=name,
+            relationship=relationship,
             id=id,
             terminator=terminator,
             compliance=compliance,
-            targetGroup=targetGroup,
-            isFilter=isFilter,
-            targetCompliance=targetCompliance,
             fieldOfView=fieldOfView,
-            countRelationship=countRelationship,
-            countValue=countValue,
+            negate=negate,
+            targetA=targetA,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.condition_relationship import ConditionRelationship
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_group_to_satellite_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_group_to_satellite_condition.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_group_to_scalar_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_group_to_target_condition.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,31 +19,31 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetGroupToScalarCondition(
+class TargetGroupToTargetCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
             "tgParam",
-            "scalar",
             "name",
+            "targetParam",
             "relationship",
         }
         
         class properties:
             
             
             class name(
@@ -85,15 +85,14 @@
                 ) -> 'relationship':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            scalar = schemas.AnyTypeSchema
             
             
             class tgParam(
                 schemas.ComposedSchema,
             ):
             
             
@@ -122,14 +121,50 @@
                 ) -> 'tgParam':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            
+            
+            class targetParam(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            TargetParameters,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'targetParam':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             id = schemas.StrSchema
             terminator = schemas.BoolSchema
             compliance = schemas.BoolSchema
             targetGroup = schemas.StrSchema
             isFilter = schemas.StrSchema
             
             
@@ -229,44 +264,46 @@
                 ) -> 'groupRoller':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            targetA = schemas.StrSchema
             __annotations__ = {
                 "name": name,
                 "relationship": relationship,
-                "scalar": scalar,
                 "tgParam": tgParam,
+                "targetParam": targetParam,
                 "id": id,
                 "terminator": terminator,
                 "compliance": compliance,
                 "targetGroup": targetGroup,
                 "isFilter": isFilter,
                 "targetCompliance": targetCompliance,
                 "countRelationship": countRelationship,
                 "countValue": countValue,
                 "groupRoller": groupRoller,
+                "targetA": targetA,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     tgParam: MetaOapg.properties.tgParam
-    scalar: MetaOapg.properties.scalar
     name: MetaOapg.properties.name
+    targetParam: MetaOapg.properties.targetParam
     relationship: MetaOapg.properties.relationship
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["tgParam"]) -> MetaOapg.properties.tgParam: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
@@ -290,26 +327,29 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["countValue"]) -> MetaOapg.properties.countValue: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["groupRoller"]) -> MetaOapg.properties.groupRoller: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], typing_extensions.Literal["targetA"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["tgParam"]) -> MetaOapg.properties.tgParam: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
@@ -333,50 +373,55 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["countValue"]) -> typing.Union[MetaOapg.properties.countValue, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["groupRoller"]) -> typing.Union[MetaOapg.properties.groupRoller, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], typing_extensions.Literal["targetA"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         tgParam: typing.Union[MetaOapg.properties.tgParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        scalar: typing.Union[MetaOapg.properties.scalar, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
+        targetParam: typing.Union[MetaOapg.properties.targetParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
         compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
         targetGroup: typing.Union[MetaOapg.properties.targetGroup, str, schemas.Unset] = schemas.unset,
         isFilter: typing.Union[MetaOapg.properties.isFilter, str, schemas.Unset] = schemas.unset,
         targetCompliance: typing.Union[MetaOapg.properties.targetCompliance, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         countRelationship: typing.Union[MetaOapg.properties.countRelationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         countValue: typing.Union[MetaOapg.properties.countValue, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         groupRoller: typing.Union[MetaOapg.properties.groupRoller, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TargetGroupToScalarCondition':
+    ) -> 'TargetGroupToTargetCondition':
         return super().__new__(
             cls,
             *_args,
             tgParam=tgParam,
-            scalar=scalar,
             name=name,
+            targetParam=targetParam,
             relationship=relationship,
             id=id,
             terminator=terminator,
             compliance=compliance,
             targetGroup=targetGroup,
             isFilter=isFilter,
             targetCompliance=targetCompliance,
             countRelationship=countRelationship,
             countValue=countValue,
             groupRoller=groupRoller,
+            targetA=targetA,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.condition_relationship import ConditionRelationship
 from sedaro_base_client.model.group_rollers import GroupRollers
 from sedaro_base_client.model.target_parameters import TargetParameters
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_group_to_target_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/celestial_target.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,47 +19,46 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetGroupToTargetCondition(
+class CelestialTarget(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "tgParam",
             "name",
-            "targetParam",
-            "relationship",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
+            id = schemas.StrSchema
+            agentId = schemas.StrSchema
             
             
-            class relationship(
+            class position(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -69,33 +68,60 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ConditionRelationship,
+                            PositionBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'relationship':
+                ) -> 'position':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            range = schemas.NumberSchema
+            lineOfSight = schemas.BoolSchema
+            
+            
+            class relativePosition(
+                schemas.ListSchema
+            ):
+            
             
+                class MetaOapg:
+                    max_items = 3
+                    min_items = 3
+                    items = schemas.NumberSchema
             
-            class tgParam(
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'relativePosition':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class targetAzimuth(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -105,33 +131,33 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TargetParameters,
+                            AngleBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'tgParam':
+                ) -> 'targetAzimuth':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class targetParam(
+            class targetElevation(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -141,67 +167,69 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TargetParameters,
+                            AngleBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'targetParam':
+                ) -> 'targetElevation':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            id = schemas.StrSchema
-            terminator = schemas.BoolSchema
-            compliance = schemas.BoolSchema
-            targetGroup = schemas.StrSchema
-            isFilter = schemas.StrSchema
             
             
-            class targetCompliance(
-                schemas.DictSchema
+            class lat(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    additional_properties = schemas.BoolSchema
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            AngleBase306,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, bool, ],
-                ) -> 'targetCompliance':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'lat':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class countRelationship(
+            class lon(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -211,34 +239,33 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ConditionRelationship,
+                            AngleBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'countRelationship':
+                ) -> 'lon':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            countValue = schemas.IntSchema
             
             
-            class groupRoller(
+            class alt(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -248,180 +275,204 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            GroupRollers,
+                            DistanceBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'groupRoller':
+                ) -> 'alt':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
+            
+            
+            class polynomialEphemerisBody(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            PolynomialEphemerisBody,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'polynomialEphemerisBody':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            targetA = schemas.StrSchema
             __annotations__ = {
                 "name": name,
-                "relationship": relationship,
-                "tgParam": tgParam,
-                "targetParam": targetParam,
                 "id": id,
-                "terminator": terminator,
-                "compliance": compliance,
-                "targetGroup": targetGroup,
-                "isFilter": isFilter,
-                "targetCompliance": targetCompliance,
-                "countRelationship": countRelationship,
-                "countValue": countValue,
-                "groupRoller": groupRoller,
-                "targetA": targetA,
+                "agentId": agentId,
+                "position": position,
+                "range": range,
+                "lineOfSight": lineOfSight,
+                "relativePosition": relativePosition,
+                "targetAzimuth": targetAzimuth,
+                "targetElevation": targetElevation,
+                "lat": lat,
+                "lon": lon,
+                "alt": alt,
+                "polynomialEphemerisBody": polynomialEphemerisBody,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    tgParam: MetaOapg.properties.tgParam
     name: MetaOapg.properties.name
-    targetParam: MetaOapg.properties.targetParam
-    relationship: MetaOapg.properties.relationship
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["tgParam"]) -> MetaOapg.properties.tgParam: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def __getitem__(self, name: typing_extensions.Literal["agentId"]) -> MetaOapg.properties.agentId: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["position"]) -> MetaOapg.properties.position: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
+    def __getitem__(self, name: typing_extensions.Literal["range"]) -> MetaOapg.properties.range: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["lineOfSight"]) -> MetaOapg.properties.lineOfSight: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetGroup"]) -> MetaOapg.properties.targetGroup: ...
+    def __getitem__(self, name: typing_extensions.Literal["relativePosition"]) -> MetaOapg.properties.relativePosition: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["isFilter"]) -> MetaOapg.properties.isFilter: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetAzimuth"]) -> MetaOapg.properties.targetAzimuth: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetCompliance"]) -> MetaOapg.properties.targetCompliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetElevation"]) -> MetaOapg.properties.targetElevation: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["countRelationship"]) -> MetaOapg.properties.countRelationship: ...
+    def __getitem__(self, name: typing_extensions.Literal["lat"]) -> MetaOapg.properties.lat: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["countValue"]) -> MetaOapg.properties.countValue: ...
+    def __getitem__(self, name: typing_extensions.Literal["lon"]) -> MetaOapg.properties.lon: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["groupRoller"]) -> MetaOapg.properties.groupRoller: ...
+    def __getitem__(self, name: typing_extensions.Literal["alt"]) -> MetaOapg.properties.alt: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
+    def __getitem__(self, name: typing_extensions.Literal["polynomialEphemerisBody"]) -> MetaOapg.properties.polynomialEphemerisBody: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], typing_extensions.Literal["targetA"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["agentId"], typing_extensions.Literal["position"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["targetAzimuth"], typing_extensions.Literal["targetElevation"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["polynomialEphemerisBody"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["tgParam"]) -> MetaOapg.properties.tgParam: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["agentId"]) -> typing.Union[MetaOapg.properties.agentId, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union[MetaOapg.properties.position, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["range"]) -> typing.Union[MetaOapg.properties.range, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["lineOfSight"]) -> typing.Union[MetaOapg.properties.lineOfSight, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetGroup"]) -> typing.Union[MetaOapg.properties.targetGroup, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["relativePosition"]) -> typing.Union[MetaOapg.properties.relativePosition, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["isFilter"]) -> typing.Union[MetaOapg.properties.isFilter, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetAzimuth"]) -> typing.Union[MetaOapg.properties.targetAzimuth, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetCompliance"]) -> typing.Union[MetaOapg.properties.targetCompliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetElevation"]) -> typing.Union[MetaOapg.properties.targetElevation, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["countRelationship"]) -> typing.Union[MetaOapg.properties.countRelationship, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["lat"]) -> typing.Union[MetaOapg.properties.lat, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["countValue"]) -> typing.Union[MetaOapg.properties.countValue, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["lon"]) -> typing.Union[MetaOapg.properties.lon, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["groupRoller"]) -> typing.Union[MetaOapg.properties.groupRoller, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["alt"]) -> typing.Union[MetaOapg.properties.alt, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["polynomialEphemerisBody"]) -> typing.Union[MetaOapg.properties.polynomialEphemerisBody, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["tgParam"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetGroup"], typing_extensions.Literal["isFilter"], typing_extensions.Literal["targetCompliance"], typing_extensions.Literal["countRelationship"], typing_extensions.Literal["countValue"], typing_extensions.Literal["groupRoller"], typing_extensions.Literal["targetA"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["agentId"], typing_extensions.Literal["position"], typing_extensions.Literal["range"], typing_extensions.Literal["lineOfSight"], typing_extensions.Literal["relativePosition"], typing_extensions.Literal["targetAzimuth"], typing_extensions.Literal["targetElevation"], typing_extensions.Literal["lat"], typing_extensions.Literal["lon"], typing_extensions.Literal["alt"], typing_extensions.Literal["polynomialEphemerisBody"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        tgParam: typing.Union[MetaOapg.properties.tgParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        targetParam: typing.Union[MetaOapg.properties.targetParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
-        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
-        targetGroup: typing.Union[MetaOapg.properties.targetGroup, str, schemas.Unset] = schemas.unset,
-        isFilter: typing.Union[MetaOapg.properties.isFilter, str, schemas.Unset] = schemas.unset,
-        targetCompliance: typing.Union[MetaOapg.properties.targetCompliance, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        countRelationship: typing.Union[MetaOapg.properties.countRelationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        countValue: typing.Union[MetaOapg.properties.countValue, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        groupRoller: typing.Union[MetaOapg.properties.groupRoller, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
+        agentId: typing.Union[MetaOapg.properties.agentId, str, schemas.Unset] = schemas.unset,
+        position: typing.Union[MetaOapg.properties.position, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        range: typing.Union[MetaOapg.properties.range, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        lineOfSight: typing.Union[MetaOapg.properties.lineOfSight, bool, schemas.Unset] = schemas.unset,
+        relativePosition: typing.Union[MetaOapg.properties.relativePosition, list, tuple, schemas.Unset] = schemas.unset,
+        targetAzimuth: typing.Union[MetaOapg.properties.targetAzimuth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        targetElevation: typing.Union[MetaOapg.properties.targetElevation, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        lat: typing.Union[MetaOapg.properties.lat, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        lon: typing.Union[MetaOapg.properties.lon, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        alt: typing.Union[MetaOapg.properties.alt, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        polynomialEphemerisBody: typing.Union[MetaOapg.properties.polynomialEphemerisBody, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TargetGroupToTargetCondition':
+    ) -> 'CelestialTarget':
         return super().__new__(
             cls,
             *_args,
-            tgParam=tgParam,
             name=name,
-            targetParam=targetParam,
-            relationship=relationship,
             id=id,
-            terminator=terminator,
-            compliance=compliance,
-            targetGroup=targetGroup,
-            isFilter=isFilter,
-            targetCompliance=targetCompliance,
-            countRelationship=countRelationship,
-            countValue=countValue,
-            groupRoller=groupRoller,
-            targetA=targetA,
+            agentId=agentId,
+            position=position,
+            range=range,
+            lineOfSight=lineOfSight,
+            relativePosition=relativePosition,
+            targetAzimuth=targetAzimuth,
+            targetElevation=targetElevation,
+            lat=lat,
+            lon=lon,
+            alt=alt,
+            polynomialEphemerisBody=polynomialEphemerisBody,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.condition_relationship import ConditionRelationship
-from sedaro_base_client.model.group_rollers import GroupRollers
-from sedaro_base_client.model.target_parameters import TargetParameters
+from sedaro_base_client.model.angle_base306 import AngleBase306
+from sedaro_base_client.model.distance_base306 import DistanceBase306
+from sedaro_base_client.model.polynomial_ephemeris_body import PolynomialEphemerisBody
+from sedaro_base_client.model.position_base306 import PositionBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_group_vector.py` & `sedaro-4.3.2/src/sedaro_base_client/model/vector_in_fov_condition.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetGroupVector(
+class VectorInFovCondition(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
@@ -37,90 +37,108 @@
 
     class MetaOapg:
         required = {
             "name",
         }
         
         class properties:
-            name = schemas.StrSchema
+            
+            
+            class name(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 100
             id = schemas.StrSchema
-            truth = schemas.AnyTypeSchema
-            estimate = schemas.AnyTypeSchema
-            eclipsed = schemas.BoolSchema
-            targetGroup = schemas.StrSchema
+            terminator = schemas.BoolSchema
+            compliance = schemas.BoolSchema
+            fieldOfView = schemas.StrSchema
+            negate = schemas.BoolSchema
+            referenceVector = schemas.StrSchema
             __annotations__ = {
                 "name": name,
                 "id": id,
-                "truth": truth,
-                "estimate": estimate,
-                "eclipsed": eclipsed,
-                "targetGroup": targetGroup,
+                "terminator": terminator,
+                "compliance": compliance,
+                "fieldOfView": fieldOfView,
+                "negate": negate,
+                "referenceVector": referenceVector,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["truth"]) -> MetaOapg.properties.truth: ...
+    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["estimate"]) -> MetaOapg.properties.estimate: ...
+    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["eclipsed"]) -> MetaOapg.properties.eclipsed: ...
+    def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetGroup"]) -> MetaOapg.properties.targetGroup: ...
+    def __getitem__(self, name: typing_extensions.Literal["negate"]) -> MetaOapg.properties.negate: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["targetGroup"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["referenceVector"]) -> MetaOapg.properties.referenceVector: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["negate"], typing_extensions.Literal["referenceVector"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["truth"]) -> typing.Union[MetaOapg.properties.truth, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["estimate"]) -> typing.Union[MetaOapg.properties.estimate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["eclipsed"]) -> typing.Union[MetaOapg.properties.eclipsed, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["negate"]) -> typing.Union[MetaOapg.properties.negate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetGroup"]) -> typing.Union[MetaOapg.properties.targetGroup, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["referenceVector"]) -> typing.Union[MetaOapg.properties.referenceVector, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["targetGroup"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["negate"], typing_extensions.Literal["referenceVector"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        truth: typing.Union[MetaOapg.properties.truth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        estimate: typing.Union[MetaOapg.properties.estimate, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        eclipsed: typing.Union[MetaOapg.properties.eclipsed, bool, schemas.Unset] = schemas.unset,
-        targetGroup: typing.Union[MetaOapg.properties.targetGroup, str, schemas.Unset] = schemas.unset,
+        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
+        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
+        fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
+        negate: typing.Union[MetaOapg.properties.negate, bool, schemas.Unset] = schemas.unset,
+        referenceVector: typing.Union[MetaOapg.properties.referenceVector, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TargetGroupVector':
+    ) -> 'VectorInFovCondition':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
-            truth=truth,
-            estimate=estimate,
-            eclipsed=eclipsed,
-            targetGroup=targetGroup,
+            terminator=terminator,
+            compliance=compliance,
+            fieldOfView=fieldOfView,
+            negate=negate,
+            referenceVector=referenceVector,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_in_fov_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_in_fov_condition.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -50,24 +50,24 @@
             
                 class MetaOapg:
                     max_length = 100
             id = schemas.StrSchema
             terminator = schemas.BoolSchema
             compliance = schemas.BoolSchema
             fieldOfView = schemas.StrSchema
-            targetA = schemas.StrSchema
             negate = schemas.BoolSchema
+            targetA = schemas.StrSchema
             __annotations__ = {
                 "name": name,
                 "id": id,
                 "terminator": terminator,
                 "compliance": compliance,
                 "fieldOfView": fieldOfView,
-                "targetA": targetA,
                 "negate": negate,
+                "targetA": targetA,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
@@ -81,20 +81,20 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
+    def __getitem__(self, name: typing_extensions.Literal["negate"]) -> MetaOapg.properties.negate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["negate"]) -> MetaOapg.properties.negate: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["targetA"], typing_extensions.Literal["negate"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["negate"], typing_extensions.Literal["targetA"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
@@ -106,39 +106,39 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["negate"]) -> typing.Union[MetaOapg.properties.negate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["negate"]) -> typing.Union[MetaOapg.properties.negate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["targetA"], typing_extensions.Literal["negate"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["negate"], typing_extensions.Literal["targetA"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
         compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
         fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
-        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
         negate: typing.Union[MetaOapg.properties.negate, bool, schemas.Unset] = schemas.unset,
+        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'TargetInFovCondition':
         return super().__new__(
             cls,
             *_args,
             name=name,
             id=id,
             terminator=terminator,
             compliance=compliance,
             fieldOfView=fieldOfView,
-            targetA=targetA,
             negate=negate,
+            targetA=targetA,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_parameters.py` & `sedaro-4.3.2/src/sedaro_base_client/model/angle_field_of_view30.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,93 +19,70 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetParameters(
-    schemas.EnumBase,
-    schemas.StrSchema
+class AngleFieldOfView30(
+    schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    An enumeration.
     """
 
 
     class MetaOapg:
-        enum_value_to_name = {
-            "SHADOW": "SHADOW",
-            "BETA": "BETA",
-            "MEAN_ANOM": "MEAN_ANOM",
-            "TRUE_ANOM": "TRUE_ANOM",
-            "LAT": "LAT",
-            "LON": "LON",
-            "ALT": "ALT",
-            "LO_SIGHT": "LO_SIGHT",
-            "RANGE": "RANGE",
-            "SOLAR_AZ": "SOLAR_AZ",
-            "SOLAR_EL": "SOLAR_EL",
-            "SAT_AZ": "SAT_AZ",
-            "SAT_EL": "SAT_EL",
-            "LOCAL_SIDEREAL_TIME": "LOCAL_SIDEREAL_TIME",
-        }
-    
-    @schemas.classproperty
-    def SHADOW(cls):
-        return cls("SHADOW")
-    
-    @schemas.classproperty
-    def BETA(cls):
-        return cls("BETA")
-    
-    @schemas.classproperty
-    def MEAN_ANOM(cls):
-        return cls("MEAN_ANOM")
-    
-    @schemas.classproperty
-    def TRUE_ANOM(cls):
-        return cls("TRUE_ANOM")
-    
-    @schemas.classproperty
-    def LAT(cls):
-        return cls("LAT")
-    
-    @schemas.classproperty
-    def LON(cls):
-        return cls("LON")
-    
-    @schemas.classproperty
-    def ALT(cls):
-        return cls("ALT")
-    
-    @schemas.classproperty
-    def LO_SIGHT(cls):
-        return cls("LO_SIGHT")
-    
-    @schemas.classproperty
-    def RANGE(cls):
-        return cls("RANGE")
-    
-    @schemas.classproperty
-    def SOLAR_AZ(cls):
-        return cls("SOLAR_AZ")
-    
-    @schemas.classproperty
-    def SOLAR_EL(cls):
-        return cls("SOLAR_EL")
-    
-    @schemas.classproperty
-    def SAT_AZ(cls):
-        return cls("SAT_AZ")
-    
-    @schemas.classproperty
-    def SAT_EL(cls):
-        return cls("SAT_EL")
-    
-    @schemas.classproperty
-    def LOCAL_SIDEREAL_TIME(cls):
-        return cls("LOCAL_SIDEREAL_TIME")
+        
+        class properties:
+            deg = schemas.NumberSchema
+            
+            
+            class rad(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_maximum = 3.141592653589793
+                    inclusive_minimum = 0.0
+            __annotations__ = {
+                "deg": deg,
+                "rad": rad,
+            }
+        additional_properties = schemas.NotAnyTypeSchema
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["deg"]) -> MetaOapg.properties.deg: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["rad"]) -> MetaOapg.properties.rad: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
+        # dict_instance[name] accessor
+        return super().__getitem__(name)
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["deg"]) -> typing.Union[MetaOapg.properties.deg, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["rad"]) -> typing.Union[MetaOapg.properties.rad, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["deg"], typing_extensions.Literal["rad"], ]):
+        return super().get_item_oapg(name)
+
+    def __new__(
+        cls,
+        *_args: typing.Union[dict, frozendict.frozendict, ],
+        deg: typing.Union[MetaOapg.properties.deg, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        rad: typing.Union[MetaOapg.properties.rad, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        _configuration: typing.Optional[schemas.Configuration] = None,
+    ) -> 'AngleFieldOfView30':
+        return super().__new__(
+            cls,
+            *_args,
+            deg=deg,
+            rad=rad,
+            _configuration=_configuration,
+        )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_to_scalar_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_res.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,215 +19,228 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetToScalarCondition(
+class BranchRes(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "scalar",
+            "dateCreated",
+            "data",
             "name",
-            "targetParam",
-            "relationship",
+            "dateModified",
+            "id",
+            "repository",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
+                    max_length = 32
+            id = schemas.IntSchema
+            dateCreated = schemas.DateTimeSchema
+            dateModified = schemas.DateTimeSchema
             
             
-            class relationship(
+            class repository(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.DictSchema
+                    any_of_1 = schemas.IntSchema
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ConditionRelationship,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'relationship':
+                ) -> 'repository':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            scalar = schemas.AnyTypeSchema
             
             
-            class targetParam(
+            class data(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TargetParameters,
+                            VehicleTemplateRes,
+                            ScenarioTemplateRes,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'targetParam':
+                ) -> 'data':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            id = schemas.StrSchema
-            terminator = schemas.BoolSchema
-            compliance = schemas.BoolSchema
-            targetA = schemas.StrSchema
+            
+            
+            class description(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 300
             __annotations__ = {
                 "name": name,
-                "relationship": relationship,
-                "scalar": scalar,
-                "targetParam": targetParam,
                 "id": id,
-                "terminator": terminator,
-                "compliance": compliance,
-                "targetA": targetA,
+                "dateCreated": dateCreated,
+                "dateModified": dateModified,
+                "repository": repository,
+                "data": data,
+                "description": description,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    scalar: MetaOapg.properties.scalar
+    dateCreated: MetaOapg.properties.dateCreated
+    data: MetaOapg.properties.data
     name: MetaOapg.properties.name
-    targetParam: MetaOapg.properties.targetParam
-    relationship: MetaOapg.properties.relationship
+    dateModified: MetaOapg.properties.dateModified
+    id: MetaOapg.properties.id
+    repository: MetaOapg.properties.repository
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
+    def __getitem__(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def __getitem__(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
+    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "data", "description", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetParam"]) -> MetaOapg.properties.targetParam: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["targetParam"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "data", "description", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        scalar: typing.Union[MetaOapg.properties.scalar, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        dateCreated: typing.Union[MetaOapg.properties.dateCreated, str, datetime, ],
+        data: typing.Union[MetaOapg.properties.data, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        targetParam: typing.Union[MetaOapg.properties.targetParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
-        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
-        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
+        dateModified: typing.Union[MetaOapg.properties.dateModified, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, ],
+        repository: typing.Union[MetaOapg.properties.repository, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TargetToScalarCondition':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'BranchRes':
         return super().__new__(
             cls,
             *_args,
-            scalar=scalar,
+            dateCreated=dateCreated,
+            data=data,
             name=name,
-            targetParam=targetParam,
-            relationship=relationship,
+            dateModified=dateModified,
             id=id,
-            terminator=terminator,
-            compliance=compliance,
-            targetA=targetA,
+            repository=repository,
+            description=description,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from sedaro_base_client.model.condition_relationship import ConditionRelationship
-from sedaro_base_client.model.target_parameters import TargetParameters
+from sedaro_base_client.model.scenario_template_res import ScenarioTemplateRes
+from sedaro_base_client.model.vehicle_template_res import VehicleTemplateRes
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_to_target_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/subsystem.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,47 +19,45 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetToTargetCondition(
+class Subsystem(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "targetAParam",
             "name",
-            "relationship",
-            "targetBParam",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
+            id = schemas.StrSchema
             
             
-            class relationship(
+            class category(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -69,69 +67,56 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ConditionRelationship,
+                            Categories,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'relationship':
+                ) -> 'category':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
-            class targetAParam(
-                schemas.ComposedSchema,
+            class components(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            TargetParameters,
-                        ]
-            
+                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'targetAParam':
+                ) -> 'components':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
             
-            class targetBParam(
+            class dissipations(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -141,138 +126,94 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TargetParameters,
+                            BaseDissipations,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'targetBParam':
+                ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            id = schemas.StrSchema
-            terminator = schemas.BoolSchema
-            compliance = schemas.BoolSchema
-            targetA = schemas.StrSchema
-            targetB = schemas.StrSchema
             __annotations__ = {
                 "name": name,
-                "relationship": relationship,
-                "targetAParam": targetAParam,
-                "targetBParam": targetBParam,
                 "id": id,
-                "terminator": terminator,
-                "compliance": compliance,
-                "targetA": targetA,
-                "targetB": targetB,
+                "category": category,
+                "components": components,
+                "dissipations": dissipations,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    targetAParam: MetaOapg.properties.targetAParam
     name: MetaOapg.properties.name
-    relationship: MetaOapg.properties.relationship
-    targetBParam: MetaOapg.properties.targetBParam
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetAParam"]) -> MetaOapg.properties.targetAParam: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetBParam"]) -> MetaOapg.properties.targetBParam: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
+    def __getitem__(self, name: typing_extensions.Literal["category"]) -> MetaOapg.properties.category: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["components"]) -> MetaOapg.properties.components: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetA"]) -> MetaOapg.properties.targetA: ...
+    def __getitem__(self, name: typing_extensions.Literal["dissipations"]) -> MetaOapg.properties.dissipations: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["targetB"]) -> MetaOapg.properties.targetB: ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["targetAParam"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["targetBParam"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], typing_extensions.Literal["targetB"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["category"], typing_extensions.Literal["components"], typing_extensions.Literal["dissipations"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetAParam"]) -> MetaOapg.properties.targetAParam: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetBParam"]) -> MetaOapg.properties.targetBParam: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["category"]) -> typing.Union[MetaOapg.properties.category, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetA"]) -> typing.Union[MetaOapg.properties.targetA, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["components"]) -> typing.Union[MetaOapg.properties.components, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["targetB"]) -> typing.Union[MetaOapg.properties.targetB, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dissipations"]) -> typing.Union[MetaOapg.properties.dissipations, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["targetAParam"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["targetBParam"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["targetA"], typing_extensions.Literal["targetB"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["category"], typing_extensions.Literal["components"], typing_extensions.Literal["dissipations"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        targetAParam: typing.Union[MetaOapg.properties.targetAParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        targetBParam: typing.Union[MetaOapg.properties.targetBParam, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
-        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
-        targetA: typing.Union[MetaOapg.properties.targetA, str, schemas.Unset] = schemas.unset,
-        targetB: typing.Union[MetaOapg.properties.targetB, str, schemas.Unset] = schemas.unset,
+        category: typing.Union[MetaOapg.properties.category, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        components: typing.Union[MetaOapg.properties.components, list, tuple, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TargetToTargetCondition':
+    ) -> 'Subsystem':
         return super().__new__(
             cls,
             *_args,
-            targetAParam=targetAParam,
             name=name,
-            relationship=relationship,
-            targetBParam=targetBParam,
             id=id,
-            terminator=terminator,
-            compliance=compliance,
-            targetA=targetA,
-            targetB=targetB,
+            category=category,
+            components=components,
+            dissipations=dissipations,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.condition_relationship import ConditionRelationship
-from sedaro_base_client.model.target_parameters import TargetParameters
+from sedaro_base_client.model.base_dissipations import BaseDissipations
+from sedaro_base_client.model.categories import Categories
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/target_vector.py` & `sedaro-4.3.2/src/sedaro_base_client/model/clock_config.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,108 +19,100 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TargetVector(
+class ClockConfig(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "name",
+            "startTime",
+            "stopTime",
         }
         
         class properties:
-            name = schemas.StrSchema
+            startTime = schemas.NumberSchema
+            stopTime = schemas.NumberSchema
             id = schemas.StrSchema
-            truth = schemas.AnyTypeSchema
-            estimate = schemas.AnyTypeSchema
-            eclipsed = schemas.BoolSchema
-            referenceTarget = schemas.StrSchema
+            realTime = schemas.BoolSchema
+            syncTime = schemas.BoolSchema
             __annotations__ = {
-                "name": name,
+                "startTime": startTime,
+                "stopTime": stopTime,
                 "id": id,
-                "truth": truth,
-                "estimate": estimate,
-                "eclipsed": eclipsed,
-                "referenceTarget": referenceTarget,
+                "realTime": realTime,
+                "syncTime": syncTime,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    name: MetaOapg.properties.name
+    startTime: MetaOapg.properties.startTime
+    stopTime: MetaOapg.properties.stopTime
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["startTime"]) -> MetaOapg.properties.startTime: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["truth"]) -> MetaOapg.properties.truth: ...
+    def __getitem__(self, name: typing_extensions.Literal["stopTime"]) -> MetaOapg.properties.stopTime: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["estimate"]) -> MetaOapg.properties.estimate: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["eclipsed"]) -> MetaOapg.properties.eclipsed: ...
+    def __getitem__(self, name: typing_extensions.Literal["realTime"]) -> MetaOapg.properties.realTime: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["referenceTarget"]) -> MetaOapg.properties.referenceTarget: ...
+    def __getitem__(self, name: typing_extensions.Literal["syncTime"]) -> MetaOapg.properties.syncTime: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["referenceTarget"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["startTime"], typing_extensions.Literal["stopTime"], typing_extensions.Literal["id"], typing_extensions.Literal["realTime"], typing_extensions.Literal["syncTime"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["startTime"]) -> MetaOapg.properties.startTime: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["truth"]) -> typing.Union[MetaOapg.properties.truth, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["stopTime"]) -> MetaOapg.properties.stopTime: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["estimate"]) -> typing.Union[MetaOapg.properties.estimate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["eclipsed"]) -> typing.Union[MetaOapg.properties.eclipsed, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["realTime"]) -> typing.Union[MetaOapg.properties.realTime, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["referenceTarget"]) -> typing.Union[MetaOapg.properties.referenceTarget, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["syncTime"]) -> typing.Union[MetaOapg.properties.syncTime, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["referenceTarget"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["startTime"], typing_extensions.Literal["stopTime"], typing_extensions.Literal["id"], typing_extensions.Literal["realTime"], typing_extensions.Literal["syncTime"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
+        startTime: typing.Union[MetaOapg.properties.startTime, decimal.Decimal, int, float, ],
+        stopTime: typing.Union[MetaOapg.properties.stopTime, decimal.Decimal, int, float, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        truth: typing.Union[MetaOapg.properties.truth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        estimate: typing.Union[MetaOapg.properties.estimate, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        eclipsed: typing.Union[MetaOapg.properties.eclipsed, bool, schemas.Unset] = schemas.unset,
-        referenceTarget: typing.Union[MetaOapg.properties.referenceTarget, str, schemas.Unset] = schemas.unset,
+        realTime: typing.Union[MetaOapg.properties.realTime, bool, schemas.Unset] = schemas.unset,
+        syncTime: typing.Union[MetaOapg.properties.syncTime, bool, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TargetVector':
+    ) -> 'ClockConfig':
         return super().__new__(
             cls,
             *_args,
-            name=name,
+            startTime=startTime,
+            stopTime=stopTime,
             id=id,
-            truth=truth,
-            estimate=estimate,
-            eclipsed=eclipsed,
-            referenceTarget=referenceTarget,
+            realTime=realTime,
+            syncTime=syncTime,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/temp_controller_state.py` & `sedaro-4.3.2/src/sedaro_base_client/model/target_group_vector.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,45 +19,37 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TempControllerState(
+class TargetGroupVector(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "constantTemperature",
             "name",
         }
         
         class properties:
+            name = schemas.StrSchema
+            id = schemas.StrSchema
             
             
-            class name(
-                schemas.StrSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_length = 100
-            
-            
-            class constantTemperature(
+            class truth(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -67,129 +59,140 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'constantTemperature':
+                ) -> 'truth':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            id = schemas.StrSchema
-            tempController = schemas.StrSchema
             
             
-            class operationalModes(
-                schemas.ListSchema
+            class estimate(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            FrameVectorBase306,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'operationalModes':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'estimate':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            active = schemas.BoolSchema
+            eclipsed = schemas.BoolSchema
+            targetGroup = schemas.StrSchema
             __annotations__ = {
                 "name": name,
-                "constantTemperature": constantTemperature,
                 "id": id,
-                "tempController": tempController,
-                "operationalModes": operationalModes,
-                "active": active,
+                "truth": truth,
+                "estimate": estimate,
+                "eclipsed": eclipsed,
+                "targetGroup": targetGroup,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    constantTemperature: MetaOapg.properties.constantTemperature
     name: MetaOapg.properties.name
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["constantTemperature"]) -> MetaOapg.properties.constantTemperature: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["tempController"]) -> MetaOapg.properties.tempController: ...
+    def __getitem__(self, name: typing_extensions.Literal["truth"]) -> MetaOapg.properties.truth: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["estimate"]) -> MetaOapg.properties.estimate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["operationalModes"]) -> MetaOapg.properties.operationalModes: ...
+    def __getitem__(self, name: typing_extensions.Literal["eclipsed"]) -> MetaOapg.properties.eclipsed: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
+    def __getitem__(self, name: typing_extensions.Literal["targetGroup"]) -> MetaOapg.properties.targetGroup: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["constantTemperature"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["tempController"], typing_extensions.Literal["operationalModes"], typing_extensions.Literal["active"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["targetGroup"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["constantTemperature"]) -> MetaOapg.properties.constantTemperature: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["tempController"]) -> typing.Union[MetaOapg.properties.tempController, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["truth"]) -> typing.Union[MetaOapg.properties.truth, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["estimate"]) -> typing.Union[MetaOapg.properties.estimate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["operationalModes"]) -> typing.Union[MetaOapg.properties.operationalModes, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["eclipsed"]) -> typing.Union[MetaOapg.properties.eclipsed, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["active"]) -> typing.Union[MetaOapg.properties.active, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["targetGroup"]) -> typing.Union[MetaOapg.properties.targetGroup, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["constantTemperature"], typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["tempController"], typing_extensions.Literal["operationalModes"], typing_extensions.Literal["active"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["truth"], typing_extensions.Literal["estimate"], typing_extensions.Literal["eclipsed"], typing_extensions.Literal["targetGroup"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        constantTemperature: typing.Union[MetaOapg.properties.constantTemperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        tempController: typing.Union[MetaOapg.properties.tempController, str, schemas.Unset] = schemas.unset,
-        operationalModes: typing.Union[MetaOapg.properties.operationalModes, list, tuple, schemas.Unset] = schemas.unset,
-        active: typing.Union[MetaOapg.properties.active, bool, schemas.Unset] = schemas.unset,
+        truth: typing.Union[MetaOapg.properties.truth, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        estimate: typing.Union[MetaOapg.properties.estimate, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        eclipsed: typing.Union[MetaOapg.properties.eclipsed, bool, schemas.Unset] = schemas.unset,
+        targetGroup: typing.Union[MetaOapg.properties.targetGroup, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TempControllerState':
+    ) -> 'TargetGroupVector':
         return super().__new__(
             cls,
             *_args,
-            constantTemperature=constantTemperature,
             name=name,
             id=id,
-            tempController=tempController,
-            operationalModes=operationalModes,
-            active=active,
+            truth=truth,
+            estimate=estimate,
+            eclipsed=eclipsed,
+            targetGroup=targetGroup,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/temperature_base299.py` & `sedaro-4.3.2/src/sedaro_base_client/model/data_type.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,79 +19,76 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TemperatureBase299(
+class DataType(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
+
+    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
+        required = {
+            "name",
+        }
         
         class properties:
-            degC = schemas.NumberSchema
-            degF = schemas.NumberSchema
             
             
-            class degK(
-                schemas.NumberSchema
+            class name(
+                schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0.0
+                    max_length = 100
+            id = schemas.StrSchema
             __annotations__ = {
-                "degC": degC,
-                "degF": degF,
-                "degK": degK,
+                "name": name,
+                "id": id,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["degC"]) -> MetaOapg.properties.degC: ...
+    name: MetaOapg.properties.name
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["degF"]) -> MetaOapg.properties.degF: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["degK"]) -> MetaOapg.properties.degK: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["degC"], typing_extensions.Literal["degF"], typing_extensions.Literal["degK"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["degC"]) -> typing.Union[MetaOapg.properties.degC, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["degF"]) -> typing.Union[MetaOapg.properties.degF, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["degK"]) -> typing.Union[MetaOapg.properties.degK, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["degC"], typing_extensions.Literal["degF"], typing_extensions.Literal["degK"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        degC: typing.Union[MetaOapg.properties.degC, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        degF: typing.Union[MetaOapg.properties.degF, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        degK: typing.Union[MetaOapg.properties.degK, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TemperatureBase299':
+    ) -> 'DataType':
         return super().__new__(
             cls,
             *_args,
-            degC=degC,
-            degF=degF,
-            degK=degK,
+            name=name,
+            id=id,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/template_crud_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/template_crud_res.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/thermal_interface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/thermal_interface.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -144,15 +144,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -180,15 +180,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -396,8 +396,8 @@
             coldTemp=coldTemp,
             hotMargin=hotMargin,
             coldMargin=coldMargin,
             _configuration=_configuration,
         )
 
 from sedaro_base_client.model.side_categories import SideCategories
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/thermal_interface_material.py` & `sedaro-4.3.2/src/sedaro_base_client/model/repo_res.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,232 +19,190 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ThermalInterfaceMaterial(
+class RepoRes(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "hotTempRating",
-            "thickness",
+            "workspace",
+            "dateCreated",
+            "dataType",
             "name",
-            "coldTempRating",
-            "resistivity",
+            "dateModified",
+            "id",
+            "branches",
         }
         
         class properties:
+            id = schemas.IntSchema
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            resistivity = schemas.NumberSchema
-            thickness = schemas.NumberSchema
+                    max_length = 64
+            workspace = schemas.DictSchema
+            dataType = schemas.StrSchema
+            dateCreated = schemas.DateTimeSchema
+            dateModified = schemas.DateTimeSchema
             
             
-            class hotTempRating(
-                schemas.ComposedSchema,
+            class branches(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            TemperatureBase299,
-                        ]
-            
+                    @staticmethod
+                    def items() -> typing.Type['BranchRes']:
+                        return BranchRes
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple['BranchRes'], typing.List['BranchRes']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'hotTempRating':
+                ) -> 'branches':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
-            
-            class coldTempRating(
-                schemas.ComposedSchema,
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            TemperatureBase299,
-                        ]
-            
-            
-                def __new__(
-                    cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'coldTempRating':
-                    return super().__new__(
-                        cls,
-                        *_args,
-                        _configuration=_configuration,
-                        **kwargs,
-                    )
-            id = schemas.StrSchema
-            
-            
-            class partNumber(
-                schemas.StrSchema
-            ):
-            
-            
-                class MetaOapg:
-                    max_length = 32
+                def __getitem__(self, i: int) -> 'BranchRes':
+                    return super().__getitem__(i)
             
             
-            class manufacturer(
+            class description(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 32
+                    max_length = 1000
             __annotations__ = {
-                "name": name,
-                "resistivity": resistivity,
-                "thickness": thickness,
-                "hotTempRating": hotTempRating,
-                "coldTempRating": coldTempRating,
                 "id": id,
-                "partNumber": partNumber,
-                "manufacturer": manufacturer,
+                "name": name,
+                "workspace": workspace,
+                "dataType": dataType,
+                "dateCreated": dateCreated,
+                "dateModified": dateModified,
+                "branches": branches,
+                "description": description,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    hotTempRating: MetaOapg.properties.hotTempRating
-    thickness: MetaOapg.properties.thickness
+    workspace: MetaOapg.properties.workspace
+    dateCreated: MetaOapg.properties.dateCreated
+    dataType: MetaOapg.properties.dataType
     name: MetaOapg.properties.name
-    coldTempRating: MetaOapg.properties.coldTempRating
-    resistivity: MetaOapg.properties.resistivity
+    dateModified: MetaOapg.properties.dateModified
+    id: MetaOapg.properties.id
+    branches: MetaOapg.properties.branches
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["hotTempRating"]) -> MetaOapg.properties.hotTempRating: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["thickness"]) -> MetaOapg.properties.thickness: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["workspace"]) -> MetaOapg.properties.workspace: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["coldTempRating"]) -> MetaOapg.properties.coldTempRating: ...
+    def __getitem__(self, name: typing_extensions.Literal["dataType"]) -> MetaOapg.properties.dataType: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["resistivity"]) -> MetaOapg.properties.resistivity: ...
+    def __getitem__(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["branches"]) -> MetaOapg.properties.branches: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["partNumber"]) -> MetaOapg.properties.partNumber: ...
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["manufacturer"]) -> MetaOapg.properties.manufacturer: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["thickness"], typing_extensions.Literal["name"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["resistivity"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "name", "workspace", "dataType", "dateCreated", "dateModified", "branches", "description", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["hotTempRating"]) -> MetaOapg.properties.hotTempRating: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["thickness"]) -> MetaOapg.properties.thickness: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["coldTempRating"]) -> MetaOapg.properties.coldTempRating: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["workspace"]) -> MetaOapg.properties.workspace: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["resistivity"]) -> MetaOapg.properties.resistivity: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dataType"]) -> MetaOapg.properties.dataType: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["partNumber"]) -> typing.Union[MetaOapg.properties.partNumber, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["manufacturer"]) -> typing.Union[MetaOapg.properties.manufacturer, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["branches"]) -> MetaOapg.properties.branches: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["thickness"], typing_extensions.Literal["name"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["resistivity"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "name", "workspace", "dataType", "dateCreated", "dateModified", "branches", "description", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        hotTempRating: typing.Union[MetaOapg.properties.hotTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        thickness: typing.Union[MetaOapg.properties.thickness, decimal.Decimal, int, float, ],
+        workspace: typing.Union[MetaOapg.properties.workspace, dict, frozendict.frozendict, ],
+        dateCreated: typing.Union[MetaOapg.properties.dateCreated, str, datetime, ],
+        dataType: typing.Union[MetaOapg.properties.dataType, str, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        coldTempRating: typing.Union[MetaOapg.properties.coldTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        resistivity: typing.Union[MetaOapg.properties.resistivity, decimal.Decimal, int, float, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        partNumber: typing.Union[MetaOapg.properties.partNumber, str, schemas.Unset] = schemas.unset,
-        manufacturer: typing.Union[MetaOapg.properties.manufacturer, str, schemas.Unset] = schemas.unset,
+        dateModified: typing.Union[MetaOapg.properties.dateModified, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, ],
+        branches: typing.Union[MetaOapg.properties.branches, list, tuple, ],
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ThermalInterfaceMaterial':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'RepoRes':
         return super().__new__(
             cls,
             *_args,
-            hotTempRating=hotTempRating,
-            thickness=thickness,
+            workspace=workspace,
+            dateCreated=dateCreated,
+            dataType=dataType,
             name=name,
-            coldTempRating=coldTempRating,
-            resistivity=resistivity,
+            dateModified=dateModified,
             id=id,
-            partNumber=partNumber,
-            manufacturer=manufacturer,
+            branches=branches,
+            description=description,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.branch_res import BranchRes
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/thruster.py` & `sedaro-4.3.2/src/sedaro_base_client/model/thruster.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -123,15 +123,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -159,15 +159,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -291,41 +291,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -347,15 +346,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -374,58 +373,86 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             busRegulator = schemas.StrSchema
             powerProcessor = schemas.StrSchema
             isFail = schemas.BoolSchema
             orientation = schemas.StrSchema
             fuelReservoir = schemas.StrSchema
             
             
@@ -695,21 +722,21 @@
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         busRegulator: typing.Union[MetaOapg.properties.busRegulator, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
         isFail: typing.Union[MetaOapg.properties.isFail, bool, schemas.Unset] = schemas.unset,
         orientation: typing.Union[MetaOapg.properties.orientation, str, schemas.Unset] = schemas.unset,
         fuelReservoir: typing.Union[MetaOapg.properties.fuelReservoir, str, schemas.Unset] = schemas.unset,
         thrust: typing.Union[MetaOapg.properties.thrust, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
@@ -748,8 +775,9 @@
             isFail=isFail,
             orientation=orientation,
             fuelReservoir=fuelReservoir,
             thrust=thrust,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/time_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_changes_res.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,157 +19,152 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TimeCondition(
+class BranchChangesRes(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "scalar",
-            "name",
-            "relationship",
+            "committed",
+            "edited",
         }
         
         class properties:
             
             
-            class name(
-                schemas.StrSchema
+            class edited(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def any_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            VehicleTemplate,
+                            ScenarioTemplate,
+                        ]
             
             
-            class relationship(
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'edited':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
+            
+            
+            class committed(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ConditionRelationship,
+                            VehicleTemplate,
+                            ScenarioTemplate,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'relationship':
+                ) -> 'committed':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            scalar = schemas.AnyTypeSchema
-            id = schemas.StrSchema
-            terminator = schemas.BoolSchema
-            compliance = schemas.BoolSchema
             __annotations__ = {
-                "name": name,
-                "relationship": relationship,
-                "scalar": scalar,
-                "id": id,
-                "terminator": terminator,
-                "compliance": compliance,
+                "edited": edited,
+                "committed": committed,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    scalar: MetaOapg.properties.scalar
-    name: MetaOapg.properties.name
-    relationship: MetaOapg.properties.relationship
+    committed: MetaOapg.properties.committed
+    edited: MetaOapg.properties.edited
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
+    def __getitem__(self, name: typing_extensions.Literal["edited"]) -> MetaOapg.properties.edited: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def __getitem__(self, name: typing_extensions.Literal["committed"]) -> MetaOapg.properties.committed: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["edited", "committed", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["scalar"]) -> MetaOapg.properties.scalar: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["edited"]) -> MetaOapg.properties.edited: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["relationship"]) -> MetaOapg.properties.relationship: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["committed"]) -> MetaOapg.properties.committed: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
-    
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["scalar"], typing_extensions.Literal["name"], typing_extensions.Literal["relationship"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["edited", "committed", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        scalar: typing.Union[MetaOapg.properties.scalar, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
-        relationship: typing.Union[MetaOapg.properties.relationship, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
-        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
+        committed: typing.Union[MetaOapg.properties.committed, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        edited: typing.Union[MetaOapg.properties.edited, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TimeCondition':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'BranchChangesRes':
         return super().__new__(
             cls,
             *_args,
-            scalar=scalar,
-            name=name,
-            relationship=relationship,
-            id=id,
-            terminator=terminator,
-            compliance=compliance,
+            committed=committed,
+            edited=edited,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from sedaro_base_client.model.condition_relationship import ConditionRelationship
+from sedaro_base_client.model.scenario_template import ScenarioTemplate
+from sedaro_base_client.model.vehicle_template import VehicleTemplate
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/tle.py` & `sedaro-4.3.2/src/sedaro_base_client/model/repo_import_req.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,65 +19,77 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class Tle(
+class RepoImportReq(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
-            "tle",
+            "workspace",
+            "file",
         }
         
         class properties:
-            tle = schemas.StrSchema
+            workspace = schemas.StrSchema
+            file = schemas.BinarySchema
             __annotations__ = {
-                "tle": tle,
+                "workspace": workspace,
+                "file": file,
             }
     
-    tle: MetaOapg.properties.tle
+    workspace: MetaOapg.properties.workspace
+    file: MetaOapg.properties.file
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["tle"]) -> MetaOapg.properties.tle: ...
+    def __getitem__(self, name: typing_extensions.Literal["workspace"]) -> MetaOapg.properties.workspace: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["file"]) -> MetaOapg.properties.file: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["tle", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["workspace", "file", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["tle"]) -> MetaOapg.properties.tle: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["workspace"]) -> MetaOapg.properties.workspace: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["file"]) -> MetaOapg.properties.file: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["tle", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["workspace", "file", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        tle: typing.Union[MetaOapg.properties.tle, str, ],
+        workspace: typing.Union[MetaOapg.properties.workspace, str, ],
+        file: typing.Union[MetaOapg.properties.file, bytes, io.FileIO, io.BufferedReader, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'Tle':
+    ) -> 'RepoImportReq':
         return super().__new__(
             cls,
             *_args,
-            tle=tle,
+            workspace=workspace,
+            file=file,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/triad_algorithm.py` & `sedaro-4.3.2/src/sedaro_base_client/model/position_base306.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,214 +19,245 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TriadAlgorithm(
+class PositionBase306(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
-        required = {
-            "name",
-        }
         
         class properties:
             
             
-            class name(
-                schemas.StrSchema
+            class llaDeg(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_items = 3
+                    min_items = 3
+                    items = schemas.NumberSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'llaDeg':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class eci(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            id = schemas.StrSchema
-            rate = schemas.NumberSchema
+                    max_items = 3
+                    min_items = 3
+                    items = schemas.NumberSchema
             
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'eci':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
             
-            class attitudeSolution(
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class gcLla(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
+                    max_items = 3
+                    min_items = 3
                     items = schemas.NumberSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'attitudeSolution':
+                ) -> 'gcLla':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class angularVelocitySolution(
+            class gcLlaDeg(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
+                    max_items = 3
+                    min_items = 3
                     items = schemas.NumberSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'angularVelocitySolution':
+                ) -> 'gcLlaDeg':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class vectorSensors(
+            class ecef(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    max_items = 3
+                    min_items = 3
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'vectorSensors':
+                ) -> 'ecef':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
-            class angularVelocitySensors(
+            class lla(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    max_items = 3
+                    min_items = 3
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'angularVelocitySensors':
+                ) -> 'lla':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             __annotations__ = {
-                "name": name,
-                "id": id,
-                "rate": rate,
-                "attitudeSolution": attitudeSolution,
-                "angularVelocitySolution": angularVelocitySolution,
-                "vectorSensors": vectorSensors,
-                "angularVelocitySensors": angularVelocitySensors,
+                "llaDeg": llaDeg,
+                "eci": eci,
+                "gcLla": gcLla,
+                "gcLlaDeg": gcLlaDeg,
+                "ecef": ecef,
+                "lla": lla,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    name: MetaOapg.properties.name
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["llaDeg"]) -> MetaOapg.properties.llaDeg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["rate"]) -> MetaOapg.properties.rate: ...
+    def __getitem__(self, name: typing_extensions.Literal["eci"]) -> MetaOapg.properties.eci: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["attitudeSolution"]) -> MetaOapg.properties.attitudeSolution: ...
+    def __getitem__(self, name: typing_extensions.Literal["gcLla"]) -> MetaOapg.properties.gcLla: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["angularVelocitySolution"]) -> MetaOapg.properties.angularVelocitySolution: ...
+    def __getitem__(self, name: typing_extensions.Literal["gcLlaDeg"]) -> MetaOapg.properties.gcLlaDeg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["vectorSensors"]) -> MetaOapg.properties.vectorSensors: ...
+    def __getitem__(self, name: typing_extensions.Literal["ecef"]) -> MetaOapg.properties.ecef: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> MetaOapg.properties.angularVelocitySensors: ...
+    def __getitem__(self, name: typing_extensions.Literal["lla"]) -> MetaOapg.properties.lla: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["vectorSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["llaDeg"], typing_extensions.Literal["eci"], typing_extensions.Literal["gcLla"], typing_extensions.Literal["gcLlaDeg"], typing_extensions.Literal["ecef"], typing_extensions.Literal["lla"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["llaDeg"]) -> typing.Union[MetaOapg.properties.llaDeg, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["rate"]) -> typing.Union[MetaOapg.properties.rate, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["eci"]) -> typing.Union[MetaOapg.properties.eci, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["attitudeSolution"]) -> typing.Union[MetaOapg.properties.attitudeSolution, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["gcLla"]) -> typing.Union[MetaOapg.properties.gcLla, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["angularVelocitySolution"]) -> typing.Union[MetaOapg.properties.angularVelocitySolution, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["gcLlaDeg"]) -> typing.Union[MetaOapg.properties.gcLlaDeg, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["vectorSensors"]) -> typing.Union[MetaOapg.properties.vectorSensors, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["ecef"]) -> typing.Union[MetaOapg.properties.ecef, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["angularVelocitySensors"]) -> typing.Union[MetaOapg.properties.angularVelocitySensors, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["lla"]) -> typing.Union[MetaOapg.properties.lla, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["rate"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["vectorSensors"], typing_extensions.Literal["angularVelocitySensors"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["llaDeg"], typing_extensions.Literal["eci"], typing_extensions.Literal["gcLla"], typing_extensions.Literal["gcLlaDeg"], typing_extensions.Literal["ecef"], typing_extensions.Literal["lla"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        rate: typing.Union[MetaOapg.properties.rate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, list, tuple, schemas.Unset] = schemas.unset,
-        angularVelocitySolution: typing.Union[MetaOapg.properties.angularVelocitySolution, list, tuple, schemas.Unset] = schemas.unset,
-        vectorSensors: typing.Union[MetaOapg.properties.vectorSensors, list, tuple, schemas.Unset] = schemas.unset,
-        angularVelocitySensors: typing.Union[MetaOapg.properties.angularVelocitySensors, list, tuple, schemas.Unset] = schemas.unset,
+        llaDeg: typing.Union[MetaOapg.properties.llaDeg, list, tuple, schemas.Unset] = schemas.unset,
+        eci: typing.Union[MetaOapg.properties.eci, list, tuple, schemas.Unset] = schemas.unset,
+        gcLla: typing.Union[MetaOapg.properties.gcLla, list, tuple, schemas.Unset] = schemas.unset,
+        gcLlaDeg: typing.Union[MetaOapg.properties.gcLlaDeg, list, tuple, schemas.Unset] = schemas.unset,
+        ecef: typing.Union[MetaOapg.properties.ecef, list, tuple, schemas.Unset] = schemas.unset,
+        lla: typing.Union[MetaOapg.properties.lla, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TriadAlgorithm':
+    ) -> 'PositionBase306':
         return super().__new__(
             cls,
             *_args,
-            name=name,
-            id=id,
-            rate=rate,
-            attitudeSolution=attitudeSolution,
-            angularVelocitySolution=angularVelocitySolution,
-            vectorSensors=vectorSensors,
-            angularVelocitySensors=angularVelocitySensors,
+            llaDeg=llaDeg,
+            eci=eci,
+            gcLla=gcLla,
+            gcLlaDeg=gcLlaDeg,
+            ecef=ecef,
+            lla=lla,
             _configuration=_configuration,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/two_conv_mppt_power_processor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/vector_sensor.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,44 +19,52 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class TwoConvMpptPowerProcessor(
+class VectorSensor(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
             "name",
+            "oneSigmaPerAxisError",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
+            
+            
+            class oneSigmaPerAxisError(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
             id = schemas.StrSchema
-            availableSolarRootPower = schemas.NumberSchema
-            solarRootPower = schemas.NumberSchema
             
             
             class partNumber(
                 schemas.StrSchema
             ):
             
             
@@ -87,15 +95,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -123,15 +131,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -255,41 +263,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ComponentDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -311,15 +318,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -338,196 +345,138 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_minimum = 0
-            
-            
-            class topologyParams(
-                schemas.ComposedSchema,
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def any_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            FullyRegDetTopologyParams,
-                            SingleConvHybridTopologyParams,
-                            QuasiRegDetTopologyParams,
-                            TwoConvMpptTopologyParams,
-                            SingleConvMpptTopologyParams,
-                        ]
-            
-            
-                def __new__(
-                    cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'topologyParams':
-                    return super().__new__(
-                        cls,
-                        *_args,
-                        _configuration=_configuration,
-                        **kwargs,
-                    )
-            
-            
-            class loads(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'loads':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
-            
-            class dynamicallyLoadedComponents(
-                schemas.ListSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'dynamicallyLoadedComponents':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            battery = schemas.StrSchema
+                    inclusive_minimum = 0.0
             
             
-            class busRegulators(
+            class conditions(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'busRegulators':
+                ) -> 'conditions':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
+            fieldOfView = schemas.StrSchema
+            referenceVector = schemas.StrSchema
             
             
-            class solarArrays(
+            class measurement(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.AnyTypeSchema
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'solarArrays':
+                ) -> 'measurement':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             __annotations__ = {
                 "name": name,
+                "oneSigmaPerAxisError": oneSigmaPerAxisError,
                 "id": id,
-                "availableSolarRootPower": availableSolarRootPower,
-                "solarRootPower": solarRootPower,
                 "partNumber": partNumber,
                 "manufacturer": manufacturer,
                 "hotTempRating": hotTempRating,
                 "coldTempRating": coldTempRating,
                 "thermalCapacitance": thermalCapacitance,
                 "cotsTemplate": cotsTemplate,
                 "subsystem": subsystem,
@@ -540,36 +489,32 @@
                 "dissipations": dissipations,
                 "hotMargin": hotMargin,
                 "coldMargin": coldMargin,
                 "temperature": temperature,
                 "storage": storage,
                 "readRate": readRate,
                 "writeRate": writeRate,
-                "topologyParams": topologyParams,
-                "loads": loads,
-                "dynamicallyLoadedComponents": dynamicallyLoadedComponents,
-                "battery": battery,
-                "busRegulators": busRegulators,
-                "solarArrays": solarArrays,
+                "conditions": conditions,
+                "fieldOfView": fieldOfView,
+                "referenceVector": referenceVector,
+                "measurement": measurement,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
+    oneSigmaPerAxisError: MetaOapg.properties.oneSigmaPerAxisError
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["availableSolarRootPower"]) -> MetaOapg.properties.availableSolarRootPower: ...
+    def __getitem__(self, name: typing_extensions.Literal["oneSigmaPerAxisError"]) -> MetaOapg.properties.oneSigmaPerAxisError: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["solarRootPower"]) -> MetaOapg.properties.solarRootPower: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["partNumber"]) -> MetaOapg.properties.partNumber: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["manufacturer"]) -> MetaOapg.properties.manufacturer: ...
     
@@ -624,46 +569,37 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["readRate"]) -> MetaOapg.properties.readRate: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["writeRate"]) -> MetaOapg.properties.writeRate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["topologyParams"]) -> MetaOapg.properties.topologyParams: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["loads"]) -> MetaOapg.properties.loads: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> MetaOapg.properties.dynamicallyLoadedComponents: ...
+    def __getitem__(self, name: typing_extensions.Literal["conditions"]) -> MetaOapg.properties.conditions: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["battery"]) -> MetaOapg.properties.battery: ...
+    def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["busRegulators"]) -> MetaOapg.properties.busRegulators: ...
+    def __getitem__(self, name: typing_extensions.Literal["referenceVector"]) -> MetaOapg.properties.referenceVector: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["solarArrays"]) -> MetaOapg.properties.solarArrays: ...
+    def __getitem__(self, name: typing_extensions.Literal["measurement"]) -> MetaOapg.properties.measurement: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["availableSolarRootPower"], typing_extensions.Literal["solarRootPower"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["topologyParams"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["battery"], typing_extensions.Literal["busRegulators"], typing_extensions.Literal["solarArrays"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["oneSigmaPerAxisError"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["conditions"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["referenceVector"], typing_extensions.Literal["measurement"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["availableSolarRootPower"]) -> typing.Union[MetaOapg.properties.availableSolarRootPower, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["oneSigmaPerAxisError"]) -> MetaOapg.properties.oneSigmaPerAxisError: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["solarRootPower"]) -> typing.Union[MetaOapg.properties.solarRootPower, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["partNumber"]) -> typing.Union[MetaOapg.properties.partNumber, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["manufacturer"]) -> typing.Union[MetaOapg.properties.manufacturer, schemas.Unset]: ...
     
@@ -718,76 +654,66 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["readRate"]) -> typing.Union[MetaOapg.properties.readRate, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["writeRate"]) -> typing.Union[MetaOapg.properties.writeRate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["topologyParams"]) -> typing.Union[MetaOapg.properties.topologyParams, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["loads"]) -> typing.Union[MetaOapg.properties.loads, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["conditions"]) -> typing.Union[MetaOapg.properties.conditions, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["battery"]) -> typing.Union[MetaOapg.properties.battery, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["busRegulators"]) -> typing.Union[MetaOapg.properties.busRegulators, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["referenceVector"]) -> typing.Union[MetaOapg.properties.referenceVector, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["solarArrays"]) -> typing.Union[MetaOapg.properties.solarArrays, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["measurement"]) -> typing.Union[MetaOapg.properties.measurement, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["availableSolarRootPower"], typing_extensions.Literal["solarRootPower"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["topologyParams"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["battery"], typing_extensions.Literal["busRegulators"], typing_extensions.Literal["solarArrays"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["oneSigmaPerAxisError"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["conditions"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["referenceVector"], typing_extensions.Literal["measurement"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
+        oneSigmaPerAxisError: typing.Union[MetaOapg.properties.oneSigmaPerAxisError, decimal.Decimal, int, float, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        availableSolarRootPower: typing.Union[MetaOapg.properties.availableSolarRootPower, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        solarRootPower: typing.Union[MetaOapg.properties.solarRootPower, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         partNumber: typing.Union[MetaOapg.properties.partNumber, str, schemas.Unset] = schemas.unset,
         manufacturer: typing.Union[MetaOapg.properties.manufacturer, str, schemas.Unset] = schemas.unset,
         hotTempRating: typing.Union[MetaOapg.properties.hotTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         coldTempRating: typing.Union[MetaOapg.properties.coldTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         thermalCapacitance: typing.Union[MetaOapg.properties.thermalCapacitance, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         cotsTemplate: typing.Union[MetaOapg.properties.cotsTemplate, str, schemas.Unset] = schemas.unset,
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        topologyParams: typing.Union[MetaOapg.properties.topologyParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
-        dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
-        battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
-        busRegulators: typing.Union[MetaOapg.properties.busRegulators, list, tuple, schemas.Unset] = schemas.unset,
-        solarArrays: typing.Union[MetaOapg.properties.solarArrays, list, tuple, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        conditions: typing.Union[MetaOapg.properties.conditions, list, tuple, schemas.Unset] = schemas.unset,
+        fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
+        referenceVector: typing.Union[MetaOapg.properties.referenceVector, str, schemas.Unset] = schemas.unset,
+        measurement: typing.Union[MetaOapg.properties.measurement, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TwoConvMpptPowerProcessor':
+    ) -> 'VectorSensor':
         return super().__new__(
             cls,
             *_args,
             name=name,
+            oneSigmaPerAxisError=oneSigmaPerAxisError,
             id=id,
-            availableSolarRootPower=availableSolarRootPower,
-            solarRootPower=solarRootPower,
             partNumber=partNumber,
             manufacturer=manufacturer,
             hotTempRating=hotTempRating,
             coldTempRating=coldTempRating,
             thermalCapacitance=thermalCapacitance,
             cotsTemplate=cotsTemplate,
             subsystem=subsystem,
@@ -800,22 +726,16 @@
             dissipations=dissipations,
             hotMargin=hotMargin,
             coldMargin=coldMargin,
             temperature=temperature,
             storage=storage,
             readRate=readRate,
             writeRate=writeRate,
-            topologyParams=topologyParams,
-            loads=loads,
-            dynamicallyLoadedComponents=dynamicallyLoadedComponents,
-            battery=battery,
-            busRegulators=busRegulators,
-            solarArrays=solarArrays,
+            conditions=conditions,
+            fieldOfView=fieldOfView,
+            referenceVector=referenceVector,
+            measurement=measurement,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
-from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
-from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
-from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
-from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/two_conv_mppt_topology_params.py` & `sedaro-4.3.2/src/sedaro_base_client/model/two_conv_mppt_topology_params.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/types.py` & `sedaro-4.3.2/src/sedaro_base_client/apis/tags/repositories_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,56 +1,31 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
-from datetime import date, datetime  # noqa: F401
-import decimal  # noqa: F401
-import functools  # noqa: F401
-import io  # noqa: F401
-import re  # noqa: F401
-import typing  # noqa: F401
-import typing_extensions  # noqa: F401
-import uuid  # noqa: F401
-
-import frozendict  # noqa: F401
-
-from sedaro_base_client import schemas  # noqa: F401
-
-
-class Types(
-    schemas.EnumBase,
-    schemas.StrSchema
+from sedaro_base_client.paths.models_repositories_.post import CreateRepo
+from sedaro_base_client.paths.models_repositories_repository_id.delete import DeleteRepo
+from sedaro_base_client.paths.models_repositories_repository_id.get import GetRepo
+from sedaro_base_client.paths.models_repositories__import.post import ImportBranchAsNewRepo
+from sedaro_base_client.paths.models_repositories_repository_id.patch import UpdateRepo
+
+
+class RepositoriesApi(
+    CreateRepo,
+    DeleteRepo,
+    GetRepo,
+    ImportBranchAsNewRepo,
+    UpdateRepo,
 ):
-    """NOTE: This class is auto generated by OpenAPI Generator.
+    """NOTE: This class is auto generated by OpenAPI Generator
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    An enumeration.
     """
-
-
-    class MetaOapg:
-        enum_value_to_name = {
-            "SpaceTarget": "SPACE_TARGET",
-            "CelestialTarget": "CELESTIAL_TARGET",
-            "GroundTarget": "GROUND_TARGET",
-        }
-    
-    @schemas.classproperty
-    def SPACE_TARGET(cls):
-        return cls("SpaceTarget")
-    
-    @schemas.classproperty
-    def CELESTIAL_TARGET(cls):
-        return cls("CelestialTarget")
-    
-    @schemas.classproperty
-    def GROUND_TARGET(cls):
-        return cls("GroundTarget")
+    pass
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/validation_error.py` & `sedaro-4.3.2/src/sedaro_base_client/model/branch_scenario_res.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,149 +19,177 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class ValidationError(
+class BranchScenarioRes(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
-            "msg",
-            "loc",
-            "type",
+            "dateCreated",
+            "name",
+            "dateModified",
+            "id",
+            "repository",
         }
         
         class properties:
             
             
-            class loc(
-                schemas.ListSchema
+            class name(
+                schemas.StrSchema
             ):
             
             
                 class MetaOapg:
+                    max_length = 32
+            id = schemas.IntSchema
+            dateCreated = schemas.DateTimeSchema
+            dateModified = schemas.DateTimeSchema
+            
+            
+            class repository(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    any_of_0 = schemas.DictSchema
+                    any_of_1 = schemas.IntSchema
                     
-                    
-                    class items(
-                        schemas.ComposedSchema,
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            any_of_0 = schemas.StrSchema
-                            any_of_1 = schemas.IntSchema
-                            
-                            @classmethod
-                            @functools.lru_cache()
-                            def any_of(cls):
-                                # we need this here to make our import statements work
-                                # we must store _composed_schemas in here so the code is only run
-                                # when we invoke this method. If we kept this at the class
-                                # level we would get an error because the class level
-                                # code would be run when this module is imported, and these composed
-                                # classes don't exist yet because their module has not finished
-                                # loading
-                                return [
-                                    cls.any_of_0,
-                                    cls.any_of_1,
-                                ]
-                    
-                    
-                        def __new__(
-                            cls,
-                            *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                        ) -> 'items':
-                            return super().__new__(
-                                cls,
-                                *_args,
-                                _configuration=_configuration,
-                                **kwargs,
-                            )
+                    @classmethod
+                    @functools.lru_cache()
+                    def any_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            cls.any_of_0,
+                            cls.any_of_1,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'loc':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'repository':
                     return super().__new__(
                         cls,
-                        _arg,
+                        *_args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            msg = schemas.StrSchema
-            type = schemas.StrSchema
+            
+            class description(
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    max_length = 300
             __annotations__ = {
-                "loc": loc,
-                "msg": msg,
-                "type": type,
+                "name": name,
+                "id": id,
+                "dateCreated": dateCreated,
+                "dateModified": dateModified,
+                "repository": repository,
+                "description": description,
             }
     
-    msg: MetaOapg.properties.msg
-    loc: MetaOapg.properties.loc
-    type: MetaOapg.properties.type
+    dateCreated: MetaOapg.properties.dateCreated
+    name: MetaOapg.properties.name
+    dateModified: MetaOapg.properties.dateModified
+    id: MetaOapg.properties.id
+    repository: MetaOapg.properties.repository
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
+    def __getitem__(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
+    def __getitem__(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "description", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["dateCreated"]) -> MetaOapg.properties.dateCreated: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["dateModified"]) -> MetaOapg.properties.dateModified: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["repository"]) -> MetaOapg.properties.repository: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "id", "dateCreated", "dateModified", "repository", "description", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        msg: typing.Union[MetaOapg.properties.msg, str, ],
-        loc: typing.Union[MetaOapg.properties.loc, list, tuple, ],
-        type: typing.Union[MetaOapg.properties.type, str, ],
+        dateCreated: typing.Union[MetaOapg.properties.dateCreated, str, datetime, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        dateModified: typing.Union[MetaOapg.properties.dateModified, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, ],
+        repository: typing.Union[MetaOapg.properties.repository, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ValidationError':
+    ) -> 'BranchScenarioRes':
         return super().__new__(
             cls,
             *_args,
-            msg=msg,
-            loc=loc,
-            type=type,
+            dateCreated=dateCreated,
+            name=name,
+            dateModified=dateModified,
+            id=id,
+            repository=repository,
+            description=description,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/vector.py` & `sedaro-4.3.2/src/sedaro_base_client/model/panel_dissipations.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,87 +19,113 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class Vector(
+class PanelDissipations(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
 
     class MetaOapg:
         required = {
-            "vector",
+            "internalLoads",
+            "total",
+            "blockingDiode",
         }
         
         class properties:
             
             
-            class vector(
-                schemas.ListSchema
+            class total(
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.NumberSchema
+                    inclusive_minimum = 0.0
             
-                def __new__(
-                    cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'vector':
-                    return super().__new__(
-                        cls,
-                        _arg,
-                        _configuration=_configuration,
-                    )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
+            class internalLoads(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            
+            
+            class blockingDiode(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
             __annotations__ = {
-                "vector": vector,
+                "total": total,
+                "internalLoads": internalLoads,
+                "blockingDiode": blockingDiode,
             }
     
-    vector: MetaOapg.properties.vector
+    internalLoads: MetaOapg.properties.internalLoads
+    total: MetaOapg.properties.total
+    blockingDiode: MetaOapg.properties.blockingDiode
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["vector"]) -> MetaOapg.properties.vector: ...
+    def __getitem__(self, name: typing_extensions.Literal["blockingDiode"]) -> MetaOapg.properties.blockingDiode: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["vector", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", "blockingDiode", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["vector"]) -> MetaOapg.properties.vector: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["blockingDiode"]) -> MetaOapg.properties.blockingDiode: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["vector", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", "blockingDiode", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        vector: typing.Union[MetaOapg.properties.vector, list, tuple, ],
+        internalLoads: typing.Union[MetaOapg.properties.internalLoads, decimal.Decimal, int, float, ],
+        total: typing.Union[MetaOapg.properties.total, decimal.Decimal, int, float, ],
+        blockingDiode: typing.Union[MetaOapg.properties.blockingDiode, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'Vector':
+    ) -> 'PanelDissipations':
         return super().__new__(
             cls,
             *_args,
-            vector=vector,
+            internalLoads=internalLoads,
+            total=total,
+            blockingDiode=blockingDiode,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/vector_in_fov_condition.py` & `sedaro-4.3.2/src/sedaro_base_client/model/processor_dissipations.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,126 +19,133 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class VectorInFovCondition(
+class ProcessorDissipations(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
-
-    Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
-            "name",
+            "internalLoads",
+            "total",
+            "busRegulators",
+            "powerController",
         }
         
         class properties:
             
             
-            class name(
-                schemas.StrSchema
+            class total(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            
+            
+            class internalLoads(
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    max_length = 100
-            id = schemas.StrSchema
-            terminator = schemas.BoolSchema
-            compliance = schemas.BoolSchema
-            fieldOfView = schemas.StrSchema
-            referenceVector = schemas.StrSchema
-            negate = schemas.BoolSchema
+                    inclusive_minimum = 0.0
+            
+            
+            class busRegulators(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
+            
+            
+            class powerController(
+                schemas.NumberSchema
+            ):
+            
+            
+                class MetaOapg:
+                    inclusive_minimum = 0.0
             __annotations__ = {
-                "name": name,
-                "id": id,
-                "terminator": terminator,
-                "compliance": compliance,
-                "fieldOfView": fieldOfView,
-                "referenceVector": referenceVector,
-                "negate": negate,
+                "total": total,
+                "internalLoads": internalLoads,
+                "busRegulators": busRegulators,
+                "powerController": powerController,
             }
-        additional_properties = schemas.NotAnyTypeSchema
-    
-    name: MetaOapg.properties.name
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    internalLoads: MetaOapg.properties.internalLoads
+    total: MetaOapg.properties.total
+    busRegulators: MetaOapg.properties.busRegulators
+    powerController: MetaOapg.properties.powerController
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["terminator"]) -> MetaOapg.properties.terminator: ...
+    def __getitem__(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["compliance"]) -> MetaOapg.properties.compliance: ...
+    def __getitem__(self, name: typing_extensions.Literal["busRegulators"]) -> MetaOapg.properties.busRegulators: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
+    def __getitem__(self, name: typing_extensions.Literal["powerController"]) -> MetaOapg.properties.powerController: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["referenceVector"]) -> MetaOapg.properties.referenceVector: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["negate"]) -> MetaOapg.properties.negate: ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["referenceVector"], typing_extensions.Literal["negate"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", "busRegulators", "powerController", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["terminator"]) -> typing.Union[MetaOapg.properties.terminator, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["total"]) -> MetaOapg.properties.total: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["compliance"]) -> typing.Union[MetaOapg.properties.compliance, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["internalLoads"]) -> MetaOapg.properties.internalLoads: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["busRegulators"]) -> MetaOapg.properties.busRegulators: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["referenceVector"]) -> typing.Union[MetaOapg.properties.referenceVector, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["powerController"]) -> MetaOapg.properties.powerController: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["negate"]) -> typing.Union[MetaOapg.properties.negate, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["terminator"], typing_extensions.Literal["compliance"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["referenceVector"], typing_extensions.Literal["negate"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["total", "internalLoads", "busRegulators", "powerController", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
-        terminator: typing.Union[MetaOapg.properties.terminator, bool, schemas.Unset] = schemas.unset,
-        compliance: typing.Union[MetaOapg.properties.compliance, bool, schemas.Unset] = schemas.unset,
-        fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
-        referenceVector: typing.Union[MetaOapg.properties.referenceVector, str, schemas.Unset] = schemas.unset,
-        negate: typing.Union[MetaOapg.properties.negate, bool, schemas.Unset] = schemas.unset,
+        internalLoads: typing.Union[MetaOapg.properties.internalLoads, decimal.Decimal, int, float, ],
+        total: typing.Union[MetaOapg.properties.total, decimal.Decimal, int, float, ],
+        busRegulators: typing.Union[MetaOapg.properties.busRegulators, decimal.Decimal, int, float, ],
+        powerController: typing.Union[MetaOapg.properties.powerController, decimal.Decimal, int, float, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'VectorInFovCondition':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'ProcessorDissipations':
         return super().__new__(
             cls,
             *_args,
-            name=name,
-            id=id,
-            terminator=terminator,
-            compliance=compliance,
-            fieldOfView=fieldOfView,
-            referenceVector=referenceVector,
-            negate=negate,
+            internalLoads=internalLoads,
+            total=total,
+            busRegulators=busRegulators,
+            powerController=powerController,
             _configuration=_configuration,
+            **kwargs,
         )
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/vector_sensor.py` & `sedaro-4.3.2/src/sedaro_base_client/model/two_conv_mppt_power_processor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,52 +19,44 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class VectorSensor(
+class TwoConvMpptPowerProcessor(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
     Class to be used internally and inherited by `Metamodel` and `Block`. Adds helper methods and properties.
     """
 
 
     class MetaOapg:
         required = {
             "name",
-            "oneSigmaPerAxisError",
         }
         
         class properties:
             
             
             class name(
                 schemas.StrSchema
             ):
             
             
                 class MetaOapg:
                     max_length = 100
-            
-            
-            class oneSigmaPerAxisError(
-                schemas.NumberSchema
-            ):
-            
-            
-                class MetaOapg:
-                    inclusive_minimum = 0.0
             id = schemas.StrSchema
+            availableSolarRootPower = schemas.NumberSchema
+            solarRootPower = schemas.NumberSchema
             
             
             class partNumber(
                 schemas.StrSchema
             ):
             
             
@@ -95,15 +87,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -131,15 +123,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -263,41 +255,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             powerConsumed = schemas.NumberSchema
             
             
             class dissipations(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    
-                    class additional_properties(
-                        schemas.NumberSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            inclusive_minimum = 0.0
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProcessorDissipations,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'dissipations':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -319,15 +310,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -346,110 +337,224 @@
             ):
             
             
                 class MetaOapg:
                     
                     
                     class additional_properties(
-                        schemas.IntSchema
+                        schemas.DictSchema
                     ):
                     
                     
                         class MetaOapg:
-                            inclusive_minimum = 0
+                            
+                            
+                            class additional_properties(
+                                schemas.NumberSchema
+                            ):
+                            
+                            
+                                class MetaOapg:
+                                    inclusive_minimum = 0.0
+                        
+                        def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            # dict_instance[name] accessor
+                            return super().__getitem__(name)
+                        
+                        def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
+                            return super().get_item_oapg(name)
+                    
+                        def __new__(
+                            cls,
+                            *_args: typing.Union[dict, frozendict.frozendict, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                        ) -> 'additional_properties':
+                            return super().__new__(
+                                cls,
+                                *_args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
                 
                 def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     # dict_instance[name] accessor
                     return super().__getitem__(name)
                 
                 def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
                     return super().get_item_oapg(name)
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, ],
+                    **kwargs: typing.Union[MetaOapg.additional_properties, dict, frozendict.frozendict, ],
                 ) -> 'storage':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             
             
             class readRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
             
             
             class writeRate(
-                schemas.IntSchema
+                schemas.NumberSchema
             ):
             
             
                 class MetaOapg:
-                    inclusive_minimum = 0
+                    inclusive_minimum = 0.0
+            
+            
+            class topologyParams(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def any_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            FullyRegDetTopologyParams,
+                            SingleConvHybridTopologyParams,
+                            QuasiRegDetTopologyParams,
+                            TwoConvMpptTopologyParams,
+                            SingleConvMpptTopologyParams,
+                        ]
             
             
-            class conditions(
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'topologyParams':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
+            
+            
+            class loads(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'loads':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class dynamicallyLoadedComponents(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'conditions':
+                ) -> 'dynamicallyLoadedComponents':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            fieldOfView = schemas.StrSchema
-            referenceVector = schemas.StrSchema
+            battery = schemas.StrSchema
             
             
-            class measurement(
+            class busRegulators(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    items = schemas.NumberSchema
+                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'measurement':
+                ) -> 'busRegulators':
+                    return super().__new__(
+                        cls,
+                        _arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class solarArrays(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'solarArrays':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             __annotations__ = {
                 "name": name,
-                "oneSigmaPerAxisError": oneSigmaPerAxisError,
                 "id": id,
+                "availableSolarRootPower": availableSolarRootPower,
+                "solarRootPower": solarRootPower,
                 "partNumber": partNumber,
                 "manufacturer": manufacturer,
                 "hotTempRating": hotTempRating,
                 "coldTempRating": coldTempRating,
                 "thermalCapacitance": thermalCapacitance,
                 "cotsTemplate": cotsTemplate,
                 "subsystem": subsystem,
@@ -462,32 +567,36 @@
                 "dissipations": dissipations,
                 "hotMargin": hotMargin,
                 "coldMargin": coldMargin,
                 "temperature": temperature,
                 "storage": storage,
                 "readRate": readRate,
                 "writeRate": writeRate,
-                "conditions": conditions,
-                "fieldOfView": fieldOfView,
-                "referenceVector": referenceVector,
-                "measurement": measurement,
+                "topologyParams": topologyParams,
+                "loads": loads,
+                "dynamicallyLoadedComponents": dynamicallyLoadedComponents,
+                "battery": battery,
+                "busRegulators": busRegulators,
+                "solarArrays": solarArrays,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     name: MetaOapg.properties.name
-    oneSigmaPerAxisError: MetaOapg.properties.oneSigmaPerAxisError
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["oneSigmaPerAxisError"]) -> MetaOapg.properties.oneSigmaPerAxisError: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["availableSolarRootPower"]) -> MetaOapg.properties.availableSolarRootPower: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["solarRootPower"]) -> MetaOapg.properties.solarRootPower: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["partNumber"]) -> MetaOapg.properties.partNumber: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["manufacturer"]) -> MetaOapg.properties.manufacturer: ...
     
@@ -542,37 +651,46 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["readRate"]) -> MetaOapg.properties.readRate: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["writeRate"]) -> MetaOapg.properties.writeRate: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["conditions"]) -> MetaOapg.properties.conditions: ...
+    def __getitem__(self, name: typing_extensions.Literal["topologyParams"]) -> MetaOapg.properties.topologyParams: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["loads"]) -> MetaOapg.properties.loads: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> MetaOapg.properties.dynamicallyLoadedComponents: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["fieldOfView"]) -> MetaOapg.properties.fieldOfView: ...
+    def __getitem__(self, name: typing_extensions.Literal["battery"]) -> MetaOapg.properties.battery: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["referenceVector"]) -> MetaOapg.properties.referenceVector: ...
+    def __getitem__(self, name: typing_extensions.Literal["busRegulators"]) -> MetaOapg.properties.busRegulators: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["measurement"]) -> MetaOapg.properties.measurement: ...
+    def __getitem__(self, name: typing_extensions.Literal["solarArrays"]) -> MetaOapg.properties.solarArrays: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["oneSigmaPerAxisError"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["conditions"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["referenceVector"], typing_extensions.Literal["measurement"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["availableSolarRootPower"], typing_extensions.Literal["solarRootPower"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["topologyParams"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["battery"], typing_extensions.Literal["busRegulators"], typing_extensions.Literal["solarArrays"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["oneSigmaPerAxisError"]) -> MetaOapg.properties.oneSigmaPerAxisError: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["availableSolarRootPower"]) -> typing.Union[MetaOapg.properties.availableSolarRootPower, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["solarRootPower"]) -> typing.Union[MetaOapg.properties.solarRootPower, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["partNumber"]) -> typing.Union[MetaOapg.properties.partNumber, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["manufacturer"]) -> typing.Union[MetaOapg.properties.manufacturer, schemas.Unset]: ...
     
@@ -627,66 +745,76 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["readRate"]) -> typing.Union[MetaOapg.properties.readRate, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["writeRate"]) -> typing.Union[MetaOapg.properties.writeRate, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["conditions"]) -> typing.Union[MetaOapg.properties.conditions, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["topologyParams"]) -> typing.Union[MetaOapg.properties.topologyParams, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["loads"]) -> typing.Union[MetaOapg.properties.loads, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["dynamicallyLoadedComponents"]) -> typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["fieldOfView"]) -> typing.Union[MetaOapg.properties.fieldOfView, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["battery"]) -> typing.Union[MetaOapg.properties.battery, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["referenceVector"]) -> typing.Union[MetaOapg.properties.referenceVector, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["busRegulators"]) -> typing.Union[MetaOapg.properties.busRegulators, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["measurement"]) -> typing.Union[MetaOapg.properties.measurement, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["solarArrays"]) -> typing.Union[MetaOapg.properties.solarArrays, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["oneSigmaPerAxisError"], typing_extensions.Literal["id"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["conditions"], typing_extensions.Literal["fieldOfView"], typing_extensions.Literal["referenceVector"], typing_extensions.Literal["measurement"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name"], typing_extensions.Literal["id"], typing_extensions.Literal["availableSolarRootPower"], typing_extensions.Literal["solarRootPower"], typing_extensions.Literal["partNumber"], typing_extensions.Literal["manufacturer"], typing_extensions.Literal["hotTempRating"], typing_extensions.Literal["coldTempRating"], typing_extensions.Literal["thermalCapacitance"], typing_extensions.Literal["cotsTemplate"], typing_extensions.Literal["subsystem"], typing_extensions.Literal["loadStates"], typing_extensions.Literal["dataSinks"], typing_extensions.Literal["dataSources"], typing_extensions.Literal["dataStorage"], typing_extensions.Literal["dataModes"], typing_extensions.Literal["powerConsumed"], typing_extensions.Literal["dissipations"], typing_extensions.Literal["hotMargin"], typing_extensions.Literal["coldMargin"], typing_extensions.Literal["temperature"], typing_extensions.Literal["storage"], typing_extensions.Literal["readRate"], typing_extensions.Literal["writeRate"], typing_extensions.Literal["topologyParams"], typing_extensions.Literal["loads"], typing_extensions.Literal["dynamicallyLoadedComponents"], typing_extensions.Literal["battery"], typing_extensions.Literal["busRegulators"], typing_extensions.Literal["solarArrays"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
-        oneSigmaPerAxisError: typing.Union[MetaOapg.properties.oneSigmaPerAxisError, decimal.Decimal, int, float, ],
         id: typing.Union[MetaOapg.properties.id, str, schemas.Unset] = schemas.unset,
+        availableSolarRootPower: typing.Union[MetaOapg.properties.availableSolarRootPower, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        solarRootPower: typing.Union[MetaOapg.properties.solarRootPower, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         partNumber: typing.Union[MetaOapg.properties.partNumber, str, schemas.Unset] = schemas.unset,
         manufacturer: typing.Union[MetaOapg.properties.manufacturer, str, schemas.Unset] = schemas.unset,
         hotTempRating: typing.Union[MetaOapg.properties.hotTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         coldTempRating: typing.Union[MetaOapg.properties.coldTempRating, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         thermalCapacitance: typing.Union[MetaOapg.properties.thermalCapacitance, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         cotsTemplate: typing.Union[MetaOapg.properties.cotsTemplate, str, schemas.Unset] = schemas.unset,
         subsystem: typing.Union[MetaOapg.properties.subsystem, str, schemas.Unset] = schemas.unset,
         loadStates: typing.Union[MetaOapg.properties.loadStates, list, tuple, schemas.Unset] = schemas.unset,
         dataSinks: typing.Union[MetaOapg.properties.dataSinks, list, tuple, schemas.Unset] = schemas.unset,
         dataSources: typing.Union[MetaOapg.properties.dataSources, list, tuple, schemas.Unset] = schemas.unset,
         dataStorage: typing.Union[MetaOapg.properties.dataStorage, str, schemas.Unset] = schemas.unset,
         dataModes: typing.Union[MetaOapg.properties.dataModes, list, tuple, schemas.Unset] = schemas.unset,
         powerConsumed: typing.Union[MetaOapg.properties.powerConsumed, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        dissipations: typing.Union[MetaOapg.properties.dissipations, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         hotMargin: typing.Union[MetaOapg.properties.hotMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         coldMargin: typing.Union[MetaOapg.properties.coldMargin, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         storage: typing.Union[MetaOapg.properties.storage, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        conditions: typing.Union[MetaOapg.properties.conditions, list, tuple, schemas.Unset] = schemas.unset,
-        fieldOfView: typing.Union[MetaOapg.properties.fieldOfView, str, schemas.Unset] = schemas.unset,
-        referenceVector: typing.Union[MetaOapg.properties.referenceVector, str, schemas.Unset] = schemas.unset,
-        measurement: typing.Union[MetaOapg.properties.measurement, list, tuple, schemas.Unset] = schemas.unset,
+        readRate: typing.Union[MetaOapg.properties.readRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        writeRate: typing.Union[MetaOapg.properties.writeRate, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        topologyParams: typing.Union[MetaOapg.properties.topologyParams, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        loads: typing.Union[MetaOapg.properties.loads, list, tuple, schemas.Unset] = schemas.unset,
+        dynamicallyLoadedComponents: typing.Union[MetaOapg.properties.dynamicallyLoadedComponents, list, tuple, schemas.Unset] = schemas.unset,
+        battery: typing.Union[MetaOapg.properties.battery, str, schemas.Unset] = schemas.unset,
+        busRegulators: typing.Union[MetaOapg.properties.busRegulators, list, tuple, schemas.Unset] = schemas.unset,
+        solarArrays: typing.Union[MetaOapg.properties.solarArrays, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'VectorSensor':
+    ) -> 'TwoConvMpptPowerProcessor':
         return super().__new__(
             cls,
             *_args,
             name=name,
-            oneSigmaPerAxisError=oneSigmaPerAxisError,
             id=id,
+            availableSolarRootPower=availableSolarRootPower,
+            solarRootPower=solarRootPower,
             partNumber=partNumber,
             manufacturer=manufacturer,
             hotTempRating=hotTempRating,
             coldTempRating=coldTempRating,
             thermalCapacitance=thermalCapacitance,
             cotsTemplate=cotsTemplate,
             subsystem=subsystem,
@@ -699,15 +827,23 @@
             dissipations=dissipations,
             hotMargin=hotMargin,
             coldMargin=coldMargin,
             temperature=temperature,
             storage=storage,
             readRate=readRate,
             writeRate=writeRate,
-            conditions=conditions,
-            fieldOfView=fieldOfView,
-            referenceVector=referenceVector,
-            measurement=measurement,
+            topologyParams=topologyParams,
+            loads=loads,
+            dynamicallyLoadedComponents=dynamicallyLoadedComponents,
+            battery=battery,
+            busRegulators=busRegulators,
+            solarArrays=solarArrays,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
+from sedaro_base_client.model.processor_dissipations import ProcessorDissipations
+from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
+from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
+from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
+from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/vector_tracking_surface.py` & `sedaro-4.3.2/src/sedaro_base_client/model/vector_tracking_surface.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -104,15 +104,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            FrameVectorBase299,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -140,15 +140,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            FrameVectorBase299,
+                            FrameVectorBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -181,15 +181,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TemperatureBase299,
+                            TemperatureBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -540,9 +540,9 @@
             refVector2=refVector2,
             vectorProjection=vectorProjection,
             articulationAngle=articulationAngle,
             trackedVector=trackedVector,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.frame_vector_base299 import FrameVectorBase299
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/vehicle_template_crud.py` & `sedaro-4.3.2/src/sedaro_base_client/model/vehicle_template_update_interface.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class VehicleTemplateCrud(
+class VehicleTemplateUpdateInterface(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
@@ -39,16 +39,16 @@
             "root",
             "delete",
         }
         
         class properties:
         
             @staticmethod
-            def root() -> typing.Type['VehicleTemplateUpdate']:
-                return VehicleTemplateUpdate
+            def root() -> typing.Type['VehicleTemplateRoot']:
+                return VehicleTemplateRoot
             
             
             class blocks(
                 schemas.ListSchema
             ):
             
             
@@ -69,105 +69,104 @@
                                 # we must store _composed_schemas in here so the code is only run
                                 # when we invoke this method. If we kept this at the class
                                 # level we would get an error because the class level
                                 # code would be run when this module is imported, and these composed
                                 # classes don't exist yet because their module has not finished
                                 # loading
                                 return [
-                                    ComponentToScalarCondition,
-                                    BodyFrameVector,
-                                    MekfAlgorithm,
-                                    SpherocylinderFuelTank,
-                                    Orbit,
-                                    SatelliteToScalarCondition,
-                                    CircularFieldOfView,
-                                    Satellite,
-                                    TargetVector,
-                                    Battery,
-                                    Thruster,
-                                    PassiveTransmitInterface,
-                                    TriadAlgorithm,
-                                    CelestialTarget,
-                                    Modem,
-                                    TargetInFovCondition,
-                                    TempControllerState,
-                                    PidAlgorithm,
-                                    DataBus,
                                     Antenna,
+                                    ResistanceLoad,
                                     PowerLoad,
-                                    TargetGroupToTargetCondition,
-                                    TargetGroupVector,
-                                    BatteryCell,
-                                    CompoundCondition,
-                                    FullyRegDetPowerProcessor,
-                                    FuelReservoir,
+                                    DataInterface,
+                                    InternalDataInterface,
+                                    ReceiveInterface,
+                                    ThermalInterface,
+                                    PassiveTransmitInterface,
+                                    CooperativeTransmitInterface,
+                                    FixedSurface,
+                                    SunTrackingSurface,
+                                    VectorTrackingSurface,
+                                    DataMode,
+                                    PassivePointingMode,
+                                    LockPointingMode,
+                                    MaxAlignPointingMode,
+                                    OperationalMode,
+                                    DataStorage,
+                                    LaserCommModule,
+                                    DataType,
+                                    LoadState,
+                                    TempControllerState,
+                                    BatteryPack,
+                                    SphericalFuelTank,
+                                    SpherocylinderFuelTank,
+                                    ThermalInterfaceMaterial,
+                                    SurfaceMaterial,
                                     ReactionWheel,
-                                    BodyInFovCondition,
+                                    SolarPanel,
+                                    SolarCell,
+                                    BatteryCell,
+                                    Modem,
+                                    Subsystem,
+                                    TriadAlgorithm,
+                                    PidAlgorithm,
+                                    SlidingModeAlgorithm,
+                                    EkfAlgorithm,
+                                    MekfAlgorithm,
+                                    AveragingAlgorithm,
+                                    StaticThrustControlAlgorithm,
                                     GpsAlgorithm,
-                                    TargetGroupToScalarCondition,
+                                    CompoundCondition,
                                     TimeCondition,
-                                    Magnetorquer,
-                                    ResistanceLoad,
-                                    OperationalMode,
-                                    StaticThrustControlAlgorithm,
-                                    VectorTrackingSurface,
-                                    BusRegulator,
-                                    DataInterface,
                                     SatelliteToSatelliteCondition,
-                                    SurfaceMaterial,
-                                    DirectionSensor,
-                                    CooperativeTransmitInterface,
-                                    ThermalInterface,
-                                    QuasiRegDetPowerProcessor,
-                                    Heater,
-                                    BatteryPack,
-                                    PositionSensor,
-                                    LocalVector,
-                                    GroundTarget,
                                     TargetGroupToSatelliteCondition,
-                                    SpaceTarget,
-                                    Cooler,
                                     SameTargetMultiCondition,
-                                    MaxAlignPointingMode,
-                                    SlidingModeAlgorithm,
-                                    InternalDataInterface,
-                                    DataMode,
-                                    OpticalAttitudeSensor,
+                                    SatelliteToScalarCondition,
+                                    TargetGroupToScalarCondition,
+                                    TargetToScalarCondition,
+                                    ComponentToScalarCondition,
                                     SatelliteToTargetCondition,
-                                    LoadState,
-                                    LaserCommModule,
-                                    LockPointingMode,
+                                    TargetGroupToTargetCondition,
+                                    TargetToTargetCondition,
+                                    TargetGroupInFovCondition,
+                                    VectorInFovCondition,
+                                    TargetInFovCondition,
+                                    BodyInFovCondition,
+                                    TargetGroup,
+                                    Cooler,
+                                    Heater,
+                                    Thruster,
+                                    Magnetorquer,
+                                    FuelReservoir,
+                                    OpticalAttitudeSensor,
+                                    DirectionSensor,
+                                    PositionSensor,
                                     VectorSensor,
+                                    AngularVelocitySensor,
+                                    PowerProcessor,
+                                    SingleConvHybridPowerProcessor,
+                                    QuasiRegDetPowerProcessor,
+                                    FullyRegDetPowerProcessor,
+                                    SingleConvMpptPowerProcessor,
                                     TwoConvMpptPowerProcessor,
-                                    SolarPanel,
+                                    BusRegulator,
+                                    BodyFrameVector,
+                                    LocalVector,
                                     CelestialVector,
-                                    AveragingAlgorithm,
-                                    TargetToScalarCondition,
-                                    SolarCell,
-                                    TargetGroup,
-                                    SolarArray,
-                                    TargetGroupInFovCondition,
-                                    EkfAlgorithm,
+                                    TargetGroupVector,
+                                    TargetVector,
+                                    DataBus,
+                                    GroundTarget,
+                                    SpaceTarget,
+                                    CelestialTarget,
+                                    Orbit,
                                     Component,
-                                    PowerProcessor,
-                                    DataStorage,
-                                    SphericalFuelTank,
-                                    ThermalInterfaceMaterial,
-                                    FixedSurface,
+                                    CircularFieldOfView,
                                     RectangularFieldOfView,
-                                    ReceiveInterface,
-                                    TargetToTargetCondition,
-                                    DataType,
-                                    SunTrackingSurface,
-                                    VectorInFovCondition,
-                                    SingleConvHybridPowerProcessor,
-                                    SingleConvMpptPowerProcessor,
-                                    PassivePointingMode,
-                                    Subsystem,
-                                    AngularVelocitySensor,
+                                    SolarArray,
+                                    Battery,
                                 ]
                     
                     
                         def __new__(
                             cls,
                             *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                             _configuration: typing.Optional[schemas.Configuration] = None,
@@ -219,19 +218,19 @@
             __annotations__ = {
                 "root": root,
                 "blocks": blocks,
                 "delete": delete,
             }
     
     blocks: MetaOapg.properties.blocks
-    root: 'VehicleTemplateUpdate'
+    root: 'VehicleTemplateRoot'
     delete: MetaOapg.properties.delete
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["root"]) -> 'VehicleTemplateUpdate': ...
+    def __getitem__(self, name: typing_extensions.Literal["root"]) -> 'VehicleTemplateRoot': ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["delete"]) -> MetaOapg.properties.delete: ...
     
@@ -240,15 +239,15 @@
     
     def __getitem__(self, name: typing.Union[typing_extensions.Literal["root", "blocks", "delete", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["root"]) -> 'VehicleTemplateUpdate': ...
+    def get_item_oapg(self, name: typing_extensions.Literal["root"]) -> 'VehicleTemplateRoot': ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["delete"]) -> MetaOapg.properties.delete: ...
     
@@ -259,19 +258,19 @@
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         blocks: typing.Union[MetaOapg.properties.blocks, list, tuple, ],
-        root: 'VehicleTemplateUpdate',
+        root: 'VehicleTemplateRoot',
         delete: typing.Union[MetaOapg.properties.delete, list, tuple, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'VehicleTemplateCrud':
+    ) -> 'VehicleTemplateUpdateInterface':
         return super().__new__(
             cls,
             *_args,
             blocks=blocks,
             root=root,
             delete=delete,
             _configuration=_configuration,
@@ -328,15 +327,14 @@
 from sedaro_base_client.model.power_processor import PowerProcessor
 from sedaro_base_client.model.quasi_reg_det_power_processor import QuasiRegDetPowerProcessor
 from sedaro_base_client.model.reaction_wheel import ReactionWheel
 from sedaro_base_client.model.receive_interface import ReceiveInterface
 from sedaro_base_client.model.rectangular_field_of_view import RectangularFieldOfView
 from sedaro_base_client.model.resistance_load import ResistanceLoad
 from sedaro_base_client.model.same_target_multi_condition import SameTargetMultiCondition
-from sedaro_base_client.model.satellite import Satellite
 from sedaro_base_client.model.satellite_to_satellite_condition import SatelliteToSatelliteCondition
 from sedaro_base_client.model.satellite_to_scalar_condition import SatelliteToScalarCondition
 from sedaro_base_client.model.satellite_to_target_condition import SatelliteToTargetCondition
 from sedaro_base_client.model.single_conv_hybrid_power_processor import SingleConvHybridPowerProcessor
 from sedaro_base_client.model.single_conv_mppt_power_processor import SingleConvMpptPowerProcessor
 from sedaro_base_client.model.sliding_mode_algorithm import SlidingModeAlgorithm
 from sedaro_base_client.model.solar_array import SolarArray
@@ -365,8 +363,8 @@
 from sedaro_base_client.model.thruster import Thruster
 from sedaro_base_client.model.time_condition import TimeCondition
 from sedaro_base_client.model.triad_algorithm import TriadAlgorithm
 from sedaro_base_client.model.two_conv_mppt_power_processor import TwoConvMpptPowerProcessor
 from sedaro_base_client.model.vector_in_fov_condition import VectorInFovCondition
 from sedaro_base_client.model.vector_sensor import VectorSensor
 from sedaro_base_client.model.vector_tracking_surface import VectorTrackingSurface
-from sedaro_base_client.model.vehicle_template_update import VehicleTemplateUpdate
+from sedaro_base_client.model.vehicle_template_root import VehicleTemplateRoot
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/vehicle_template_res.py` & `sedaro-4.3.2/src/sedaro_base_client/model/vehicle_template_res.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -188,15 +188,14 @@
                 ) -> 'index':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            selfId = schemas.StrSchema
             
             
             class cadFileName(
                 schemas.StrSchema
             ):
             
             
@@ -222,14 +221,16 @@
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             missionOrbit = schemas.StrSchema
+            activeOpMode = schemas.StrSchema
+            powerProcessor = schemas.StrSchema
             dynamicMass = schemas.NumberSchema
             
             
             class dynamicInertia(
                 schemas.ListSchema
             ):
             
@@ -270,20 +271,50 @@
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            activeOpMode = schemas.StrSchema
-            powerProcessor = schemas.StrSchema
-        
-            @staticmethod
-            def position() -> typing.Type['PositionBase299']:
-                return PositionBase299
+            
+            
+            class position(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            PositionBase306,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'position':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             
             
             class velocity(
                 schemas.ListSchema
             ):
             
             
@@ -319,15 +350,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            QuaternionBase299,
+                            QuaternionBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -639,48 +670,35 @@
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
             class attitudeSolution(
-                schemas.ComposedSchema,
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            QuaternionBase299,
-                        ]
-            
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'attitudeSolution':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
             
             class attitudeSolutionError(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
@@ -744,48 +762,35 @@
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
             class commandedAttitude(
-                schemas.ComposedSchema,
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            QuaternionBase299,
-                        ]
-            
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'commandedAttitude':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
             
             class commandedAngularRates(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
@@ -898,33 +903,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             beta = schemas.NumberSchema
             
             
             class orbitalElements(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    additional_properties = schemas.NumberSchema
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            OrbitalElementsData,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'orbitalElements':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -1010,56 +1022,56 @@
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            _quantityKinds = schemas.DictSchema
+            selfId = schemas.StrSchema
+            _relationships = schemas.DictSchema
             _supers = schemas.DictSchema
+            _quantityKinds = schemas.DictSchema
             
             
-            class _block_names(
+            class _blockNames(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
                     _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> '_block_names':
+                ) -> '_blockNames':
                     return super().__new__(
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            _relationships = schemas.DictSchema
             __annotations__ = {
                 "cadKey": cadKey,
                 "cadSignedUrl": cadSignedUrl,
                 "cadScaleFactor": cadScaleFactor,
                 "mass": mass,
                 "inertia": inertia,
                 "blocks": blocks,
                 "index": index,
-                "selfId": selfId,
                 "cadFileName": cadFileName,
                 "enabledModules": enabledModules,
                 "missionOrbit": missionOrbit,
-                "dynamicMass": dynamicMass,
-                "dynamicInertia": dynamicInertia,
                 "activeOpMode": activeOpMode,
                 "powerProcessor": powerProcessor,
+                "dynamicMass": dynamicMass,
+                "dynamicInertia": dynamicInertia,
                 "position": position,
                 "velocity": velocity,
                 "attitude": attitude,
                 "angularVelocity": angularVelocity,
                 "torque": torque,
                 "srpTorque": srpTorque,
                 "dragTorque": dragTorque,
@@ -1078,18 +1090,19 @@
                 "commandedAngularRates": commandedAngularRates,
                 "lvlhAxes": lvlhAxes,
                 "enuAxes": enuAxes,
                 "beta": beta,
                 "orbitalElements": orbitalElements,
                 "shadow": shadow,
                 "activeCommInterfaces": activeCommInterfaces,
-                "_quantityKinds": _quantityKinds,
-                "_supers": _supers,
-                "_block_names": _block_names,
+                "selfId": selfId,
                 "_relationships": _relationships,
+                "_supers": _supers,
+                "_quantityKinds": _quantityKinds,
+                "_blockNames": _blockNames,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     inertia: MetaOapg.properties.inertia
     cadScaleFactor: MetaOapg.properties.cadScaleFactor
     cadSignedUrl: MetaOapg.properties.cadSignedUrl
     mass: MetaOapg.properties.mass
@@ -1113,39 +1126,36 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["blocks"]) -> MetaOapg.properties.blocks: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["index"]) -> MetaOapg.properties.index: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["selfId"]) -> MetaOapg.properties.selfId: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["cadFileName"]) -> MetaOapg.properties.cadFileName: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["enabledModules"]) -> MetaOapg.properties.enabledModules: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["missionOrbit"]) -> MetaOapg.properties.missionOrbit: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dynamicMass"]) -> MetaOapg.properties.dynamicMass: ...
+    def __getitem__(self, name: typing_extensions.Literal["activeOpMode"]) -> MetaOapg.properties.activeOpMode: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dynamicInertia"]) -> MetaOapg.properties.dynamicInertia: ...
+    def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["activeOpMode"]) -> MetaOapg.properties.activeOpMode: ...
+    def __getitem__(self, name: typing_extensions.Literal["dynamicMass"]) -> MetaOapg.properties.dynamicMass: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
+    def __getitem__(self, name: typing_extensions.Literal["dynamicInertia"]) -> MetaOapg.properties.dynamicInertia: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["position"]) -> 'PositionBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["position"]) -> MetaOapg.properties.position: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["velocity"]) -> MetaOapg.properties.velocity: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["attitude"]) -> MetaOapg.properties.attitude: ...
     
@@ -1215,26 +1225,29 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["shadow"]) -> MetaOapg.properties.shadow: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["activeCommInterfaces"]) -> MetaOapg.properties.activeCommInterfaces: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["_quantityKinds"]) -> MetaOapg.properties._quantityKinds: ...
+    def __getitem__(self, name: typing_extensions.Literal["selfId"]) -> MetaOapg.properties.selfId: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["_relationships"]) -> MetaOapg.properties._relationships: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["_supers"]) -> MetaOapg.properties._supers: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["_block_names"]) -> MetaOapg.properties._block_names: ...
+    def __getitem__(self, name: typing_extensions.Literal["_quantityKinds"]) -> MetaOapg.properties._quantityKinds: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["_relationships"]) -> MetaOapg.properties._relationships: ...
+    def __getitem__(self, name: typing_extensions.Literal["_blockNames"]) -> MetaOapg.properties._blockNames: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["selfId"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_block_names"], typing_extensions.Literal["_relationships"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], typing_extensions.Literal["selfId"], typing_extensions.Literal["_relationships"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_blockNames"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["inertia"]) -> MetaOapg.properties.inertia: ...
     
     @typing.overload
@@ -1252,39 +1265,36 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["blocks"]) -> typing.Union[MetaOapg.properties.blocks, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["index"]) -> typing.Union[MetaOapg.properties.index, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["selfId"]) -> typing.Union[MetaOapg.properties.selfId, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["cadFileName"]) -> typing.Union[MetaOapg.properties.cadFileName, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["enabledModules"]) -> typing.Union[MetaOapg.properties.enabledModules, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["missionOrbit"]) -> typing.Union[MetaOapg.properties.missionOrbit, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dynamicMass"]) -> typing.Union[MetaOapg.properties.dynamicMass, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["activeOpMode"]) -> typing.Union[MetaOapg.properties.activeOpMode, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dynamicInertia"]) -> typing.Union[MetaOapg.properties.dynamicInertia, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["activeOpMode"]) -> typing.Union[MetaOapg.properties.activeOpMode, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dynamicMass"]) -> typing.Union[MetaOapg.properties.dynamicMass, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dynamicInertia"]) -> typing.Union[MetaOapg.properties.dynamicInertia, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union['PositionBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union[MetaOapg.properties.position, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["velocity"]) -> typing.Union[MetaOapg.properties.velocity, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["attitude"]) -> typing.Union[MetaOapg.properties.attitude, schemas.Unset]: ...
     
@@ -1354,96 +1364,98 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["shadow"]) -> typing.Union[MetaOapg.properties.shadow, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["activeCommInterfaces"]) -> typing.Union[MetaOapg.properties.activeCommInterfaces, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["_quantityKinds"]) -> typing.Union[MetaOapg.properties._quantityKinds, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["selfId"]) -> typing.Union[MetaOapg.properties.selfId, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["_relationships"]) -> typing.Union[MetaOapg.properties._relationships, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["_supers"]) -> typing.Union[MetaOapg.properties._supers, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["_block_names"]) -> typing.Union[MetaOapg.properties._block_names, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["_quantityKinds"]) -> typing.Union[MetaOapg.properties._quantityKinds, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["_relationships"]) -> typing.Union[MetaOapg.properties._relationships, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["_blockNames"]) -> typing.Union[MetaOapg.properties._blockNames, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["selfId"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_block_names"], typing_extensions.Literal["_relationships"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["blocks"], typing_extensions.Literal["index"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], typing_extensions.Literal["selfId"], typing_extensions.Literal["_relationships"], typing_extensions.Literal["_supers"], typing_extensions.Literal["_quantityKinds"], typing_extensions.Literal["_blockNames"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         inertia: typing.Union[MetaOapg.properties.inertia, list, tuple, ],
         cadScaleFactor: typing.Union[MetaOapg.properties.cadScaleFactor, decimal.Decimal, int, float, ],
         cadSignedUrl: typing.Union[MetaOapg.properties.cadSignedUrl, str, ],
         mass: typing.Union[MetaOapg.properties.mass, decimal.Decimal, int, float, ],
         cadKey: typing.Union[MetaOapg.properties.cadKey, str, ],
         blocks: typing.Union[MetaOapg.properties.blocks, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         index: typing.Union[MetaOapg.properties.index, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        selfId: typing.Union[MetaOapg.properties.selfId, str, schemas.Unset] = schemas.unset,
         cadFileName: typing.Union[MetaOapg.properties.cadFileName, str, schemas.Unset] = schemas.unset,
         enabledModules: typing.Union[MetaOapg.properties.enabledModules, list, tuple, schemas.Unset] = schemas.unset,
         missionOrbit: typing.Union[MetaOapg.properties.missionOrbit, str, schemas.Unset] = schemas.unset,
-        dynamicMass: typing.Union[MetaOapg.properties.dynamicMass, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dynamicInertia: typing.Union[MetaOapg.properties.dynamicInertia, list, tuple, schemas.Unset] = schemas.unset,
         activeOpMode: typing.Union[MetaOapg.properties.activeOpMode, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
-        position: typing.Union['PositionBase299', schemas.Unset] = schemas.unset,
+        dynamicMass: typing.Union[MetaOapg.properties.dynamicMass, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        dynamicInertia: typing.Union[MetaOapg.properties.dynamicInertia, list, tuple, schemas.Unset] = schemas.unset,
+        position: typing.Union[MetaOapg.properties.position, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         velocity: typing.Union[MetaOapg.properties.velocity, list, tuple, schemas.Unset] = schemas.unset,
         attitude: typing.Union[MetaOapg.properties.attitude, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         angularVelocity: typing.Union[MetaOapg.properties.angularVelocity, list, tuple, schemas.Unset] = schemas.unset,
         torque: typing.Union[MetaOapg.properties.torque, list, tuple, schemas.Unset] = schemas.unset,
         srpTorque: typing.Union[MetaOapg.properties.srpTorque, list, tuple, schemas.Unset] = schemas.unset,
         dragTorque: typing.Union[MetaOapg.properties.dragTorque, list, tuple, schemas.Unset] = schemas.unset,
         gravityGradientTorque: typing.Union[MetaOapg.properties.gravityGradientTorque, list, tuple, schemas.Unset] = schemas.unset,
         positionSolution: typing.Union[MetaOapg.properties.positionSolution, list, tuple, schemas.Unset] = schemas.unset,
         positionSolutionError: typing.Union[MetaOapg.properties.positionSolutionError, list, tuple, schemas.Unset] = schemas.unset,
         positionCovariance: typing.Union[MetaOapg.properties.positionCovariance, list, tuple, schemas.Unset] = schemas.unset,
         velocitySolution: typing.Union[MetaOapg.properties.velocitySolution, list, tuple, schemas.Unset] = schemas.unset,
         velocitySolutionError: typing.Union[MetaOapg.properties.velocitySolutionError, list, tuple, schemas.Unset] = schemas.unset,
         velocityCovariance: typing.Union[MetaOapg.properties.velocityCovariance, list, tuple, schemas.Unset] = schemas.unset,
-        attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, list, tuple, schemas.Unset] = schemas.unset,
         attitudeSolutionError: typing.Union[MetaOapg.properties.attitudeSolutionError, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySolution: typing.Union[MetaOapg.properties.angularVelocitySolution, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySolutionError: typing.Union[MetaOapg.properties.angularVelocitySolutionError, list, tuple, schemas.Unset] = schemas.unset,
-        commandedAttitude: typing.Union[MetaOapg.properties.commandedAttitude, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        commandedAttitude: typing.Union[MetaOapg.properties.commandedAttitude, list, tuple, schemas.Unset] = schemas.unset,
         commandedAngularRates: typing.Union[MetaOapg.properties.commandedAngularRates, list, tuple, schemas.Unset] = schemas.unset,
         lvlhAxes: typing.Union[MetaOapg.properties.lvlhAxes, list, tuple, schemas.Unset] = schemas.unset,
         enuAxes: typing.Union[MetaOapg.properties.enuAxes, list, tuple, schemas.Unset] = schemas.unset,
         beta: typing.Union[MetaOapg.properties.beta, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        orbitalElements: typing.Union[MetaOapg.properties.orbitalElements, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        orbitalElements: typing.Union[MetaOapg.properties.orbitalElements, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         shadow: typing.Union[MetaOapg.properties.shadow, bool, schemas.Unset] = schemas.unset,
         activeCommInterfaces: typing.Union[MetaOapg.properties.activeCommInterfaces, list, tuple, schemas.Unset] = schemas.unset,
-        _quantityKinds: typing.Union[MetaOapg.properties._quantityKinds, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        _supers: typing.Union[MetaOapg.properties._supers, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        _block_names: typing.Union[MetaOapg.properties._block_names, list, tuple, schemas.Unset] = schemas.unset,
+        selfId: typing.Union[MetaOapg.properties.selfId, str, schemas.Unset] = schemas.unset,
         _relationships: typing.Union[MetaOapg.properties._relationships, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        _supers: typing.Union[MetaOapg.properties._supers, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        _quantityKinds: typing.Union[MetaOapg.properties._quantityKinds, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        _blockNames: typing.Union[MetaOapg.properties._blockNames, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
     ) -> 'VehicleTemplateRes':
         return super().__new__(
             cls,
             *_args,
             inertia=inertia,
             cadScaleFactor=cadScaleFactor,
             cadSignedUrl=cadSignedUrl,
             mass=mass,
             cadKey=cadKey,
             blocks=blocks,
             index=index,
-            selfId=selfId,
             cadFileName=cadFileName,
             enabledModules=enabledModules,
             missionOrbit=missionOrbit,
-            dynamicMass=dynamicMass,
-            dynamicInertia=dynamicInertia,
             activeOpMode=activeOpMode,
             powerProcessor=powerProcessor,
+            dynamicMass=dynamicMass,
+            dynamicInertia=dynamicInertia,
             position=position,
             velocity=velocity,
             attitude=attitude,
             angularVelocity=angularVelocity,
             torque=torque,
             srpTorque=srpTorque,
             dragTorque=dragTorque,
@@ -1462,16 +1474,18 @@
             commandedAngularRates=commandedAngularRates,
             lvlhAxes=lvlhAxes,
             enuAxes=enuAxes,
             beta=beta,
             orbitalElements=orbitalElements,
             shadow=shadow,
             activeCommInterfaces=activeCommInterfaces,
-            _quantityKinds=_quantityKinds,
-            _supers=_supers,
-            _block_names=_block_names,
+            selfId=selfId,
             _relationships=_relationships,
+            _supers=_supers,
+            _quantityKinds=_quantityKinds,
+            _blockNames=_blockNames,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.position_base299 import PositionBase299
-from sedaro_base_client.model.quaternion_base299 import QuaternionBase299
+from sedaro_base_client.model.orbital_elements_data import OrbitalElementsData
+from sedaro_base_client.model.position_base306 import PositionBase306
+from sedaro_base_client.model.quaternion_base306 import QuaternionBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/model/vehicle_template_update.py` & `sedaro-4.3.2/src/sedaro_base_client/model/vehicle_template_root.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from datetime import date, datetime  # noqa: F401
 import decimal  # noqa: F401
 import functools  # noqa: F401
 import io  # noqa: F401
@@ -19,23 +19,23 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
 
-class VehicleTemplateUpdate(
+class VehicleTemplateRoot(
     schemas.DictSchema
 ):
     """NOTE: This class is auto generated by OpenAPI Generator.
     Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
 
-    Class for the updateable fields on VehicleTemplate
+    Vehicle Template Root Attributes
     """
 
 
     class MetaOapg:
         required = {
             "inertia",
             "cadScaleFactor",
@@ -108,15 +108,14 @@
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            selfId = schemas.StrSchema
             
             
             class cadFileName(
                 schemas.StrSchema
             ):
             
             
@@ -142,14 +141,16 @@
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             missionOrbit = schemas.StrSchema
+            activeOpMode = schemas.StrSchema
+            powerProcessor = schemas.StrSchema
             dynamicMass = schemas.NumberSchema
             
             
             class dynamicInertia(
                 schemas.ListSchema
             ):
             
@@ -190,20 +191,50 @@
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            activeOpMode = schemas.StrSchema
-            powerProcessor = schemas.StrSchema
-        
-            @staticmethod
-            def position() -> typing.Type['PositionBase299']:
-                return PositionBase299
+            
+            
+            class position(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            PositionBase306,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'position':
+                    return super().__new__(
+                        cls,
+                        *_args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             
             
             class velocity(
                 schemas.ListSchema
             ):
             
             
@@ -239,15 +270,15 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            QuaternionBase299,
+                            QuaternionBase306,
                         ]
             
             
                 def __new__(
                     cls,
                     *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
@@ -559,48 +590,35 @@
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
             class attitudeSolution(
-                schemas.ComposedSchema,
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            QuaternionBase299,
-                        ]
-            
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'attitudeSolution':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
             
             class attitudeSolutionError(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
@@ -664,48 +682,35 @@
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             
             
             class commandedAttitude(
-                schemas.ComposedSchema,
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            QuaternionBase299,
-                        ]
-            
+                    items = schemas.NumberSchema
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'commandedAttitude':
                     return super().__new__(
                         cls,
-                        *_args,
+                        _arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
             
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
             
             class commandedAngularRates(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
@@ -818,33 +823,40 @@
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
             beta = schemas.NumberSchema
             
             
             class orbitalElements(
-                schemas.DictSchema
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    additional_properties = schemas.NumberSchema
-                
-                def __getitem__(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    # dict_instance[name] accessor
-                    return super().__getitem__(name)
-                
-                def get_item_oapg(self, name: typing.Union[str, ]) -> MetaOapg.additional_properties:
-                    return super().get_item_oapg(name)
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            OrbitalElementsData,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    *_args: typing.Union[dict, frozendict.frozendict, ],
+                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[MetaOapg.additional_properties, decimal.Decimal, int, float, ],
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                 ) -> 'orbitalElements':
                     return super().__new__(
                         cls,
                         *_args,
                         _configuration=_configuration,
                         **kwargs,
                     )
@@ -930,28 +942,28 @@
                         cls,
                         _arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
+            selfId = schemas.StrSchema
             __annotations__ = {
                 "cadKey": cadKey,
                 "cadSignedUrl": cadSignedUrl,
                 "cadScaleFactor": cadScaleFactor,
                 "mass": mass,
                 "inertia": inertia,
-                "selfId": selfId,
                 "cadFileName": cadFileName,
                 "enabledModules": enabledModules,
                 "missionOrbit": missionOrbit,
-                "dynamicMass": dynamicMass,
-                "dynamicInertia": dynamicInertia,
                 "activeOpMode": activeOpMode,
                 "powerProcessor": powerProcessor,
+                "dynamicMass": dynamicMass,
+                "dynamicInertia": dynamicInertia,
                 "position": position,
                 "velocity": velocity,
                 "attitude": attitude,
                 "angularVelocity": angularVelocity,
                 "torque": torque,
                 "srpTorque": srpTorque,
                 "dragTorque": dragTorque,
@@ -970,14 +982,15 @@
                 "commandedAngularRates": commandedAngularRates,
                 "lvlhAxes": lvlhAxes,
                 "enuAxes": enuAxes,
                 "beta": beta,
                 "orbitalElements": orbitalElements,
                 "shadow": shadow,
                 "activeCommInterfaces": activeCommInterfaces,
+                "selfId": selfId,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
     inertia: MetaOapg.properties.inertia
     cadScaleFactor: MetaOapg.properties.cadScaleFactor
     cadSignedUrl: MetaOapg.properties.cadSignedUrl
     mass: MetaOapg.properties.mass
@@ -995,39 +1008,36 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["mass"]) -> MetaOapg.properties.mass: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["cadKey"]) -> MetaOapg.properties.cadKey: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["selfId"]) -> MetaOapg.properties.selfId: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["cadFileName"]) -> MetaOapg.properties.cadFileName: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["enabledModules"]) -> MetaOapg.properties.enabledModules: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["missionOrbit"]) -> MetaOapg.properties.missionOrbit: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dynamicMass"]) -> MetaOapg.properties.dynamicMass: ...
+    def __getitem__(self, name: typing_extensions.Literal["activeOpMode"]) -> MetaOapg.properties.activeOpMode: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["dynamicInertia"]) -> MetaOapg.properties.dynamicInertia: ...
+    def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["activeOpMode"]) -> MetaOapg.properties.activeOpMode: ...
+    def __getitem__(self, name: typing_extensions.Literal["dynamicMass"]) -> MetaOapg.properties.dynamicMass: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["powerProcessor"]) -> MetaOapg.properties.powerProcessor: ...
+    def __getitem__(self, name: typing_extensions.Literal["dynamicInertia"]) -> MetaOapg.properties.dynamicInertia: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["position"]) -> 'PositionBase299': ...
+    def __getitem__(self, name: typing_extensions.Literal["position"]) -> MetaOapg.properties.position: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["velocity"]) -> MetaOapg.properties.velocity: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["attitude"]) -> MetaOapg.properties.attitude: ...
     
@@ -1096,15 +1106,18 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["shadow"]) -> MetaOapg.properties.shadow: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["activeCommInterfaces"]) -> MetaOapg.properties.activeCommInterfaces: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["selfId"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["selfId"]) -> MetaOapg.properties.selfId: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], typing_extensions.Literal["selfId"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["inertia"]) -> MetaOapg.properties.inertia: ...
     
     @typing.overload
@@ -1116,39 +1129,36 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["mass"]) -> MetaOapg.properties.mass: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["cadKey"]) -> MetaOapg.properties.cadKey: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["selfId"]) -> typing.Union[MetaOapg.properties.selfId, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["cadFileName"]) -> typing.Union[MetaOapg.properties.cadFileName, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["enabledModules"]) -> typing.Union[MetaOapg.properties.enabledModules, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["missionOrbit"]) -> typing.Union[MetaOapg.properties.missionOrbit, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dynamicMass"]) -> typing.Union[MetaOapg.properties.dynamicMass, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["activeOpMode"]) -> typing.Union[MetaOapg.properties.activeOpMode, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["dynamicInertia"]) -> typing.Union[MetaOapg.properties.dynamicInertia, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["activeOpMode"]) -> typing.Union[MetaOapg.properties.activeOpMode, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dynamicMass"]) -> typing.Union[MetaOapg.properties.dynamicMass, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["powerProcessor"]) -> typing.Union[MetaOapg.properties.powerProcessor, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["dynamicInertia"]) -> typing.Union[MetaOapg.properties.dynamicInertia, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union['PositionBase299', schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["position"]) -> typing.Union[MetaOapg.properties.position, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["velocity"]) -> typing.Union[MetaOapg.properties.velocity, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["attitude"]) -> typing.Union[MetaOapg.properties.attitude, schemas.Unset]: ...
     
@@ -1217,77 +1227,79 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["shadow"]) -> typing.Union[MetaOapg.properties.shadow, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["activeCommInterfaces"]) -> typing.Union[MetaOapg.properties.activeCommInterfaces, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["selfId"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["selfId"]) -> typing.Union[MetaOapg.properties.selfId, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inertia"], typing_extensions.Literal["cadScaleFactor"], typing_extensions.Literal["cadSignedUrl"], typing_extensions.Literal["mass"], typing_extensions.Literal["cadKey"], typing_extensions.Literal["cadFileName"], typing_extensions.Literal["enabledModules"], typing_extensions.Literal["missionOrbit"], typing_extensions.Literal["activeOpMode"], typing_extensions.Literal["powerProcessor"], typing_extensions.Literal["dynamicMass"], typing_extensions.Literal["dynamicInertia"], typing_extensions.Literal["position"], typing_extensions.Literal["velocity"], typing_extensions.Literal["attitude"], typing_extensions.Literal["angularVelocity"], typing_extensions.Literal["torque"], typing_extensions.Literal["srpTorque"], typing_extensions.Literal["dragTorque"], typing_extensions.Literal["gravityGradientTorque"], typing_extensions.Literal["positionSolution"], typing_extensions.Literal["positionSolutionError"], typing_extensions.Literal["positionCovariance"], typing_extensions.Literal["velocitySolution"], typing_extensions.Literal["velocitySolutionError"], typing_extensions.Literal["velocityCovariance"], typing_extensions.Literal["attitudeSolution"], typing_extensions.Literal["attitudeSolutionError"], typing_extensions.Literal["angularVelocitySolution"], typing_extensions.Literal["angularVelocitySolutionError"], typing_extensions.Literal["commandedAttitude"], typing_extensions.Literal["commandedAngularRates"], typing_extensions.Literal["lvlhAxes"], typing_extensions.Literal["enuAxes"], typing_extensions.Literal["beta"], typing_extensions.Literal["orbitalElements"], typing_extensions.Literal["shadow"], typing_extensions.Literal["activeCommInterfaces"], typing_extensions.Literal["selfId"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, ],
         inertia: typing.Union[MetaOapg.properties.inertia, list, tuple, ],
         cadScaleFactor: typing.Union[MetaOapg.properties.cadScaleFactor, decimal.Decimal, int, float, ],
         cadSignedUrl: typing.Union[MetaOapg.properties.cadSignedUrl, str, ],
         mass: typing.Union[MetaOapg.properties.mass, decimal.Decimal, int, float, ],
         cadKey: typing.Union[MetaOapg.properties.cadKey, str, ],
-        selfId: typing.Union[MetaOapg.properties.selfId, str, schemas.Unset] = schemas.unset,
         cadFileName: typing.Union[MetaOapg.properties.cadFileName, str, schemas.Unset] = schemas.unset,
         enabledModules: typing.Union[MetaOapg.properties.enabledModules, list, tuple, schemas.Unset] = schemas.unset,
         missionOrbit: typing.Union[MetaOapg.properties.missionOrbit, str, schemas.Unset] = schemas.unset,
-        dynamicMass: typing.Union[MetaOapg.properties.dynamicMass, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        dynamicInertia: typing.Union[MetaOapg.properties.dynamicInertia, list, tuple, schemas.Unset] = schemas.unset,
         activeOpMode: typing.Union[MetaOapg.properties.activeOpMode, str, schemas.Unset] = schemas.unset,
         powerProcessor: typing.Union[MetaOapg.properties.powerProcessor, str, schemas.Unset] = schemas.unset,
-        position: typing.Union['PositionBase299', schemas.Unset] = schemas.unset,
+        dynamicMass: typing.Union[MetaOapg.properties.dynamicMass, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        dynamicInertia: typing.Union[MetaOapg.properties.dynamicInertia, list, tuple, schemas.Unset] = schemas.unset,
+        position: typing.Union[MetaOapg.properties.position, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         velocity: typing.Union[MetaOapg.properties.velocity, list, tuple, schemas.Unset] = schemas.unset,
         attitude: typing.Union[MetaOapg.properties.attitude, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         angularVelocity: typing.Union[MetaOapg.properties.angularVelocity, list, tuple, schemas.Unset] = schemas.unset,
         torque: typing.Union[MetaOapg.properties.torque, list, tuple, schemas.Unset] = schemas.unset,
         srpTorque: typing.Union[MetaOapg.properties.srpTorque, list, tuple, schemas.Unset] = schemas.unset,
         dragTorque: typing.Union[MetaOapg.properties.dragTorque, list, tuple, schemas.Unset] = schemas.unset,
         gravityGradientTorque: typing.Union[MetaOapg.properties.gravityGradientTorque, list, tuple, schemas.Unset] = schemas.unset,
         positionSolution: typing.Union[MetaOapg.properties.positionSolution, list, tuple, schemas.Unset] = schemas.unset,
         positionSolutionError: typing.Union[MetaOapg.properties.positionSolutionError, list, tuple, schemas.Unset] = schemas.unset,
         positionCovariance: typing.Union[MetaOapg.properties.positionCovariance, list, tuple, schemas.Unset] = schemas.unset,
         velocitySolution: typing.Union[MetaOapg.properties.velocitySolution, list, tuple, schemas.Unset] = schemas.unset,
         velocitySolutionError: typing.Union[MetaOapg.properties.velocitySolutionError, list, tuple, schemas.Unset] = schemas.unset,
         velocityCovariance: typing.Union[MetaOapg.properties.velocityCovariance, list, tuple, schemas.Unset] = schemas.unset,
-        attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        attitudeSolution: typing.Union[MetaOapg.properties.attitudeSolution, list, tuple, schemas.Unset] = schemas.unset,
         attitudeSolutionError: typing.Union[MetaOapg.properties.attitudeSolutionError, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySolution: typing.Union[MetaOapg.properties.angularVelocitySolution, list, tuple, schemas.Unset] = schemas.unset,
         angularVelocitySolutionError: typing.Union[MetaOapg.properties.angularVelocitySolutionError, list, tuple, schemas.Unset] = schemas.unset,
-        commandedAttitude: typing.Union[MetaOapg.properties.commandedAttitude, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        commandedAttitude: typing.Union[MetaOapg.properties.commandedAttitude, list, tuple, schemas.Unset] = schemas.unset,
         commandedAngularRates: typing.Union[MetaOapg.properties.commandedAngularRates, list, tuple, schemas.Unset] = schemas.unset,
         lvlhAxes: typing.Union[MetaOapg.properties.lvlhAxes, list, tuple, schemas.Unset] = schemas.unset,
         enuAxes: typing.Union[MetaOapg.properties.enuAxes, list, tuple, schemas.Unset] = schemas.unset,
         beta: typing.Union[MetaOapg.properties.beta, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        orbitalElements: typing.Union[MetaOapg.properties.orbitalElements, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        orbitalElements: typing.Union[MetaOapg.properties.orbitalElements, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         shadow: typing.Union[MetaOapg.properties.shadow, bool, schemas.Unset] = schemas.unset,
         activeCommInterfaces: typing.Union[MetaOapg.properties.activeCommInterfaces, list, tuple, schemas.Unset] = schemas.unset,
+        selfId: typing.Union[MetaOapg.properties.selfId, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'VehicleTemplateUpdate':
+    ) -> 'VehicleTemplateRoot':
         return super().__new__(
             cls,
             *_args,
             inertia=inertia,
             cadScaleFactor=cadScaleFactor,
             cadSignedUrl=cadSignedUrl,
             mass=mass,
             cadKey=cadKey,
-            selfId=selfId,
             cadFileName=cadFileName,
             enabledModules=enabledModules,
             missionOrbit=missionOrbit,
-            dynamicMass=dynamicMass,
-            dynamicInertia=dynamicInertia,
             activeOpMode=activeOpMode,
             powerProcessor=powerProcessor,
+            dynamicMass=dynamicMass,
+            dynamicInertia=dynamicInertia,
             position=position,
             velocity=velocity,
             attitude=attitude,
             angularVelocity=angularVelocity,
             torque=torque,
             srpTorque=srpTorque,
             dragTorque=dragTorque,
@@ -1306,12 +1318,14 @@
             commandedAngularRates=commandedAngularRates,
             lvlhAxes=lvlhAxes,
             enuAxes=enuAxes,
             beta=beta,
             orbitalElements=orbitalElements,
             shadow=shadow,
             activeCommInterfaces=activeCommInterfaces,
+            selfId=selfId,
             _configuration=_configuration,
         )
 
-from sedaro_base_client.model.position_base299 import PositionBase299
-from sedaro_base_client.model.quaternion_base299 import QuaternionBase299
+from sedaro_base_client.model.orbital_elements_data import OrbitalElementsData
+from sedaro_base_client.model.position_base306 import PositionBase306
+from sedaro_base_client.model.quaternion_base306 import QuaternionBase306
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/models/__init__.py` & `sedaro-4.3.2/src/sedaro_base_client/models/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,34 +9,36 @@
 # from sedaro_base_client.model.pet import Pet
 # or import this package, but before doing it, use:
 # import sys
 # sys.setrecursionlimit(n)
 
 from sedaro_base_client.model.agent import Agent
 from sedaro_base_client.model.agent_group import AgentGroup
-from sedaro_base_client.model.angle_base299 import AngleBase299
-from sedaro_base_client.model.angle_field_of_view31 import AngleFieldOfView31
+from sedaro_base_client.model.angle_base306 import AngleBase306
+from sedaro_base_client.model.angle_field_of_view30 import AngleFieldOfView30
+from sedaro_base_client.model.angle_field_of_view35 import AngleFieldOfView35
 from sedaro_base_client.model.angle_field_of_view36 import AngleFieldOfView36
-from sedaro_base_client.model.angle_field_of_view37 import AngleFieldOfView37
 from sedaro_base_client.model.angle_sensors20 import AngleSensors20
 from sedaro_base_client.model.angle_sensors51 import AngleSensors51
 from sedaro_base_client.model.angle_sensors56 import AngleSensors56
-from sedaro_base_client.model.angular_velocity_base299 import AngularVelocityBase299
+from sedaro_base_client.model.angular_velocity_base306 import AngularVelocityBase306
 from sedaro_base_client.model.angular_velocity_sensor import AngularVelocitySensor
-from sedaro_base_client.model.angular_velocity_sensors82 import AngularVelocitySensors82
+from sedaro_base_client.model.angular_velocity_sensors84 import AngularVelocitySensors84
 from sedaro_base_client.model.antenna import Antenna
 from sedaro_base_client.model.averaging_algorithm import AveragingAlgorithm
+from sedaro_base_client.model.base_dissipations import BaseDissipations
 from sedaro_base_client.model.battery import Battery
 from sedaro_base_client.model.battery_cell import BatteryCell
 from sedaro_base_client.model.battery_pack import BatteryPack
+from sedaro_base_client.model.battery_pack_dissipations import BatteryPackDissipations
 from sedaro_base_client.model.body_frame_vector import BodyFrameVector
 from sedaro_base_client.model.body_frame_vector_types import BodyFrameVectorTypes
 from sedaro_base_client.model.body_in_fov_condition import BodyInFovCondition
+from sedaro_base_client.model.branch_changes_res import BranchChangesRes
 from sedaro_base_client.model.branch_create import BranchCreate
-from sedaro_base_client.model.branch_delete_res import BranchDeleteRes
 from sedaro_base_client.model.branch_merge import BranchMerge
 from sedaro_base_client.model.branch_merge_conflicts_res import BranchMergeConflictsRes
 from sedaro_base_client.model.branch_res import BranchRes
 from sedaro_base_client.model.branch_scenario_res import BranchScenarioRes
 from sedaro_base_client.model.branch_update import BranchUpdate
 from sedaro_base_client.model.branch_vehicle_res import BranchVehicleRes
 from sedaro_base_client.model.branch_verify_password import BranchVerifyPassword
@@ -45,14 +47,15 @@
 from sedaro_base_client.model.celestial_pointing_directions import CelestialPointingDirections
 from sedaro_base_client.model.celestial_target import CelestialTarget
 from sedaro_base_client.model.celestial_vector import CelestialVector
 from sedaro_base_client.model.circular_field_of_view import CircularFieldOfView
 from sedaro_base_client.model.classical_orbital_elements import ClassicalOrbitalElements
 from sedaro_base_client.model.clock_config import ClockConfig
 from sedaro_base_client.model.component import Component
+from sedaro_base_client.model.component_dissipations import ComponentDissipations
 from sedaro_base_client.model.component_parameters import ComponentParameters
 from sedaro_base_client.model.component_to_scalar_condition import ComponentToScalarCondition
 from sedaro_base_client.model.compound_condition import CompoundCondition
 from sedaro_base_client.model.compound_operators import CompoundOperators
 from sedaro_base_client.model.condition_relationship import ConditionRelationship
 from sedaro_base_client.model.configuration_types import ConfigurationTypes
 from sedaro_base_client.model.conflicts_obj import ConflictsObj
@@ -66,27 +69,30 @@
 from sedaro_base_client.model.data_mode import DataMode
 from sedaro_base_client.model.data_service_response import DataServiceResponse
 from sedaro_base_client.model.data_set import DataSet
 from sedaro_base_client.model.data_storage import DataStorage
 from sedaro_base_client.model.data_type import DataType
 from sedaro_base_client.model.deleted_entity import DeletedEntity
 from sedaro_base_client.model.direction_sensor import DirectionSensor
-from sedaro_base_client.model.distance_sensors70 import DistanceSensors70
-from sedaro_base_client.model.duration_load70 import DurationLoad70
+from sedaro_base_client.model.distance_base306 import DistanceBase306
+from sedaro_base_client.model.distance_sensors72 import DistanceSensors72
+from sedaro_base_client.model.duration_base306 import DurationBase306
+from sedaro_base_client.model.duration_load69 import DurationLoad69
 from sedaro_base_client.model.duration_operational_mode18 import DurationOperationalMode18
-from sedaro_base_client.model.duration_operational_mode19 import DurationOperationalMode19
 from sedaro_base_client.model.duration_operational_mode20 import DurationOperationalMode20
-from sedaro_base_client.model.duration_operational_mode28 import DurationOperationalMode28
-from sedaro_base_client.model.duration_operational_mode29 import DurationOperationalMode29
+from sedaro_base_client.model.duration_operational_mode22 import DurationOperationalMode22
+from sedaro_base_client.model.duration_operational_mode31 import DurationOperationalMode31
+from sedaro_base_client.model.duration_operational_mode33 import DurationOperationalMode33
 from sedaro_base_client.model.ekf_algorithm import EkfAlgorithm
+from sedaro_base_client.model.entity_delete_res import EntityDeleteRes
 from sedaro_base_client.model.eps_output_types import EpsOutputTypes
 from sedaro_base_client.model.equatorial_circular_reference_orbit import EquatorialCircularReferenceOrbit
 from sedaro_base_client.model.external_state_set_request import ExternalStateSetRequest
 from sedaro_base_client.model.fixed_surface import FixedSurface
-from sedaro_base_client.model.frame_vector_base299 import FrameVectorBase299
+from sedaro_base_client.model.frame_vector_base306 import FrameVectorBase306
 from sedaro_base_client.model.fuel_reservoir import FuelReservoir
 from sedaro_base_client.model.fully_reg_det_power_processor import FullyRegDetPowerProcessor
 from sedaro_base_client.model.fully_reg_det_topology_params import FullyRegDetTopologyParams
 from sedaro_base_client.model.geostationary_reference_orbit import GeostationaryReferenceOrbit
 from sedaro_base_client.model.geostationary_transfer_reference_orbit import GeostationaryTransferReferenceOrbit
 from sedaro_base_client.model.gps_algorithm import GpsAlgorithm
 from sedaro_base_client.model.ground_target import GroundTarget
@@ -107,40 +113,46 @@
 from sedaro_base_client.model.mekf_algorithm import MekfAlgorithm
 from sedaro_base_client.model.message_res import MessageRes
 from sedaro_base_client.model.modem import Modem
 from sedaro_base_client.model.operational_mode import OperationalMode
 from sedaro_base_client.model.optical_attitude_sensor import OpticalAttitudeSensor
 from sedaro_base_client.model.orbit import Orbit
 from sedaro_base_client.model.orbital_elements_data import OrbitalElementsData
+from sedaro_base_client.model.panel_dissipations import PanelDissipations
 from sedaro_base_client.model.passive_pointing_mode import PassivePointingMode
 from sedaro_base_client.model.passive_transmit_interface import PassiveTransmitInterface
 from sedaro_base_client.model.per_round_external_state import PerRoundExternalState
 from sedaro_base_client.model.pid_algorithm import PidAlgorithm
 from sedaro_base_client.model.polar_circular_reference_orbit import PolarCircularReferenceOrbit
 from sedaro_base_client.model.polynomial_ephemeris_body import PolynomialEphemerisBody
-from sedaro_base_client.model.position_base299 import PositionBase299
+from sedaro_base_client.model.position_base306 import PositionBase306
 from sedaro_base_client.model.position_sensor import PositionSensor
 from sedaro_base_client.model.power_load import PowerLoad
 from sedaro_base_client.model.power_processor import PowerProcessor
+from sedaro_base_client.model.processor_dissipations import ProcessorDissipations
 from sedaro_base_client.model.quasi_reg_det_power_processor import QuasiRegDetPowerProcessor
 from sedaro_base_client.model.quasi_reg_det_topology_params import QuasiRegDetTopologyParams
-from sedaro_base_client.model.quaternion_base299 import QuaternionBase299
+from sedaro_base_client.model.quaternion_base306 import QuaternionBase306
 from sedaro_base_client.model.reaction_wheel import ReactionWheel
 from sedaro_base_client.model.receive_interface import ReceiveInterface
 from sedaro_base_client.model.rectangular_field_of_view import RectangularFieldOfView
+from sedaro_base_client.model.repo_create_req import RepoCreateReq
+from sedaro_base_client.model.repo_import_req import RepoImportReq
+from sedaro_base_client.model.repo_res import RepoRes
+from sedaro_base_client.model.repo_update_req import RepoUpdateReq
 from sedaro_base_client.model.resistance_load import ResistanceLoad
 from sedaro_base_client.model.same_target_multi_condition import SameTargetMultiCondition
-from sedaro_base_client.model.satellite import Satellite
 from sedaro_base_client.model.satellite_parameters import SatelliteParameters
 from sedaro_base_client.model.satellite_to_satellite_condition import SatelliteToSatelliteCondition
 from sedaro_base_client.model.satellite_to_scalar_condition import SatelliteToScalarCondition
 from sedaro_base_client.model.satellite_to_target_condition import SatelliteToTargetCondition
-from sedaro_base_client.model.scenario_template_crud import ScenarioTemplateCrud
+from sedaro_base_client.model.scenario_template import ScenarioTemplate
 from sedaro_base_client.model.scenario_template_res import ScenarioTemplateRes
-from sedaro_base_client.model.scenario_template_update import ScenarioTemplateUpdate
+from sedaro_base_client.model.scenario_template_root import ScenarioTemplateRoot
+from sedaro_base_client.model.scenario_template_update_interface import ScenarioTemplateUpdateInterface
 from sedaro_base_client.model.side_categories import SideCategories
 from sedaro_base_client.model.simulation_job import SimulationJob
 from sedaro_base_client.model.single_conv_hybrid_power_processor import SingleConvHybridPowerProcessor
 from sedaro_base_client.model.single_conv_hybrid_topology_params import SingleConvHybridTopologyParams
 from sedaro_base_client.model.single_conv_mppt_power_processor import SingleConvMpptPowerProcessor
 from sedaro_base_client.model.single_conv_mppt_topology_params import SingleConvMpptTopologyParams
 from sedaro_base_client.model.sliding_mode_algorithm import SlidingModeAlgorithm
@@ -167,15 +179,15 @@
 from sedaro_base_client.model.target_group_vector import TargetGroupVector
 from sedaro_base_client.model.target_in_fov_condition import TargetInFovCondition
 from sedaro_base_client.model.target_parameters import TargetParameters
 from sedaro_base_client.model.target_to_scalar_condition import TargetToScalarCondition
 from sedaro_base_client.model.target_to_target_condition import TargetToTargetCondition
 from sedaro_base_client.model.target_vector import TargetVector
 from sedaro_base_client.model.temp_controller_state import TempControllerState
-from sedaro_base_client.model.temperature_base299 import TemperatureBase299
+from sedaro_base_client.model.temperature_base306 import TemperatureBase306
 from sedaro_base_client.model.template_crud_res import TemplateCrudRes
 from sedaro_base_client.model.thermal_interface import ThermalInterface
 from sedaro_base_client.model.thermal_interface_material import ThermalInterfaceMaterial
 from sedaro_base_client.model.thruster import Thruster
 from sedaro_base_client.model.time_condition import TimeCondition
 from sedaro_base_client.model.tle import Tle
 from sedaro_base_client.model.triad_algorithm import TriadAlgorithm
@@ -183,10 +195,11 @@
 from sedaro_base_client.model.two_conv_mppt_topology_params import TwoConvMpptTopologyParams
 from sedaro_base_client.model.types import Types
 from sedaro_base_client.model.validation_error import ValidationError
 from sedaro_base_client.model.vector import Vector
 from sedaro_base_client.model.vector_in_fov_condition import VectorInFovCondition
 from sedaro_base_client.model.vector_sensor import VectorSensor
 from sedaro_base_client.model.vector_tracking_surface import VectorTrackingSurface
-from sedaro_base_client.model.vehicle_template_crud import VehicleTemplateCrud
+from sedaro_base_client.model.vehicle_template import VehicleTemplate
 from sedaro_base_client.model.vehicle_template_res import VehicleTemplateRes
-from sedaro_base_client.model.vehicle_template_update import VehicleTemplateUpdate
+from sedaro_base_client.model.vehicle_template_root import VehicleTemplateRoot
+from sedaro_base_client.model.vehicle_template_update_interface import VehicleTemplateUpdateInterface
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/__init__.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,13 +7,18 @@
 
 class PathValues(str, enum.Enum):
     MODELS_BRANCHES_BRANCH_ID_TEMPLATE = "/models/branches/{branchId}/template"
     SIMULATIONS_BRANCHES_BRANCH_ID_CONTROL_ = "/simulations/branches/{branchId}/control/"
     SIMULATIONS_BRANCHES_BRANCH_ID_CONTROL_JOB_ID = "/simulations/branches/{branchId}/control/{jobId}"
     SIMULATIONS_JOBS_JOB_ID_EXTERNALS_AGENT_ID_EXTERNAL_STATE_BLOCK_ID = "/simulations/jobs/{jobId}/externals/{agentId}/{externalStateBlockId}"
     DATA_ID = "/data/{id}"
+    MODELS_REPOSITORIES_ = "/models/repositories/"
+    MODELS_REPOSITORIES_REPOSITORY_ID = "/models/repositories/{repositoryId}"
+    MODELS_REPOSITORIES__IMPORT = "/models/repositories//import"
     MODELS_BRANCHES_BRANCH_ID = "/models/branches/{branchId}"
-    MODELS_BRANCHES_BRANCH_IDSHAREAUTH_ = "/models/branches/{branchId}share-auth/"
-    MODELS_BRANCHES_BRANCH_IDCOMMITS_ = "/models/branches/{branchId}commits/"
+    MODELS_BRANCHES_BRANCH_ID_SHAREAUTH_ = "/models/branches/{branchId}/share-auth/"
+    MODELS_BRANCHES_BRANCH_ID_COMMITS_ = "/models/branches/{branchId}/commits/"
     MODELS_BRANCHES_CURRENT_BRANCH_ID_MERGE_INCOMING_BRANCH_ID = "/models/branches/{currentBranchId}/merge/{incomingBranchId}"
-    MODELS_BRANCHES_BRANCH_IDCOMMITTED_ = "/models/branches/{branchId}committed/"
-    MODELS_BRANCHES_BRANCH_IDSAVED_ = "/models/branches/{branchId}saved/"
+    MODELS_BRANCHES_BRANCH_ID_COMMITTED_ = "/models/branches/{branchId}/committed/"
+    MODELS_BRANCHES_BRANCH_ID_SAVED_ = "/models/branches/{branchId}/saved/"
+    MODELS_BRANCHES_BRANCH_ID_CHANGES_ = "/models/branches/{branchId}/changes/"
+    MODELS_BRANCHES_BRANCH_ID_EXPORT_ = "/models/branches/{branchId}/export/"
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/data_id/get.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/data_id/get.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/delete.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/delete.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,16 +21,16 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
+from sedaro_base_client.model.entity_delete_res import EntityDeleteRes
 from sedaro_base_client.model.http_validation_error import HTTPValidationError
-from sedaro_base_client.model.branch_delete_res import BranchDeleteRes
 
 from . import path
 
 # Path params
 BranchIdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
@@ -52,15 +52,15 @@
 
 request_path_branch_id = api_client.PathParameter(
     name="branchId",
     style=api_client.ParameterStyle.SIMPLE,
     schema=BranchIdSchema,
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = BranchDeleteRes
+SchemaFor200ResponseBodyApplicationJson = EntityDeleteRes
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     response: urllib3.HTTPResponse
     body: typing.Union[
         SchemaFor200ResponseBodyApplicationJson,
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/get.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/get.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/patch.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/patch.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id/post.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id/post.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_id_template/patch.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_template/patch.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,18 +21,18 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from sedaro_base_client import schemas  # noqa: F401
 
-from sedaro_base_client.model.vehicle_template_crud import VehicleTemplateCrud
-from sedaro_base_client.model.scenario_template_crud import ScenarioTemplateCrud
+from sedaro_base_client.model.scenario_template_update_interface import ScenarioTemplateUpdateInterface
 from sedaro_base_client.model.template_crud_res import TemplateCrudRes
 from sedaro_base_client.model.http_validation_error import HTTPValidationError
+from sedaro_base_client.model.vehicle_template_update_interface import VehicleTemplateUpdateInterface
 
 from . import path
 
 # Path params
 BranchIdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
@@ -75,16 +75,16 @@
             # we must store _composed_schemas in here so the code is only run
             # when we invoke this method. If we kept this at the class
             # level we would get an error because the class level
             # code would be run when this module is imported, and these composed
             # classes don't exist yet because their module has not finished
             # loading
             return [
-                ScenarioTemplateCrud,
-                VehicleTemplateCrud,
+                VehicleTemplateUpdateInterface,
+                ScenarioTemplateUpdateInterface,
             ]
 
 
     def __new__(
         cls,
         *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
@@ -216,15 +216,15 @@
         path_params: RequestPathParams = frozendict.frozendict(),
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         stream: bool = False,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         skip_deserialization: bool = False,
     ):
         """
-        CRUD Template and Blocks
+        Update a Template Model
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommits_/post.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_commits_/post.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idcommitted_/get.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_committed_/get.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idsaved_/get.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_saved_/get.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_branch_idshare_auth_/post.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_branch_id_share_auth_/post.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/post.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/models_branches_current_branch_id_merge_incoming_branch_id/post.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/get.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/get.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/post.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_/post.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/delete.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/delete.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/get.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/simulations_branches_branch_id_control_job_id/get.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/get.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/get.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/patch.py` & `sedaro-4.3.2/src/sedaro_base_client/paths/simulations_jobs_job_id_externals_agent_id_external_state_block_id/patch.py`

 * *Files identical despite different names*

### Comparing `sedaro-4.3.1/src/sedaro_base_client/rest.py` & `sedaro-4.3.2/src/sedaro_base_client/rest.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 import logging
 import ssl
 from urllib.parse import urlencode
 import typing
```

### Comparing `sedaro-4.3.1/src/sedaro_base_client/schemas.py` & `sedaro-4.3.2/src/sedaro_base_client/schemas.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # coding: utf-8
 
 """
     Sedaro API
 
-     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Currently the documentation for 200 responses to Block create, read, update, and delete (CRUD) operations is incorrect. This is due to an issue with our documentation generator.  Under each Block Group, the documentation will show `name`, `collection`, and `data` keys.  In reality, this level does not exist and should be skipped.  See the schema under the `data` key of a Template's Block Group for the correct schema of such Block Group. - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
+     Allows for consumption of Sedaro services. Read more about Sedaro at [docs.sedaro.com](https://docs.sedaro.com).  ### Clients  **Python:** [sedaro](https://pypi.org/project/sedaro/) - This package provides additional functionality on top of the auto-generated OpenAPI client. See the package docs for more information.  ### API Key  To access the Sedaro service via this API, you will need an API key.  You can generate an API key for your account in the Sedaro [Management Console](https://satellite.sedaro.com/#/account). Once complete, pass the API key in all requests via the `X_API_KEY` HTTP header.  *API keys grant full access to your account and should never be shared. If you think your API key has been compromised, you can revoke it in the [Management Console](https://satellite.sedaro.com/#/account).*  ### Jupyter Notebooks  For additional examples of how to use this API for modeling and simulation, see our [Mod-Sim Notebooks](https://github.com/sedaro/modsim-notebooks).  ### Community, Support, Discussion  If you have any issues or suggestions, please reach out:  1. Join the Sedaro Community [Slack](https://join.slack.com/t/sedaro-community/shared_invite/zt-1jps4i711-mXy88AZQ9AV7YcEXr8x7Ow) 2. Email us at support@sedarotech.com  ### Known Issues  - Error responses are more specific than what is shown throughout the documentation.  A 4xx or 5xx error will be returned in all error cases.  Only a `200` status indicates success.  See a given error response for additional details.   # noqa: E501
 
-    The version of the OpenAPI document: 4.3.1
+    The version of the OpenAPI document: 4.3.2
     Generated by: https://openapi-generator.tech
 """
 
 from collections import defaultdict
 from datetime import date, datetime, timedelta  # noqa: F401
 import functools
 import decimal
```

